//---------------------------------------------------------------------------
/*
PicToCode, tool to convert a picture to C++ code
Copyright (C) 2010-2011 Richel Bilderbeek

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.If not, see <http://www.gnu.org/licenses/>.
*/
//---------------------------------------------------------------------------
//From http://www.richelbilderbeek.nl/ToolPicToCode.htm
//---------------------------------------------------------------------------
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#include "qtpictocodemaindialog.h"

#include <cassert>


#include <boost/lexical_cast.hpp>
#include <boost/numeric/conversion/cast.hpp>

#include <QBitmap>
#include <QDesktopWidget>
#include <QFileDialog>

#include "pictocodemaindialog.h"
#include "pictocodemenudialog.h"
#include "qtsprites.h"
#include "ui_qtpictocodemaindialog.h"
#pragma GCC diagnostic pop

ribi::QtPicToCodeMainDialog::QtPicToCodeMainDialog(QWidget *parent)
  : QtHideAndShowDialog(parent), //Removed Qt::Window flag
    ui(new Ui::QtPicToCodeMainDialog)
{
  ui->setupUi(this);
  ui->edit_code->setWordWrapMode(QTextOption::NoWrap);
  ui->label_picture->setPixmap(QtSprites::DrawR());

  //Put the dialog in the screen center
  const QRect screen = QApplication::desktop()->screenGeometry();
  this->setGeometry(0,0,screen.width() * 8 / 10,screen.height() * 8 / 10);
  this->move( screen.center() - this->rect().center() );
}

ribi::QtPicToCodeMainDialog::~QtPicToCodeMainDialog() noexcept
{
  delete ui;
}

const ribi::PicToCodeMainDialog::YxImage ribi::QtPicToCodeMainDialog::ImageToImage(const QImage& qt_image)
{
  const int width  = qt_image.width();
  const int height = qt_image.height();

  PicToCodeMainDialog::YxImage image;
  image.m_v.resize(height,std::vector<PicToCodeMainDialog::Pixel>(width));

  for (int y=0; y!=height; ++y)
  {
    const unsigned char * const line
      = static_cast<const unsigned char *>(qt_image.scanLine(y));
    for (int x=0; x!=width; ++x)
    {
      image.m_v[y][x].a = static_cast<int>(line[(x*4)+3]);
      image.m_v[y][x].r = static_cast<int>(line[(x*4)+2]);
      image.m_v[y][x].g = static_cast<int>(line[(x*4)+1]);
      image.m_v[y][x].b = static_cast<int>(line[(x*4)+0]);
    }
  }
  return image;
}

void ribi::QtPicToCodeMainDialog::on_button_select_file_clicked()
{
  QFileDialog d;
  //Select only picture files
  {
    QStringList filters;
    filters
      << "*.png" << "*.PNG"
      << "*.bmp" << "*.BMP";
    d.setNameFilters(filters);
  }
  d.setFileMode(QFileDialog::ExistingFile);
  d.exec();
  if (d.selectedFiles().size()==0) return;
  assert(d.selectedFiles().size()==1);
  const QString filename = d.selectedFiles().operator[](0);
  ui->label_picture->setPixmap(QPixmap(filename));
}

void ribi::QtPicToCodeMainDialog::on_button_convert_clicked()
{
  const std::vector<std::string> v
    = (ui->radio_nds->isChecked()
    ? PicToNdsCode(ui->label_picture->pixmap()->toImage())
    : PicToQtCode(ui->label_picture->pixmap()->toImage())
    );

  ui->edit_code->clear();
  for(const std::string& s: v)
  {
    ui->edit_code->appendPlainText(s.c_str());
  }

}

const std::vector<std::string>
  ribi::QtPicToCodeMainDialog::PicToNdsCode(const QImage& image) const
{
  std::vector<std::string> v;
  //Function declaration
  v.push_back("//Code generated by PicToCode version " + PicToCodeMenuDialog().GetVersion());
  v.push_back("//From http://www.richelbilderbeek.nl/ToolPicToCode.htm");
  v.push_back("struct Pic");
  v.push_back("{");
  v.push_back("  void Draw(u16 * const buffer,const int x,const int y) const");
  v.push_back("  {");
  v.push_back("    const int maxx = 256;");
  v.push_back("    //const int maxy = 192;");

  const int width  = std::min(256,ui->label_picture->pixmap()->width());
  const int height = std::min(192,ui->label_picture->pixmap()->height());

  assert(image.bytesPerLine() / width == 4
    && "Assume there are 4 bytes per pixel");

  for (int y=0; y!=height; ++y)
  {
    const unsigned char * const line
      = static_cast<const unsigned char *>(image.scanLine(y));
    for (int x=0; x!=width; ++x)
    {
      const int a = boost::numeric_cast<int>(line[x*4+3]);
      if (!a) continue;
      const int r = boost::numeric_cast<int>(line[x*4+2]) >> 3;
      const int g = boost::numeric_cast<int>(line[x*4+1]) >> 3;
      const int b = boost::numeric_cast<int>(line[x*4+0]) >> 3;
      v.push_back(
          std::string("    buffer[((y+")
        + boost::lexical_cast<std::string>(y)
        + std::string(")*maxx)+(x+")
        + boost::lexical_cast<std::string>(x)
        + std::string(")] = RGB15(")
        + boost::lexical_cast<std::string>(r)
        + std::string(",")
        + boost::lexical_cast<std::string>(g)
        + std::string(",")
        + boost::lexical_cast<std::string>(b)
        + std::string(");"));
    }
  }
  v.push_back("  }");
  v.push_back(
    std::string("  int GetWidth() const { return ")
    + boost::lexical_cast<std::string>(width)
    + std::string("; }"));
  v.push_back(
    std::string("  int GetHeight() const { return ")
    + boost::lexical_cast<std::string>(height)
    + std::string("; }"));

  v.push_back("};");
  return v;
}

const std::vector<std::string>
  ribi::QtPicToCodeMainDialog::PicToQtCode(const QImage& qt_image) const
{
  return PicToCodeMainDialog::PicToQtCode(
    ImageToImage(qt_image));
  /*
  const PicToCodeMainDialog::YxImage image = ImageToImage(qt_image);
  const int width  = image.width();
  const int height = image.height();
  assert(width  == qt_image.width());
  assert(height == qt_image.height());

  std::vector<std::string> v;
  //Function declaration
  v.push_back("//Code generated by PicToCode version " + PicToCodeMenuDialog::GetVersion());
  v.push_back("//From http://www.richelbilderbeek.nl/ToolPicToCode.htm");
  v.push_back("QPixmap Draw()");
  v.push_back("{");
  v.push_back("  const int width  = "
    + boost::lexical_cast<std::string>(width) + ";");
  v.push_back("  const int height = "
    + boost::lexical_cast<std::string>(height) + ";");
  v.push_back("  QPixmap pixmap(width,height);");
  v.push_back("  QImage image = pixmap.toImage();");
  for (int y=0; y!=height; ++y)
  {

    v.push_back("  {");
    v.push_back("    unsigned char * const line");
    v.push_back("      = static_cast<unsigned char *>(image.scanLine("
      + boost::lexical_cast<std::string>(y)
      + "));");
    for (int x=0; x!=width; ++x)
    {
      v.push_back("    line["
        + boost::lexical_cast<std::string>((x*4)+0)
        + "] = "
        + boost::lexical_cast<std::string>(image.m_v[y][x].b)
        + "; line["
        + boost::lexical_cast<std::string>((x*4)+1)
        + "] = "
        + boost::lexical_cast<std::string>(image.m_v[y][x].g)
        +"; line["
        + boost::lexical_cast<std::string>((x*4)+2)
        + "] = "
        + boost::lexical_cast<std::string>(image.m_v[y][x].r)
        +"; line["
        + boost::lexical_cast<std::string>((x*4)+3)
        + "] = "
        + boost::lexical_cast<std::string>(image.m_v[y][x].a)
        +";");
    }
    v.push_back("  }");
  }
  v.push_back("  pixmap = pixmap.fromImage(image);");
  v.push_back("  //Add transparency");
  v.push_back("  const QBitmap mask = pixmap.createMaskFromColor(QColor(0,0,0,0).rgb());");
  v.push_back("  pixmap.setMask(mask);");
  v.push_back("  return pixmap;");
  v.push_back("}");
  return v;
  */
}

