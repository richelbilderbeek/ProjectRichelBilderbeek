<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>BinaryNewickVector</title>
  <meta name="description" content="C++ BinaryNewickVector"/>
  <meta name="keywords" content="C++ BinaryNewickVector "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a></h1>
<p>&nbsp;</p>
<!-- This page is generated by CodeToHtml version 1.1.647 at Fri Jun  6 17:12:17 2014
 -->
<p><img src="PicStl.png" alt="STL"/><img src="PicQtCreator.png" alt="Qt Creator"/><img src="PicLubuntu.png" alt="Lubuntu"/></p>
<p>&nbsp;</p>
<p>
  <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> is a <a href="CppDataType.htm">data type</a>
  for storing phylogenies in the <a href="CppNewick.htm">Newick</a> format.
</p>
<p>&nbsp;</p>
<p>
  The <a href="Tools.htm">tool</a> <a href="ToolTestBinaryNewickVector.htm">TestBinaryNewickVector</a>
  is a GUI to test and experiment with <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>.
</p>
<p>&nbsp;</p>
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppBinaryNewickVector/CppBinaryNewickVector.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppBinaryNewickVector/CppBinaryNewickVector.pri" border = "1"><tr><td><code>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppBinaryNewickVector.htm">CppBinaryNewickVector</a><br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppBinaryNewickVector.htm">CppBinaryNewickVector</a>/<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.cpp<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a>&nbsp;&nbsp;+= \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppBinaryNewickVector.htm">CppBinaryNewickVector</a>/<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.h<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppBinaryNewickVector.htm">CppBinaryNewickVector</a>/Licence.txt<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppBinaryNewickVector/binarynewickvector.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppBinaryNewickVector/binarynewickvector.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>, <b><a href="CppClass.htm">class</a></b> to store a <a href="CppNewick.htm">Newick</a> as a <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppBinaryNewickVector.htm">CppBinaryNewickVector</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> RIBI_BINARYNEWICKVECTOR_H<br/>
<a href="CppDefine.htm">#define</a> RIBI_BINARYNEWICKVECTOR_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBigInt.htm">BigIntegerLibrary</a>.hh"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>storage.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> manages a <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; resembling<br/>
<a href="CppComment.htm">///</a>a binary <a href="CppNewick.htm">Newick</a>.<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> CalcDenominator(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBigInt.htm">BigInteger</a> <a href="CppCalcNumOfCombinations.htm">CalcNumOfCombinations</a>() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBigInt.htm">BigInteger</a> <a href="CppCalcNumOfSymmetries.htm">CalcNumOfSymmetries</a>() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v.empty(); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Peek at the implementation<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; Peek() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; <a href="CppGetSimplerNewicks.htm">GetSimplerNewicks</a>() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>,<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; <a href="CppGetRootBranches.htm">GetRootBranches</a>() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsSimple() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Size() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; m_v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppDouble.htm">double</a></b> CalculateProbabilityInternal(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>Storage&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt;&amp; storage);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsCloseBracketRight(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> pos) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsOpenBracketLeft(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> pos) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> LoseBrackets(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> TermIsNotOne(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> TermIsOne(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPublic.htm">public</a></b>:<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppDouble.htm">double</a></b> CalculateProbability(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppNewick.htm">newick</a>_str,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppNewick.htm">Newick</a>Compare(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; lhs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> RIBI_BINARYNEWICKVECTOR_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppBinaryNewickVector/binarynewickvector.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppBinaryNewickVector/binarynewickvector.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>, <b><a href="CppClass.htm">class</a></b> to store a <a href="CppNewick.htm">Newick</a> as a <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppBinaryNewickVector.htm">CppBinaryNewickVector</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppDequeH.htm">deque</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFunctionalH.htm">functional</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppMapH.htm">map</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppNumericH.htm">numeric</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBigInt.htm">BigIntegerLibrary</a>.hh"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;: m_v{<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s)}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::IsUnary<a href="CppNewick.htm">Newick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s)));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Can I add these as well?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::IsUnary<a href="CppNewick.htm">Newick</a>(m_v) <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(m_v));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(m_v.empty() <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v)<br/>
&nbsp;&nbsp;: m_v{v}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::IsUnary<a href="CppNewick.htm">Newick</a>(m_v) <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(m_v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v.empty() <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::CalcDenominator(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppNewick.htm">Newick</a>::CalcDenominator(Peek(),theta);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBigInt.htm">BigInteger</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppCalcNumOfCombinations.htm">CalcNumOfCombinations</a>() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppNewick.htm">Newick</a>::<a href="CppCalcNumOfCombinations.htm">CalcNumOfCombinations</a>Binary(m_v);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBigInt.htm">BigInteger</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppCalcNumOfSymmetries.htm">CalcNumOfSymmetries</a>() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppNewick.htm">Newick</a>::<a href="CppCalcNumOfSymmetriesBinary.htm">CalcNumOfSymmetriesBinary</a>(m_v);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::IsSimple(m_v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(theta &gt; 0.0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(m_v,theta);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::CalculateProbability(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppNewick.htm">newick</a>_str,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(<a href="CppNewick.htm">newick</a>_str));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::IsUnary<a href="CppNewick.htm">Newick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(<a href="CppNewick.htm">newick</a>_str))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(<a href="CppNewick.htm">newick</a>_str)));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(theta &gt; 0.0);<br/>
&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> <a href="CppNewick.htm">newick</a>(<a href="CppNewick.htm">newick</a>_str);<br/>
&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>Storage&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; storage(<a href="CppNewick.htm">newick</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CalculateProbabilityInternal(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">newick</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;theta,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;storage);<br/>
<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::CalculateProbabilityInternal(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta,<br/>
&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>Storage&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt;&amp; storage)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> DEBUG_BINARYNEWICKVECTOR_CALCULATEPROBABILITYINTERNAL<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b>(1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is n already known?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p <a href="CppOperatorAssign.htm">=</a> storage.Find(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (p<a href="CppOperatorNotEqual.htm">!=</a>0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> simple phylogeny<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n.IsSimple())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p <a href="CppOperatorAssign.htm">=</a> n.CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(theta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.Store(n,p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Complex<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Generate other <a href="CppNewick.htm">Newick</a>s and their coefficients<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; coefficients;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; <a href="CppNewick.htm">newick</a>s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> d <a href="CppOperatorAssign.htm">=</a> n.CalcDenominator(theta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> DEBUG_BINARYNEWICKVECTOR_CALCULATEPROBABILITYINTERNAL<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Denominator <b><a href="CppFor.htm">for</a></b> "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> n.ToStr()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> " <a href="CppOperatorAssign.htm">=</a> "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;,<b><a href="CppInt.htm">int</a></b>&gt; <a href="CppNewick.htm">Newick</a>FrequencyPair;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppNewick.htm">Newick</a>FrequencyPair&gt; <a href="CppNewick.htm">newick</a>_freqs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppGetSimplerNewicks.htm">GetSimplerNewicks</a>FrequencyPairs(n.Peek());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppNewick.htm">Newick</a>FrequencyPair&amp; p: <a href="CppNewick.htm">newick</a>_freqs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> frequency <a href="CppOperatorAssign.htm">=</a> p.second;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(frequency &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (frequency <a href="CppOperatorEqual.htm">==</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">newick</a>s.push_back(p.first);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coefficients.push_back(theta <a href="CppOperatorDivide.htm">/</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> f_d <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(frequency);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">newick</a>s.push_back(p.first);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coefficients.push_back( (f_d*(f_d-1.0)) <a href="CppOperatorDivide.htm">/</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> DEBUG_BINARYNEWICKVECTOR_CALCULATEPROBABILITYINTERNAL<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppNewick.htm">Newick</a>::<a href="CppNewickToString.htm">NewickToString</a>(p.first)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> " has coefficient "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(coefficients.back())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ask help <a href="CppAbout.htm">about</a> these <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">newick</a>s.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">newick</a>s.size() <a href="CppOperatorEqual.htm">==</a> coefficients.size() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> p <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursive <a href="CppFunction.htm">function</a> call<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p<a href="CppOperatorPlusAssign.htm">+=</a>(coefficients[i] * CalculateProbabilityInternal(<a href="CppNewick.htm">newick</a>s[i],theta,storage));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.Store(n,p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdBad_alloc.htm">std::bad_alloc</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.CleanUp();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppStdBad_alloc.htm">std::bad_alloc</a>\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.CleanUp();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppStdException.htm">std::exception</a>";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (...)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage.CleanUp();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Unknown <a href="CppException.htm">exception</a>\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppGetSimplerNewicks.htm">GetSimplerNewicks</a>() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::GetSimplerBinary<a href="CppNewick.htm">Newick</a>s(m_v);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; w(v.begin(),v.end());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>,<a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppGetRootBranches.htm">GetRootBranches</a>() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
&nbsp;&nbsp;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;,<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; p<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppGetRootBranches.htm">GetRootBranches</a>Binary(m_v);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "3.1";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2009-06-01: <a href="CppVersion.htm">Version</a> 1.0: Initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2010-08-10: <a href="CppVersion.htm">Version</a> 1.1: Major architectural revision",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2011-02-20: <a href="CppVersion.htm">Version</a> 1.2: Removed helper <a href="CppFunction.htm">function</a>s from global <b><a href="CppNamespace.htm">namespace</a></b>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2011-02-22: <a href="CppVersion.htm">Version</a> 2.0: Changed file management",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2011-03-01: <a href="CppVersion.htm">Version</a> 3.0: major rewrite of <a href="CppAlgorithm.htm">algorithm</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2011-04-08: <a href="CppVersion.htm">Version</a> 3.1: fixed error forgiven by G<a href="CppOperatorIncrement.htm">++</a>, but fatal <b><a href="CppFor.htm">for</a></b> <a href="CppI686-pc-mingw32-qmake.htm">i686-pc-mingw32-qmake</a>"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
 <b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::IsCloseBracketRight(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> pos) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_v.size();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos &lt; sz);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[pos]<a href="CppOperatorEqual.htm">==</a>1);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=pos+1; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) <a href="CppComment.htm">//</a>+1 because v[pos]<a href="CppOperatorEqual.htm">==</a>1<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> m_v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorEqual.htm">==</a> <a href="CppNewick.htm">Newick</a>::bracket_close) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorEqual.htm">==</a> <a href="CppNewick.htm">Newick</a>::bracket_open) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>There will always be a <b><a href="CppFinal.htm">final</a></b> closing bracket at the right<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> that is not stored in a <a href="CppSortedBinaryNewickVector.htm">SortedBinaryNewickVector</a>'s <a href="CppStdVector.htm">std::vector</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::IsOpenBracketLeft(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> pos) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[pos]<a href="CppOperatorEqual.htm">==</a>1);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=pos-1; i<a href="CppOperatorNotEqual.htm">!=</a>-1; <a href="CppOperatorDecrement.htm">--</a>i) <a href="CppComment.htm">//</a>-1, because v[pos]<a href="CppOperatorEqual.htm">==</a>1<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> m_v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorEqual.htm">==</a> <a href="CppNewick.htm">Newick</a>::bracket_open) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorEqual.htm">==</a> <a href="CppNewick.htm">Newick</a>::bracket_close) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>There will always be a trailing opening bracket at the left<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> that is not stored in a <a href="CppSortedBinaryNewickVector.htm">SortedBinaryNewickVector</a>'s <a href="CppStdVector.htm">std::vector</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::IsSimple() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppNewick.htm">Newick</a>::IsSimple(m_v);<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::SetTheta(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
<a href="CppComment.htm">//</a>{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(theta &gt; 0.0);<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;m_theta <a href="CppOperatorAssign.htm">=</a> theta;<br/>
<a href="CppComment.htm">//</a>}<br/>
<br/>
<a href="CppComment.htm">//</a>Does the following conversions:<br/>
<a href="CppComment.htm">//</a> (5,(5,1)) <a href="CppOperatorMinus.htm">-</a>&gt; (5,6)<br/>
<a href="CppComment.htm">//</a> (4,(5,1)) <a href="CppOperatorMinus.htm">-</a>&gt; (4,6)<br/>
<a href="CppComment.htm">//</a> (4,(3,1)) <a href="CppOperatorMinus.htm">-</a>&gt; (4,4)<br/>
<a href="CppComment.htm">//</a> (4,(1,1)) <a href="CppOperatorMinus.htm">-</a>&gt; (4,2)<br/>
<a href="CppComment.htm">//</a> string_pos <a href="CppPointer.htm">point</a>s at an index in the string current.<a href="CppNewick.htm">newick</a> after the '1'<br/>
<a href="CppComment.htm">//</a> For example, <b><a href="CppFor.htm">for</a></b> (4,(3,1)) the string_pos equals 7<br/>
<a href="CppComment.htm">//</a> num is the other value between brackets<br/>
<a href="CppComment.htm">//</a> For example, <b><a href="CppFor.htm">for</a></b> (4,(3,1)) num will equal 3<br/>
<a href="CppComment.htm">//</a> (5,(5,1)) <a href="CppOperatorMinus.htm">-</a>&gt; (5,6)<br/>
<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a>&gt; sz <a href="CppOperatorAssign.htm">=</a> 9<br/>
<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a>&gt; bracket_open_pos&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> 3<br/>
<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a>&gt; bracket_close_pos <a href="CppOperatorAssign.htm">=</a> 7<br/>
<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a>&gt; sz_loss <a href="CppOperatorAssign.htm">=</a> 4 <a href="CppOperatorAssign.htm">=</a> 7 <a href="CppOperatorMinus.htm">-</a> 3 <a href="CppOperatorAssign.htm">=</a> bracket_close_pos <a href="CppOperatorMinus.htm">-</a> bracket_open_pos<br/>
<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a>&gt; new_sz <a href="CppOperatorAssign.htm">=</a> 5<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::LoseBrackets(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[i] <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x&gt;0);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v_copy <a href="CppOperatorAssign.htm">=</a> m_v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bracket_open_pos<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> FindPosBefore(m_v,<a href="CppNewick.htm">Newick</a>::bracket_open,i);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(bracket_open_pos &gt; <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bracket_close_pos<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> FindPosAfter(m_v,<a href="CppNewick.htm">Newick</a>::bracket_close,i);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(bracket_close_pos &lt; Size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> Size();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz_lose <a href="CppOperatorAssign.htm">=</a> bracket_close_pos <a href="CppOperatorMinus.htm">-</a> bracket_open_pos;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz_new <a href="CppOperatorAssign.htm">=</a> sz <a href="CppOperatorMinus.htm">-</a> sz_lose;<br/>
&nbsp;&nbsp;v_copy[bracket_open_pos] <a href="CppOperatorAssign.htm">=</a> x+1;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;::<a href="CppIterator.htm">iterator</a> begin_iter(&amp;v_copy[bracket_close_pos+1]);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;::<a href="CppIterator.htm">iterator</a> output_iter(&amp;v_copy[bracket_open_pos+1]);<br/>
&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(begin_iter,v_copy.end(),output_iter);<br/>
&nbsp;&nbsp;v_copy.resize(sz_new);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(v_copy);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppNewick.htm">Newick</a>Compare(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> l_sz <a href="CppOperatorAssign.htm">=</a> lhs.size();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> r_sz <a href="CppOperatorAssign.htm">=</a> rhs.size();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (l_sz &lt; r_sz) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (l_sz &gt; r_sz) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;::const_iterator Iter;<br/>
&nbsp;&nbsp;Iter lhs_iter <a href="CppOperatorAssign.htm">=</a> lhs.begin();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Iter lhs_end <a href="CppOperatorAssign.htm">=</a> lhs.end();<br/>
&nbsp;&nbsp;Iter rhs_iter <a href="CppOperatorAssign.htm">=</a> rhs.begin();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> ( ; lhs_iter <a href="CppOperatorNotEqual.htm">!=</a> lhs_end; <a href="CppOperatorIncrement.htm">++</a>lhs_iter, <a href="CppOperatorIncrement.htm">++</a>rhs_iter)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x_l <a href="CppOperatorAssign.htm">=</a> *lhs_iter;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x_r <a href="CppOperatorAssign.htm">=</a> *rhs_iter;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x_l &lt; x_r) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x_l &gt; x_r) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::Size() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size());<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::TermIsNotOne(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[i]&gt;1);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v(m_v);<br/>
&nbsp;&nbsp;<a href="CppOperatorDecrement.htm">--</a>v[i];<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(v);<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a>TermIsOne is called whenever a '1' is found in a <a href="CppNewick.htm">newick</a> structure<br/>
<a href="CppComment.htm">//</a>string_pos has the index of the <a href="CppChar.htm">character</a> after <b><a href="CppThis.htm">this</a></b> '1'<br/>
<a href="CppComment.htm">//</a> (when a string has multiple 1's, TermIsOne is called <b><a href="CppFor.htm">for</a></b> each '1',<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;with each <a href="CppTime.htm">time</a> a different string_pos)<br/>
<a href="CppComment.htm">//</a>If <b><a href="CppThis.htm">this</a></b> '1' is between two brackets, with one other number,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;these two numbers are added and the brackets are removed<br/>
<a href="CppComment.htm">//</a>If <b><a href="CppThis.htm">this</a></b> '1' is not between two brackets,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;the <a href="CppNewick.htm">newick</a> string <b><a href="CppReturn.htm">return</a></b>ed is empty<br/>
<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> examples<br/>
<a href="CppComment.htm">//</a> (3,(15,1)), string_pos 8 <a href="CppOperatorMinus.htm">-</a>&gt; (3,16)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp; EXIT1<br/>
<a href="CppComment.htm">//</a> (2,(23,1)), string_pos 8 <a href="CppOperatorMinus.htm">-</a>&gt; (2,24)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp; EXIT1<br/>
<a href="CppComment.htm">//</a> (1,(20,5)), string_pos 2 <a href="CppOperatorMinus.htm">-</a>&gt; [empty]<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT-2<br/>
<a href="CppComment.htm">//</a> (1,(1,1)), string_pos 2 <a href="CppOperatorMinus.htm">-</a>&gt; [empty]<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXIT-2<br/>
<a href="CppComment.htm">//</a> (1,(1,1)), string_pos 5 <a href="CppOperatorMinus.htm">-</a>&gt; (1,2)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXIT-2<br/>
<a href="CppComment.htm">//</a> (1,(1,1)), string_pos 7 <a href="CppOperatorMinus.htm">-</a>&gt; (1,2)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;&nbsp;&nbsp;&nbsp;EXIT-1<br/>
<a href="CppComment.htm">//</a> ((1,2,3),3), string_pos 3 <a href="CppOperatorMinus.htm">-</a>&gt; (3,3) <a href="CppComment.htm">//</a>Might be incorrect: <a href="CppAlgorithm.htm">algorithm</a> holds <b><a href="CppFor.htm">for</a></b> two numbers between brackets<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;^<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::TermIsOne(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_v.size();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(new_<a href="CppNewick.htm">newick</a>.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; sz);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[i] <a href="CppOperatorEqual.htm">==</a> 1); <a href="CppComment.htm">//</a>Must be a 1<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> open_bracket_left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> IsOpenBracketLeft(i);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> close_bracket_right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> IsCloseBracketRight(i);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (open_bracket_left <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> close_bracket_right <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find other_value<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> other_value <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If adjecent to the left is a comma<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> and subsequently a value,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i &gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_v[i-1]&nbsp;&nbsp;&gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_value <a href="CppOperatorAssign.htm">=</a> m_v[i-1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorPlus.htm">+</a> 1 &lt; sz<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_v[i+1]&nbsp;&nbsp;&gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_value <a href="CppOperatorAssign.htm">=</a> m_v[i+1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(other_value <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> LoseBrackets(other_value,i);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Return an empty <a href="CppSortedBinaryNewickVector.htm">SortedBinaryNewickVector</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check that well-formed <a href="CppNewick.htm">Newick</a>s are confirmed valid<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppCreateValidNewicks.htm">CreateValidNewicks</a>();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("I must be accepted: " <a href="CppOperatorPlus.htm">+</a> s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> valid <a href="CppNewick.htm">newick</a>s (as <a href="CppStdString.htm">std::string</a>) are marked as valid<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>::<a href="CppCheckNewick.htm">CheckNewick</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "(" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> __<a href="CppCfile.htm">FILE</a>__ <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> __LINE__ <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ": " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> e.what() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> valid <a href="CppNewick.htm">newick</a>s (as <a href="CppStdVector.htm">std::vector</a>) are marked as valid<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; n <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>::<a href="CppCheckNewick.htm">CheckNewick</a>(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(n));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " (<a href="CppConvert.htm">convert</a>ed to <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;): "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> e.what();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <a href="CppStdString.htm">std::string</a> conversion (from <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<a href="CppStdString.htm">std::string</a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( !<a href="CppNewick.htm">Newick</a>::IsUnary<a href="CppNewick.htm">Newick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !<a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> temp(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorEqual.htm">==</a> temp.ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " (<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> from <a href="CppStdString.htm">std::string</a>): "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> e.what();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <a href="CppStdString.htm">std::string</a> conversion (from <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; n <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> temp(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorEqual.htm">==</a> temp.ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " (<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> from <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;): "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> e.what();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the simpler <a href="CppNewick.htm">Newick</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; simpler<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::GetSimplerBinary<a href="CppNewick.htm">Newick</a>s(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; simple: simpler)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(simple));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>::<a href="CppCheckNewick.htm">CheckNewick</a>(simple);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the branches, only of binary <a href="CppNewick.htm">Newick</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;,<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppGetRootBranches.htm">GetRootBranches</a>Binary(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(b.first));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(b.second));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(m_v));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppNewick.htm">Newick</a>::<a href="CppNewickToString.htm">NewickToString</a>(m_v);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> lhs.v &lt; rhs.v;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>::<a href="CppNewick.htm">Newick</a>Compare(lhs.Peek(),rhs.Peek());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
