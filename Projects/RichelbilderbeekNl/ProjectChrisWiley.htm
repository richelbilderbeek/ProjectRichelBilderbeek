<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>ChrisWiley</title>
  <meta name="description" content="C++ ChrisWiley"/>
  <meta name="keywords" content="C++ ChrisWiley "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="ProjectChrisWiley.htm">ChrisWiley</a></h1>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/bird.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/bird.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "bird.h"<br/>
#include &lt;cstdlib&gt;<br/>
//---------------------------------------------------------------------------<br/>
Bird::Bird(const Bird&amp; mother, const Bird&amp; father, const double&amp; mutation)<br/>
{<br/>
&nbsp;&nbsp;descent = (mother.descent + father.descent) / 2.0;<br/>
&nbsp;&nbsp;assert(descent&gt;=-1.0 &amp;&amp; descent&lt;=1.0);<br/>
&nbsp;&nbsp;const double chanceBeingPied = 1.0-((descent+1.0)/2.0);<br/>
&nbsp;&nbsp;assert(chanceBeingPied&gt;=0.0 &amp;&amp; chanceBeingPied&lt;=1.0);<br/>
&nbsp;&nbsp;species = (rnd::uniform() &gt; chanceBeingPied ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;//Make a bit<br/>
&nbsp;&nbsp;unsigned int number = std::rand()%64;<br/>
&nbsp;&nbsp;index = (number%2==0 ? mother.index : father.index);<br/>
&nbsp;&nbsp;number&gt;&gt;=1;<br/>
&nbsp;&nbsp;trait = (number%2==0 ? mother.trait : father.trait);<br/>
&nbsp;&nbsp;trait+=rnd::normal(0.0,mutation);<br/>
&nbsp;&nbsp;number&gt;&gt;=1;<br/>
&nbsp;&nbsp;preference = (number%2==0 ? mother.preference : father.preference);<br/>
&nbsp;&nbsp;preference+=rnd::normal(0.0,mutation);<br/>
&nbsp;&nbsp;number&gt;&gt;=1;<br/>
&nbsp;&nbsp;assessingError = (number%2==0 ? mother.assessingError : father.assessingError);<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Male&gt; Bird::createMales(const Parameters&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;//Create males<br/>
&nbsp;&nbsp;assert(parameters.fractionMaleA&gt;=0.0 &amp;&amp; parameters.fractionMaleA&lt;=1.0);<br/>
&nbsp;&nbsp;//Create an empty vector of males<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males; //(parameters.nMales);<br/>
&nbsp;&nbsp;//Calculate the number of males of speciesA<br/>
&nbsp;&nbsp;const unsigned int nSpeciesA =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0.5 + (static_cast&lt;double&gt;(parameters.nMales) * parameters.fractionMaleA)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
&nbsp;&nbsp;const unsigned int nSpeciesB =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0.5 + (static_cast&lt;double&gt;(parameters.nMales) * (1.0-parameters.fractionMaleA))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
&nbsp;&nbsp;//Dot("Of " + IntToStr(nMales) + " males, there are " + IntToStr(nSpeciesA) + " of speciesA");<br/>
&nbsp;&nbsp;//Fill the vector<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSpeciesA; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Male maleA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.species = piedFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.descent = -1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.trait = rnd::normal(parameters.meanTraitA, parameters.stdDevTraitA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.preference = rnd::normal(parameters.meanPreferenceA, parameters.stdDevPreferenceA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.assessingError = parameters.assessingErrorA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.push_back(maleA);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (unsigned int i=0 ; i&lt;nSpeciesB; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Male maleB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.species = collaredFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.descent = 1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.trait = rnd::normal(parameters.meanTraitB, parameters.stdDevTraitB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.preference = rnd::normal(parameters.meanPreferenceB, parameters.stdDevPreferenceB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.assessingError = parameters.assessingErrorB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.push_back(maleB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return males;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Female&gt; Bird::createFemales(const Parameters&amp; parameters)<br/>
//Create females<br/>
{<br/>
&nbsp;&nbsp;assert(parameters.fractionFemaleA&gt;=0.0 &amp;&amp; parameters.fractionFemaleA&lt;=1.0);<br/>
&nbsp;&nbsp;//Create an empty vector of females<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females;<br/>
&nbsp;&nbsp;//Calculate the number of females of speciesA<br/>
&nbsp;&nbsp;const unsigned int nSpeciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= 0.5 + (static_cast&lt;double&gt;(parameters.nFemales) * parameters.fractionFemaleA)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
<br/>
&nbsp;&nbsp;const unsigned int nSpeciesB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= 0.5 + (static_cast&lt;double&gt;(parameters.nFemales) * (1.0-parameters.fractionFemaleA))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
<br/>
&nbsp;&nbsp;//Fill the vector<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSpeciesA; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Female femaleA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.species = piedFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.descent = -1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.preference = rnd::normal(parameters.meanPreferenceA, parameters.stdDevPreferenceA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.assessingError = parameters.assessingErrorA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.trait = rnd::normal(parameters.meanTraitA, parameters.stdDevTraitA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.push_back(femaleA);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (unsigned int i=0 ; i&lt;nSpeciesB; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Female femaleB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.species = collaredFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.descent = 1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.preference = rnd::normal(parameters.meanPreferenceB, parameters.stdDevPreferenceB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.assessingError = parameters.assessingErrorB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.trait = rnd::normal(parameters.meanTraitB, parameters.stdDevTraitB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.push_back(femaleB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return females;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Male&gt; Bird::createTestMales(<br/>
&nbsp;&nbsp;const Parameters&amp; /*parameters*/,<br/>
&nbsp;&nbsp;const double&amp; species1, const double&amp; trait1,<br/>
&nbsp;&nbsp;const double&amp; species2, const double&amp; trait2,<br/>
&nbsp;&nbsp;const double&amp; species3, const double&amp; trait3,<br/>
&nbsp;&nbsp;const double&amp; species4, const double&amp; trait4<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;//Create an empty vector of males<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males;<br/>
&nbsp;&nbsp;//Calculate the number of males of speciesA<br/>
&nbsp;&nbsp;//Dot("Of " + IntToStr(nMales) + " males, there are " + IntToStr(nSpeciesA) + " of speciesA");<br/>
&nbsp;&nbsp;//Fill the vector<br/>
&nbsp;&nbsp;Male male1, male2, male3, male4;<br/>
&nbsp;&nbsp;male1.descent = species1; male1.trait = trait1; male1.species = (rnd::uniform() &gt; 1.0-((male1.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;male2.descent = species2; male2.trait = trait2; male2.species = (rnd::uniform() &gt; 1.0-((male2.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;male3.descent = species3; male3.trait = trait3; male3.species = (rnd::uniform() &gt; 1.0-((male3.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;male4.descent = species4; male4.trait = trait4; male4.species = (rnd::uniform() &gt; 1.0-((male4.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;males.push_back(male1);<br/>
&nbsp;&nbsp;males.push_back(male2);<br/>
&nbsp;&nbsp;males.push_back(male3);<br/>
&nbsp;&nbsp;males.push_back(male4);<br/>
&nbsp;&nbsp;return males;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Female&gt; Bird::createTestFemales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species, const double&amp; preference)<br/>
//Create females<br/>
{<br/>
&nbsp;&nbsp;//Create an empty vector of females<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females;<br/>
&nbsp;&nbsp;//Fill the vector with one female<br/>
&nbsp;&nbsp;Female female;<br/>
&nbsp;&nbsp;female.descent = species;<br/>
&nbsp;&nbsp;female.species = (rnd::uniform() &gt; 1.0-((female.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;female.preference = preference;<br/>
&nbsp;&nbsp;female.assessingError = parameters.assessingErrorA;<br/>
&nbsp;&nbsp;females.push_back(female);<br/>
&nbsp;&nbsp;return females;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/bird.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/bird.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef BIRD_H<br/>
#define BIRD_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;cassert&gt;<br/>
#include "helperfunctions.h"<br/>
#include "parameters.h"<br/>
#include "enums.h"<br/>
#include "random.h"<br/>
<br/>
class Couple; //Forward declaration<br/>
<br/>
class Bird<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
<br/>
&nbsp;&nbsp;Bird(const Bird&amp; mother, const Bird&amp; father, const double&amp; mutation);<br/>
<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createMales(const Parameters&amp; parameters);<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createFemales(const Parameters&amp; parameters);<br/>
<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createTestMales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species1, const double&amp; trait1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species2, const double&amp; trait2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species3, const double&amp; trait3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species4, const double&amp; trait4);<br/>
<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createTestFemales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species, const double&amp; preference);<br/>
<br/>
&nbsp;&nbsp;unsigned int index;<br/>
&nbsp;&nbsp;double descent;<br/>
&nbsp;&nbsp;enumSpecies species;<br/>
&nbsp;&nbsp;double trait;<br/>
&nbsp;&nbsp;double preference;<br/>
&nbsp;&nbsp;double assessingError;<br/>
<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;//No empty constructor, Birds are either created from parents or<br/>
&nbsp;&nbsp;//from the static createMales/createFemales functions<br/>
&nbsp;&nbsp;Bird() {}<br/>
};<br/>
<br/>
typedef Bird Male;<br/>
typedef Bird Female;<br/>
<br/>
struct Offspring<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females;<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&nbsp;&nbsp; males;<br/>
};<br/>
<br/>
typedef Offspring Population;<br/>
<br/>
class Couple<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;Couple(const Female&amp; anyFemale, const Male&amp; anyMale)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: female(anyFemale),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;male(anyMale)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Nothing<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Female female;<br/>
&nbsp;&nbsp;Male&nbsp;&nbsp; male;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
#endif // BIRD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/densitydependentselection.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/densitydependentselection.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "densitydependentselection.h"<br/>
#include "speciestally.h"<br/>
//---------------------------------------------------------------------------<br/>
//bool StateDensityDependentSelectionAfterMating::canDoSelection(<br/>
//&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; /*females*/,<br/>
//&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; /*males*/,<br/>
//&nbsp;&nbsp;const Parameters&amp; /*parameters*/,<br/>
//&nbsp;&nbsp;std::string&amp; /*errorMessage*/<br/>
//&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
//&nbsp;&nbsp;) const<br/>
//{<br/>
//&nbsp;&nbsp;return true;<br/>
//}<br/>
//---------------------------------------------------------------------------<br/>
//void StateDensityDependentSelectionAfterMating::doSelection(<br/>
//&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; /*females*/,<br/>
//&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; /*males*/,<br/>
//&nbsp;&nbsp;const Parameters&amp; /*parameters*/<br/>
//&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
//&nbsp;&nbsp;) const<br/>
//{<br/>
//&nbsp;&nbsp;//Nothing, density dependent selection is found in MatingSystemFixedNumberOffspring<br/>
//}<br/>
//---------------------------------------------------------------------------<br/>
//This type of selection occurs before mating<br/>
//Idea is, that the population structure is constant before mating.<br/>
//This means that the number of malesA, malesB, femalesA and femalesB<br/>
//is constant. This is reached by removing superfluous individuals.<br/>
//If however, too few individuals are present, selection cannot take<br/>
//place and the population is called extinct.<br/>
bool StateDensityDependentSelectionBeforeMating::canDoSelection(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;//assert(speciesTally.isNull()==false);<br/>
&nbsp;&nbsp;SpeciesTally speciesTally;<br/>
&nbsp;&nbsp;speciesTally.tallySpecies(females,males);<br/>
<br/>
&nbsp;&nbsp;if ( speciesTally.getNfemalesA() &lt; parameters.getNfemalesAwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage = "Too few femalesA for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNfemalesAwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if ( speciesTally.getNfemalesB() &lt; parameters.getNfemalesBwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage = "Too few femalesB for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNfemalesBwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if ( speciesTally.getNmalesA() &lt; parameters.getNmalesAwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage = "Too few malesA for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNmalesAwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if ( speciesTally.getNmalesB() &lt; parameters.getNmalesBwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage =&nbsp;&nbsp;"Too few malesB for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNmalesBwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void StateDensityDependentSelectionBeforeMating::doSelection(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;unsigned int nMalesAwanted&nbsp;&nbsp; = parameters.getNmalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nMalesBwanted&nbsp;&nbsp; = parameters.getNmalesBwanted();<br/>
&nbsp;&nbsp;assert(nMalesAwanted + nMalesBwanted == parameters.nMales);<br/>
&nbsp;&nbsp;unsigned int nFemalesAwanted = parameters.getNfemalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nFemalesBwanted = parameters.getNfemalesBwanted();<br/>
&nbsp;&nbsp;assert(nFemalesAwanted + nFemalesBwanted == parameters.nFemales);<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;males.size(); ) //No increment<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (males[i].species == piedFlycatcher) //Male is of type A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesAwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; males.erase(males.begin() + i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nMalesAwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //Male is of type B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesBwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; males.erase(males.begin() + i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nMalesBwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;females.size(); ) //No increment<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (females[i].species == piedFlycatcher) //Female is of type A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesAwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; females.erase(females.begin() + i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nFemalesAwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //Female is of type B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesBwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; females.erase(females.begin() + i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nFemalesBwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#ifdef __HACK_089236408766433745<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int fs = females.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int ms = males.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int fw = parameters.nFemales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int mw = parameters.nMales;<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;std::random_shuffle(females.begin(), females.end());<br/>
&nbsp;&nbsp;std::random_shuffle(males.begin(), males.end());<br/>
&nbsp;&nbsp;assert(females.size()==parameters.nFemales);<br/>
&nbsp;&nbsp;assert(males.size()==parameters.nMales);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/densitydependentselection.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/densitydependentselection.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef DENSITYDEPENDENTSELECTION_H<br/>
#define DENSITYDEPENDENTSELECTION_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
//#include "UnitTallies.h"<br/>
#include "parameters.h"<br/>
#include "bird.h"<br/>
<br/>
class StateDensityDependentSelectionBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateDensityDependentSelectionBase() {}<br/>
&nbsp;&nbsp;virtual std::string getString() const = 0;<br/>
&nbsp;&nbsp;virtual bool canDoSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const = 0;<br/>
&nbsp;&nbsp;virtual void doSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const = 0;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
//class StateDensityDependentSelectionAfterMating : public StateDensityDependentSelectionBase<br/>
//{<br/>
//&nbsp;&nbsp;public:<br/>
//&nbsp;&nbsp;StateDensityDependentSelectionAfterMating() {}<br/>
//&nbsp;&nbsp;std::string getString() const { return "DensityDependentSelectionAfterMating"; }<br/>
//&nbsp;&nbsp;bool canDoSelection(<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;std::string&amp; errorMessage<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
//&nbsp;&nbsp;void doSelection(<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
//};<br/>
//---------------------------------------------------------------------------<br/>
class StateDensityDependentSelectionBeforeMating : public StateDensityDependentSelectionBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateDensityDependentSelectionBeforeMating() {}<br/>
&nbsp;&nbsp;std::string getString() const { return "DensityDependentSelectionBeforeMating"; }<br/>
&nbsp;&nbsp;bool canDoSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
&nbsp;&nbsp;void doSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
#endif // DENSITYDEPENDENTSELECTION_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/enums.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/enums.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef ENUMS_H<br/>
#define ENUMS_H<br/>
//---------------------------------------------------------------------------<br/>
enum enumSpecies<br/>
{<br/>
&nbsp;&nbsp;piedFlycatcher, //descent/speciesValue = -1<br/>
&nbsp;&nbsp;collaredFlycatcher&nbsp;&nbsp;//descent/speciesValue = 1.0<br/>
};<br/>
<br/>
enum enumDensityDependentSelection<br/>
{<br/>
&nbsp;&nbsp;beforeMating,<br/>
&nbsp;&nbsp;afterMating<br/>
};<br/>
<br/>
enum enumMatingSystem<br/>
{<br/>
&nbsp;&nbsp;monogamy,<br/>
&nbsp;&nbsp;polygyny //Male can mate multiple times<br/>
};<br/>
<br/>
enum enumFemaleSampling<br/>
{<br/>
&nbsp;&nbsp;bestOfNconspicific,<br/>
&nbsp;&nbsp;bestOfNextremeTrait,<br/>
&nbsp;&nbsp;bestOfNclosestTrait,<br/>
&nbsp;&nbsp;fixedThresholdConspicific,<br/>
&nbsp;&nbsp;fixedThresholdTraitSign,<br/>
&nbsp;&nbsp;fixedThresholdProbabilistic<br/>
};<br/>
<br/>
<br/>
#endif // ENUMS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/femalesampling.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/femalesampling.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;algorithm&gt;<br/>
#include "femalesampling.h"<br/>
//---------------------------------------------------------------------------<br/>
#define EXTREME_TEST<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingBestOfNconspicific::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int bestOfHowMuch = parameters.bestOfHowMuch;<br/>
&nbsp;&nbsp;//Create the male indices<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndices = createIndicesUnique(bestOfHowMuch, males.size());<br/>
&nbsp;&nbsp;const std::vector&lt;unsigned int&gt; maleIndicesCopy = maleIndices;<br/>
<br/>
&nbsp;&nbsp;//Remove the males that are either heterospecific or assessed wrong<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;maleIndices.size(); ) //No ++i indeed<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt; female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (female.species == piedFlycatcher) //Female is of species A (piedFlyCatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].species == collaredFlycatcher) //Male is of species B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndices.erase(maleIndices.begin() + i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //Male is of species A (piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++i; } //The male is a conspicific and remains in the vecor<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //Female is of species B (collaredFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].species == collaredFlycatcher) //Male is of species B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++i; }//The male is a conspicific and remains in the vecor<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //Male is of species A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndices.erase(maleIndices.begin() + i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//maleIndices.erase(&amp;maleIndices.at(i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i; //The wrongly assessed male remains<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Dot("Remaining male Indices"); Dot(maleIndices);<br/>
<br/>
&nbsp;&nbsp;//With the remaining candidats, she mates at random<br/>
&nbsp;&nbsp;if (maleIndices.size()&gt;0) //She found a suitable candidat<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int candidatIndex = std::rand()%maleIndices.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return maleIndicesCopy[ std::rand()%maleIndicesCopy.size() ];<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingBestOfNextremeTrait::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int bestOfHowMuch = ( parameters.bestOfHowMuch &lt; males.size() ? parameters.bestOfHowMuch : males.size());<br/>
&nbsp;&nbsp;//Create the male indices<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndices = createIndicesUnique(bestOfHowMuch, males.size());<br/>
<br/>
&nbsp;&nbsp;//Dot("Male Indices"); Dot(maleIndices);<br/>
<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;{ //Get the best male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (female.preference &lt; 0.0) //Find male with lowest trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int candidatIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bestTrait = males[ maleIndices[0] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=1; i&lt;bestOfHowMuch; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].trait &lt; bestTrait)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestTrait = males[ maleIndices[i] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidatIndex = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //Find male with highest trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int candidatIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bestTrait = males[ maleIndices[0] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=1; i&lt;bestOfHowMuch; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].trait &gt; bestTrait)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestTrait = males[ maleIndices[i] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidatIndex = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Female mates at random<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int candidatIndex = std::rand()%bestOfHowMuch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingBestOfNclosestTrait::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int bestOfHowMuch = ( parameters.bestOfHowMuch &lt; males.size() ? parameters.bestOfHowMuch : males.size());<br/>
&nbsp;&nbsp;//Create the male indices<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndices = createIndicesUnique(bestOfHowMuch, males.size());<br/>
<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;{ //Get the best male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int candidatIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double closestTrait = std::fabs(males[ maleIndices[0] ].trait - female.preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=1; i&lt;bestOfHowMuch; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::fabs(males[ maleIndices[i] ].trait - female.preference) &lt; closestTrait)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closestTrait = std::fabs(males[ maleIndices[0] ].trait - female.preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidatIndex = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Female mates at random<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int candidatIndex = std::rand()%bestOfHowMuch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingFixedThresholdConspicific::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; /*parameters*/) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;const enumSpecies femaleSpecies = female.species;<br/>
&nbsp;&nbsp;for(unsigned int i = 0; i &lt; nMales*2; ++i) //The female searches all males 2x<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int maleIndex = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const enumSpecies maleSpecies = males[maleIndex].species;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt;= female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him when either having a trait smaller of bigger then 0.5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (femaleSpecies == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleSpecies == piedFlycatcher) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male of species B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleSpecies == collaredFlycatcher) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(female.assessingError&gt;0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//She has not found a mate<br/>
&nbsp;&nbsp;//Dot("Female #" + IntToStr(female.index) + " has not found a mate");<br/>
&nbsp;&nbsp;return nMales;<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingFixedThresholdTraitSign::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; /*parameters*/) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;const double femalePreference = female.preference;<br/>
&nbsp;&nbsp;for(unsigned int i = 0; i &lt; nMales*2; ++i) //The female searches all males 2x<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int maleIndex = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double maleTrait = males[maleIndex].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt;= female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him when either having a trait smaller of bigger then 0.5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (femalePreference&lt;=0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male with low trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleTrait &lt;= 0.0) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male with high trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleTrait &gt;= 0.0) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(female.assessingError&gt;0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//She has not found a mate<br/>
&nbsp;&nbsp;return nMales;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingFixedThresholdProbabilistic::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;const double sigmaSquared = parameters.sigmaSquared;<br/>
&nbsp;&nbsp;const double femalePreference = female.preference;<br/>
&nbsp;&nbsp;for(unsigned int i = 0; i &lt; nMales*2; ++i) //The female searches all males 2x<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int maleIndex = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double maleTrait = males[maleIndex].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt;= female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him when either having a trait smaller of bigger then 0.5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//const double chanceToMate = std::exp(-(maleTrait-femalePreference)*(maleTrait-femalePreference)/sigmaSquared);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double chanceToMate = getChanceToMate(femalePreference,maleTrait,sigmaSquared);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &lt; chanceToMate) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(female.assessingError&gt;0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//She has not found a mate<br/>
&nbsp;&nbsp;return nMales;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double StateFemaleSamplingFixedThresholdProbabilistic::getChanceToMate(<br/>
&nbsp;&nbsp;const double&amp; femalePreference,<br/>
&nbsp;&nbsp;const double&amp; maleTrait,<br/>
&nbsp;&nbsp;const double&amp; sigmaSquared)<br/>
{<br/>
&nbsp;&nbsp; return std::exp(-(maleTrait-femalePreference)*(maleTrait-femalePreference)/sigmaSquared);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
//<br/>
// HELPER FUNCTIONS<br/>
//<br/>
//---------------------------------------------------------------------------<br/>
/*<br/>
unsigned int getBestMaleIndex(const std::vector&lt;double&gt;&amp; maleTraits, const double&amp; femalePreference, const double&amp; assessingError)<br/>
//unsigned int getBestMaleIndex(<br/>
//&nbsp;&nbsp;const std::vector&lt;double&gt;&amp; maleTraits,<br/>
//&nbsp;&nbsp;const double&amp; femalePreference,<br/>
//&nbsp;&nbsp;const double&amp; assessingError)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned int&gt; bestMaleIndices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nCandidats = maleTraits.size();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nCandidats; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt; assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses her preference<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleTraits[i] == femalePreference) bestMaleIndices.push_back(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestMaleIndices.push_back(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Select from the indices of best males the winner<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nCompetitors = bestMaleIndices.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (nCompetitors==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Only losers, female chooses at random from all candidats<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int bestMaleIndex = std::rand()%nCandidats;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(bestMaleIndex&lt;nCandidats);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bestMaleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//There are winner males, as nCompetitors &gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int luckyCompetitorIndex = std::rand()%nCompetitors;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int bestMaleIndex = bestMaleIndices[luckyCompetitorIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bestMaleIndex&lt;nCandidats);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return bestMaleIndex;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//This function produces a vector of traits, in this case the select males' trait/ornaments<br/>
std::vector&lt;double&gt; createTraitsVector(const std::vector&lt;Male&gt;&amp; males, const std::vector&lt;unsigned int&gt;&amp; maleIndex)<br/>
//std::vector&lt;double&gt; createTraitsVector(<br/>
//&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
//&nbsp;&nbsp;const std::vector&lt;unsigned int&gt;&amp; maleIndex)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = maleIndex.size();<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; maleTraits(nMales);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nMales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int indexMale = maleIndex[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleTraits[i] = males[indexMale].trait;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return maleTraits;<br/>
}<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
//Creates a vector of size 'bestOfHowMuch' with indices from 0 to 'nMales'<br/>
//An index might occur twice: if every index should be unique use 'createMaleIndices' instead.<br/>
std::vector&lt;unsigned int&gt; createIndices(<br/>
&nbsp;&nbsp;const unsigned int&amp; bestOfHowMuch,<br/>
&nbsp;&nbsp;const unsigned int&amp; nMales)<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndex(nMales);<br/>
&nbsp;&nbsp;for(unsigned int mate = 0; mate &lt; bestOfHowMuch; ++mate)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex[mate] = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//No checking if a male is already chosen twice<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//if you want to do so, use 'createMaleIndicesUnique' instead of this function<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return maleIndex;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Creates a vector of size 'bestOfHowMuch' from 0 to 'nMales'<br/>
//Every index is unique: if this is not important use 'createMaleIndices' instead<br/>
std::vector&lt;unsigned int&gt; createIndicesUnique(<br/>
&nbsp;&nbsp;const unsigned int&amp; bestOfHowMuch,<br/>
&nbsp;&nbsp;const unsigned int&amp; nMales)<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndex;<br/>
<br/>
&nbsp;&nbsp;if (bestOfHowMuch&lt;nMales)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex.resize(bestOfHowMuch);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bestOfHowMuch&lt;=nMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex[0] = std::rand()%nMales; //0th element is always unique<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned int mate = 1; mate &lt; bestOfHowMuch; ++mate)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int index = 1000000; //1M<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = std::rand()%nMales; //Do draw a random index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::find(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndex.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndex.begin()+mate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index) != (maleIndex.begin()+mate)); //While not unqiue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndex[mate] = index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{ //To few males (nMales &lt; bestOfHowMuch)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex.resize(nMales);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int male = 0; male&lt; nMales; ++male) maleIndex[male] = male;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return maleIndex;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/femalesampling.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/femalesampling.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef FEMALESAMPLING_H<br/>
#define FEMALESAMPLING_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include "bird.h"<br/>
#include "parameters.h"<br/>
#include "random.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBase() {}<br/>
&nbsp;&nbsp;virtual unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const = 0;<br/>
&nbsp;&nbsp;virtual std::string getFemaleSampling() const = 0;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBestOfNconspicific : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBestOfNconspicific() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Best of N conspicific"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBestOfNextremeTrait : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBestOfNextremeTrait() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Best of N extreme trait"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBestOfNclosestTrait : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBestOfNclosestTrait() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Best of N closest trait"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingFixedThresholdConspicific : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingFixedThresholdConspicific() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Fixed threshold conspicific"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingFixedThresholdTraitSign : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingFixedThresholdTraitSign() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Fixed threshold trait sign"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingFixedThresholdProbabilistic : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingFixedThresholdProbabilistic() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Fixed threshold probabilistic"; }<br/>
&nbsp;&nbsp;static inline double getChanceToMate(const double&amp; femalePreference, const double&amp; maleTrait, const double&amp; sigmaSquared);<br/>
<br/>
<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;unsigned int&gt; createIndices(const unsigned int&amp; bestOfHowMuch, const unsigned int&amp; nMales);<br/>
std::vector&lt;unsigned int&gt; createIndicesUnique(const unsigned int&amp; bestOfHowMuch, const unsigned int&amp; nMales);<br/>
//std::vector&lt;double&gt; createSpeciesVector(const std::vector&lt;Male&gt;&amp; males, const std::vector&lt;unsigned int&gt;&amp; maleIndex);<br/>
//std::vector&lt;double&gt; createTraitsVector(const std::vector&lt;Male&gt;&amp; males, const std::vector&lt;unsigned int&gt;&amp; maleIndex);<br/>
//unsigned int getBestMaleIndex(const std::vector&lt;double&gt;&amp; maleTraits, const double&amp; femalePreference, const double&amp; assessingError);<br/>
//---------------------------------------------------------------------------<br/>
#endif // FEMALESAMPLING_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/helperfunctions.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/helperfunctions.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;cmath&gt;<br/>
#include "helperfunctions.h"<br/>
//---------------------------------------------------------------------------<br/>
//#define EXTENSIVE_LOG<br/>
//---------------------------------------------------------------------------<br/>
bool fileExists(const std::string&amp; fileName)<br/>
{<br/>
&nbsp;&nbsp;std::fstream fin;<br/>
&nbsp;&nbsp;fin.open(fileName.c_str(),std::ios::in);<br/>
&nbsp;&nbsp;if( fin.is_open() )<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fin.close();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fin.close();<br/>
&nbsp;&nbsp;return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
 unsigned int totalSum(const std::vector&lt;unsigned int&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;unsigned int sum=0;<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sum+=myVector[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return(sum);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
template&lt;class T&gt; T totalSum(const std::vector&lt;T&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;T sum=0;<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sum+=myVector[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return(sum);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int getIndexLowestValue(const std::vector&lt;double&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;unsigned int indexLowest = 0;<br/>
&nbsp;&nbsp;double lowestValue = myVector[0];<br/>
&nbsp;&nbsp;for (unsigned int i=1; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double value = myVector[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (value &lt; lowestValue)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowestValue = value;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexLowest = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return indexLowest;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int getIndexHighestValue(const std::vector&lt;double&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;unsigned int indexHighest = 0;<br/>
&nbsp;&nbsp;double highestValue = myVector[0];<br/>
&nbsp;&nbsp;for (unsigned int i=1; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double value = myVector[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (value &gt; highestValue)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highestValue = value;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexHighest = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return indexHighest;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string doubleToBitString(const double&amp; anyDouble)<br/>
{<br/>
&nbsp;&nbsp;static union MyUnion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int myInts[2];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double myDouble;<br/>
&nbsp;&nbsp;} myUnion;<br/>
&nbsp;&nbsp;myUnion.myDouble = anyDouble;<br/>
<br/>
&nbsp;&nbsp;unsigned int myInt0 = myUnion.myInts[0];<br/>
&nbsp;&nbsp;unsigned int myInt1 = myUnion.myInts[1];<br/>
&nbsp;&nbsp;std::string myBitString;<br/>
&nbsp;&nbsp;for (unsigned int i = 0; i&lt;32; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myInt0%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "0" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "1" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myInt0&gt;&gt;=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (unsigned int i = 0; i&lt;32; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myInt1%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "0" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "1" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myInt1&gt;&gt;=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return myBitString;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
template &lt;class T&gt;<br/>
void meanAndStdDev(const std::vector&lt;T&gt;&amp; myVector, double&amp; mean, double&amp; stdDev)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;assert(size&gt;1);<br/>
&nbsp;&nbsp;const double dSize = static_cast&lt;double&gt;(size);<br/>
&nbsp;&nbsp;mean = 0;<br/>
&nbsp;&nbsp;double sumX = 0;<br/>
&nbsp;&nbsp;double sumXsquared = 0;<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const T value = myVector[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sumX+=value;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sumXsquared+=(value*value);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mean+=value;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;mean/=dSize;<br/>
&nbsp;&nbsp;stdDev = std::sqrt(((dSize*sumXsquared)-(sumX*sumX))/(dSize *(dSize-1.0)));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string ftoa(const double&amp; x)<br/>
{<br/>
&nbsp;&nbsp;std::ostringstream o;<br/>
&nbsp;&nbsp;if (!(o &lt;&lt; x)) return "ERROR";<br/>
&nbsp;&nbsp;return o.str();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string itoa(const int&amp; x)<br/>
{<br/>
&nbsp;&nbsp;std::ostringstream o;<br/>
&nbsp;&nbsp;if (!(o &lt;&lt; x)) return "ERROR";<br/>
&nbsp;&nbsp;return o.str();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::string&amp; message)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::clog &lt;&lt; "ODS: " &lt;&lt; message &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::vector&lt;double&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;std::string output = "index: ";<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;output+=ftoa(myVector[i])+" ";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot(output);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::vector&lt;int&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;std::string output = "index: ";<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;output+=itoa(myVector[i])+" ";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot(output);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::vector&lt;unsigned int&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;std::string output = "index: ";<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;output+=itoa(myVector[i])+" ";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot(output);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/helperfunctions.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/helperfunctions.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef HELPERFUNCTIONS_H<br/>
#define HELPERFUNCTIONS_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;sstream&gt;<br/>
#include &lt;assert.h&gt;<br/>
#include &lt;fstream&gt;<br/>
<br/>
<br/>
unsigned int totalSum(const std::vector&lt;unsigned int&gt;&amp; myVector);<br/>
template&lt;class T&gt; T totalSum(const std::vector&lt;T&gt;&amp; myVector);<br/>
unsigned int getIndexLowestValue(const std::vector&lt;double&gt;&amp; myVector);<br/>
unsigned int getIndexHighestValue(const std::vector&lt;double&gt;&amp; myVector);<br/>
template &lt;class T&gt; void meanAndStdDev(const std::vector&lt;T&gt;&amp; myVector, double&amp; mean, double&amp; stdDev);<br/>
<br/>
<br/>
std::string itoa(const int&amp; x);<br/>
std::string ftoa(const double&amp; x);<br/>
bool fileExists(const std::string&amp; fileName);<br/>
std::string doubleToBitString(const double&amp; anyDouble);<br/>
<br/>
void Dot(const std::string&amp; message);<br/>
void Dot(const std::vector&lt;unsigned int&gt;&amp; myVector);<br/>
void Dot(const std::vector&lt;int&gt;&amp; myVector);<br/>
void Dot(const std::vector&lt;double&gt;&amp; myVector);<br/>
<br/>
<br/>
<br/>
#endif // HELPERFUNCTIONS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/main.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/main.cpp" border = "1"><tr><td><code>
#include &lt;iostream&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;assert.h&gt;<br/>
<br/>
#include "parameters.h"<br/>
#include "simulation.h"<br/>
#include "helperfunctions.h"<br/>
//Parameters readParametersFromFile(const std::string&amp; fileName);<br/>
//---------------------------------------------------------------------------<br/>
int main(int argc, char* argv[])<br/>
{<br/>
&nbsp;&nbsp;if (argc&lt;2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Please enter name of data file after file name,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "\ne.g. ProjectChrisWileySTL data.txt" &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (fileExists(argv[1])==false)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Please enter a VALID and EXISTING name of data file after file name." &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Parameters parameters = readParametersFromFile(argv[1]);<br/>
<br/>
&nbsp;&nbsp;//Simulation simulation(parameters);<br/>
&nbsp;&nbsp;//std::auto_ptr&lt;Simulation&gt; simulation(new Simulation(<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/matetally.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/matetally.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "matetally.h"<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::reset()<br/>
{<br/>
&nbsp;&nbsp;nMateAA = 0;<br/>
&nbsp;&nbsp;nMateAB = 0;<br/>
&nbsp;&nbsp;nMateBA = 0;<br/>
&nbsp;&nbsp;nMateBB = 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::operator/=(const unsigned int&amp; intValue)<br/>
{<br/>
&nbsp;&nbsp;nMateAA/=intValue;<br/>
&nbsp;&nbsp;nMateAB/=intValue;<br/>
&nbsp;&nbsp;nMateBA/=intValue;<br/>
&nbsp;&nbsp;nMateBB/=intValue;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::operator+=(const MateTally&amp; mateTally)<br/>
{<br/>
&nbsp;&nbsp;nMateAA+=mateTally.nMateAA;<br/>
&nbsp;&nbsp;nMateAB+=mateTally.nMateAB;<br/>
&nbsp;&nbsp;nMateBA+=mateTally.nMateBA;<br/>
&nbsp;&nbsp;nMateBB+=mateTally.nMateBB;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string MateTally::get() const<br/>
{<br/>
&nbsp;&nbsp;std::string result;<br/>
&nbsp;&nbsp;result+= "nMateAA: " + itoa(nMateAA);<br/>
&nbsp;&nbsp;result+= " ,nMateAB: " + itoa(nMateAB);<br/>
&nbsp;&nbsp;result+= " ,nMateBA: " + itoa(nMateBA);<br/>
&nbsp;&nbsp;result+= " ,nMateBB: " + itoa(nMateBB);<br/>
&nbsp;&nbsp;return result;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool MateTally::isNull() const<br/>
{<br/>
&nbsp;&nbsp;if ( nMateAA!=0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| nMateAB!=0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| nMateBA!=0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| nMateBB!=0) return false;<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::tally(const Bird&amp; mother, const Bird&amp; father)<br/>
{<br/>
&nbsp;&nbsp;if (mother.species == piedFlycatcher)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (father.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateAA; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateAB; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (father.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateBA; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateBB; }<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
double MateTally::calculateBiasA() const<br/>
{<br/>
&nbsp;&nbsp;return (nMateAB + nMateBA == 0 ? 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: static_cast&lt;double&gt;(nMateAB) / static_cast&lt;double&gt;(nMateAB + nMateBA));<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
double MateTally::calculateBiasB() const<br/>
{<br/>
&nbsp;&nbsp;return (nMateAB + nMateBA == 0 ? 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: static_cast&lt;double&gt;(nMateBA) / static_cast&lt;double&gt;(nMateAB + nMateBA));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
double MateTally::calculateFractionMixedPairs() const<br/>
{<br/>
&nbsp;&nbsp;return (this-&gt;isNull()==true ? 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: static_cast&lt;double&gt;(nMateAB + nMateBA) / static_cast&lt;double&gt;(nMateAA + nMateAB + nMateBA + nMateBB));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/matetally.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/matetally.h" border = "1"><tr><td><code>
#ifndef MATETALLY_H<br/>
#define MATETALLY_H<br/>
<br/>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "bird.h"<br/>
//---------------------------------------------------------------------------<br/>
class MateTally<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;MateTally() { reset(); }<br/>
&nbsp;&nbsp;void tally(const Bird&amp; mother, const Bird&amp; father);<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;std::string get() const;<br/>
&nbsp;&nbsp;bool isNull() const;<br/>
&nbsp;&nbsp;double calculateBiasA() const;<br/>
&nbsp;&nbsp;double calculateBiasB() const;<br/>
&nbsp;&nbsp;double calculateFractionMixedPairs() const;<br/>
<br/>
&nbsp;&nbsp;unsigned int getNmateAA() const { return nMateAA; } //Female A - male A<br/>
&nbsp;&nbsp;unsigned int getNmateAB() const { return nMateAB; } //Female A - male B<br/>
&nbsp;&nbsp;unsigned int getNmateBA() const { return nMateBA; } //Female B - male A<br/>
&nbsp;&nbsp;unsigned int getNmateBB() const { return nMateBB; } //Female B - male B<br/>
&nbsp;&nbsp;unsigned int getNmateAll() const { return nMateAA + nMateAB + nMateBA + nMateBB; }<br/>
<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; intValue);<br/>
&nbsp;&nbsp;void operator+=(const MateTally&amp;&nbsp;&nbsp;mateTally);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;unsigned int nMateAA; //Female A - male A<br/>
&nbsp;&nbsp;unsigned int nMateAB; //Female A - male B<br/>
&nbsp;&nbsp;unsigned int nMateBA; //Female B - male A<br/>
&nbsp;&nbsp;unsigned int nMateBB; //Female B - male B<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
#endif // MATETALLY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/matingsystem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/matingsystem.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "matingsystem.h"<br/>
#include "speciestally.h"<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemMonogamyFixedNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; debugMateTally(new MateTally);<br/>
<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;//Get the fraction of species A and B<br/>
&nbsp;&nbsp;const SpeciesTally speciesTally(males,females);<br/>
<br/>
&nbsp;&nbsp;unsigned int nMalesAwanted&nbsp;&nbsp; = parameters.getNmalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nMalesBwanted&nbsp;&nbsp; = parameters.getNmalesBwanted();<br/>
&nbsp;&nbsp;assert(nMalesAwanted + nMalesBwanted == parameters.nMales);<br/>
&nbsp;&nbsp;unsigned int nFemalesAwanted = parameters.getNfemalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nFemalesBwanted = parameters.getNfemalesBwanted();<br/>
&nbsp;&nbsp;assert(nFemalesAwanted + nFemalesBwanted == parameters.nFemales);<br/>
<br/>
&nbsp;&nbsp;const unsigned int nSpeciesAwanted = nMalesAwanted + nFemalesAwanted;<br/>
&nbsp;&nbsp;const unsigned int nSpeciesBwanted = nMalesBwanted + nFemalesBwanted;<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
<br/>
&nbsp;&nbsp;assert(females.size()&gt;0);<br/>
<br/>
&nbsp;&nbsp;//Create the couples<br/>
&nbsp;&nbsp;std::vector&lt; Couple &gt; couples;<br/>
&nbsp;&nbsp;for(unsigned int female = 0; female &lt; females.size() &amp;&amp; males.size() &gt; 0; /*nothing*/)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++female;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Form the std::pair from the lovers and store them in the std::vector couples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Couple couple(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;couples.push_back(couple);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Remove the couple from the desperate others<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.erase(males.begin() + winnerIndex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.erase(females.begin() + female);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Let the couples produce offspring<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesA; //speciesA.reserve(nSpeciesAwanted);<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesB; //speciesB.reserve(nSpeciesBwanted);<br/>
&nbsp;&nbsp;const unsigned int nCouples = couples.size();<br/>
&nbsp;&nbsp;const unsigned int maxTries = (nSpeciesAwanted + nSpeciesBwanted) * (nSpeciesAwanted + nSpeciesBwanted);<br/>
&nbsp;&nbsp;unsigned int myTry = 0;<br/>
&nbsp;&nbsp;while(speciesA.size()!=nSpeciesAwanted || speciesB.size()!=nSpeciesBwanted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++myTry;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myTry==maxTries) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned int couple = 0; couple &lt; nCouples; ++couple)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(couples[couple].female,couples[couple].male,mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (birdy.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesA.size() &lt; nSpeciesAwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesA.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(couples[couple].female,couples[couple].male); //DEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesB.size() &lt; nSpeciesBwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesB.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Dot("Broke while loop in reproduction");<br/>
&nbsp;&nbsp;//Now the vectors of speciesA and speciesB are created,<br/>
&nbsp;&nbsp;//they have to be changed to vectors of males and females<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;if (myTry==maxTries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Create offspring of a failed simulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Easy! Just give the empty Offspring back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return offspring;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;assert(speciesA.size()==nSpeciesAwanted);<br/>
&nbsp;&nbsp;assert(speciesB.size()==nSpeciesBwanted);<br/>
&nbsp;&nbsp;//Females<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesAwanted; ++i) offspring.females.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesBwanted; ++i) offspring.females.push_back(speciesB[i]);<br/>
&nbsp;&nbsp;//Males<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesAwanted; i&lt;nSpeciesAwanted; ++i) offspring.males.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesBwanted; i&lt;nSpeciesBwanted; ++i) offspring.males.push_back(speciesB[i]);<br/>
<br/>
&nbsp;&nbsp;assert(offspring.females.size()==nFemalesAwanted+nFemalesBwanted);<br/>
&nbsp;&nbsp;assert(offspring.males.size()==nMalesAwanted+nMalesBwanted);<br/>
<br/>
&nbsp;&nbsp;//Dot("mateTally: "+mateTally.get());<br/>
&nbsp;&nbsp;//Dot("DebugTally: "+debugMateTally-&gt;get());<br/>
&nbsp;&nbsp;return offspring;<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemPolygynyFixedNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;//Get the fraction of species A and B<br/>
&nbsp;&nbsp;const SpeciesTally speciesTally(males,females);<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;const unsigned int nMalesAwanted&nbsp;&nbsp; = static_cast&lt;double&gt;(parameters.nMales * speciesTally.getNallMalesA()) / static_cast&lt;double&gt;(speciesTally.getNallMales());<br/>
&nbsp;&nbsp;const unsigned int nMalesBwanted&nbsp;&nbsp; = static_cast&lt;double&gt;(parameters.nMales * speciesTally.getNallMalesB()) / static_cast&lt;double&gt;(speciesTally.getNallMales());<br/>
&nbsp;&nbsp;const unsigned int nFemalesAwanted = static_cast&lt;double&gt;(parameters.nFemales * speciesTally.getNfemalesA()) / static_cast&lt;double&gt;(speciesTally.getNallFemales());<br/>
&nbsp;&nbsp;const unsigned int nFemalesBwanted = static_cast&lt;double&gt;(parameters.nFemales * speciesTally.getNfemalesB()) / static_cast&lt;double&gt;(speciesTally.getNallFemales());<br/>
&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;unsigned int nMalesAwanted&nbsp;&nbsp; = parameters.getNmalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nMalesBwanted&nbsp;&nbsp; = parameters.getNmalesBwanted();<br/>
&nbsp;&nbsp;assert(nMalesAwanted + nMalesBwanted == parameters.nMales);<br/>
&nbsp;&nbsp;unsigned int nFemalesAwanted = parameters.getNfemalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nFemalesBwanted = parameters.getNfemalesBwanted();<br/>
&nbsp;&nbsp;assert(nFemalesAwanted + nFemalesBwanted == parameters.nFemales);<br/>
<br/>
&nbsp;&nbsp;const unsigned int nSpeciesAwanted = nMalesAwanted + nFemalesAwanted;<br/>
&nbsp;&nbsp;const unsigned int nSpeciesBwanted = nMalesBwanted + nFemalesBwanted;<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;assert(nFemales&gt;0);<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesA;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesB;<br/>
<br/>
&nbsp;&nbsp;const unsigned int maxTries = (nSpeciesAwanted + nSpeciesBwanted) * (nSpeciesAwanted + nSpeciesBwanted);<br/>
&nbsp;&nbsp;unsigned int myTry = 0;<br/>
&nbsp;&nbsp;while(speciesA.size()!=nSpeciesAwanted || speciesB.size()!=nSpeciesBwanted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++myTry;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myTry==maxTries) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned int female = 0; female &lt; nFemales; ++female)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(females[female],males[winnerIndex],mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (birdy.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesA.size() &lt; nSpeciesAwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesA.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesB.size() &lt; nSpeciesBwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesB.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Dot("Broke while loop in reproduction above line ");<br/>
<br/>
&nbsp;&nbsp;//Now the vectors of speciesA and speciesB are created,<br/>
&nbsp;&nbsp;//they have to be changed to vectors of males and females<br/>
<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;if (myTry==maxTries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Create offspring of a failed simulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Easy! Just give the empty Offspring back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return offspring;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;assert(speciesA.size()==nSpeciesAwanted);<br/>
&nbsp;&nbsp;assert(speciesB.size()==nSpeciesBwanted);<br/>
&nbsp;&nbsp;//Females<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesAwanted; ++i) offspring.females.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesBwanted; ++i) offspring.females.push_back(speciesB[i]);<br/>
&nbsp;&nbsp;//Males<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesAwanted; i&lt;nSpeciesAwanted; ++i) offspring.males.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesBwanted; i&lt;nSpeciesBwanted; ++i) offspring.males.push_back(speciesB[i]);<br/>
<br/>
&nbsp;&nbsp;assert(offspring.females.size()==nFemalesAwanted+nFemalesBwanted);<br/>
&nbsp;&nbsp;assert(offspring.males.size()==nMalesAwanted+nMalesBwanted);<br/>
&nbsp;&nbsp;return offspring;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemMonogamyFreeNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; debugMateTally(new MateTally);<br/>
<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
&nbsp;&nbsp;assert(females.size()&gt;0);<br/>
<br/>
&nbsp;&nbsp;//Create the couples<br/>
&nbsp;&nbsp;std::vector&lt; Couple &gt; couples;<br/>
&nbsp;&nbsp;for(unsigned int female = 0; female &lt; females.size() &amp;&amp; males.size() &gt; 0; )<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++female;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Form the std::pair from the lovers and store them in the std::vector couples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Couple couple(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;couples.push_back(couple);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Remove the couple from the desperate others<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.erase(males.begin() + winnerIndex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.erase(females.begin() + female);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Let the couples produce offspring<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;const unsigned int nCouples = couples.size();<br/>
&nbsp;&nbsp;for(unsigned int couple = 0; couple &lt; nCouples; ++couple)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nOffspring = parameters.nOffspring;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nOffspring; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(couples[couple].female,couples[couple].male,mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(couples[couple].female,couples[couple].male); //DEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::rand()%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.males.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.females.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Now the vectors of speciesA and speciesB are created,<br/>
&nbsp;&nbsp;//they have to be changed to vectors of males and females<br/>
&nbsp;&nbsp;//Dot("mateTally: "+mateTally.get());<br/>
&nbsp;&nbsp;//Dot("DebugTally: "+debugMateTally-&gt;get());<br/>
&nbsp;&nbsp;return offspring;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemPolygynyFreeNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; debugMateTally(new MateTally);<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;//Get the fraction of species A and B<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;assert(nFemales&gt;0);<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;for(unsigned int female = 0; female &lt; nFemales; ++female)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nOffspring = parameters.nOffspring;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let them produce many offspring<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nOffspring; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(females[female],males[winnerIndex],mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(females[female],males[winnerIndex]); //DEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::rand()%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.males.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.females.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return offspring;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/matingsystem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/matingsystem.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef MATINGSYSTEM_H<br/>
#define MATINGSYSTEM_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
<br/>
<br/>
#include "bird.h"<br/>
#include "parameters.h"<br/>
#include "femalesampling.h"<br/>
#include "matetally.h"<br/>
#include "helperfunctions.h"<br/>
#include "random.h"<br/>
<br/>
class StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemBase() {}<br/>
&nbsp;&nbsp;virtual std::string getMatingSystem() const = 0;<br/>
&nbsp;&nbsp;virtual Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) = 0;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemMonogamyFixedNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemMonogamyFixedNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "MonogamyFixedNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemPolygynyFixedNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemPolygynyFixedNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "PolygynyFixedNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemMonogamyFreeNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemMonogamyFreeNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "MonogamyFreeNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemPolygynyFreeNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemPolygynyFreeNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "PolygynyFreeNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
#endif // MATINGSYSTEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/parameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/parameters.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;cstdlib&gt;<br/>
//---------------------------------------------------------------------------<br/>
#include "parameters.h"<br/>
//---------------------------------------------------------------------------<br/>
void Parameters::reset()<br/>
{<br/>
&nbsp;&nbsp; nFemales = 0;<br/>
&nbsp;&nbsp; nMales = 0;<br/>
&nbsp;&nbsp; fractionMaleA = 0.0;<br/>
&nbsp;&nbsp; fractionFemaleA = 0.0;<br/>
&nbsp;&nbsp; bestOfHowMuch = 0;<br/>
&nbsp;&nbsp; assessingErrorA = 0.0;<br/>
&nbsp;&nbsp; assessingErrorB = 0.0;<br/>
&nbsp;&nbsp; meanTraitA = 0.0;<br/>
&nbsp;&nbsp; meanTraitB = 0.0;<br/>
&nbsp;&nbsp; meanPreferenceA = 0.0;<br/>
&nbsp;&nbsp; meanPreferenceB = 0.0;<br/>
&nbsp;&nbsp; stdDevTraitA = 0.0;<br/>
&nbsp;&nbsp; stdDevTraitB = 0.0;<br/>
&nbsp;&nbsp; stdDevPreferenceA = 0.0;<br/>
&nbsp;&nbsp; stdDevPreferenceB = 0.0;<br/>
&nbsp;&nbsp; sigmaSquared = 0.0;<br/>
&nbsp;&nbsp; nSimulations = 0;<br/>
&nbsp;&nbsp; //simIndex = 0;<br/>
&nbsp;&nbsp; costTrait = 0.0;<br/>
&nbsp;&nbsp; costPreference = 0.0;<br/>
&nbsp;&nbsp; mutationRate = 0.0;<br/>
&nbsp;&nbsp; matingSystem = monogamy;<br/>
&nbsp;&nbsp; femaleSampling = bestOfNconspicific;<br/>
&nbsp;&nbsp; densityDependentSelection = afterMating;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNmalesAwanted() const<br/>
{<br/>
&nbsp;&nbsp;//return static_cast&lt;double&gt;(nMales) * fractionMaleA;<br/>
&nbsp;&nbsp;//return nMales * fractionMaleA;<br/>
&nbsp;&nbsp;const unsigned int result = nMales * fractionMaleA;<br/>
&nbsp;&nbsp;const unsigned int nMalesBwanted = getNmalesBwanted();<br/>
&nbsp;&nbsp;if (result+nMalesBwanted==nMales) return result;<br/>
&nbsp;&nbsp;else if (result+nMalesBwanted==nMales-1) return result+1;<br/>
&nbsp;&nbsp;else assert(!"Should not get here"); std::exit(1); return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNmalesBwanted() const<br/>
{<br/>
&nbsp;&nbsp;return nMales * (1.0-fractionMaleA);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNfemalesAwanted() const<br/>
{<br/>
&nbsp;&nbsp;//return static_cast&lt;double&gt;(nFemales) * fractionFemaleA;<br/>
&nbsp;&nbsp;//return nFemales * fractionFemaleA;<br/>
&nbsp;&nbsp;const unsigned int result = nFemales * fractionFemaleA;<br/>
&nbsp;&nbsp;const unsigned int nFemalesBwanted = getNfemalesBwanted();<br/>
&nbsp;&nbsp;if (result+nFemalesBwanted==nFemales) return result;<br/>
&nbsp;&nbsp;else if (result+nFemalesBwanted==nFemales-1) return result+1;<br/>
&nbsp;&nbsp;else assert(!"Should not get here"); std::exit(1); return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNfemalesBwanted() const<br/>
{<br/>
&nbsp;&nbsp;//return static_cast&lt;double&gt;(nFemales) * (1.0-fractionFemaleA);<br/>
&nbsp;&nbsp;return nFemales * (1.0-fractionFemaleA);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Parameters::readFromFile(const std::string&amp; fileName)<br/>
{<br/>
&nbsp;&nbsp;assert(fileExists(fileName)==true);<br/>
&nbsp;&nbsp;std::ifstream in (fileName.c_str());<br/>
&nbsp;&nbsp;std::string myString;<br/>
&nbsp;&nbsp;int tempInt;<br/>
&nbsp;&nbsp;for (int i=0; !in.eof(); ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;in &gt;&gt; myString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nGenerations")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nGenerations; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nFemales")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nFemales; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nMales")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nMales; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="fractionMaleA")&nbsp;&nbsp;&nbsp;&nbsp; { in &gt;&gt; fractionMaleA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="fractionFemaleA")&nbsp;&nbsp; { in &gt;&gt; fractionFemaleA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="bestOfHowMuch")&nbsp;&nbsp;&nbsp;&nbsp; { in &gt;&gt; bestOfHowMuch; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="assessingErrorA")&nbsp;&nbsp; { in &gt;&gt; assessingErrorA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="assessingErrorB")&nbsp;&nbsp; { in &gt;&gt; assessingErrorB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanTraitA")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; meanTraitA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanTraitB")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; meanTraitB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanPreferenceA")&nbsp;&nbsp; { in &gt;&gt; meanPreferenceA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanPreferenceB")&nbsp;&nbsp; { in &gt;&gt; meanPreferenceB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevTraitA")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; stdDevTraitA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevTraitB")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; stdDevTraitB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevPreferenceA") { in &gt;&gt; stdDevPreferenceA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevPreferenceB") { in &gt;&gt; stdDevPreferenceB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="sigmaSquared")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; sigmaSquared; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nSimulations")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nSimulations; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nOffspring")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nOffspring; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="surviveSpeciesAlpha") { in &gt;&gt; surviveSpeciesAlpha; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="surviveSpeciesBeta")&nbsp;&nbsp;{ in &gt;&gt; surviveSpeciesBeta; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="costTrait")&nbsp;&nbsp;{ in &gt;&gt; costTrait; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="costPreference")&nbsp;&nbsp;{ in &gt;&gt; costPreference; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="mutationRate")&nbsp;&nbsp;{ in &gt;&gt; mutationRate; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="matingSystem")&nbsp;&nbsp;{ in &gt;&gt; tempInt; matingSystem = static_cast&lt;enumMatingSystem&gt;(tempInt); continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="femaleSampling")&nbsp;&nbsp;{ in &gt;&gt; tempInt; femaleSampling = static_cast&lt;enumFemaleSampling&gt;(tempInt); continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="densityDependentSelection")&nbsp;&nbsp;{ in &gt;&gt; tempInt; densityDependentSelection = static_cast&lt;enumDensityDependentSelection&gt;(tempInt); continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown file parameter"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;in.close();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Parameters::writeToFile(const std::string&amp; fileName)<br/>
{<br/>
&nbsp;&nbsp;std::ofstream out (fileName.c_str());<br/>
&nbsp;&nbsp;out &lt;&lt; "nGenerations" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nGenerations &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nFemales" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nFemales &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nMales" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nMales &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "fractionMaleA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; fractionMaleA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "fractionFemaleA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; fractionFemaleA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "bestOfHowMuch" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; bestOfHowMuch &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "assessingErrorA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; assessingErrorA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "assessingErrorB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; assessingErrorB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanTraitA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; meanTraitA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanTraitB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; meanTraitB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanPreferenceA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; meanPreferenceA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanPreferenceB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; meanPreferenceB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevTraitA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; stdDevTraitA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevTraitB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; stdDevTraitB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevPreferenceA" &lt;&lt; '\t'&nbsp;&nbsp;&lt;&lt; stdDevPreferenceA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevPreferenceB" &lt;&lt; '\t'&nbsp;&nbsp;&lt;&lt; stdDevPreferenceB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "sigmaSquared" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; sigmaSquared &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nSimulations" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nSimulations &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nOffspring" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nOffspring &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "surviveSpeciesAlpha" &lt;&lt; '\t'&nbsp;&nbsp;&lt;&lt; surviveSpeciesAlpha &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "surviveSpeciesBeta" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; surviveSpeciesBeta &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "costTrait" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; costTrait &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "costPreference" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; costPreference &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "mutationRate" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; mutationRate &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "matingSystem" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; static_cast&lt;int&gt;(matingSystem) &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "femaleSampling" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; static_cast&lt;int&gt;(femaleSampling) &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "densityDependentSelection" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; static_cast&lt;int&gt;(densityDependentSelection) &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out.close();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/parameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/parameters.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef PARAMETERS_H<br/>
#define PARAMETERS_H<br/>
//---------------------------------------------------------------------------<br/>
#include "enums.h"<br/>
#include "helperfunctions.h"<br/>
<br/>
class Parameters<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;unsigned int nGenerations;&nbsp;&nbsp;//Number of generations<br/>
&nbsp;&nbsp;unsigned int nFemales;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Number of females<br/>
&nbsp;&nbsp;unsigned int nMales;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Number of males<br/>
&nbsp;&nbsp;double fractionMaleA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Fraction of males being of species A<br/>
&nbsp;&nbsp;double fractionFemaleA;&nbsp;&nbsp;&nbsp;&nbsp; //Fraction of males being of species B<br/>
&nbsp;&nbsp;unsigned int bestOfHowMuch; //Value of N in Best-of-N<br/>
&nbsp;&nbsp;double assessingErrorA ;&nbsp;&nbsp;&nbsp;&nbsp;//The probability a female A assess a male wrong<br/>
&nbsp;&nbsp;double assessingErrorB;&nbsp;&nbsp;&nbsp;&nbsp; //The probability a female B assess a male wrong<br/>
&nbsp;&nbsp;double meanTraitA;<br/>
&nbsp;&nbsp;double meanTraitB;<br/>
&nbsp;&nbsp;double meanPreferenceA;<br/>
&nbsp;&nbsp;double meanPreferenceB;<br/>
&nbsp;&nbsp;double stdDevTraitA;<br/>
&nbsp;&nbsp;double stdDevTraitB;<br/>
&nbsp;&nbsp;double stdDevPreferenceA;<br/>
&nbsp;&nbsp;double stdDevPreferenceB;<br/>
&nbsp;&nbsp;double sigmaSquared;<br/>
&nbsp;&nbsp;unsigned int nSimulations; //Number of simulations<br/>
&nbsp;&nbsp;unsigned int nOffspring;&nbsp;&nbsp; //Number of offspring produced per couple<br/>
&nbsp;&nbsp;//unsigned int simIndex; //The simulation's index, or: the simIndex-th simulation that is being run<br/>
&nbsp;&nbsp;double surviveSpeciesAlpha;<br/>
&nbsp;&nbsp;double surviveSpeciesBeta;<br/>
&nbsp;&nbsp;double costTrait;<br/>
&nbsp;&nbsp;double costPreference;<br/>
&nbsp;&nbsp;double mutationRate;<br/>
&nbsp;&nbsp;enumMatingSystem matingSystem;&nbsp;&nbsp;&nbsp;&nbsp; //Monogamy/polygyny<br/>
&nbsp;&nbsp;enumFemaleSampling femaleSampling; //The way a female samples the male population<br/>
&nbsp;&nbsp;enumDensityDependentSelection densityDependentSelection;<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;unsigned int getNmalesAwanted() const;<br/>
&nbsp;&nbsp;unsigned int getNmalesBwanted() const;<br/>
&nbsp;&nbsp;unsigned int getNfemalesAwanted() const;<br/>
&nbsp;&nbsp;unsigned int getNfemalesBwanted() const;<br/>
&nbsp;&nbsp;void readFromFile(const std::string&amp; fileName);<br/>
&nbsp;&nbsp;void writeToFile(const std::string&amp; fileName);<br/>
};<br/>
<br/>
<br/>
<br/>
<br/>
#endif // PARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/ProjectChrisWiley.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/ProjectChrisWiley.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
//---------------------------------------------------------------------------<br/>
USEFORM("UnitMain.cpp", FormMain);<br/>
USEFORM("UnitThreeDotsChasing.cpp", FormThreeDotsChasing);<br/>
USEFORM("UnitAboutBox2.cpp", FormAboutBox2);<br/>
//---------------------------------------------------------------------------<br/>
WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)<br/>
{<br/>
&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;Initialize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;Title = "The Chris Wiley Project";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;CreateForm(__classid(TFormMain), &amp;FormMain);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;Run();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch (Exception &amp;exception)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;ShowException(&amp;exception);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch (...)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw Exception("");<br/>
&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception &amp;exception)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;ShowException(&amp;exception);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/ProjectChrisWileyDesktop.pro</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/ProjectChrisWileyDesktop.pro" border = "1"><tr><td><code>
#-------------------------------------------------<br/>
#<br/>
# Project created by QtCreator 2010-07-22T22:43:13<br/>
#<br/>
#-------------------------------------------------<br/>
SOURCES += \ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;bird.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;matetally.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciestally.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;timepoint.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;timeseries.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simulation.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;results.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;random.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;matingsystem.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;helperfunctions.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femalesampling.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;densitydependentselection.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;main.cpp<br/>
HEADERS += \ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;bird.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;matetally.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciestally.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;timepoint.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;timeseries.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;simulation.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;results.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;random.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;matingsystem.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;helperfunctions.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femalesampling.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;densitydependentselection.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;enums.h<br/>
QT += core gui<br/>
TEMPLATE = app<br/>
RESOURCES +=<br/>
FORMS +=<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/random.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/random.cpp" border = "1"><tr><td><code>
#include "random.h"<br/>
<br/>
long int rnd::idum;<br/>
int rnd::MBIG&nbsp;&nbsp;= 1000000000;<br/>
int rnd::MSEED = 161803398;<br/>
int rnd::MZ = 0;<br/>
double rnd::FAC = (1.0/MBIG);<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/random.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/random.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef PROJECTCHRISWILEY_RANDOM_H<br/>
#define PROJECTCHRISWILEY_RANDOM_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;cmath&gt;<br/>
#include &lt;cstdlib&gt;<br/>
//---------------------------------------------------------------------------<br/>
class rnd<br/>
{<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;static long int idum;<br/>
&nbsp;&nbsp;static int MBIG;<br/>
&nbsp;&nbsp;static int MSEED;<br/>
&nbsp;&nbsp;static int MZ;<br/>
&nbsp;&nbsp;static double FAC;<br/>
<br/>
<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;//Returns a uniform random value from 0.0 to 1.0<br/>
&nbsp;&nbsp;static double uniform()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static int inext,inextp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static long ma[56];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static int iff=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;long mj,mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int i,ii,k;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (idum &lt; 0 || iff == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iff=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj=MSEED-(idum &lt; 0 ? -idum : idum);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj %= MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[55]=mj;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=54;i++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii=(21*i) % 55;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[ii]=mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=mj-mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mk &lt; MZ) mk += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj=ma[ii];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (k=1;k&lt;=4;k++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=55;i++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[i] -= ma[1+(i+30) % 55];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ma[i] &lt; MZ) ma[i] += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inext=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inextp=31;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idum=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (++inext == 56) inext=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (++inextp == 56) inextp=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mj=ma[inext]-ma[inextp];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mj &lt; MZ) mj += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ma[inext]=mj;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return mj*FAC;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;static double gasdev()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static int iset=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static double gset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double fac,r,v1,v2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//double uniform();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;uniform();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;(iset == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1=2.0*uniform()-1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2=2.0*uniform()-1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=v1*v1+v2*v2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (r &gt;= 1.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac=sqrt(-2.0*log(r)/r);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gset=v1*fac;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iset=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return v2*fac;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iset=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return gset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Sets the seed for the random number sequence<br/>
&nbsp;&nbsp;static void SetSeed(const int&amp; seed)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;idum = long(-std::abs(seed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;100; i++) uniform();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Returns a random number from a gaussian distrubution<br/>
&nbsp;&nbsp;static double normal(const double&amp; mean,const double&amp; stdev)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return gasdev()*stdev + mean;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Returns a random integer from 0 to N<br/>
&nbsp;&nbsp;static int RandomNumber(const int&amp; N)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int out;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x=std::floor(uniform()*N);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;out=int (x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return out;<br/>
&nbsp;&nbsp;}<br/>
};<br/>
<br/>
<br/>
#endif // PROJECTCHRISWILEY_RANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/results.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/results.cpp" border = "1"><tr><td><code>
#include "results.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/results.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/results.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef RESULTS_H<br/>
#define RESULTS_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
//---------------------------------------------------------------------------<br/>
class ResultsSingleton<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;static ResultsSingleton* instance()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mpInstance==0) mpInstance = new ResultsSingleton();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return mpInstance;<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;ResultsSingleton() {}<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;static ResultsSingleton* mpInstance;<br/>
};<br/>
<br/>
<br/>
<br/>
#endif // RESULTS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/simulation.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/simulation.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "bird.h"<br/>
#include "simulation.h"<br/>
//---------------------------------------------------------------------------<br/>
Simulation::Simulation(const Parameters&amp; parameters)<br/>
&nbsp;&nbsp;: mParameters(parameters),<br/>
&nbsp;&nbsp;mMateTally(new MateTally),<br/>
&nbsp;&nbsp;mError("Finished simulation without errors.")<br/>
{<br/>
&nbsp;&nbsp;//Copy parameters from mParameters<br/>
&nbsp;&nbsp;setMatingSystem(mParameters.matingSystem, mParameters.densityDependentSelection);<br/>
&nbsp;&nbsp;setFemaleSampling(mParameters.femaleSampling);<br/>
&nbsp;&nbsp;//Reset results<br/>
&nbsp;&nbsp;mMateTally-&gt;reset();<br/>
&nbsp;&nbsp;mMales = Bird::createMales(mParameters);<br/>
&nbsp;&nbsp;mFemales = Bird::createFemales(mParameters);<br/>
<br/>
&nbsp;&nbsp;//Shuffle the males and females<br/>
&nbsp;&nbsp;std::random_shuffle(mMales.begin()&nbsp;&nbsp;, mMales.end()&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;std::random_shuffle(mFemales.begin(), mFemales.end());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::execute()<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nGenerations = mParameters.nGenerations;<br/>
&nbsp;&nbsp;mTimeSeries.timePoints.resize(nGenerations);<br/>
&nbsp;&nbsp;for (unsigned int generation=0; generation&lt;nGenerations; ++generation)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//log("Start of species selection. Nmales: " + IntToStr(mMales.size()) + ",Nfemales: " + IntToStr(mFemales.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyOffspring.tallySpecies(mFemales,mMales);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].getSample(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesSelection();&nbsp;&nbsp; //Selection on species, hybrids have disadvantage<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//log("Start of viabilitySelection. Nmales: " + IntToStr(mMales.size()) + ",Nfemales: " + IntToStr(mFemales.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyAfterSpeciesSelection.tallySpecies(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;viabilitySelection(); //Selection on trait, individuals with high trait have disadvantage<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//log("Selection before mating. Nmales: " + IntToStr(mMales.size()) + ",Nfemales: " + IntToStr(mFemales.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyAfterTraitSelection.tallySpecies(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool canDoSelection = mDensityDependentSelection-&gt;canDoSelection(mFemales,mMales,mParameters,mError);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (canDoSelection==false) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mDensityDependentSelection-&gt;doSelection(mFemales,mMales,mParameters);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyAfterDensityDependentSelection.tallySpecies(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Offspring offspring = mMatingSystem-&gt;mate(mMales,mFemales,mParameters,mFemaleSampling,mTimeSeries.timePoints[generation].mateTally);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::swap(mFemales, offspring.females);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::swap(mMales, offspring.males);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mFemales.size()==0) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mMales.size()==0) break;<br/>
<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Selection on species, hybrids have disadvantage<br/>
void Simulation::speciesSelection()<br/>
{<br/>
&nbsp;&nbsp;//Easy implementation: hybrids just die<br/>
&nbsp;&nbsp;for (unsigned int male = 0; male &lt; mMales.size(); ++male)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(male &lt; mMales.size() &amp;&amp; willDieSpecies(mMales[male])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(&amp;mMales[male]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(mMales.begin() + male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;for (unsigned int female = 0; female &lt; mFemales.size(); ++female)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(female &lt; mFemales.size() &amp;&amp; willDieSpecies(mFemales[female])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(&amp;mFemales[female]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(mFemales.begin() + female);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Selection on trait, individuals with high trait have disadvantage<br/>
void Simulation::viabilitySelection()<br/>
{<br/>
&nbsp;&nbsp;//Easy implementation: hybrids just die<br/>
&nbsp;&nbsp;for (unsigned int male = 0; male &lt; mMales.size(); ++male)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(male &lt; mMales.size() &amp;&amp; willDieTrait(mMales[male])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(&amp;mMales[male]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(mMales.begin() + male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;for (unsigned int female = 0; female &lt; mFemales.size(); ++female)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(female &lt; mFemales.size() &amp;&amp; willDiePreference(mFemales[female])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(&amp;mFemales[female]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(mFemales.begin() + female);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Kills the hybrids<br/>
bool Simulation::willDieSpecies(const Bird&amp; bird)<br/>
{<br/>
&nbsp;&nbsp;assert(bird.descent&gt;=-1.0 &amp;&amp; bird.descent&lt;=1.0);<br/>
&nbsp;&nbsp;const double chanceToSurvive<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= chanceToSurviveSpecies(bird.descent, mParameters.surviveSpeciesAlpha, mParameters.surviveSpeciesBeta);<br/>
&nbsp;&nbsp;//const double chanceToSurvive = 1.0 - (mParameters.surviveSpeciesAlpha *<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;std::exp(-mParameters.surviveSpeciesBeta * bird.descent * bird.descent));<br/>
&nbsp;&nbsp;assert(chanceToSurvive&gt;=0.0 &amp;&amp; chanceToSurvive&lt;=1.0);<br/>
&nbsp;&nbsp;//Dot("bird.descent: " + FloatToStr(bird.descent)<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;+ ", chance to survive: " + FloatToStr(chanceToSurvive));<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; chanceToSurvive) return true;<br/>
&nbsp;&nbsp;else return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool Simulation::willDieTrait(const Male&amp; male)<br/>
{<br/>
&nbsp;&nbsp;const double chanceToSurvive = chanceToSurviveTrait(male.trait, mParameters.costTrait);<br/>
&nbsp;&nbsp;//const double chanceToSurvive<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;= std::exp(-mParameters.costTrait * male.trait * male.trait);<br/>
&nbsp;&nbsp;assert(chanceToSurvive&gt;=0.0 &amp;&amp; chanceToSurvive&lt;=1.0);<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; chanceToSurvive) return true;<br/>
&nbsp;&nbsp;else return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool Simulation::willDiePreference(const Female&amp; female)<br/>
{<br/>
&nbsp;&nbsp;const double chanceToSurvive<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;= std::exp(-mParameters.costPreference * female.preference * female.preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= chanceToSurvivePreference(female.preference, mParameters.costPreference);<br/>
&nbsp;&nbsp;assert(chanceToSurvive&gt;=0.0 &amp;&amp; chanceToSurvive&lt;=1.0);<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; chanceToSurvive) return true;<br/>
&nbsp;&nbsp;else return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::setMatingSystem(<br/>
&nbsp;&nbsp;const enumMatingSystem&amp; matingSystem,<br/>
&nbsp;&nbsp;const enumDensityDependentSelection&amp; selection)<br/>
{<br/>
&nbsp;&nbsp;setDensityDependentSelection(selection);<br/>
<br/>
&nbsp;&nbsp;switch(selection)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Selection after mating<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case afterMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(matingSystem)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case monogamy:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemMonogamyFixedNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case polygyny:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemPolygynyFixedNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown mating system"); std::exit(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Selection before mating<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case beforeMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(matingSystem)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case monogamy:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemMonogamyFreeNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case polygyny:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemPolygynyFreeNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown mating system"); std::exit(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown enumDensityDependentSelection"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot("Mating system set to: " + mMatingSystem-&gt;getMatingSystem());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::setFemaleSampling(const enumFemaleSampling&amp; femaleSampling)<br/>
{<br/>
&nbsp;&nbsp;switch(femaleSampling)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingBestOfNconspicific);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingBestOfNextremeTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingBestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingFixedThresholdConspicific);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingFixedThresholdTraitSign);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingFixedThresholdProbabilistic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown female sampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot("Female sampling set to: " + mFemaleSampling-&gt;getFemaleSampling());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::setDensityDependentSelection(const enumDensityDependentSelection&amp; selection)<br/>
{<br/>
&nbsp;&nbsp;switch(selection)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case beforeMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mDensityDependentSelection.reset(new StateDensityDependentSelectionBeforeMating);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//case afterMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;mDensityDependentSelection.reset(new StateDensityDependentSelectionAfterMating);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown enumDensityDependentSelection"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot("Density dependent selection set to: " + mDensityDependentSelection-&gt;getString());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double Simulation::chanceToSurviveSpecies(const double&amp; descent, const double&amp; alpha, const double&amp; beta)<br/>
{<br/>
&nbsp;&nbsp;return 1.0 - (alpha * std::exp(-beta * descent * descent));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double Simulation::chanceToSurviveTrait(const double&amp; trait, const double&amp; costTrait)<br/>
{<br/>
&nbsp;&nbsp;return&nbsp;&nbsp;std::exp(-costTrait * trait * trait);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double Simulation::chanceToSurvivePreference(const double&amp; preference, const double&amp; costPreference)<br/>
{<br/>
&nbsp;&nbsp;return&nbsp;&nbsp;std::exp(-costPreference * preference * preference);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/simulation.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/simulation.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef PROJECTCHRISWILEY_SIMULATION_H<br/>
#define PROJECTCHRISWILEY_SIMULATION_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;cmath&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include "enums.h"<br/>
#include "parameters.h"<br/>
#include "matetally.h"<br/>
#include "speciestally.h"<br/>
#include "helperfunctions.h"<br/>
#include "timeseries.h"<br/>
#include "bird.h"<br/>
//---------------------------------------------------------------------------<br/>
//Forward declarations of States<br/>
class StateMatingSystemBase;<br/>
class StateFemaleSamplingBase;<br/>
class StateDensityDependentSelectionBase;<br/>
<br/>
class Simulation<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;Simulation(const Parameters&amp;);<br/>
&nbsp;&nbsp;void execute();<br/>
&nbsp;&nbsp;TimeSeries getTimeSeries() const { return mTimeSeries; }<br/>
&nbsp;&nbsp;void setMatingSystem(const enumMatingSystem&amp;, const enumDensityDependentSelection&amp;);<br/>
<br/>
&nbsp;&nbsp;void setFemaleSampling(const enumFemaleSampling&amp;);<br/>
&nbsp;&nbsp;void setDensityDependentSelection(const enumDensityDependentSelection&amp;);<br/>
<br/>
&nbsp;&nbsp;//void showPopulation(TStringGrid * stringGrid) const;<br/>
&nbsp;&nbsp;static inline double chanceToSurviveSpecies(const double&amp; descent, const double&amp; alpha, const double&amp; beta);<br/>
&nbsp;&nbsp;static inline double chanceToSurviveTrait(const double&amp; trait, const double&amp; costTrait);<br/>
&nbsp;&nbsp;static inline double chanceToSurvivePreference(const double&amp; preference, const double&amp; costPreference);<br/>
<br/>
&nbsp;&nbsp;//Debugging<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;const Parameters mParameters;<br/>
<br/>
&nbsp;&nbsp;void speciesSelection();<br/>
&nbsp;&nbsp;void viabilitySelection();<br/>
&nbsp;&nbsp;bool willDieSpecies(const Bird&amp; bird);<br/>
&nbsp;&nbsp;bool willDiePreference(const Female&amp; female);<br/>
&nbsp;&nbsp;bool willDieTrait(const Male&amp; male);<br/>
<br/>
&nbsp;&nbsp;void mating();<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateMatingSystemBase&gt; mMatingSystem;<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateFemaleSamplingBase&gt; mFemaleSampling;<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateDensityDependentSelectionBase&gt; mDensityDependentSelection;<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; mMateTally;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; mMales;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; mFemales;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; mOffspring;<br/>
&nbsp;&nbsp;TimeSeries mTimeSeries;<br/>
<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;std::string mError;<br/>
};<br/>
<br/>
#include "femalesampling.h"<br/>
#include "matingsystem.h"<br/>
#include "densitydependentselection.h"<br/>
<br/>
#endif // PROJECTCHRISWILEY_SIMULATION_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/speciestally.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/speciestally.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
#include "speciestally.h"<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::tallySpecies(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males)<br/>
{<br/>
&nbsp;&nbsp;//Females first<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nFemales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const enumSpecies species = females[i].species;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (species==piedFlycatcher) ++(nFemalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nFemalesB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Tally the men<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nMales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const enumSpecies species = males[i].species;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (species==piedFlycatcher) ++(nMalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nMalesB);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;//Females first<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nFemales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double descent = females[i].descent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (descent &lt; -0.5)&nbsp;&nbsp;&nbsp;&nbsp; ++(nFemalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.0) ++(nFemaleHybridsA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.5) ++(nFemaleHybridsB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nFemalesB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Tally the men<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nMales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double descent = males[i].descent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (descent &lt; -0.5)&nbsp;&nbsp;&nbsp;&nbsp; ++(nMalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.0) ++(nMaleHybridsA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.5) ++(nMaleHybridsB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nMalesB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*/<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::reset()<br/>
{<br/>
&nbsp;&nbsp;nMalesA = 0;<br/>
&nbsp;&nbsp;nMalesB = 0;<br/>
&nbsp;&nbsp;nFemalesA = 0;<br/>
&nbsp;&nbsp;nFemalesB = 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool SpeciesTally::isNull() const<br/>
{<br/>
&nbsp;&nbsp;if (nMalesA&gt;0) return false;<br/>
&nbsp;&nbsp;if (nMalesB&gt;0) return false;<br/>
&nbsp;&nbsp;if (nFemalesA&gt;0) return false;<br/>
&nbsp;&nbsp;if (nFemalesB&gt;0) return false;<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::operator+=(const SpeciesTally&amp; speciesTally)<br/>
{<br/>
&nbsp;&nbsp;nMalesA+=speciesTally.nMalesA;<br/>
&nbsp;&nbsp;nMalesB+=speciesTally.nMalesB;<br/>
&nbsp;&nbsp;nFemalesA+=speciesTally.nFemalesA;<br/>
&nbsp;&nbsp;nFemalesB+=speciesTally.nFemalesB;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::operator/=(const unsigned int&amp; intValue)<br/>
{<br/>
&nbsp;&nbsp;nMalesA/=intValue;<br/>
&nbsp;&nbsp;nMalesB/=intValue;<br/>
&nbsp;&nbsp;nFemalesA/=intValue;<br/>
&nbsp;&nbsp;nFemalesB/=intValue;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/speciestally.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/speciestally.h" border = "1"><tr><td><code>
#ifndef SPECIESTALLY_H<br/>
#define SPECIESTALLY_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "bird.h"<br/>
//---------------------------------------------------------------------------<br/>
class SpeciesTally<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;SpeciesTally() { reset(); }<br/>
&nbsp;&nbsp;SpeciesTally(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reset();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tallySpecies(females,males);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;bool isNull() const;<br/>
&nbsp;&nbsp;void tallySpecies(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males);<br/>
&nbsp;&nbsp;void operator+=(const SpeciesTally&amp; speciesTally);<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; intValue);<br/>
<br/>
&nbsp;&nbsp;//Plain retrieval<br/>
&nbsp;&nbsp;unsigned int getNmalesA()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nMalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;unsigned int getNmalesB()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nMalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;unsigned int getNfemalesA()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nFemalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;unsigned int getNfemalesB()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nFemalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;//Some group retrieval<br/>
&nbsp;&nbsp;unsigned int getNallMalesA()&nbsp;&nbsp; const { return nMalesA; }<br/>
&nbsp;&nbsp;unsigned int getNallMalesB()&nbsp;&nbsp; const { return nMalesB; }<br/>
&nbsp;&nbsp;unsigned int getNallMales()&nbsp;&nbsp;&nbsp;&nbsp;const { return nMalesA + nMalesB; }<br/>
&nbsp;&nbsp;unsigned int getNallFemalesA() const { return nFemalesA; }<br/>
&nbsp;&nbsp;unsigned int getNallFemalesB() const { return nFemalesB; }<br/>
&nbsp;&nbsp;unsigned int getNallFemales()&nbsp;&nbsp;const { return nFemalesA + nFemalesB; }<br/>
&nbsp;&nbsp;unsigned int getNall()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return getNallFemales() + getNallMales(); }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;//The private variables it is all about<br/>
&nbsp;&nbsp;unsigned int nMalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &lt; -0.5<br/>
&nbsp;&nbsp;unsigned int nMalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &gt; 0.5<br/>
&nbsp;&nbsp;unsigned int nFemalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &lt; -0.5<br/>
&nbsp;&nbsp;unsigned int nFemalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &gt; 0.5<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif // SPECIESTALLY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/timepoint.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/timepoint.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "timepoint.h"<br/>
//---------------------------------------------------------------------------<br/>
void TimePoint::reset()<br/>
{<br/>
&nbsp;&nbsp;traits.resize(0);<br/>
&nbsp;&nbsp;preferences.resize(0);<br/>
&nbsp;&nbsp;descents.resize(0);<br/>
&nbsp;&nbsp;mateTally.reset();<br/>
&nbsp;&nbsp;speciesTallyOffspring.reset();<br/>
&nbsp;&nbsp;speciesTallyAfterSpeciesSelection.reset();<br/>
&nbsp;&nbsp;speciesTallyAfterTraitSelection.reset();<br/>
&nbsp;&nbsp;speciesTallyAfterDensityDependentSelection.reset();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool TimePoint::isNull() const<br/>
{<br/>
&nbsp;&nbsp;if (traits.size()&gt;0) return false;<br/>
&nbsp;&nbsp;if (preferences.size()&gt;0) return false;<br/>
&nbsp;&nbsp;if (descents.size()&gt;0) return false;<br/>
&nbsp;&nbsp;if (mateTally.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyOffspring.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyAfterSpeciesSelection.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyAfterTraitSelection.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyAfterDensityDependentSelection.isNull()==false) return false;<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TimePoint::getSample(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int sampleSize = 2;<br/>
&nbsp;&nbsp;//Get sample of female preferences<br/>
&nbsp;&nbsp;unsigned int nFemalesA = 0, nFemalesB = 0;<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemales ; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (females[i].species==piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesA&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferences.push_back(females[i].preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(females[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nFemalesA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesB&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferences.push_back(females[i].preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(females[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nFemalesB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesA==sampleSize &amp;&amp; nFemalesB==sampleSize) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nFemalesA&lt;=sampleSize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nFemalesB&lt;=sampleSize);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Get sample of male traits<br/>
&nbsp;&nbsp;unsigned int nMalesA = 0, nMalesB = 0;<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nMales ; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (males[i].species==piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesA&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traits.push_back(males[i].trait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(males[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nMalesA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesB&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traits.push_back(males[i].trait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(males[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nMalesB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesA==sampleSize &amp;&amp; nMalesB==sampleSize) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nMalesA&lt;=sampleSize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nMalesB&lt;=sampleSize);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/timepoint.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/timepoint.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef TIMEPOINT_H<br/>
#define TIMEPOINT_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include "matetally.h"<br/>
#include "speciestally.h"<br/>
//---------------------------------------------------------------------------<br/>
class TimePoint<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;TimePoint() { reset(); }<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; traits;<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; preferences;<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; descents;<br/>
&nbsp;&nbsp;MateTally mateTally;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyOffspring;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyAfterSpeciesSelection;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyAfterTraitSelection;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyAfterDensityDependentSelection;<br/>
<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;bool isNull() const;<br/>
&nbsp;&nbsp;void getSample(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males);<br/>
<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; valueInt) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const double value = static_cast&lt;double&gt;(valueInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyOffspring/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterSpeciesSelection/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterTraitSelection/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterDensityDependentSelection/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::random_shuffle(traits.begin(),traits.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::random_shuffle(preferences.begin(),preferences.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::random_shuffle(descents.begin(),descents.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;traits.resize(traits.size()/valueInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;preferences.resize(preferences.size()/valueInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;descents.resize(descents.size()/valueInt);<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;void operator+=(const TimePoint&amp; timePoint) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mateTally+=timePoint.mateTally;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyOffspring+=timePoint.speciesTallyOffspring;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterSpeciesSelection+=timePoint.speciesTallyAfterSpeciesSelection;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterTraitSelection+=timePoint.speciesTallyAfterTraitSelection;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterDensityDependentSelection+=timePoint.speciesTallyAfterDensityDependentSelection;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int traitSize = timePoint.traits.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;traitSize; ++i) traits.push_back(timePoint.traits[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int preferenceSize = timePoint.preferences.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;preferenceSize; ++i) preferences.push_back(timePoint.preferences[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int descentSize = timePoint.descents.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;descentSize; ++i) descents.push_back(timePoint.descents[i]);<br/>
&nbsp;&nbsp;}<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
#endif // TIMEPOINT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/timeseries.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/timeseries.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include "timeseries.h"<br/>
//---------------------------------------------------------------------------<br/>
void getMeanAndStdErrorEndPoint(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimePoint&amp; mean, TimePoint&amp; stdError)<br/>
{<br/>
&nbsp;&nbsp;assert(mean.isNull()==true);<br/>
&nbsp;&nbsp;assert(stdError.isNull()==true);<br/>
<br/>
&nbsp;&nbsp;//Only set: biasA, biasB, fractionMixedPairs<br/>
<br/>
&nbsp;&nbsp;const unsigned int nTimeSeries = timeSeries.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nTimeSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Get the index of the final index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int time = timeSeries[i].timePoints.size() - 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mean += timeSeries[i].timePoints[time];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;mean/=nTimeSeries;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void getMeanAndStdErrorTimeSeries(<br/>
&nbsp;&nbsp;const std::vector&lt;TimeSeries&gt;&amp; timeSeries,<br/>
&nbsp;&nbsp;TimeSeries&amp; mean,<br/>
&nbsp;&nbsp;TimeSeries&amp; /*stdError*/)<br/>
{<br/>
&nbsp;&nbsp;assert(mean.isNull()==true);<br/>
&nbsp;&nbsp;mean = timeSeries[0];<br/>
&nbsp;&nbsp;const unsigned int nTimeSeries = timeSeries.size();<br/>
&nbsp;&nbsp;for (unsigned i=1; i&lt;nTimeSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Get the index of the final index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mean += timeSeries[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;mean/=nTimeSeries;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/timeseries.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/timeseries.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richl Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef TIMESERIES_H<br/>
#define TIMESERIES_H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert.h&gt;<br/>
#include "timepoint.h"<br/>
//---------------------------------------------------------------------------<br/>
class TimeSeries<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;std::vector&lt;TimePoint&gt; timePoints;<br/>
&nbsp;&nbsp;bool isNull() const<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (timePoints.size()&gt;0) return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;void operator+=(const TimeSeries&amp; timeSeries) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTimePoints = timePoints.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(timeSeries.timePoints.size()==nTimePoints);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nTimePoints; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timePoints[i]+=timeSeries.timePoints[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; valueInt) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTimePoints = timePoints.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nTimePoints; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timePoints[i]/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
void getMeanAndStdErrorEndPoint(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimePoint&amp; mean, TimePoint&amp; stdError);<br/>
void getMeanAndStdErrorTimeSeries(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimeSeries&amp; mean, TimeSeries&amp; stdError);<br/>
//TimeSeries getAverageTimeSeries(const std::vector&lt;TimeSeries&gt;&amp; timeSeries);<br/>
//TimePoint getAverageEndTimePoint(const std::vector&lt;TimeSeries&gt;&amp; timeSeries);<br/>
//---------------------------------------------------------------------------<br/>
#endif // TIMESERIES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/UnitAboutBox2.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/UnitAboutBox2.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitAboutBox2.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormAboutBox2 *FormAboutBox2;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormAboutBox2::TFormAboutBox2(TComponent* Owner)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/UnitAboutBox2.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/UnitAboutBox2.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitAboutBox2H<br/>
#define UnitAboutBox2H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;Classes.hpp&gt;<br/>
#include &lt;Controls.hpp&gt;<br/>
#include &lt;StdCtrls.hpp&gt;<br/>
#include &lt;Forms.hpp&gt;<br/>
#include &lt;ExtCtrls.hpp&gt;<br/>
#include &lt;Graphics.hpp&gt;<br/>
//---------------------------------------------------------------------------<br/>
class TFormAboutBox2 : public TForm<br/>
{<br/>
__published:	// IDE-managed Components<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TImage *Image1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TStaticText *StaticText1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TStaticText *StaticText2;<br/>
&nbsp;&nbsp;TStaticText *StaticText3;<br/>
private:	// User declarations<br/>
public:		// User declarations<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__fastcall TFormAboutBox2(TComponent* Owner);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
extern PACKAGE TFormAboutBox2 *FormAboutBox2;<br/>
//---------------------------------------------------------------------------<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/UnitMain.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/UnitMain.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitMain.h"<br/>
#include "UnitAboutBox2.h"<br/>
#include "UnitThreeDotsChasing.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormMain *FormMain;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormMain::TFormMain(TComponent* Owner)<br/>
&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString("NDEBUG defined. No output anymore");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;Caption = this-&gt;Caption + " NoDebug";<br/>
&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString("NDEBUG not defined.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;Caption = this-&gt;Caption + " Debug";<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][0] = "";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][0] = "Female" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][0] = "Male #1";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][0] = "Male #2";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][0] = "Male #3";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][0] = "Male #4";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][1] = "SpeciesValue";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][1] = "-1.0" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][1] = "-1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][1] = "-0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][1] = "0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][1] = "1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][2] = "Trait/Preference";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][2] = "1.0" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][2] = "-1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][2] = "-0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][2] = "0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][2] = "1.0";<br/>
<br/>
&nbsp;&nbsp;//Fill in StringGridParameters<br/>
&nbsp;&nbsp;StringGridParameters-&gt;RowCount = 23;<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 0] = "Parameter";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 0] = "Value";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 1] = "Number of females";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 1] = "1000";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 2] = "Number of males";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 2] = "1000";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 3] = "Best-of-how-much";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 3] = "5";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 4] = "Assessing error A";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 4] = "0.001";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 5] = "Assessing error B";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 5] = "0.001";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 6] = "Mean trait A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 6] = "-1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 7] = "StdDev trait A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 7] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 8] = "Mean trait B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 8] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 9] = "StdDev trait B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 9] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][10] = "Mean preference A";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][10] = "-1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][11] = "StdDev preference A";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][11] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][12] = "Mean preference B";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][12] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][13] = "StdDev preference B";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][13] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][14] = "Number of simulations"; StringGridParameters-&gt;Cells[1][14] = "1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][15] = "Number of generations"; StringGridParameters-&gt;Cells[1][15] = "1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][16] = "Number of offspring";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][16] = "6";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][17] = "SurviveSpeciesAlpha";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][17] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][18] = "SurviveSpeciesBeta";&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][18] = "10.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][19] = "SigmaSquared";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][19] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][20] = "Cost trait";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][20] = "0.1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][21] = "Cost preference";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][21] = "0.01";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][22] = "Mutation rate";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][22] = "0.01";<br/>
<br/>
&nbsp;&nbsp;PageControlSimChange(0);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonRunClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//Check the input in own scope<br/>
&nbsp;&nbsp;if (checkInput()==false) return;<br/>
<br/>
&nbsp;&nbsp;StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text = "Running simulation";<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcherSleeping.cur");<br/>
&nbsp;&nbsp;Refresh(); //To draw this text to the StatusBar<br/>
<br/>
&nbsp;&nbsp;emptyChart(ChartBias);<br/>
&nbsp;&nbsp;emptyChart(ChartMateFraction);<br/>
<br/>
&nbsp;&nbsp;//Read parameters<br/>
&nbsp;&nbsp;Parameters parameters = readStringGrid();<br/>
&nbsp;&nbsp;parameters.matingSystem&nbsp;&nbsp; = (RadioGroupGamy-&gt;ItemIndex&nbsp;&nbsp;== 0 ? monogamy : polygyny);<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: parameters.femaleSampling = bestOfNconspicific;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: parameters.femaleSampling = bestOfNextremeTrait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: parameters.femaleSampling = bestOfNclosestTrait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: parameters.femaleSampling = fixedThresholdConspicific;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: parameters.femaleSampling = fixedThresholdTraitSign;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: parameters.femaleSampling = fixedThresholdProbabilistic; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown index of RadioGroupTestSampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;parameters.densityDependentSelection = (RadioGroupDensityDependentSelection-&gt;ItemIndex == 0 ? afterMating : beforeMating );<br/>
<br/>
&nbsp;&nbsp;//Show parameters<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Clear();<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of males: " + IntToStr(parameters.nMales));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of males: " + IntToStr(parameters.nMales));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of females: " + IntToStr(parameters.nFemales));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Best of how much: " + IntToStr(parameters.bestOfHowMuch));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Assessing error A: " + FloatToStr(parameters.assessingErrorA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Assessing error B: " + FloatToStr(parameters.assessingErrorB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean trait A: " + FloatToStr(parameters.meanTraitA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev trait A: " + FloatToStr(parameters.stdDevTraitA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean trait males B: " + FloatToStr(parameters.meanTraitB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev trait males B: " + FloatToStr(parameters.stdDevTraitB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean preference A: " + FloatToStr(parameters.meanPreferenceA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev preference A: " + FloatToStr(parameters.stdDevPreferenceA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean preference males B: " + FloatToStr(parameters.meanPreferenceB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev preference males B: " + FloatToStr(parameters.stdDevPreferenceB));<br/>
<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of simulation: " + IntToStr(parameters.nSimulations));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of generations: " + IntToStr(parameters.nGenerations));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of offspring per couple: " + IntToStr(parameters.nOffspring));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("SurviveSpeciesAlpha: " + FloatToStr(parameters.surviveSpeciesAlpha));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("SurviveSpeciesBeta: " + FloatToStr(parameters.surviveSpeciesBeta));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("SigmaSquared: " + FloatToStr(parameters.sigmaSquared));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Cost trait: " + FloatToStr(parameters.costTrait));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Cost preference: " + FloatToStr(parameters.costPreference));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mutation rate: " + FloatToStr(parameters.mutationRate));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add(parameters.matingSystem&nbsp;&nbsp;== monogamy ? "Mating system: monogamy" : "Mating system: polygyny" );<br/>
&nbsp;&nbsp;switch(parameters.femaleSampling)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Best-Of-N conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Best-Of-N extreme trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Best-Of-N closest trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Fixed threshold conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Fixed threshold trait sign");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Fixed threshold probabilistic");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add(parameters.densityDependentSelection==beforeMating ? "Density dependent selection: before mating" : "Density dependent selection: after mating");<br/>
<br/>
&nbsp;&nbsp;//Start simulation<br/>
&nbsp;&nbsp;const double deltaFraction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionStep-&gt;Text.ToDouble() : 1.0);<br/>
&nbsp;&nbsp;const double fractionFrom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionFrom-&gt;Text.ToDouble() : EditFraction-&gt;Text.ToDouble());<br/>
&nbsp;&nbsp;const double fractionTo<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionTo-&gt;Text.ToDouble() : 1.0);<br/>
<br/>
&nbsp;&nbsp;std::string lastErrorMessage;<br/>
&nbsp;&nbsp;for (double fraction = fractionFrom; fraction &lt; fractionTo; fraction+=deltaFraction)<br/>
&nbsp;&nbsp;//double fraction = 0.9;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ProgressBarSim-&gt;Position = fraction * ProgressBarSim-&gt;Max;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ProgressBarSim-&gt;Refresh();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartBiasTime);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartMateTime);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartPopSize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartTraitPreference);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.fractionMaleA&nbsp;&nbsp; = fraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.fractionFemaleA = fraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//parameters.nGenerations = 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimulations = parameters.nSimulations;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;TimeSeries&gt; allTimeSeries; //Size 0, use push_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int simulation = 0; simulation &lt; nSimulations; ++simulation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stick parameter in simulation and run it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;Simulation&gt; simulation(new Simulation(parameters));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//simulation-&gt;showPopulation(StringGridDebug);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simulation-&gt;execute();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Get the results from the sim<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//const TimeSeries thisSimTimeSeries = simulation-&gt;getTimeSeries();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//timeSeries.push_back(thisSimTimeSeries);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allTimeSeries.push_back(simulation-&gt;getTimeSeries());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastErrorMessage = simulation-&gt;mError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Plot the average of the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TimePoint timePointMean, timePointStdError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;getMeanAndStdErrorEndPoint(allTimeSeries,timePointMean,timePointStdError);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TimeSeries timeSeriesMean, timeSeriesStdError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;getMeanAndStdErrorTimeSeries(allTimeSeries,timeSeriesMean, timeSeriesStdError);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plotTimePoint(timePointMean, timePointStdError,fraction);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plotTimeSeries(timeSeriesMean, timeSeriesStdError);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text = toAnsiString(lastErrorMessage);<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==0) PlaySound("PiedFlycatcher.wav",0,SND_FILENAME | SND_ASYNC);<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
//Checks the input, returns true if all valid<br/>
bool TFormMain::checkInput()<br/>
{<br/>
&nbsp;&nbsp;int checkInt; bool check; double checkDouble;<br/>
&nbsp;&nbsp;//nFemales<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][1],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nFemales' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nFemales' should be positive"; return false; }<br/>
&nbsp;&nbsp;//nMales<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][2],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nMales' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nMales' should be positive"; return false; }<br/>
&nbsp;&nbsp;//bestOfHowMuch<br/>
&nbsp;&nbsp;if (&nbsp;&nbsp; RadioGroupFemaleSampling-&gt;ItemIndex == 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| RadioGroupFemaleSampling-&gt;ItemIndex == 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| RadioGroupFemaleSampling-&gt;ItemIndex == 2 ) //If female uses bestOfHowMuch<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][3],checkInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'bestOfHowMuch' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'bestOfHowMuch' should be bigger then 0"; return false; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//assessingErrorA<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][4],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorA' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorA' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorA' should be smaller or equal to 1.0"; return false; }<br/>
&nbsp;&nbsp;//assessingErrorB<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][5],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorB' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorB' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorB' should be smaller or equal to 1.0"; return false; }<br/>
&nbsp;&nbsp;//Mean trait males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][6],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean trait males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev trait males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][7],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev trait males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean trait males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][8],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean trait males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev trait males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][9],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev trait males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean preference males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][10],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean preference males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev preference males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][11],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev preference males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean preference males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][12],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean preference males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev preference males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][13],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev preference males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Number of simulations<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][14],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of simulations' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of simulations' should be positive"; return false; }<br/>
&nbsp;&nbsp;//Number of generations<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][15],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of generations' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of generations' should be positive"; return false; }<br/>
&nbsp;&nbsp;//Number of offspring<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][16],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of offspring' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of offspring' should be positive"; return false; }<br/>
&nbsp;&nbsp;//SurviveSpeciesAlpha<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][17],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesAlpha' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesAlpha' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesAlpha' should be smaller or equal to 1.0"; return false; }<br/>
&nbsp;&nbsp;//SurviveSpeciesBeta<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][18],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesBeta' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesBeta' should be positive"; return false; }<br/>
&nbsp;&nbsp;//SigmaSquared<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][19],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SigmaSquared' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt;= 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SigmaSquared' should be positive"; return false; }<br/>
&nbsp;&nbsp;//CostTrait<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][20],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostTrait' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostTrait' should be positive"; return false; }<br/>
&nbsp;&nbsp;//CostPreference<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][21],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostPreference' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostPreference' should be positive"; return false; }<br/>
&nbsp;&nbsp;//MutationRate<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][22],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'MutationRate' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'MutationRate' should be positive"; return false; }<br/>
<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::plotTimePoint(<br/>
&nbsp;&nbsp;const TimePoint&amp; mean,<br/>
&nbsp;&nbsp;const TimePoint&amp; stdError,<br/>
&nbsp;&nbsp;const double&amp; chartX)<br/>
{<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[0]-&gt;AddXY(chartX,mean.mateTally.calculateBiasA());<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[1]-&gt;AddXY(chartX,mean.mateTally.calculateBiasB());<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[2]-&gt;AddXY(chartX,mean.mateTally.calculateFractionMixedPairs());<br/>
<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[0]-&gt;AddXY(chartX,mean.mateTally.getNmateAA());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[1]-&gt;AddXY(chartX,mean.mateTally.getNmateAB());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[2]-&gt;AddXY(chartX,mean.mateTally.getNmateBA());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[3]-&gt;AddXY(chartX,mean.mateTally.getNmateBB());<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::plotTimeSeries(<br/>
&nbsp;&nbsp;const TimeSeries&amp; mean,<br/>
&nbsp;&nbsp;const TimeSeries&amp; stdError)<br/>
{<br/>
&nbsp;&nbsp;emptyChart(ChartPopSize);<br/>
&nbsp;&nbsp;emptyChart(ChartMateTime);<br/>
&nbsp;&nbsp;const unsigned int nGenerations = mean.timePoints.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nGenerations; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double iD = static_cast&lt;double&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[5]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[6]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[5]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[6]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[5]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[6]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNall());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[0]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateAA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[1]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateAB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[2]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateBA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[3]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateBB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[4]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateAll());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartBiasTime-&gt;Series[0]-&gt;AddXY(iD,mean.timePoints[i].mateTally.calculateBiasA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartBiasTime-&gt;Series[1]-&gt;AddXY(iD,mean.timePoints[i].mateTally.calculateBiasB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartBiasTime-&gt;Series[2]-&gt;AddXY(iD,mean.timePoints[i].mateTally.calculateFractionMixedPairs());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTraits = mean.timePoints[i].traits.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nTraits; ++j) ChartTraitPreference-&gt;Series[0]-&gt;AddXY(iD,mean.timePoints[i].traits[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nPreferences = mean.timePoints[i].preferences.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nPreferences; ++j) ChartTraitPreference-&gt;Series[1]-&gt;AddXY(iD,mean.timePoints[i].preferences[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSpeciesValues = mean.timePoints[i].descents.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nSpeciesValues; ++j) ChartTraitPreference-&gt;Series[2]-&gt;AddXY(iD,mean.timePoints[i].descents[j]);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::setCursor(const String&amp; cursorName)<br/>
{<br/>
&nbsp;&nbsp;TCursor myCursor = static_cast&lt;TCursor&gt;(22);<br/>
&nbsp;&nbsp;Screen-&gt;Cursors[22] = LoadCursorFromFile(cursorName.c_str());<br/>
&nbsp;&nbsp;Cursor = myCursor;<br/>
&nbsp;&nbsp;FormMain-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;PageControlMain-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;PanelLeft-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ChartBias-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ChartPopSize-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ChartMateTime-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ButtonRun-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ProgressBarSim-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RadioGroupGamy-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RichEdit2-&gt;Cursor = myCursor;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Parameters TFormMain::readStringGrid() const<br/>
{<br/>
&nbsp;&nbsp;Parameters parameters;<br/>
&nbsp;&nbsp;parameters.nFemales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 1].ToInt();<br/>
&nbsp;&nbsp;parameters.nMales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 2].ToInt();<br/>
&nbsp;&nbsp;parameters.bestOfHowMuch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 3].ToInt();<br/>
&nbsp;&nbsp;parameters.assessingErrorA&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 4].ToDouble();<br/>
&nbsp;&nbsp;parameters.assessingErrorB&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 5].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanTraitA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 6].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevTraitA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 7].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanTraitB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 8].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevTraitB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 9].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanPreferenceA&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][10].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevPreferenceA&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][11].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanPreferenceB&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][12].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevPreferenceB&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][13].ToDouble();<br/>
&nbsp;&nbsp;parameters.nSimulations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][14].ToInt();<br/>
&nbsp;&nbsp;parameters.nGenerations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][15].ToInt();<br/>
&nbsp;&nbsp;parameters.nOffspring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][16].ToInt();<br/>
&nbsp;&nbsp;parameters.surviveSpeciesAlpha = StringGridParameters-&gt;Cells[1][17].ToDouble();<br/>
&nbsp;&nbsp;parameters.surviveSpeciesBeta&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][18].ToDouble();<br/>
&nbsp;&nbsp;parameters.sigmaSquared&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][19].ToDouble();<br/>
&nbsp;&nbsp;parameters.costTrait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][20].ToDouble();<br/>
&nbsp;&nbsp;parameters.costPreference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][21].ToDouble();<br/>
&nbsp;&nbsp;parameters.mutationRate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][22].ToDouble();<br/>
&nbsp;&nbsp;return parameters;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonTestClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateFemaleSamplingBase&gt; femaleSampling;<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: femaleSampling.reset(new StateFemaleSamplingBestOfNconspicific); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: femaleSampling.reset(new StateFemaleSamplingBestOfNextremeTrait); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: femaleSampling.reset(new StateFemaleSamplingBestOfNclosestTrait); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: femaleSampling.reset(new StateFemaleSamplingFixedThresholdConspicific); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: femaleSampling.reset(new StateFemaleSamplingFixedThresholdTraitSign); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: femaleSampling.reset(new StateFemaleSamplingFixedThresholdProbabilistic); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown index of RadioGroupTestSampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Parameters parameters = readStringGrid();<br/>
&nbsp;&nbsp;const double femaleSpeciesValue = StringGridTest-&gt;Cells[1][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue1&nbsp;&nbsp;= StringGridTest-&gt;Cells[2][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue2&nbsp;&nbsp;= StringGridTest-&gt;Cells[3][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue3&nbsp;&nbsp;= StringGridTest-&gt;Cells[4][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue4&nbsp;&nbsp;= StringGridTest-&gt;Cells[5][1].ToDouble();<br/>
&nbsp;&nbsp;const double femalePreference&nbsp;&nbsp; = StringGridTest-&gt;Cells[1][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[2][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[3][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[4][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[5][2].ToDouble();<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females = Bird::createTestFemales(parameters,femaleSpeciesValue, femalePreference);<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males = Bird::createTestMales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue1, maleTrait1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue2, maleTrait2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue3, maleTrait3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue4, maleTrait4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; histogramWinner(4);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;4; ++i) histogramWinner[i]=0;<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;1000; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males,females[0],parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++(histogramWinner[winnerIndex]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;emptyChart(ChartTest);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(0.0,histogramWinner[0]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(1.0,histogramWinner[1]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(2.0,histogramWinner[2]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(3.0,histogramWinner[3]);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonTestSurvivalSpeciesClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double alpha = StringGridParameters-&gt;Cells[1][17].ToDouble();<br/>
&nbsp;&nbsp;const double beta&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][18].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double y = 1.0 - (alpha * std::exp(-beta * descent * descent))");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("SurviveSpeciesAlpha: " + FloatToStr(alpha) + ", SurviveSpeciesBeta: " + FloatToStr(beta));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "SpeciesValue/descent";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance of survival";<br/>
&nbsp;&nbsp;for (double descent = -1.0; descent&lt;1.0; descent+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double surviveSpecies = Simulation::chanceToSurviveSpecies(descent,alpha,beta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(descent,surviveSpecies);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::FormMouseMove(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TShiftState Shift, int X, int Y)<br/>
{<br/>
&nbsp;&nbsp;TCursor myCursor = static_cast&lt;TCursor&gt;(22);<br/>
&nbsp;&nbsp;Screen-&gt;Cursors[22] = LoadCursorFromFile("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;Cursor = myCursor;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonSaveClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Parameters: ");<br/>
<br/>
&nbsp;&nbsp;if (PageControlSim-&gt;ActivePageIndex==0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("FractionA : " + EditFraction-&gt;Text);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Fration A from: " + EditFractionFrom-&gt;Text<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " to: " + EditFractionTo-&gt;Text<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " in steps of: " + EditFractionStep-&gt;Text);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getStringGrid(StringGridParameters).release());<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupGamy-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //monogamous<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Mating system: monogamous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //polygynous<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Mating system: polygynous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Best-Of-N conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Best-Of-N extreme trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: //bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Best-Of-N closest trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: //fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Fixed threshold conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: //fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Fixed threshold trait sign");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: //fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Fixed threshold probabilistic");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupDensityDependentSelection-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Density dependent selection: in reproduction, after mating");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Density dependent selection: after selection, before mating");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Biases in time: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,BiasA,BiasB,Fraction of mixed pairs");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartBiasTime).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Trait and preferences in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Traits in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,Traits");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChartSeries(ChartTraitPreference-&gt;Series[0]).release());<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Traits in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,Preference");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChartSeries(ChartTraitPreference-&gt;Series[1]).release());<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Descent in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,Descent");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChartSeries(ChartTraitPreference-&gt;Series[2]).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Number of matings in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Number of matings in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,AA,AB,BA,BB,Sum");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartMateTime).release());<br/>
<br/>
&nbsp;&nbsp;Dot("number of individuals in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Number of individuals in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,FemalesA,FemalesB,MalesA,MalesB");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartPopSize).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Biases for different fractions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Biases for different fractions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Fraction,BiasA,BiasB,Fraction of mixed pairs");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartBias).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Number of matings for different proportions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Number of matings for different proportions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Fraction,AA,AB,BA,BB");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartMateFraction).release());<br/>
<br/>
&nbsp;&nbsp;if (SaveDialog1-&gt;Execute()==true)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;SaveToFile(SaveDialog1-&gt;FileName);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines = stringList.release();<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::BitBtn1Click(TObject *Sender)<br/>
{<br/>
/*<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcher.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcherSleeping.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*/<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
std::string toString(const String&amp; ansi)<br/>
{<br/>
&nbsp;&nbsp;const char * myChar = ansi.c_str();<br/>
&nbsp;&nbsp;const std::string myString = myChar;<br/>
&nbsp;&nbsp;return myString;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
String toAnsiString(const std::string&amp; myString)<br/>
{<br/>
&nbsp;&nbsp;const char * myChar = myString.c_str();<br/>
&nbsp;&nbsp;const String myAnsi = myChar;<br/>
&nbsp;&nbsp;return myAnsi;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void emptyChart(TChart* chart)<br/>
{<br/>
&nbsp;&nbsp;const int nSeries = chart-&gt;SeriesCount();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;chart-&gt;Series[i]-&gt;Clear();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::auto_ptr&lt;TStringList&gt; getStringGrid(const TStringGrid * stringGrid)<br/>
{<br/>
&nbsp;&nbsp;//Those Borland people were not const correct, so I need a const cast here<br/>
&nbsp;&nbsp;//Grumble, grumble...<br/>
&nbsp;&nbsp;TStringGrid * grid = const_cast&lt;TStringGrid*&gt;(stringGrid);<br/>
&nbsp;&nbsp;const String seperator = ",";<br/>
<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
&nbsp;&nbsp;const int maxy = grid-&gt;RowCount;<br/>
&nbsp;&nbsp;const int maxx = grid-&gt;ColCount;<br/>
&nbsp;&nbsp;for (int y=0; y&lt;maxy; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String myString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int x=0; x&lt;maxx-1; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString+=grid-&gt;Cells[x][y] + seperator; //This function should have been const, as it is a read function<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myString+=grid-&gt;Cells[maxx-1][y];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return stringList;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::auto_ptr&lt;TStringList&gt; getChart(const TChart * anyChart)<br/>
{<br/>
&nbsp;&nbsp;//Those Borland people were not const correct, so I need a const cast here<br/>
&nbsp;&nbsp;//Grumble, grumble...<br/>
&nbsp;&nbsp;TChart * chart = const_cast&lt;TChart*&gt;(anyChart);<br/>
&nbsp;&nbsp;const String seperator = ",";<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
<br/>
&nbsp;&nbsp;//Copy the pointers to the values<br/>
&nbsp;&nbsp;std::vector&lt; TChartValueList* &gt; xValuesVector;<br/>
&nbsp;&nbsp;std::vector&lt; TChartValueList* &gt; yValuesVector;<br/>
&nbsp;&nbsp;const int nSeries = chart-&gt;SeriesCount();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xValuesVector.push_back(chart-&gt;Series[i]-&gt;XValues);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;yValuesVector.push_back(chart-&gt;Series[i]-&gt;YValues);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Assume there are as many X's as Y's<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(xValuesVector[i]-&gt;Count()==yValuesVector[i]-&gt;Count());<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Make a nice collumn of X values and then all Y values<br/>
&nbsp;&nbsp;const int nRows = xValuesVector[0]-&gt;Count();<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(xValuesVector[i]-&gt;Count()==nRows);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(yValuesVector[i]-&gt;Count()==nRows);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const unsigned int nCols = xValuesVector.size();<br/>
&nbsp;&nbsp;assert(nCols == yValuesVector.size());<br/>
<br/>
&nbsp;&nbsp;for (int y=0; y&lt;nRows; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String myString = FloatToStr(xValuesVector[0]-&gt;operator [](y)) + seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int x=0; x&lt;nCols-1; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString+=FloatToStr(yValuesVector[x]-&gt;operator [](y)) + seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myString+=FloatToStr(yValuesVector[nCols-1]-&gt;operator [](y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return stringList;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::auto_ptr&lt;TStringList&gt; getChartSeries(const TChartSeries * series)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
&nbsp;&nbsp;const String seperator = ",";<br/>
<br/>
&nbsp;&nbsp;//Copy the pointers to the values<br/>
&nbsp;&nbsp;TChartValueList * xValues = series-&gt;XValues;<br/>
&nbsp;&nbsp;TChartValueList * yValues = series-&gt;YValues;<br/>
&nbsp;&nbsp;//Assume there are as many X's as Y's<br/>
&nbsp;&nbsp;assert(xValues-&gt;Count()==yValues-&gt;Count());<br/>
<br/>
&nbsp;&nbsp;const int nRows = xValues-&gt;Count();<br/>
&nbsp;&nbsp;double x = -1.0;<br/>
&nbsp;&nbsp;String myString;<br/>
&nbsp;&nbsp;for (int y=0; y&lt;nRows; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double thisX = xValues-&gt;operator [](y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (x!=thisX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString = FloatToStr(thisX) + seperator + FloatToStr(yValues-&gt;operator [](y)) + seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = thisX;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString += FloatToStr(yValues-&gt;operator [](y))+seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;return stringList;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestTraitClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double costTrait = StringGridParameters-&gt;Cells[1][20].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double survival = std::exp(-costTrait * trait * trait);");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("costTrait: " + FloatToStr(costTrait));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "Species trait";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance of survival";<br/>
&nbsp;&nbsp;for (double maleTrait = -1.0; maleTrait&lt;1.0; maleTrait+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double survivalTrait = Simulation::chanceToSurviveTrait(maleTrait,costTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(maleTrait,survivalTrait);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestPreferenceClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double costPreference = StringGridParameters-&gt;Cells[1][21].ToDouble();<br/>
<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double survival = std::exp(-costPreference * preference * preference");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("costPreference: " + FloatToStr(costPreference));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "Species preference";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance of survival";<br/>
&nbsp;&nbsp;for (double femalePreference = -1.0; femalePreference&lt;1.0; femalePreference+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double survivalPreference = Simulation::chanceToSurvivePreference(femalePreference,costPreference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(femalePreference,survivalPreference);<br/>
&nbsp;&nbsp;}<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestProbabilisticMatingClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;const double femalePreference = 0.0;<br/>
&nbsp;&nbsp;const double sigmaSquared = StringGridParameters-&gt;Cells[1][19].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double chanceToMate =std::exp(-(maleTrait-femalePreference)*(maleTrait-femalePreference)/sigmaSquared);");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("FemalePreference: 0.0 (in this example)");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("sigmaSquared: " + FloatToStr(sigmaSquared));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "Male trait";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance to mate";<br/>
&nbsp;&nbsp;for (double maleTrait = -1.0; maleTrait&lt;1.0; maleTrait+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double chanceToMate =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StateFemaleSamplingFixedThresholdProbabilistic::getChanceToMate(femalePreference, maleTrait, sigmaSquared);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(maleTrait,chanceToMate);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::StringGridParametersSelectCell(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ACol, int ARow, bool &amp;CanSelect)<br/>
{<br/>
&nbsp;&nbsp;//Show help<br/>
&nbsp;&nbsp;switch (ARow)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;1: StringGridParameters-&gt;Hint = "Number of females used in every generation"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;2: StringGridParameters-&gt;Hint = "Number of males used in every generation"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;3: StringGridParameters-&gt;Hint = "Number of males the female can sample from"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;4: StringGridParameters-&gt;Hint = "Assessing error made by species A (0.0 = perfect sampling, 1.0=random mating)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;5: StringGridParameters-&gt;Hint = "Assessing error made by species B (0.0 = perfect sampling, 1.0=random mating)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;6: StringGridParameters-&gt;Hint = "Initial mean trait of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;7: StringGridParameters-&gt;Hint = "Initial StdDev of the trait of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;8: StringGridParameters-&gt;Hint = "Initial mean trait of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;9: StringGridParameters-&gt;Hint = "Initial StdDev of the trait of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 10: StringGridParameters-&gt;Hint = "Initial mean preference of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 11: StringGridParameters-&gt;Hint = "Initial StdDev of the preference of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 12: StringGridParameters-&gt;Hint = "Initial mean preference of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 13: StringGridParameters-&gt;Hint = "Initial StdDev of the preference of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 14: StringGridParameters-&gt;Hint = "Number of simulations of which the results are an average of"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 15: StringGridParameters-&gt;Hint = "Number of generations"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 16: StringGridParameters-&gt;Hint = "Number of offspring produced (used when density dependent selection = before reproduction)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 17: StringGridParameters-&gt;Hint = "Chance to die of pure hybrids (0.0 = Hybrids have equal survival, 1.0 = hybrids will die by chance 100%)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 18: StringGridParameters-&gt;Hint = "Increase in fitmess from hybrids to pure species (0.0 = hybrids and pure have equal survival, 100.0 = pure species have 100% survival)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 19: StringGridParameters-&gt;Hint = "Choosiness of female (only used in probabilistic mating, 1000.0 = random mating, 0.001 = very choosy"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 20: StringGridParameters-&gt;Hint = "Cost trait in survival/trait (0.0 = trait is costless, 10.0 = trait is expensive)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 21: StringGridParameters-&gt;Hint = "Cost preference in survival/preference (0.0 = preference is costless, 10.0 = preference is expensive)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 22: StringGridParameters-&gt;Hint = "Standard deviation of mutation rate"; break;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestHelpClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ShowMessage(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"These tests show the functions used."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nThe results shown are derived from the functions used in the simulation"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\n(so no code duplication, except in the Chart titles)"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nThe parameters used are from the Parameter StringGrid on the left."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nNote that for these functions, the parameters are NOT checked."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nTherefore, it is possible to give in a negative cost for trait,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nwhich will also yield a result, but when starting the simulation,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nthese values WILL be checked."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::RadioGroupFemaleSamplingClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //Best of N conspicific<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female chooses a conspicific from a lek of N males";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //Best of N most extreme trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female chooses a male with the most extreme trait from a lek of N males. If her preference is smaller then 0.0, she prefers a male with trait smaller then 0.0";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: //Best of N closest trait-preference<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female chooses a male with trait closest near her preference from a lek of N males";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: //Fixed threshold conspicific<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female searches infinitely for a conspicific";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: //Fixed threshold same trait sign<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female searches infinitely for a male with the same trait sign as her preference (i.e. a negative-preference female prefers a negative-trait male)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: //Fixed threshold probabilistic<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female searches infinitely for a male with trait close to her preference. The chance she will mate with him is defined by SigmaSquared";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
void __fastcall TFormMain::RadioGroupDensityDependentSelectionClick(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;switch(RadioGroupDensityDependentSelection-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //In reproduction, nOffspring = popSize parents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupDensityDependentSelection-&gt;Hint = "In reproduction, there are offspring produced until the original fractions of speciesA and speciesB are reached for a population size of nMales + nFemales";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //After selection, nMatureOffspring = popSize parents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupDensityDependentSelection-&gt;Hint = "After selection, before mating, the population is cut down to the needed fractions of speciesA and speciesB to a population size of nMales + nFemales";<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::RadioGroupGamyClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;switch(RadioGroupGamy-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //Monogamy<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupGamy-&gt;Hint = "After a female has selected a male, they will be a couple for life (that is, one generation)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //Polygyny<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupGamy-&gt;Hint = "A male can mate with multiple females";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::PageControlSimChange(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//ShowMessage("TEST" + IntToStr(PageControlSim-&gt;ActivePageIndex));<br/>
&nbsp;&nbsp;if (PageControlSim-&gt;ActivePageIndex == 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Single fraction sim (in time)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[0]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[1]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[2]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[3]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[4]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[5]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Range of fractions sim<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[0]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[1]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[2]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[3]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[4]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[5]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::BitBtn1MouseDown(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TMouseButton Button, TShiftState Shift, int X, int Y)<br/>
{<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcher.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcherSleeping.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (Button == mbRight &amp;&amp;&nbsp;&nbsp;X &lt; 10 &amp;&amp; Y &lt; 10)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;TFormAboutBox2&gt; aboutBox(new TFormAboutBox2(this));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;TFormThreeDotsChasing&gt; threeDotsChasing(new TFormThreeDotsChasing(this));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const int sumWidth = aboutBox-&gt;Width + threeDotsChasing-&gt;Width;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;aboutBox-&gt;Show();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;aboutBox-&gt;Left = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;threeDotsChasing-&gt;ShowModal();<br/>
&nbsp;&nbsp;}<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/UnitMain.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/UnitMain.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitMainH<br/>
#define UnitMainH<br/>
#include &lt;Chart.hpp&gt;<br/>
#include &lt;Classes.hpp&gt;<br/>
#include &lt;ComCtrls.hpp&gt;<br/>
#include &lt;Controls.hpp&gt;<br/>
#include &lt;ExtCtrls.hpp&gt;<br/>
#include &lt;Grids.hpp&gt;<br/>
#include &lt;Series.hpp&gt;<br/>
#include &lt;StdCtrls.hpp&gt;<br/>
#include &lt;TeEngine.hpp&gt;<br/>
#include &lt;TeeProcs.hpp&gt;<br/>
#include &lt;AppEvnts.hpp&gt;<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;mmsystem.h&gt;<br/>
#include &lt;Buttons.hpp&gt;<br/>
#include &lt;Dialogs.hpp&gt;<br/>
//#include &lt;Buttons.hpp&gt;<br/>
//#include &lt;utility&gt;<br/>
//#include &lt;functional&gt;<br/>
//#include &lt;iterator&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include "UnitSimulation.h"<br/>
#include "UnitTimeSeries.h"<br/>
#include "UnitParameters.h"<br/>
//---------------------------------------------------------------------------<br/>
class TFormMain : public TForm<br/>
{<br/>
__published:	// IDE-managed Components<br/>
&nbsp;&nbsp;TStringGrid *StringGridParameters;<br/>
&nbsp;&nbsp;TButton *ButtonRun;<br/>
&nbsp;&nbsp;TStatusBar *StatusBarMain;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartBias;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelLeft;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRadioGroup *RadioGroupGamy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRadioGroup *RadioGroupFemaleSampling;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TProgressBar *ProgressBarSim;<br/>
&nbsp;&nbsp;TPageControl *PageControlMain;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRichEdit *RichEdit2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRadioGroup *RadioGroupDensityDependentSelection;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartPopSize;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series13;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelLeftTop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series16;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series19;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFractionFrom;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFractionTo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFractionStep;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartMateTime;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series21;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series22;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series23;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TStringGrid *StringGridTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBarSeries *Series4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartTraitPreference;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPointSeries *Series5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPointSeries *Series6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartMateFraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series9;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series11;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series24;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPointSeries *Series25;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *Panel1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPageControl *PageControlSim;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet13;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet14;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPageControl *PageControl2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet8;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet9;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelTestProbTop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestSurvivalSpecies;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartTestProbabilities;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series26;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBitBtn *BitBtn1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartBiasTime;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series27;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series28;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series29;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonSave;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSaveDialog *SaveDialog1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRichEdit *RichEditOutput;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestTrait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestPreference;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestProbabilisticMating;<br/>
&nbsp;&nbsp;TButton *ButtonTestHelp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheetAbout;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRichEdit *RichEditAbout;<br/>
&nbsp;&nbsp;void __fastcall ButtonRunClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestSurvivalSpeciesClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall FormMouseMove(TObject *Sender, TShiftState Shift,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int X, int Y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall BitBtn1Click(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonSaveClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestTraitClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestPreferenceClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestProbabilisticMatingClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall StringGridParametersSelectCell(TObject *Sender, int ACol,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ARow, bool &amp;CanSelect);<br/>
&nbsp;&nbsp;void __fastcall ButtonTestHelpClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall RadioGroupFemaleSamplingClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall RadioGroupDensityDependentSelectionClick(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall RadioGroupGamyClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall PageControlSimChange(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall BitBtn1MouseDown(TObject *Sender, TMouseButton Button,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TShiftState Shift, int X, int Y);<br/>
private:	// User declarations<br/>
&nbsp;&nbsp;void setCursor(const String&amp; cursorName);<br/>
&nbsp;&nbsp;bool checkInput();<br/>
&nbsp;&nbsp;void TFormMain::plotTimePoint(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimePoint&amp; mean,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimePoint&amp; stdError,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; chartX);<br/>
&nbsp;&nbsp;void TFormMain::plotTimeSeries(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimeSeries&amp; mean,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimeSeries&amp; stdError);<br/>
&nbsp;&nbsp;Parameters readStringGrid() const;<br/>
public:		// User declarations<br/>
&nbsp;&nbsp;__fastcall TFormMain(TComponent* Owner);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
extern PACKAGE TFormMain *FormMain;<br/>
//---------------------------------------------------------------------------<br/>
std::string toString(const String&amp; ansi);<br/>
String toAnsiString(const std::string&amp; myString);<br/>
void emptyChart(TChart* chart);<br/>
std::auto_ptr&lt;TStringList&gt; getStringGrid(const TStringGrid * stringGrid);<br/>
std::auto_ptr&lt;TStringList&gt; getChart(const TChart * anyChart);<br/>
std::auto_ptr&lt;TStringList&gt; getChartSeries(const TChartSeries * series);<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/UnitThreeDotsChasing.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/UnitThreeDotsChasing.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitThreeDotsChasing.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormThreeDotsChasing *FormThreeDotsChasing;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormThreeDotsChasing::TFormThreeDotsChasing(TComponent* Owner)<br/>
&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
&nbsp;&nbsp;points.resize(4);<br/>
&nbsp;&nbsp;std::srand(clock());<br/>
<br/>
&nbsp;&nbsp;FormResize(0);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormThreeDotsChasing::ApplicationEvents1Idle(TObject *Sender, bool &amp;Done)<br/>
{<br/>
&nbsp;&nbsp;//++count;<br/>
&nbsp;&nbsp;//this-&gt;Caption = count;<br/>
<br/>
&nbsp;&nbsp;const char nPoints = points.size();<br/>
&nbsp;&nbsp;const short maxy = Image1-&gt;Height;<br/>
&nbsp;&nbsp;const short maxx = Image1-&gt;Width;<br/>
&nbsp;&nbsp;for (char i=0; i&lt;nPoints; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const char other = (i+1)%nPoints;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(other&gt;=0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(other&lt;nPoints);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].x &lt; points[other].x) ++(points[i].dx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else --(points[i].dx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].y &lt; points[other].y) ++(points[i].dy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else --(points[i].dy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].x+=points[i].dx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].x&lt;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].x=0; points[i].dx = -points[i].dx; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (points[i].x&gt;=maxx)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].x=maxx-1; points[i].dx = -points[i].dx; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].y+=points[i].dy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].y&lt;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].y=0; points[i].dy = -points[i].dy; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (points[i].y&gt;=maxy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].y=maxy-1; points[i].dy = -points[i].dy; }<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;unsigned char * pLine;<br/>
&nbsp;&nbsp;for (short y=0; y&lt;maxy; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pLine=static_cast&lt;unsigned char *&gt;(Image1-&gt;Picture-&gt;Bitmap-&gt;ScanLine[y]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (short x=0; x&lt;maxx; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexRedX&nbsp;&nbsp; = abs(x-points[0].x)%maxx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexRedY&nbsp;&nbsp; = abs(y-points[0].y)%maxy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexGreenX = abs(x-points[1].x)%maxx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexGreenY = abs(y-points[1].y)%maxy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexBlueX&nbsp;&nbsp;= abs(x-points[2].x)%maxx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexBlueY&nbsp;&nbsp;= abs(y-points[2].y)%maxy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedX&nbsp;&nbsp; &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenX &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueX&nbsp;&nbsp;&gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedY&nbsp;&nbsp; &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenY &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueY&nbsp;&nbsp;&gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedX&nbsp;&nbsp; &lt; this-&gt;ClientWidth);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenX &lt; this-&gt;ClientWidth);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueX&nbsp;&nbsp;&lt; this-&gt;ClientWidth);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedY&nbsp;&nbsp; &lt; this-&gt;ClientHeight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenY &lt; this-&gt;ClientHeight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueY&nbsp;&nbsp;&lt; this-&gt;ClientHeight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pLine[x*3+0]= distance[indexBlueX ][indexBlueY ]; //Blue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pLine[x*3+1]= distance[indexGreenX][indexGreenY]; //Green<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pLine[x*3+2]= distance[indexRedX&nbsp;&nbsp;][indexRedY&nbsp;&nbsp;]; //Red<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;this-&gt;Canvas-&gt;Draw(0,0,Image1-&gt;Picture-&gt;Graphic);<br/>
&nbsp;&nbsp;Done = false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormThreeDotsChasing::FormClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;resetPoints();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormThreeDotsChasing::resetPoints()<br/>
{<br/>
&nbsp;&nbsp;const short width&nbsp;&nbsp;= this-&gt;ClientWidth;<br/>
&nbsp;&nbsp;const short height = this-&gt;ClientHeight;<br/>
&nbsp;&nbsp;const char nPoints = points.size();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nPoints; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].x = std::rand()%width;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].y = std::rand()%height;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].dx = (std::rand()%5)-2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].dy = (std::rand()%5)-2;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormThreeDotsChasing::FormResize(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//Generate vectors for look-up table<br/>
&nbsp;&nbsp;const short width&nbsp;&nbsp;= this-&gt;ClientWidth;<br/>
&nbsp;&nbsp;const short height = this-&gt;ClientHeight;<br/>
<br/>
&nbsp;&nbsp;distance.resize(width);<br/>
&nbsp;&nbsp;for (int i=0; i&lt;width; ++i) distance[i].resize(height);<br/>
<br/>
&nbsp;&nbsp;//Generate look-up table<br/>
&nbsp;&nbsp;const double widthD&nbsp;&nbsp;= static_cast&lt;double&gt;(width);<br/>
&nbsp;&nbsp;const double heightD = static_cast&lt;double&gt;(height);<br/>
&nbsp;&nbsp;const double maxDist = sqrt( (widthD*widthD) + (heightD*heightD) );<br/>
&nbsp;&nbsp;for (int x=0; x&lt;width; ++x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int y=0; y&lt;height; ++y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double xD = static_cast&lt;double&gt;(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double yD = static_cast&lt;double&gt;(y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double dist = sqrt( (xD*xD) + (yD*yD) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//distance[x][y] = 256.0 * dist / maxDist;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance[x][y] = 255.0 * std::exp(-dist/150.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Points<br/>
&nbsp;&nbsp;resetPoints();<br/>
&nbsp;&nbsp;//Create image<br/>
&nbsp;&nbsp;Image1-&gt;Picture-&gt;Bitmap-&gt;Width&nbsp;&nbsp;= width;<br/>
&nbsp;&nbsp;Image1-&gt;Picture-&gt;Bitmap-&gt;Height = height;<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/QtPostProject/UnitThreeDotsChasing.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/QtPostProject/UnitThreeDotsChasing.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitThreeDotsChasingH<br/>
#define UnitThreeDotsChasingH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;Classes.hpp&gt;<br/>
#include &lt;Controls.hpp&gt;<br/>
#include &lt;StdCtrls.hpp&gt;<br/>
#include &lt;Forms.hpp&gt;<br/>
#include &lt;AppEvnts.hpp&gt;<br/>
#include &lt;ExtCtrls.hpp&gt;<br/>
#include &lt;Graphics.hpp&gt;<br/>
//---------------------------------------------------------------------------<br/>
#define NDEBUG<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert&gt;<br/>
#include &lt;math&gt;<br/>
#include &lt;time&gt;<br/>
//---------------------------------------------------------------------------<br/>
class TFormThreeDotsChasing : public TForm<br/>
{<br/>
__published:	// IDE-managed Components<br/>
&nbsp;&nbsp;TImage *Image1;<br/>
&nbsp;&nbsp;TApplicationEvents *ApplicationEvents1;<br/>
&nbsp;&nbsp;void __fastcall ApplicationEvents1Idle(TObject *Sender, bool &amp;Done);<br/>
&nbsp;&nbsp;void __fastcall FormClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall FormResize(TObject *Sender);<br/>
private:	// User declarations<br/>
public:		// User declarations<br/>
&nbsp;&nbsp;__fastcall TFormThreeDotsChasing(TComponent* Owner);<br/>
&nbsp;&nbsp;//int count;<br/>
&nbsp;&nbsp;std::vector&lt; std::vector&lt;unsigned char&gt; &gt; distance;<br/>
<br/>
&nbsp;&nbsp;struct Point<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;short x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;short y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char dx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char dy;<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;short abs(const short&amp; i) { return (i&lt;0 ? -i : i); }<br/>
&nbsp;&nbsp;std::vector&lt; Point &gt; points;<br/>
&nbsp;&nbsp;void resetPoints();<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
extern PACKAGE TFormThreeDotsChasing *FormThreeDotsChasing;<br/>
//---------------------------------------------------------------------------<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/ProjectChrisWiley.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/ProjectChrisWiley.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
//---------------------------------------------------------------------------<br/>
USEFORM("UnitMain.cpp", FormMain);<br/>
USEFORM("UnitThreeDotsChasing.cpp", FormThreeDotsChasing);<br/>
USEFORM("UnitAboutBox2.cpp", FormAboutBox2);<br/>
//---------------------------------------------------------------------------<br/>
WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)<br/>
{<br/>
&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;Initialize();<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;Title = "The Chris Wiley Project";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;CreateForm(__classid(TFormMain), &amp;FormMain);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;Run();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch (Exception &amp;exception)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;ShowException(&amp;exception);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch (...)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw Exception("");<br/>
&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception &amp;exception)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application-&gt;ShowException(&amp;exception);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitAboutBox2.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitAboutBox2.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitAboutBox2.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormAboutBox2 *FormAboutBox2;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormAboutBox2::TFormAboutBox2(TComponent* Owner)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitAboutBox2.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitAboutBox2.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitAboutBox2H<br/>
#define UnitAboutBox2H<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;Classes.hpp&gt;<br/>
#include &lt;Controls.hpp&gt;<br/>
#include &lt;StdCtrls.hpp&gt;<br/>
#include &lt;Forms.hpp&gt;<br/>
#include &lt;ExtCtrls.hpp&gt;<br/>
#include &lt;Graphics.hpp&gt;<br/>
//---------------------------------------------------------------------------<br/>
class TFormAboutBox2 : public TForm<br/>
{<br/>
__published:	// IDE-managed Components<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TImage *Image1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TStaticText *StaticText1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TStaticText *StaticText2;<br/>
&nbsp;&nbsp;TStaticText *StaticText3;<br/>
private:	// User declarations<br/>
public:		// User declarations<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__fastcall TFormAboutBox2(TComponent* Owner);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
extern PACKAGE TFormAboutBox2 *FormAboutBox2;<br/>
//---------------------------------------------------------------------------<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitBird.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitBird.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitBird.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
Bird::Bird(const Bird&amp; mother, const Bird&amp; father, const double&amp; mutation)<br/>
{<br/>
&nbsp;&nbsp;descent = (mother.descent + father.descent) / 2.0;<br/>
&nbsp;&nbsp;assert(descent&gt;=-1.0 &amp;&amp; descent&lt;=1.0);<br/>
&nbsp;&nbsp;const double chanceBeingPied = 1.0-((descent+1.0)/2.0);<br/>
&nbsp;&nbsp;assert(chanceBeingPied&gt;=0.0 &amp;&amp; chanceBeingPied&lt;=1.0);<br/>
&nbsp;&nbsp;species = (rnd::uniform() &gt; chanceBeingPied ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;//Make a bit<br/>
&nbsp;&nbsp;unsigned int number = std::rand()%64;<br/>
&nbsp;&nbsp;index = (number%2==0 ? mother.index : father.index);<br/>
&nbsp;&nbsp;number&gt;&gt;=1;<br/>
&nbsp;&nbsp;trait = (number%2==0 ? mother.trait : father.trait);<br/>
&nbsp;&nbsp;trait+=rnd::normal(0.0,mutation);<br/>
&nbsp;&nbsp;number&gt;&gt;=1;<br/>
&nbsp;&nbsp;preference = (number%2==0 ? mother.preference : father.preference);<br/>
&nbsp;&nbsp;preference+=rnd::normal(0.0,mutation);<br/>
&nbsp;&nbsp;number&gt;&gt;=1;<br/>
&nbsp;&nbsp;assessingError = (number%2==0 ? mother.assessingError : father.assessingError);<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Male&gt; Bird::createMales(const Parameters&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;//Create males<br/>
&nbsp;&nbsp;assert(parameters.fractionMaleA&gt;=0.0 &amp;&amp; parameters.fractionMaleA&lt;=1.0);<br/>
&nbsp;&nbsp;//Create an empty vector of males<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males; //(parameters.nMales);<br/>
&nbsp;&nbsp;//Calculate the number of males of speciesA<br/>
&nbsp;&nbsp;const unsigned int nSpeciesA =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0.5 + (static_cast&lt;double&gt;(parameters.nMales) * parameters.fractionMaleA)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
&nbsp;&nbsp;const unsigned int nSpeciesB =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0.5 + (static_cast&lt;double&gt;(parameters.nMales) * (1.0-parameters.fractionMaleA))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
&nbsp;&nbsp;//Dot("Of " + IntToStr(nMales) + " males, there are " + IntToStr(nSpeciesA) + " of speciesA");<br/>
&nbsp;&nbsp;//Fill the vector<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSpeciesA; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Male maleA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.species = piedFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.descent = -1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.trait = rnd::normal(parameters.meanTraitA, parameters.stdDevTraitA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.preference = rnd::normal(parameters.meanPreferenceA, parameters.stdDevPreferenceA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleA.assessingError = parameters.assessingErrorA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.push_back(maleA);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (unsigned int i=0 ; i&lt;nSpeciesB; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Male maleB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.species = collaredFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.descent = 1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.trait = rnd::normal(parameters.meanTraitB, parameters.stdDevTraitB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.preference = rnd::normal(parameters.meanPreferenceB, parameters.stdDevPreferenceB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleB.assessingError = parameters.assessingErrorB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.push_back(maleB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return males;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Female&gt; Bird::createFemales(const Parameters&amp; parameters)<br/>
//Create females<br/>
{<br/>
&nbsp;&nbsp;assert(parameters.fractionFemaleA&gt;=0.0 &amp;&amp; parameters.fractionFemaleA&lt;=1.0);<br/>
&nbsp;&nbsp;//Create an empty vector of females<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females;<br/>
&nbsp;&nbsp;//Calculate the number of females of speciesA<br/>
&nbsp;&nbsp;const unsigned int nSpeciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= 0.5 + (static_cast&lt;double&gt;(parameters.nFemales) * parameters.fractionFemaleA)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
<br/>
&nbsp;&nbsp;const unsigned int nSpeciesB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= 0.5 + (static_cast&lt;double&gt;(parameters.nFemales) * (1.0-parameters.fractionFemaleA))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (parameters.densityDependentSelection == beforeMating ? 2.0 : 1.0);<br/>
<br/>
&nbsp;&nbsp;//Fill the vector<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSpeciesA; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Female femaleA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.species = piedFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.descent = -1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.preference = rnd::normal(parameters.meanPreferenceA, parameters.stdDevPreferenceA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.assessingError = parameters.assessingErrorA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleA.trait = rnd::normal(parameters.meanTraitA, parameters.stdDevTraitA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.push_back(femaleA);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (unsigned int i=0 ; i&lt;nSpeciesB; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Female femaleB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.index = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.species = collaredFlycatcher;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.descent = 1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.preference = rnd::normal(parameters.meanPreferenceB, parameters.stdDevPreferenceB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.assessingError = parameters.assessingErrorB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;femaleB.trait = rnd::normal(parameters.meanTraitB, parameters.stdDevTraitB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.push_back(femaleB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return females;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Male&gt; Bird::createTestMales(<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const double&amp; species1, const double&amp; trait1,<br/>
&nbsp;&nbsp;const double&amp; species2, const double&amp; trait2,<br/>
&nbsp;&nbsp;const double&amp; species3, const double&amp; trait3,<br/>
&nbsp;&nbsp;const double&amp; species4, const double&amp; trait4<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;//Create an empty vector of males<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males;<br/>
&nbsp;&nbsp;//Calculate the number of males of speciesA<br/>
&nbsp;&nbsp;//Dot("Of " + IntToStr(nMales) + " males, there are " + IntToStr(nSpeciesA) + " of speciesA");<br/>
&nbsp;&nbsp;//Fill the vector<br/>
&nbsp;&nbsp;Male male1, male2, male3, male4;<br/>
&nbsp;&nbsp;male1.descent = species1; male1.trait = trait1; male1.species = (rnd::uniform() &gt; 1.0-((male1.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;male2.descent = species2; male2.trait = trait2; male2.species = (rnd::uniform() &gt; 1.0-((male2.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;male3.descent = species3; male3.trait = trait3; male3.species = (rnd::uniform() &gt; 1.0-((male3.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;male4.descent = species4; male4.trait = trait4; male4.species = (rnd::uniform() &gt; 1.0-((male4.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;males.push_back(male1);<br/>
&nbsp;&nbsp;males.push_back(male2);<br/>
&nbsp;&nbsp;males.push_back(male3);<br/>
&nbsp;&nbsp;males.push_back(male4);<br/>
&nbsp;&nbsp;return males;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;Female&gt; Bird::createTestFemales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species, const double&amp; preference)<br/>
//Create females<br/>
{<br/>
&nbsp;&nbsp;//Create an empty vector of females<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females;<br/>
&nbsp;&nbsp;//Fill the vector with one female<br/>
&nbsp;&nbsp;Female female;<br/>
&nbsp;&nbsp;female.descent = species;<br/>
&nbsp;&nbsp;female.species = (rnd::uniform() &gt; 1.0-((female.descent+1.0)/2.0) ? collaredFlycatcher : piedFlycatcher);<br/>
&nbsp;&nbsp;female.preference = preference;<br/>
&nbsp;&nbsp;female.assessingError = parameters.assessingErrorA;<br/>
&nbsp;&nbsp;females.push_back(female);<br/>
&nbsp;&nbsp;return females;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitBird.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitBird.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitBirdH<br/>
#define UnitBirdH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert&gt;<br/>
#include "UnitHelperFunctions.h"<br/>
#include "UnitParameters.h"<br/>
#include "UnitEnums.h"<br/>
#include "UnitRandom.h"<br/>
<br/>
class Couple; //Forward declaration<br/>
<br/>
class Bird<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
<br/>
&nbsp;&nbsp;Bird(const Bird&amp; mother, const Bird&amp; father, const double&amp; mutation);<br/>
<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createMales(const Parameters&amp; parameters);<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createFemales(const Parameters&amp; parameters);<br/>
<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createTestMales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species1, const double&amp; trait1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species2, const double&amp; trait2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species3, const double&amp; trait3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species4, const double&amp; trait4);<br/>
<br/>
&nbsp;&nbsp;static std::vector&lt;Bird&gt; createTestFemales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; species, const double&amp; preference);<br/>
<br/>
&nbsp;&nbsp;unsigned int index;<br/>
&nbsp;&nbsp;double descent;<br/>
&nbsp;&nbsp;enumSpecies species;<br/>
&nbsp;&nbsp;double trait;<br/>
&nbsp;&nbsp;double preference;<br/>
&nbsp;&nbsp;double assessingError;<br/>
<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;//No empty constructor, Birds are either created from parents or<br/>
&nbsp;&nbsp;//from the static createMales/createFemales functions<br/>
&nbsp;&nbsp;Bird() {}<br/>
};<br/>
<br/>
typedef Bird Male;<br/>
typedef Bird Female;<br/>
<br/>
struct Offspring<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females;<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&nbsp;&nbsp; males;<br/>
};<br/>
<br/>
typedef Offspring Population;<br/>
<br/>
class Couple<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;Couple(const Female&amp; anyFemale, const Male&amp; anyMale)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: female(anyFemale),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;male(anyMale)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Nothing<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const Female female;<br/>
&nbsp;&nbsp;const Male&nbsp;&nbsp; male;<br/>
};<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitDensityDependentSelection.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitDensityDependentSelection.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitDensityDependentSelection.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
bool StateDensityDependentSelectionAfterMating::canDoSelection(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void StateDensityDependentSelectionAfterMating::doSelection(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;//Nothing, density dependent selection is found in MatingSystemFixedNumberOffspring<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//This type of selection occurs before mating<br/>
//Idea is, that the population structure is constant before mating.<br/>
//This means that the number of malesA, malesB, femalesA and femalesB<br/>
//is constant. This is reached by removing superfluous individuals.<br/>
//If however, too few individuals are present, selection cannot take<br/>
//place and the population is called extinct.<br/>
bool StateDensityDependentSelectionBeforeMating::canDoSelection(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;//assert(speciesTally.isNull()==false);<br/>
&nbsp;&nbsp;SpeciesTally speciesTally;<br/>
&nbsp;&nbsp;speciesTally.tallySpecies(females,males);<br/>
<br/>
&nbsp;&nbsp;if ( speciesTally.getNfemalesA() &lt; parameters.getNfemalesAwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage = "Too few femalesA for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNfemalesAwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if ( speciesTally.getNfemalesB() &lt; parameters.getNfemalesBwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage = "Too few femalesB for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNfemalesBwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if ( speciesTally.getNmalesA() &lt; parameters.getNmalesAwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage = "Too few malesA for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNmalesAwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if ( speciesTally.getNmalesB() &lt; parameters.getNmalesBwanted())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;errorMessage =&nbsp;&nbsp;"Too few malesB for selection."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" Needed: " + itoa(parameters.getNmalesBwanted())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " ,got: " + itoa(speciesTally.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Dot(errorMessage);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void StateDensityDependentSelectionBeforeMating::doSelection(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;unsigned int nMalesAwanted&nbsp;&nbsp; = parameters.getNmalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nMalesBwanted&nbsp;&nbsp; = parameters.getNmalesBwanted();<br/>
&nbsp;&nbsp;assert(nMalesAwanted + nMalesBwanted == parameters.nMales);<br/>
&nbsp;&nbsp;unsigned int nFemalesAwanted = parameters.getNfemalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nFemalesBwanted = parameters.getNfemalesBwanted();<br/>
&nbsp;&nbsp;assert(nFemalesAwanted + nFemalesBwanted == parameters.nFemales);<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;males.size(); ) //No increment<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (males[i].species == piedFlycatcher) //Male is of type A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesAwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; males.erase(&amp;males[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nMalesAwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //Male is of type B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesBwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; males.erase(&amp;males[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nMalesBwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;females.size(); ) //No increment<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (females[i].species == piedFlycatcher) //Female is of type A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesAwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; females.erase(&amp;females[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nFemalesAwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //Female is of type B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesBwanted==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Erase the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; females.erase(&amp;females[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Keep the female<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--nFemalesBwanted;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#ifdef __HACK_089236408766433745<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int fs = females.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int ms = males.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int fw = parameters.nFemales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int mw = parameters.nMales;<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;std::random_shuffle(females.begin(), females.end());<br/>
&nbsp;&nbsp;std::random_shuffle(males.begin(), males.end());<br/>
&nbsp;&nbsp;assert(females.size()==parameters.nFemales);<br/>
&nbsp;&nbsp;assert(males.size()==parameters.nMales);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitDensityDependentSelection.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitDensityDependentSelection.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitDensityDependentSelectionH<br/>
#define UnitDensityDependentSelectionH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include "UnitTallies.h"<br/>
#include "UnitParameters.h"<br/>
#include "UnitBird.h"<br/>
<br/>
class StateDensityDependentSelectionBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateDensityDependentSelectionBase() {}<br/>
&nbsp;&nbsp;virtual std::string getString() const = 0;<br/>
&nbsp;&nbsp;virtual bool canDoSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const = 0;<br/>
&nbsp;&nbsp;virtual void doSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const = 0;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateDensityDependentSelectionAfterMating : public StateDensityDependentSelectionBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateDensityDependentSelectionAfterMating() {}<br/>
&nbsp;&nbsp;std::string getString() const { return "DensityDependentSelectionAfterMating"; }<br/>
&nbsp;&nbsp;bool canDoSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
&nbsp;&nbsp;void doSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateDensityDependentSelectionBeforeMating : public StateDensityDependentSelectionBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateDensityDependentSelectionBeforeMating() {}<br/>
&nbsp;&nbsp;std::string getString() const { return "DensityDependentSelectionBeforeMating"; }<br/>
&nbsp;&nbsp;bool canDoSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string&amp; errorMessage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
&nbsp;&nbsp;void doSelection(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const SpeciesTally&amp; speciesTally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) const;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitEnums.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitEnums.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitEnums.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitEnums.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitEnums.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitEnumsH<br/>
#define UnitEnumsH<br/>
//---------------------------------------------------------------------------<br/>
enum enumSpecies<br/>
{<br/>
&nbsp;&nbsp;piedFlycatcher, //descent/speciesValue = -1<br/>
&nbsp;&nbsp;collaredFlycatcher&nbsp;&nbsp;//descent/speciesValue = 1.0<br/>
};<br/>
<br/>
enum enumDensityDependentSelection<br/>
{<br/>
&nbsp;&nbsp;beforeMating,<br/>
&nbsp;&nbsp;afterMating<br/>
};<br/>
<br/>
enum enumMatingSystem<br/>
{<br/>
&nbsp;&nbsp;monogamy,<br/>
&nbsp;&nbsp;polygyny //Male can mate multiple times<br/>
};<br/>
<br/>
enum enumFemaleSampling<br/>
{<br/>
&nbsp;&nbsp;bestOfNconspicific,<br/>
&nbsp;&nbsp;bestOfNextremeTrait,<br/>
&nbsp;&nbsp;bestOfNclosestTrait,<br/>
&nbsp;&nbsp;fixedThresholdConspicific,<br/>
&nbsp;&nbsp;fixedThresholdTraitSign,<br/>
&nbsp;&nbsp;fixedThresholdProbabilistic<br/>
};<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitFemaleSampling.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitFemaleSampling.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitFemaleSampling.h"<br/>
<br/>
#define EXTREME_TEST<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingBestOfNconspicific::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int bestOfHowMuch = parameters.bestOfHowMuch;<br/>
&nbsp;&nbsp;//Create the male indices<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndices = createIndicesUnique(bestOfHowMuch, males.size());<br/>
&nbsp;&nbsp;const std::vector&lt;unsigned int&gt; maleIndicesCopy = maleIndices;<br/>
<br/>
&nbsp;&nbsp;//Remove the males that are either heterospecific or assessed wrong<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;maleIndices.size(); ) //No ++i indeed<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt; female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (female.species == piedFlycatcher) //Female is of species A (piedFlyCatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].species == collaredFlycatcher) //Male is of species B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndices.erase(&amp;maleIndices[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //Male is of species A (piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++i; } //The male is a conspicific and remains in the vecor<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //Female is of species B (collaredFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].species == collaredFlycatcher) //Male is of species B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++i; }//The male is a conspicific and remains in the vecor<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //Male is of species A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndices.erase(&amp;maleIndices[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//maleIndices.erase(&amp;maleIndices.at(i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i; //The wrongly assessed male remains<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Dot("Remaining male Indices"); Dot(maleIndices);<br/>
<br/>
&nbsp;&nbsp;//With the remaining candidats, she mates at random<br/>
&nbsp;&nbsp;if (maleIndices.size()&gt;0) //She found a suitable candidat<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int candidatIndex = std::rand()%maleIndices.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return maleIndicesCopy[ std::rand()%maleIndicesCopy.size() ];<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingBestOfNextremeTrait::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int bestOfHowMuch = ( parameters.bestOfHowMuch &lt; males.size() ? parameters.bestOfHowMuch : males.size());<br/>
&nbsp;&nbsp;//Create the male indices<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndices = createIndicesUnique(bestOfHowMuch, males.size());<br/>
<br/>
&nbsp;&nbsp;//Dot("Male Indices"); Dot(maleIndices);<br/>
<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;{ //Get the best male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (female.preference &lt; 0.0) //Find male with lowest trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int candidatIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bestTrait = males[ maleIndices[0] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=1; i&lt;bestOfHowMuch; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].trait &lt; bestTrait)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestTrait = males[ maleIndices[i] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidatIndex = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //Find male with highest trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int candidatIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bestTrait = males[ maleIndices[0] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=1; i&lt;bestOfHowMuch; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (males[ maleIndices[i] ].trait &gt; bestTrait)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestTrait = males[ maleIndices[i] ].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidatIndex = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Female mates at random<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int candidatIndex = std::rand()%bestOfHowMuch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingBestOfNclosestTrait::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int bestOfHowMuch = ( parameters.bestOfHowMuch &lt; males.size() ? parameters.bestOfHowMuch : males.size());<br/>
&nbsp;&nbsp;//Create the male indices<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndices = createIndicesUnique(bestOfHowMuch, males.size());<br/>
<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;{ //Get the best male<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int candidatIndex = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double closestTrait = std::fabs(males[ maleIndices[0] ].trait - female.preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=1; i&lt;bestOfHowMuch; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::fabs(males[ maleIndices[i] ].trait - female.preference) &lt; closestTrait)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closestTrait = std::fabs(males[ maleIndices[0] ].trait - female.preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidatIndex = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Female mates at random<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int candidatIndex = std::rand()%bestOfHowMuch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int winnerIndex = maleIndices[candidatIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return winnerIndex;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingFixedThresholdConspicific::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;const enumSpecies femaleSpecies = female.species;<br/>
&nbsp;&nbsp;for(unsigned int i = 0; i &lt; nMales*2; ++i) //The female searches all males 2x<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int maleIndex = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const enumSpecies maleSpecies = males[maleIndex].species;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt;= female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him when either having a trait smaller of bigger then 0.5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (femaleSpecies == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleSpecies == piedFlycatcher) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male of species B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleSpecies == collaredFlycatcher) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(female.assessingError&gt;0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//She has not found a mate<br/>
&nbsp;&nbsp;//Dot("Female #" + IntToStr(female.index) + " has not found a mate");<br/>
&nbsp;&nbsp;return nMales;<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingFixedThresholdTraitSign::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;const double femalePreference = female.preference;<br/>
&nbsp;&nbsp;for(unsigned int i = 0; i &lt; nMales*2; ++i) //The female searches all males 2x<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int maleIndex = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double maleTrait = males[maleIndex].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt;= female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him when either having a trait smaller of bigger then 0.5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (femalePreference&lt;=0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male with low trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleTrait &lt;= 0.0) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //She fancies a male with high trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleTrait &gt;= 0.0) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(female.assessingError&gt;0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//She has not found a mate<br/>
&nbsp;&nbsp;return nMales;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int StateFemaleSamplingFixedThresholdProbabilistic::getWinnerIndex(<br/>
&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Female&amp; female,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters) const<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;const double sigmaSquared = parameters.sigmaSquared;<br/>
&nbsp;&nbsp;const double femalePreference = female.preference;<br/>
&nbsp;&nbsp;for(unsigned int i = 0; i &lt; nMales*2; ++i) //The female searches all males 2x<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int maleIndex = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double maleTrait = males[maleIndex].trait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt;= female.assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him when either having a trait smaller of bigger then 0.5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//const double chanceToMate = std::exp(-(maleTrait-femalePreference)*(maleTrait-femalePreference)/sigmaSquared);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double chanceToMate = getChanceToMate(femalePreference,maleTrait,sigmaSquared);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &lt; chanceToMate) return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(female.assessingError&gt;0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return maleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//She has not found a mate<br/>
&nbsp;&nbsp;return nMales;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double StateFemaleSamplingFixedThresholdProbabilistic::getChanceToMate(<br/>
&nbsp;&nbsp;const double&amp; femalePreference,<br/>
&nbsp;&nbsp;const double&amp; maleTrait,<br/>
&nbsp;&nbsp;const double&amp; sigmaSquared)<br/>
{<br/>
&nbsp;&nbsp; return std::exp(-(maleTrait-femalePreference)*(maleTrait-femalePreference)/sigmaSquared);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
//<br/>
// HELPER FUNCTIONS<br/>
//<br/>
//---------------------------------------------------------------------------<br/>
/*<br/>
unsigned int getBestMaleIndex(const std::vector&lt;double&gt;&amp; maleTraits, const double&amp; femalePreference, const double&amp; assessingError)<br/>
//unsigned int getBestMaleIndex(<br/>
//&nbsp;&nbsp;const std::vector&lt;double&gt;&amp; maleTraits,<br/>
//&nbsp;&nbsp;const double&amp; femalePreference,<br/>
//&nbsp;&nbsp;const double&amp; assessingError)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;unsigned int&gt; bestMaleIndices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nCandidats = maleTraits.size();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nCandidats; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rnd::uniform() &gt; assessingError) //The female does NOT make an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses her preference<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( maleTraits[i] == femalePreference) bestMaleIndices.push_back(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else //The female makes an error<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //The female chooses him whatever species he is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestMaleIndices.push_back(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Select from the indices of best males the winner<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nCompetitors = bestMaleIndices.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (nCompetitors==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Only losers, female chooses at random from all candidats<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int bestMaleIndex = std::rand()%nCandidats;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(bestMaleIndex&lt;nCandidats);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bestMaleIndex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//There are winner males, as nCompetitors &gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int luckyCompetitorIndex = std::rand()%nCompetitors;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int bestMaleIndex = bestMaleIndices[luckyCompetitorIndex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bestMaleIndex&lt;nCandidats);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return bestMaleIndex;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//This function produces a vector of traits, in this case the select males' trait/ornaments<br/>
std::vector&lt;double&gt; createTraitsVector(const std::vector&lt;Male&gt;&amp; males, const std::vector&lt;unsigned int&gt;&amp; maleIndex)<br/>
//std::vector&lt;double&gt; createTraitsVector(<br/>
//&nbsp;&nbsp;const std::vector&lt;Male&gt;&amp; males,<br/>
//&nbsp;&nbsp;const std::vector&lt;unsigned int&gt;&amp; maleIndex)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nMales = maleIndex.size();<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; maleTraits(nMales);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nMales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int indexMale = maleIndex[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleTraits[i] = males[indexMale].trait;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return maleTraits;<br/>
}<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
//Creates a vector of size 'bestOfHowMuch' with indices from 0 to 'nMales'<br/>
//An index might occur twice: if every index should be unique use 'createMaleIndices' instead.<br/>
std::vector&lt;unsigned int&gt; createIndices(<br/>
&nbsp;&nbsp;const unsigned int&amp; bestOfHowMuch,<br/>
&nbsp;&nbsp;const unsigned int&amp; nMales)<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndex(nMales);<br/>
&nbsp;&nbsp;for(unsigned int mate = 0; mate &lt; bestOfHowMuch; ++mate)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex[mate] = std::rand()%nMales;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//No checking if a male is already chosen twice<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//if you want to do so, use 'createMaleIndicesUnique' instead of this function<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return maleIndex;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Creates a vector of size 'bestOfHowMuch' from 0 to 'nMales'<br/>
//Every index is unique: if this is not important use 'createMaleIndices' instead<br/>
std::vector&lt;unsigned int&gt; createIndicesUnique(<br/>
&nbsp;&nbsp;const unsigned int&amp; bestOfHowMuch,<br/>
&nbsp;&nbsp;const unsigned int&amp; nMales)<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; maleIndex;<br/>
<br/>
&nbsp;&nbsp;if (bestOfHowMuch&lt;nMales)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex.resize(bestOfHowMuch);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bestOfHowMuch&lt;=nMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex[0] = std::rand()%nMales; //0th element is always unique<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned int mate = 1; mate &lt; bestOfHowMuch; ++mate)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int index = 1000000; //1M<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = std::rand()%nMales; //Do draw a random index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while( std::find(maleIndex.begin(),maleIndex.begin()+mate,index) != maleIndex.begin()+mate); //While not unqiue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maleIndex[mate] = index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{ //To few males (nMales &lt; bestOfHowMuch)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleIndex.resize(nMales);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int male = 0; male&lt; nMales; ++male) maleIndex[male] = male;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return maleIndex;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitFemaleSampling.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitFemaleSampling.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitFemaleSamplingH<br/>
#define UnitFemaleSamplingH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include "UnitBird.h"<br/>
#include "UnitParameters.h"<br/>
#include "UnitRandom.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBase() {}<br/>
&nbsp;&nbsp;virtual unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const = 0;<br/>
&nbsp;&nbsp;virtual std::string getFemaleSampling() const = 0;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBestOfNconspicific : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBestOfNconspicific() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Best of N conspicific"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBestOfNextremeTrait : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBestOfNextremeTrait() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Best of N extreme trait"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingBestOfNclosestTrait : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingBestOfNclosestTrait() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Best of N closest trait"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingFixedThresholdConspicific : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingFixedThresholdConspicific() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Fixed threshold conspicific"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingFixedThresholdTraitSign : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingFixedThresholdTraitSign() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Fixed threshold trait sign"; }<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateFemaleSamplingFixedThresholdProbabilistic : public StateFemaleSamplingBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateFemaleSamplingFixedThresholdProbabilistic() {}<br/>
&nbsp;&nbsp;unsigned int getWinnerIndex(const std::vector&lt;Male&gt;&amp; males, const Female&amp; female, const Parameters&amp; parameters) const;<br/>
&nbsp;&nbsp;std::string getFemaleSampling() const { return "Fixed threshold probabilistic"; }<br/>
&nbsp;&nbsp;static inline double getChanceToMate(const double&amp; femalePreference, const double&amp; maleTrait, const double&amp; sigmaSquared);<br/>
<br/>
<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
std::vector&lt;unsigned int&gt; createIndices(const unsigned int&amp; bestOfHowMuch, const unsigned int&amp; nMales);<br/>
std::vector&lt;unsigned int&gt; createIndicesUnique(const unsigned int&amp; bestOfHowMuch, const unsigned int&amp; nMales);<br/>
//std::vector&lt;double&gt; createSpeciesVector(const std::vector&lt;Male&gt;&amp; males, const std::vector&lt;unsigned int&gt;&amp; maleIndex);<br/>
//std::vector&lt;double&gt; createTraitsVector(const std::vector&lt;Male&gt;&amp; males, const std::vector&lt;unsigned int&gt;&amp; maleIndex);<br/>
//unsigned int getBestMaleIndex(const std::vector&lt;double&gt;&amp; maleTraits, const double&amp; femalePreference, const double&amp; assessingError);<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitHelperFunctions.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitHelperFunctions.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
#include "UnitHelperFunctions.h"<br/>
<br/>
//#define EXTENSIVE_LOG<br/>
//---------------------------------------------------------------------------<br/>
bool fileExists(const std::string&amp; fileName)<br/>
{<br/>
&nbsp;&nbsp;std::fstream fin;<br/>
&nbsp;&nbsp;fin.open(fileName.c_str(),std::ios::in);<br/>
&nbsp;&nbsp;if( fin.is_open() )<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fin.close();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fin.close();<br/>
&nbsp;&nbsp;return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
 unsigned int totalSum(const std::vector&lt;unsigned int&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;unsigned int sum=0;<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sum+=myVector[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return(sum);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
template&lt;class T&gt; T totalSum(const std::vector&lt;T&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;T sum=0;<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sum+=myVector[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return(sum);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int getIndexLowestValue(const std::vector&lt;double&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;unsigned int indexLowest = 0;<br/>
&nbsp;&nbsp;double lowestValue = myVector[0];<br/>
&nbsp;&nbsp;for (unsigned int i=1; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double value = myVector[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (value &lt; lowestValue)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowestValue = value;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexLowest = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return indexLowest;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int getIndexHighestValue(const std::vector&lt;double&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;unsigned int indexHighest = 0;<br/>
&nbsp;&nbsp;double highestValue = myVector[0];<br/>
&nbsp;&nbsp;for (unsigned int i=1; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double value = myVector[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (value &gt; highestValue)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highestValue = value;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexHighest = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return indexHighest;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string doubleToBitString(const double&amp; anyDouble)<br/>
{<br/>
&nbsp;&nbsp;static union MyUnion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int myInts[2];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double myDouble;<br/>
&nbsp;&nbsp;} myUnion;<br/>
&nbsp;&nbsp;myUnion.myDouble = anyDouble;<br/>
<br/>
&nbsp;&nbsp;unsigned int myInt0 = myUnion.myInts[0];<br/>
&nbsp;&nbsp;unsigned int myInt1 = myUnion.myInts[1];<br/>
&nbsp;&nbsp;std::string myBitString;<br/>
&nbsp;&nbsp;for (unsigned int i = 0; i&lt;32; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myInt0%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "0" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "1" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myInt0&gt;&gt;=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (unsigned int i = 0; i&lt;32; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myInt1%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "0" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myBitString = "1" + myBitString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myInt1&gt;&gt;=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return myBitString;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
template &lt;class T&gt;<br/>
void meanAndStdDev(const std::vector&lt;T&gt;&amp; myVector, double&amp; mean, double&amp; stdDev)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;assert(size&gt;1);<br/>
&nbsp;&nbsp;const double dSize = static_cast&lt;double&gt;(size);<br/>
&nbsp;&nbsp;mean = 0;<br/>
&nbsp;&nbsp;double sumX = 0;<br/>
&nbsp;&nbsp;double sumXsquared = 0;<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const T value = myVector[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sumX+=value;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sumXsquared+=(value*value);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mean+=value;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;mean/=dSize;<br/>
&nbsp;&nbsp;stdDev = std::sqrt(((dSize*sumXsquared)-(sumX*sumX))/(dSize *(dSize-1.0)));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string ftoa(const double&amp; x)<br/>
{<br/>
&nbsp;&nbsp;std::ostringstream o;<br/>
&nbsp;&nbsp;if (!(o &lt;&lt; x)) return "ERROR";<br/>
&nbsp;&nbsp;return o.str();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string itoa(const int&amp; x)<br/>
{<br/>
&nbsp;&nbsp;std::ostringstream o;<br/>
&nbsp;&nbsp;if (!(o &lt;&lt; x)) return "ERROR";<br/>
&nbsp;&nbsp;return o.str();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::string&amp; message)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef USE_STL_ONLY<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(message.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "ODS: " &lt;&lt; message &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::vector&lt;double&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;std::string output = "index: ";<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;output+=ftoa(myVector[i])+" ";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot(output);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::vector&lt;int&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;std::string output = "index: ";<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;output+=itoa(myVector[i])+" ";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot(output);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Dot(const std::vector&lt;unsigned int&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;std::string output = "index: ";<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;output+=itoa(myVector[i])+" ";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot(output);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitHelperFunctions.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitHelperFunctions.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitHelperFunctionsH<br/>
#define UnitHelperFunctionsH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;sstream&gt;<br/>
#include &lt;assert.h&gt;<br/>
#include &lt;fstream&gt;<br/>
<br/>
#ifndef USE_STL_ONLY<br/>
&nbsp;&nbsp;#include &lt;System.hpp&gt;<br/>
#endif<br/>
<br/>
unsigned int totalSum(const std::vector&lt;unsigned int&gt;&amp; myVector);<br/>
template&lt;class T&gt; T totalSum(const std::vector&lt;T&gt;&amp; myVector);<br/>
unsigned int getIndexLowestValue(const std::vector&lt;double&gt;&amp; myVector);<br/>
unsigned int getIndexHighestValue(const std::vector&lt;double&gt;&amp; myVector);<br/>
template &lt;class T&gt; void meanAndStdDev(const std::vector&lt;T&gt;&amp; myVector, double&amp; mean, double&amp; stdDev);<br/>
<br/>
<br/>
std::string itoa(const int&amp; x);<br/>
std::string ftoa(const double&amp; x);<br/>
bool fileExists(const std::string&amp; fileName);<br/>
std::string doubleToBitString(const double&amp; anyDouble);<br/>
<br/>
void Dot(const std::string&amp; message);<br/>
void Dot(const std::vector&lt;unsigned int&gt;&amp; myVector);<br/>
void Dot(const std::vector&lt;int&gt;&amp; myVector);<br/>
void Dot(const std::vector&lt;double&gt;&amp; myVector);<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitMain.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitMain.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitMain.h"<br/>
#include "UnitAboutBox2.h"<br/>
#include "UnitThreeDotsChasing.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormMain *FormMain;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormMain::TFormMain(TComponent* Owner)<br/>
&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString("NDEBUG defined. No output anymore");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;Caption = this-&gt;Caption + " NoDebug";<br/>
&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString("NDEBUG not defined.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;Caption = this-&gt;Caption + " Debug";<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][0] = "";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][0] = "Female" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][0] = "Male #1";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][0] = "Male #2";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][0] = "Male #3";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][0] = "Male #4";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][1] = "SpeciesValue";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][1] = "-1.0" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][1] = "-1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][1] = "-0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][1] = "0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][1] = "1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][2] = "Trait/Preference";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][2] = "1.0" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][2] = "-1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][2] = "-0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][2] = "0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][2] = "1.0";<br/>
<br/>
&nbsp;&nbsp;//Fill in StringGridParameters<br/>
&nbsp;&nbsp;StringGridParameters-&gt;RowCount = 23;<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 0] = "Parameter";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 0] = "Value";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 1] = "Number of females";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 1] = "1000";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 2] = "Number of males";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 2] = "1000";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 3] = "Best-of-how-much";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 3] = "5";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 4] = "Assessing error A";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 4] = "0.001";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 5] = "Assessing error B";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 5] = "0.001";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 6] = "Mean trait A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 6] = "-1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 7] = "StdDev trait A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 7] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 8] = "Mean trait B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 8] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 9] = "StdDev trait B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 9] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][10] = "Mean preference A";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][10] = "-1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][11] = "StdDev preference A";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][11] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][12] = "Mean preference B";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][12] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][13] = "StdDev preference B";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][13] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][14] = "Number of simulations"; StringGridParameters-&gt;Cells[1][14] = "1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][15] = "Number of generations"; StringGridParameters-&gt;Cells[1][15] = "1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][16] = "Number of offspring";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][16] = "6";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][17] = "SurviveSpeciesAlpha";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][17] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][18] = "SurviveSpeciesBeta";&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][18] = "10.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][19] = "SigmaSquared";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][19] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][20] = "Cost trait";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][20] = "0.1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][21] = "Cost preference";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][21] = "0.01";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][22] = "Mutation rate";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][22] = "0.01";<br/>
<br/>
&nbsp;&nbsp;PageControlSimChange(0);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonRunClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//Check the input in own scope<br/>
&nbsp;&nbsp;if (checkInput()==false) return;<br/>
<br/>
&nbsp;&nbsp;StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text = "Running simulation";<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcherSleeping.cur");<br/>
&nbsp;&nbsp;Refresh(); //To draw this text to the StatusBar<br/>
<br/>
&nbsp;&nbsp;emptyChart(ChartBias);<br/>
&nbsp;&nbsp;emptyChart(ChartMateFraction);<br/>
<br/>
&nbsp;&nbsp;//Read parameters<br/>
&nbsp;&nbsp;Parameters parameters = readStringGrid();<br/>
&nbsp;&nbsp;parameters.matingSystem&nbsp;&nbsp; = (RadioGroupGamy-&gt;ItemIndex&nbsp;&nbsp;== 0 ? monogamy : polygyny);<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: parameters.femaleSampling = bestOfNconspicific;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: parameters.femaleSampling = bestOfNextremeTrait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: parameters.femaleSampling = bestOfNclosestTrait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: parameters.femaleSampling = fixedThresholdConspicific;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: parameters.femaleSampling = fixedThresholdTraitSign;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: parameters.femaleSampling = fixedThresholdProbabilistic; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown index of RadioGroupTestSampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;parameters.densityDependentSelection = (RadioGroupDensityDependentSelection-&gt;ItemIndex == 0 ? afterMating : beforeMating );<br/>
<br/>
&nbsp;&nbsp;//Show parameters<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Clear();<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of males: " + IntToStr(parameters.nMales));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of males: " + IntToStr(parameters.nMales));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of females: " + IntToStr(parameters.nFemales));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Best of how much: " + IntToStr(parameters.bestOfHowMuch));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Assessing error A: " + FloatToStr(parameters.assessingErrorA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Assessing error B: " + FloatToStr(parameters.assessingErrorB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean trait A: " + FloatToStr(parameters.meanTraitA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev trait A: " + FloatToStr(parameters.stdDevTraitA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean trait males B: " + FloatToStr(parameters.meanTraitB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev trait males B: " + FloatToStr(parameters.stdDevTraitB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean preference A: " + FloatToStr(parameters.meanPreferenceA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev preference A: " + FloatToStr(parameters.stdDevPreferenceA));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mean preference males B: " + FloatToStr(parameters.meanPreferenceB));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("StdDev preference males B: " + FloatToStr(parameters.stdDevPreferenceB));<br/>
<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of simulation: " + IntToStr(parameters.nSimulations));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of generations: " + IntToStr(parameters.nGenerations));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Number of offspring per couple: " + IntToStr(parameters.nOffspring));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("SurviveSpeciesAlpha: " + FloatToStr(parameters.surviveSpeciesAlpha));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("SurviveSpeciesBeta: " + FloatToStr(parameters.surviveSpeciesBeta));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("SigmaSquared: " + FloatToStr(parameters.sigmaSquared));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Cost trait: " + FloatToStr(parameters.costTrait));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Cost preference: " + FloatToStr(parameters.costPreference));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Mutation rate: " + FloatToStr(parameters.mutationRate));<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add(parameters.matingSystem&nbsp;&nbsp;== monogamy ? "Mating system: monogamy" : "Mating system: polygyny" );<br/>
&nbsp;&nbsp;switch(parameters.femaleSampling)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Best-Of-N conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Best-Of-N extreme trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Best-Of-N closest trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Fixed threshold conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Fixed threshold trait sign");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add("Female sampling: Fixed threshold probabilistic");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines-&gt;Add(parameters.densityDependentSelection==beforeMating ? "Density dependent selection: before mating" : "Density dependent selection: after mating");<br/>
<br/>
&nbsp;&nbsp;//Start simulation<br/>
&nbsp;&nbsp;const double deltaFraction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionStep-&gt;Text.ToDouble() : 1.0);<br/>
&nbsp;&nbsp;const double fractionFrom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionFrom-&gt;Text.ToDouble() : EditFraction-&gt;Text.ToDouble());<br/>
&nbsp;&nbsp;const double fractionTo<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionTo-&gt;Text.ToDouble() : 1.0);<br/>
<br/>
&nbsp;&nbsp;std::string lastErrorMessage;<br/>
&nbsp;&nbsp;for (double fraction = fractionFrom; fraction &lt; fractionTo; fraction+=deltaFraction)<br/>
&nbsp;&nbsp;//double fraction = 0.9;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ProgressBarSim-&gt;Position = fraction * ProgressBarSim-&gt;Max;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ProgressBarSim-&gt;Refresh();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartBiasTime);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartMateTime);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartPopSize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;emptyChart(ChartTraitPreference);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.fractionMaleA&nbsp;&nbsp; = fraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.fractionFemaleA = fraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//parameters.nGenerations = 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimulations = parameters.nSimulations;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;TimeSeries&gt; allTimeSeries; //Size 0, use push_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int simulation = 0; simulation &lt; nSimulations; ++simulation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stick parameter in simulation and run it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;Simulation&gt; simulation(new Simulation(parameters));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//simulation-&gt;showPopulation(StringGridDebug);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simulation-&gt;execute();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Get the results from the sim<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//const TimeSeries thisSimTimeSeries = simulation-&gt;getTimeSeries();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//timeSeries.push_back(thisSimTimeSeries);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allTimeSeries.push_back(simulation-&gt;getTimeSeries());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastErrorMessage = simulation-&gt;mError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Plot the average of the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TimePoint timePointMean, timePointStdError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;getMeanAndStdErrorEndPoint(allTimeSeries,timePointMean,timePointStdError);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TimeSeries timeSeriesMean, timeSeriesStdError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;getMeanAndStdErrorTimeSeries(allTimeSeries,timeSeriesMean, timeSeriesStdError);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plotTimePoint(timePointMean, timePointStdError,fraction);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plotTimeSeries(timeSeriesMean, timeSeriesStdError);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text = toAnsiString(lastErrorMessage);<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==0) PlaySound("PiedFlycatcher.wav",0,SND_FILENAME | SND_ASYNC);<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
//Checks the input, returns true if all valid<br/>
bool TFormMain::checkInput()<br/>
{<br/>
&nbsp;&nbsp;int checkInt; bool check; double checkDouble;<br/>
&nbsp;&nbsp;//nFemales<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][1],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nFemales' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nFemales' should be positive"; return false; }<br/>
&nbsp;&nbsp;//nMales<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][2],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nMales' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nMales' should be positive"; return false; }<br/>
&nbsp;&nbsp;//bestOfHowMuch<br/>
&nbsp;&nbsp;if (&nbsp;&nbsp; RadioGroupFemaleSampling-&gt;ItemIndex == 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| RadioGroupFemaleSampling-&gt;ItemIndex == 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| RadioGroupFemaleSampling-&gt;ItemIndex == 2 ) //If female uses bestOfHowMuch<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][3],checkInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'bestOfHowMuch' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'bestOfHowMuch' should be bigger then 0"; return false; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//assessingErrorA<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][4],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorA' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorA' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorA' should be smaller or equal to 1.0"; return false; }<br/>
&nbsp;&nbsp;//assessingErrorB<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][5],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorB' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorB' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingErrorB' should be smaller or equal to 1.0"; return false; }<br/>
&nbsp;&nbsp;//Mean trait males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][6],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean trait males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev trait males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][7],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev trait males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean trait males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][8],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean trait males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev trait males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][9],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev trait males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean preference males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][10],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean preference males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev preference males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][11],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev preference males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean preference males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][12],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean preference males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev preference males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][13],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev preference males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Number of simulations<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][14],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of simulations' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of simulations' should be positive"; return false; }<br/>
&nbsp;&nbsp;//Number of generations<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][15],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of generations' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of generations' should be positive"; return false; }<br/>
&nbsp;&nbsp;//Number of offspring<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][16],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of offspring' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Number of offspring' should be positive"; return false; }<br/>
&nbsp;&nbsp;//SurviveSpeciesAlpha<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][17],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesAlpha' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesAlpha' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesAlpha' should be smaller or equal to 1.0"; return false; }<br/>
&nbsp;&nbsp;//SurviveSpeciesBeta<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][18],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesBeta' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SurviveSpeciesBeta' should be positive"; return false; }<br/>
&nbsp;&nbsp;//SigmaSquared<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][19],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SigmaSquared' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt;= 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'SigmaSquared' should be positive"; return false; }<br/>
&nbsp;&nbsp;//CostTrait<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][20],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostTrait' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostTrait' should be positive"; return false; }<br/>
&nbsp;&nbsp;//CostPreference<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][21],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostPreference' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'CostPreference' should be positive"; return false; }<br/>
&nbsp;&nbsp;//MutationRate<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][22],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'MutationRate' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'MutationRate' should be positive"; return false; }<br/>
<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::plotTimePoint(<br/>
&nbsp;&nbsp;const TimePoint&amp; mean,<br/>
&nbsp;&nbsp;const TimePoint&amp; stdError,<br/>
&nbsp;&nbsp;const double&amp; chartX)<br/>
{<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[0]-&gt;AddXY(chartX,mean.mateTally.calculateBiasA());<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[1]-&gt;AddXY(chartX,mean.mateTally.calculateBiasB());<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[2]-&gt;AddXY(chartX,mean.mateTally.calculateFractionMixedPairs());<br/>
<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[0]-&gt;AddXY(chartX,mean.mateTally.getNmateAA());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[1]-&gt;AddXY(chartX,mean.mateTally.getNmateAB());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[2]-&gt;AddXY(chartX,mean.mateTally.getNmateBA());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[3]-&gt;AddXY(chartX,mean.mateTally.getNmateBB());<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::plotTimeSeries(<br/>
&nbsp;&nbsp;const TimeSeries&amp; mean,<br/>
&nbsp;&nbsp;const TimeSeries&amp; stdError)<br/>
{<br/>
&nbsp;&nbsp;emptyChart(ChartPopSize);<br/>
&nbsp;&nbsp;emptyChart(ChartMateTime);<br/>
&nbsp;&nbsp;const unsigned int nGenerations = mean.timePoints.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nGenerations; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double iD = static_cast&lt;double&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[5]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[6]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.00,mean.timePoints[i].speciesTallyOffspring.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[5]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[6]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.20,mean.timePoints[i].speciesTallyAfterSpeciesSelection.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[5]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmaleHybridsA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[6]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmaleHybridsB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.40,mean.timePoints[i].speciesTallyAfterTraitSelection.getNall());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[1]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[2]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.60,mean.timePoints[i].speciesTallyAfterDensityDependentSelection.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[0]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateAA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[1]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateAB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[2]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateBA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[3]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateBB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[4]-&gt;AddXY(iD,mean.timePoints[i].mateTally.getNmateAll());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartBiasTime-&gt;Series[0]-&gt;AddXY(iD,mean.timePoints[i].mateTally.calculateBiasA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartBiasTime-&gt;Series[1]-&gt;AddXY(iD,mean.timePoints[i].mateTally.calculateBiasB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartBiasTime-&gt;Series[2]-&gt;AddXY(iD,mean.timePoints[i].mateTally.calculateFractionMixedPairs());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTraits = mean.timePoints[i].traits.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nTraits; ++j) ChartTraitPreference-&gt;Series[0]-&gt;AddXY(iD,mean.timePoints[i].traits[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nPreferences = mean.timePoints[i].preferences.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nPreferences; ++j) ChartTraitPreference-&gt;Series[1]-&gt;AddXY(iD,mean.timePoints[i].preferences[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSpeciesValues = mean.timePoints[i].descents.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nSpeciesValues; ++j) ChartTraitPreference-&gt;Series[2]-&gt;AddXY(iD,mean.timePoints[i].descents[j]);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::setCursor(const String&amp; cursorName)<br/>
{<br/>
&nbsp;&nbsp;TCursor myCursor = static_cast&lt;TCursor&gt;(22);<br/>
&nbsp;&nbsp;Screen-&gt;Cursors[22] = LoadCursorFromFile(cursorName.c_str());<br/>
&nbsp;&nbsp;Cursor = myCursor;<br/>
&nbsp;&nbsp;FormMain-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;PageControlMain-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;PanelLeft-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ChartBias-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ChartPopSize-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ChartMateTime-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ButtonRun-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;ProgressBarSim-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RadioGroupGamy-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Cursor = myCursor;<br/>
&nbsp;&nbsp;RichEdit2-&gt;Cursor = myCursor;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Parameters TFormMain::readStringGrid() const<br/>
{<br/>
&nbsp;&nbsp;Parameters parameters;<br/>
&nbsp;&nbsp;parameters.nFemales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 1].ToInt();<br/>
&nbsp;&nbsp;parameters.nMales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 2].ToInt();<br/>
&nbsp;&nbsp;parameters.bestOfHowMuch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 3].ToInt();<br/>
&nbsp;&nbsp;parameters.assessingErrorA&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 4].ToDouble();<br/>
&nbsp;&nbsp;parameters.assessingErrorB&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 5].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanTraitA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 6].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevTraitA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 7].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanTraitB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 8].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevTraitB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 9].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanPreferenceA&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][10].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevPreferenceA&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][11].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanPreferenceB&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][12].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevPreferenceB&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][13].ToDouble();<br/>
&nbsp;&nbsp;parameters.nSimulations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][14].ToInt();<br/>
&nbsp;&nbsp;parameters.nGenerations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][15].ToInt();<br/>
&nbsp;&nbsp;parameters.nOffspring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][16].ToInt();<br/>
&nbsp;&nbsp;parameters.surviveSpeciesAlpha = StringGridParameters-&gt;Cells[1][17].ToDouble();<br/>
&nbsp;&nbsp;parameters.surviveSpeciesBeta&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][18].ToDouble();<br/>
&nbsp;&nbsp;parameters.sigmaSquared&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][19].ToDouble();<br/>
&nbsp;&nbsp;parameters.costTrait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][20].ToDouble();<br/>
&nbsp;&nbsp;parameters.costPreference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][21].ToDouble();<br/>
&nbsp;&nbsp;parameters.mutationRate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][22].ToDouble();<br/>
&nbsp;&nbsp;return parameters;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonTestClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateFemaleSamplingBase&gt; femaleSampling;<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: femaleSampling.reset(new StateFemaleSamplingBestOfNconspicific); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: femaleSampling.reset(new StateFemaleSamplingBestOfNextremeTrait); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: femaleSampling.reset(new StateFemaleSamplingBestOfNclosestTrait); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: femaleSampling.reset(new StateFemaleSamplingFixedThresholdConspicific); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: femaleSampling.reset(new StateFemaleSamplingFixedThresholdTraitSign); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: femaleSampling.reset(new StateFemaleSamplingFixedThresholdProbabilistic); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown index of RadioGroupTestSampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Parameters parameters = readStringGrid();<br/>
&nbsp;&nbsp;const double femaleSpeciesValue = StringGridTest-&gt;Cells[1][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue1&nbsp;&nbsp;= StringGridTest-&gt;Cells[2][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue2&nbsp;&nbsp;= StringGridTest-&gt;Cells[3][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue3&nbsp;&nbsp;= StringGridTest-&gt;Cells[4][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue4&nbsp;&nbsp;= StringGridTest-&gt;Cells[5][1].ToDouble();<br/>
&nbsp;&nbsp;const double femalePreference&nbsp;&nbsp; = StringGridTest-&gt;Cells[1][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[2][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[3][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[4][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[5][2].ToDouble();<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females = Bird::createTestFemales(parameters,femaleSpeciesValue, femalePreference);<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males = Bird::createTestMales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue1, maleTrait1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue2, maleTrait2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue3, maleTrait3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue4, maleTrait4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; histogramWinner(4);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;4; ++i) histogramWinner[i]=0;<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;1000; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males,females[0],parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++(histogramWinner[winnerIndex]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;emptyChart(ChartTest);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(0.0,histogramWinner[0]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(1.0,histogramWinner[1]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(2.0,histogramWinner[2]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(3.0,histogramWinner[3]);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonTestSurvivalSpeciesClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double alpha = StringGridParameters-&gt;Cells[1][17].ToDouble();<br/>
&nbsp;&nbsp;const double beta&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][18].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double y = 1.0 - (alpha * std::exp(-beta * descent * descent))");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("SurviveSpeciesAlpha: " + FloatToStr(alpha) + ", SurviveSpeciesBeta: " + FloatToStr(beta));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "SpeciesValue/descent";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance of survival";<br/>
&nbsp;&nbsp;for (double descent = -1.0; descent&lt;1.0; descent+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double surviveSpecies = Simulation::chanceToSurviveSpecies(descent,alpha,beta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(descent,surviveSpecies);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::FormMouseMove(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TShiftState Shift, int X, int Y)<br/>
{<br/>
&nbsp;&nbsp;TCursor myCursor = static_cast&lt;TCursor&gt;(22);<br/>
&nbsp;&nbsp;Screen-&gt;Cursors[22] = LoadCursorFromFile("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;Cursor = myCursor;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonSaveClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Parameters: ");<br/>
<br/>
&nbsp;&nbsp;if (PageControlSim-&gt;ActivePageIndex==0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("FractionA : " + EditFraction-&gt;Text);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Fration A from: " + EditFractionFrom-&gt;Text<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " to: " + EditFractionTo-&gt;Text<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ " in steps of: " + EditFractionStep-&gt;Text);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getStringGrid(StringGridParameters).release());<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupGamy-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //monogamous<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Mating system: monogamous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //polygynous<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Mating system: polygynous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Best-Of-N conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Best-Of-N extreme trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: //bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Best-Of-N closest trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: //fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Fixed threshold conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: //fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Fixed threshold trait sign");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: //fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Female sampling: Fixed threshold probabilistic");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupDensityDependentSelection-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Density dependent selection: in reproduction, after mating");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add("Density dependent selection: after selection, before mating");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Biases in time: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,BiasA,BiasB,Fraction of mixed pairs");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartBiasTime).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Trait and preferences in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Traits in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,Traits");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChartSeries(ChartTraitPreference-&gt;Series[0]).release());<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Traits in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,Preference");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChartSeries(ChartTraitPreference-&gt;Series[1]).release());<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Descent in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,Descent");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChartSeries(ChartTraitPreference-&gt;Series[2]).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Number of matings in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Number of matings in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,AA,AB,BA,BB,Sum");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartMateTime).release());<br/>
<br/>
&nbsp;&nbsp;Dot("number of individuals in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Number of individuals in time");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Time,FemalesA,FemalesB,MalesA,MalesB");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartPopSize).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Biases for different fractions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Biases for different fractions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Fraction,BiasA,BiasB,Fraction of mixed pairs");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartBias).release());<br/>
<br/>
&nbsp;&nbsp;Dot("Number of matings for different proportions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add(" ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Number of matings for different proportions of maleA: ");<br/>
&nbsp;&nbsp;stringList-&gt;Add("Fraction,AA,AB,BA,BB");<br/>
&nbsp;&nbsp;stringList-&gt;AddStrings(getChart(ChartMateFraction).release());<br/>
<br/>
&nbsp;&nbsp;if (SaveDialog1-&gt;Execute()==true)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;SaveToFile(SaveDialog1-&gt;FileName);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;RichEditOutput-&gt;Lines = stringList.release();<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::BitBtn1Click(TObject *Sender)<br/>
{<br/>
/*<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcher.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcherSleeping.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*/<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
std::string toString(const String&amp; ansi)<br/>
{<br/>
&nbsp;&nbsp;const char * myChar = ansi.c_str();<br/>
&nbsp;&nbsp;const std::string myString = myChar;<br/>
&nbsp;&nbsp;return myString;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
String toAnsiString(const std::string&amp; myString)<br/>
{<br/>
&nbsp;&nbsp;const char * myChar = myString.c_str();<br/>
&nbsp;&nbsp;const String myAnsi = myChar;<br/>
&nbsp;&nbsp;return myAnsi;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void emptyChart(TChart* chart)<br/>
{<br/>
&nbsp;&nbsp;const int nSeries = chart-&gt;SeriesCount();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;chart-&gt;Series[i]-&gt;Clear();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::auto_ptr&lt;TStringList&gt; getStringGrid(const TStringGrid * stringGrid)<br/>
{<br/>
&nbsp;&nbsp;//Those Borland people were not const correct, so I need a const cast here<br/>
&nbsp;&nbsp;//Grumble, grumble...<br/>
&nbsp;&nbsp;TStringGrid * grid = const_cast&lt;TStringGrid*&gt;(stringGrid);<br/>
&nbsp;&nbsp;const String seperator = ",";<br/>
<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
&nbsp;&nbsp;const int maxy = grid-&gt;RowCount;<br/>
&nbsp;&nbsp;const int maxx = grid-&gt;ColCount;<br/>
&nbsp;&nbsp;for (int y=0; y&lt;maxy; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String myString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int x=0; x&lt;maxx-1; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString+=grid-&gt;Cells[x][y] + seperator; //This function should have been const, as it is a read function<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myString+=grid-&gt;Cells[maxx-1][y];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return stringList;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::auto_ptr&lt;TStringList&gt; getChart(const TChart * anyChart)<br/>
{<br/>
&nbsp;&nbsp;//Those Borland people were not const correct, so I need a const cast here<br/>
&nbsp;&nbsp;//Grumble, grumble...<br/>
&nbsp;&nbsp;TChart * chart = const_cast&lt;TChart*&gt;(anyChart);<br/>
&nbsp;&nbsp;const String seperator = ",";<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
<br/>
&nbsp;&nbsp;//Copy the pointers to the values<br/>
&nbsp;&nbsp;std::vector&lt; TChartValueList* &gt; xValuesVector;<br/>
&nbsp;&nbsp;std::vector&lt; TChartValueList* &gt; yValuesVector;<br/>
&nbsp;&nbsp;const int nSeries = chart-&gt;SeriesCount();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xValuesVector.push_back(chart-&gt;Series[i]-&gt;XValues);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;yValuesVector.push_back(chart-&gt;Series[i]-&gt;YValues);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Assume there are as many X's as Y's<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(xValuesVector[i]-&gt;Count()==yValuesVector[i]-&gt;Count());<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Make a nice collumn of X values and then all Y values<br/>
&nbsp;&nbsp;const int nRows = xValuesVector[0]-&gt;Count();<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(xValuesVector[i]-&gt;Count()==nRows);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(yValuesVector[i]-&gt;Count()==nRows);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const unsigned int nCols = xValuesVector.size();<br/>
&nbsp;&nbsp;assert(nCols == yValuesVector.size());<br/>
<br/>
&nbsp;&nbsp;for (int y=0; y&lt;nRows; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String myString = FloatToStr(xValuesVector[0]-&gt;operator [](y)) + seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int x=0; x&lt;nCols-1; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString+=FloatToStr(yValuesVector[x]-&gt;operator [](y)) + seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;myString+=FloatToStr(yValuesVector[nCols-1]-&gt;operator [](y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return stringList;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::auto_ptr&lt;TStringList&gt; getChartSeries(const TChartSeries * series)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;TStringList&gt; stringList(new TStringList);<br/>
&nbsp;&nbsp;const String seperator = ",";<br/>
<br/>
&nbsp;&nbsp;//Copy the pointers to the values<br/>
&nbsp;&nbsp;TChartValueList * xValues = series-&gt;XValues;<br/>
&nbsp;&nbsp;TChartValueList * yValues = series-&gt;YValues;<br/>
&nbsp;&nbsp;//Assume there are as many X's as Y's<br/>
&nbsp;&nbsp;assert(xValues-&gt;Count()==yValues-&gt;Count());<br/>
<br/>
&nbsp;&nbsp;const int nRows = xValues-&gt;Count();<br/>
&nbsp;&nbsp;double x = -1.0;<br/>
&nbsp;&nbsp;String myString;<br/>
&nbsp;&nbsp;for (int y=0; y&lt;nRows; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double thisX = xValues-&gt;operator [](y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (x!=thisX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString = FloatToStr(thisX) + seperator + FloatToStr(yValues-&gt;operator [](y)) + seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = thisX;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myString += FloatToStr(yValues-&gt;operator [](y))+seperator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;stringList-&gt;Add(myString);<br/>
&nbsp;&nbsp;return stringList;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestTraitClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double costTrait = StringGridParameters-&gt;Cells[1][20].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double survival = std::exp(-costTrait * trait * trait);");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("costTrait: " + FloatToStr(costTrait));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "Species trait";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance of survival";<br/>
&nbsp;&nbsp;for (double maleTrait = -1.0; maleTrait&lt;1.0; maleTrait+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double survivalTrait = Simulation::chanceToSurviveTrait(maleTrait,costTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(maleTrait,survivalTrait);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestPreferenceClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double costPreference = StringGridParameters-&gt;Cells[1][21].ToDouble();<br/>
<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double survival = std::exp(-costPreference * preference * preference");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("costPreference: " + FloatToStr(costPreference));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "Species preference";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance of survival";<br/>
&nbsp;&nbsp;for (double femalePreference = -1.0; femalePreference&lt;1.0; femalePreference+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double survivalPreference = Simulation::chanceToSurvivePreference(femalePreference,costPreference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(femalePreference,survivalPreference);<br/>
&nbsp;&nbsp;}<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestProbabilisticMatingClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;const double femalePreference = 0.0;<br/>
&nbsp;&nbsp;const double sigmaSquared = StringGridParameters-&gt;Cells[1][19].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double chanceToMate =std::exp(-(maleTrait-femalePreference)*(maleTrait-femalePreference)/sigmaSquared);");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("FemalePreference: 0.0 (in this example)");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("sigmaSquared: " + FloatToStr(sigmaSquared));<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;BottomAxis-&gt;Title-&gt;Caption = "Male trait";<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;LeftAxis-&gt;Title-&gt;Caption = "Chance to mate";<br/>
&nbsp;&nbsp;for (double maleTrait = -1.0; maleTrait&lt;1.0; maleTrait+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double chanceToMate =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StateFemaleSamplingFixedThresholdProbabilistic::getChanceToMate(femalePreference, maleTrait, sigmaSquared);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(maleTrait,chanceToMate);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::StringGridParametersSelectCell(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ACol, int ARow, bool &amp;CanSelect)<br/>
{<br/>
&nbsp;&nbsp;//Show help<br/>
&nbsp;&nbsp;switch (ARow)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;1: StringGridParameters-&gt;Hint = "Number of females used in every generation"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;2: StringGridParameters-&gt;Hint = "Number of males used in every generation"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;3: StringGridParameters-&gt;Hint = "Number of males the female can sample from"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;4: StringGridParameters-&gt;Hint = "Assessing error made by species A (0.0 = perfect sampling, 1.0=random mating)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;5: StringGridParameters-&gt;Hint = "Assessing error made by species B (0.0 = perfect sampling, 1.0=random mating)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;6: StringGridParameters-&gt;Hint = "Initial mean trait of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;7: StringGridParameters-&gt;Hint = "Initial StdDev of the trait of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;8: StringGridParameters-&gt;Hint = "Initial mean trait of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&nbsp;9: StringGridParameters-&gt;Hint = "Initial StdDev of the trait of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 10: StringGridParameters-&gt;Hint = "Initial mean preference of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 11: StringGridParameters-&gt;Hint = "Initial StdDev of the preference of species A"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 12: StringGridParameters-&gt;Hint = "Initial mean preference of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 13: StringGridParameters-&gt;Hint = "Initial StdDev of the preference of species B"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 14: StringGridParameters-&gt;Hint = "Number of simulations of which the results are an average of"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 15: StringGridParameters-&gt;Hint = "Number of generations"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 16: StringGridParameters-&gt;Hint = "Number of offspring produced (used when density dependent selection = before reproduction)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 17: StringGridParameters-&gt;Hint = "Chance to die of pure hybrids (0.0 = Hybrids have equal survival, 1.0 = hybrids will die by chance 100%)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 18: StringGridParameters-&gt;Hint = "Increase in fitmess from hybrids to pure species (0.0 = hybrids and pure have equal survival, 100.0 = pure species have 100% survival)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 19: StringGridParameters-&gt;Hint = "Choosiness of female (only used in probabilistic mating, 1000.0 = random mating, 0.001 = very choosy"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 20: StringGridParameters-&gt;Hint = "Cost trait in survival/trait (0.0 = trait is costless, 10.0 = trait is expensive)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 21: StringGridParameters-&gt;Hint = "Cost preference in survival/preference (0.0 = preference is costless, 10.0 = preference is expensive)"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 22: StringGridParameters-&gt;Hint = "Standard deviation of mutation rate"; break;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::ButtonTestHelpClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ShowMessage(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"These tests show the functions used."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nThe results shown are derived from the functions used in the simulation"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\n(so no code duplication, except in the Chart titles)"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nThe parameters used are from the Parameter StringGrid on the left."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nNote that for these functions, the parameters are NOT checked."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nTherefore, it is possible to give in a negative cost for trait,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nwhich will also yield a result, but when starting the simulation,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"\nthese values WILL be checked."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::RadioGroupFemaleSamplingClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //Best of N conspicific<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female chooses a conspicific from a lek of N males";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //Best of N most extreme trait<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female chooses a male with the most extreme trait from a lek of N males. If her preference is smaller then 0.0, she prefers a male with trait smaller then 0.0";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: //Best of N closest trait-preference<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female chooses a male with trait closest near her preference from a lek of N males";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: //Fixed threshold conspicific<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female searches infinitely for a conspicific";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: //Fixed threshold same trait sign<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female searches infinitely for a male with the same trait sign as her preference (i.e. a negative-preference female prefers a negative-trait male)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: //Fixed threshold probabilistic<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupFemaleSampling-&gt;Hint = "The female searches infinitely for a male with trait close to her preference. The chance she will mate with him is defined by SigmaSquared";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
void __fastcall TFormMain::RadioGroupDensityDependentSelectionClick(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;switch(RadioGroupDensityDependentSelection-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //In reproduction, nOffspring = popSize parents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupDensityDependentSelection-&gt;Hint = "In reproduction, there are offspring produced until the original fractions of speciesA and speciesB are reached for a population size of nMales + nFemales";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //After selection, nMatureOffspring = popSize parents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupDensityDependentSelection-&gt;Hint = "After selection, before mating, the population is cut down to the needed fractions of speciesA and speciesB to a population size of nMales + nFemales";<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::RadioGroupGamyClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;switch(RadioGroupGamy-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: //Monogamy<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupGamy-&gt;Hint = "After a female has selected a male, they will be a couple for life (that is, one generation)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: //Polygyny<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGroupGamy-&gt;Hint = "A male can mate with multiple females";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::PageControlSimChange(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//ShowMessage("TEST" + IntToStr(PageControlSim-&gt;ActivePageIndex));<br/>
&nbsp;&nbsp;if (PageControlSim-&gt;ActivePageIndex == 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Single fraction sim (in time)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[0]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[1]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[2]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[3]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[4]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[5]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Range of fractions sim<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[0]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[1]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[2]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[3]-&gt;TabVisible = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[4]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PageControlMain-&gt;Pages[5]-&gt;TabVisible = true;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::BitBtn1MouseDown(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TMouseButton Button, TShiftState Shift, int X, int Y)<br/>
{<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcher.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcherSleeping.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (Button == mbRight &amp;&amp;&nbsp;&nbsp;X &lt; 10 &amp;&amp; Y &lt; 10)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;TFormAboutBox2&gt; aboutBox(new TFormAboutBox2(this));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;TFormThreeDotsChasing&gt; threeDotsChasing(new TFormThreeDotsChasing(this));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//const int sumWidth = aboutBox-&gt;Width + threeDotsChasing-&gt;Width;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;aboutBox-&gt;Show();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;aboutBox-&gt;Left = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;threeDotsChasing-&gt;ShowModal();<br/>
&nbsp;&nbsp;}<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitMain.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitMain.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitMainH<br/>
#define UnitMainH<br/>
#include &lt;Chart.hpp&gt;<br/>
#include &lt;Classes.hpp&gt;<br/>
#include &lt;ComCtrls.hpp&gt;<br/>
#include &lt;Controls.hpp&gt;<br/>
#include &lt;ExtCtrls.hpp&gt;<br/>
#include &lt;Grids.hpp&gt;<br/>
#include &lt;Series.hpp&gt;<br/>
#include &lt;StdCtrls.hpp&gt;<br/>
#include &lt;TeEngine.hpp&gt;<br/>
#include &lt;TeeProcs.hpp&gt;<br/>
#include &lt;AppEvnts.hpp&gt;<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;mmsystem.h&gt;<br/>
#include &lt;Buttons.hpp&gt;<br/>
#include &lt;Dialogs.hpp&gt;<br/>
//#include &lt;Buttons.hpp&gt;<br/>
//#include &lt;utility&gt;<br/>
//#include &lt;functional&gt;<br/>
//#include &lt;iterator&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include "UnitSimulation.h"<br/>
#include "UnitTimeSeries.h"<br/>
#include "UnitParameters.h"<br/>
//---------------------------------------------------------------------------<br/>
class TFormMain : public TForm<br/>
{<br/>
__published:	// IDE-managed Components<br/>
&nbsp;&nbsp;TStringGrid *StringGridParameters;<br/>
&nbsp;&nbsp;TButton *ButtonRun;<br/>
&nbsp;&nbsp;TStatusBar *StatusBarMain;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartBias;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelLeft;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRadioGroup *RadioGroupGamy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRadioGroup *RadioGroupFemaleSampling;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TProgressBar *ProgressBarSim;<br/>
&nbsp;&nbsp;TPageControl *PageControlMain;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRichEdit *RichEdit2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRadioGroup *RadioGroupDensityDependentSelection;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartPopSize;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series13;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelLeftTop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series16;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series19;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFractionFrom;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFractionTo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFractionStep;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartMateTime;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series21;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series22;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series23;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TStringGrid *StringGridTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBarSeries *Series4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartTraitPreference;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPointSeries *Series5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPointSeries *Series6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartMateFraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series9;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series11;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series24;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPointSeries *Series25;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *Panel1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPageControl *PageControlSim;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet13;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet14;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEdit *EditFraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLabel *Label2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPageControl *PageControl2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet8;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet9;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPanel *PanelTestProbTop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestSurvivalSpecies;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartTestProbabilities;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series26;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TBitBtn *BitBtn1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheet10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TChart *ChartBiasTime;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series27;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series28;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLineSeries *Series29;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonSave;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSaveDialog *SaveDialog1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRichEdit *RichEditOutput;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestTrait;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestPreference;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TButton *ButtonTestProbabilisticMating;<br/>
&nbsp;&nbsp;TButton *ButtonTestHelp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTabSheet *TabSheetAbout;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRichEdit *RichEditAbout;<br/>
&nbsp;&nbsp;void __fastcall ButtonRunClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestSurvivalSpeciesClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall FormMouseMove(TObject *Sender, TShiftState Shift,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int X, int Y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall BitBtn1Click(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonSaveClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestTraitClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestPreferenceClick(TObject *Sender);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void __fastcall ButtonTestProbabilisticMatingClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall StringGridParametersSelectCell(TObject *Sender, int ACol,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ARow, bool &amp;CanSelect);<br/>
&nbsp;&nbsp;void __fastcall ButtonTestHelpClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall RadioGroupFemaleSamplingClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall RadioGroupDensityDependentSelectionClick(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall RadioGroupGamyClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall PageControlSimChange(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall BitBtn1MouseDown(TObject *Sender, TMouseButton Button,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TShiftState Shift, int X, int Y);<br/>
private:	// User declarations<br/>
&nbsp;&nbsp;void setCursor(const String&amp; cursorName);<br/>
&nbsp;&nbsp;bool checkInput();<br/>
&nbsp;&nbsp;void TFormMain::plotTimePoint(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimePoint&amp; mean,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimePoint&amp; stdError,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double&amp; chartX);<br/>
&nbsp;&nbsp;void TFormMain::plotTimeSeries(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimeSeries&amp; mean,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimeSeries&amp; stdError);<br/>
&nbsp;&nbsp;Parameters readStringGrid() const;<br/>
public:		// User declarations<br/>
&nbsp;&nbsp;__fastcall TFormMain(TComponent* Owner);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
extern PACKAGE TFormMain *FormMain;<br/>
//---------------------------------------------------------------------------<br/>
std::string toString(const String&amp; ansi);<br/>
String toAnsiString(const std::string&amp; myString);<br/>
void emptyChart(TChart* chart);<br/>
std::auto_ptr&lt;TStringList&gt; getStringGrid(const TStringGrid * stringGrid);<br/>
std::auto_ptr&lt;TStringList&gt; getChart(const TChart * anyChart);<br/>
std::auto_ptr&lt;TStringList&gt; getChartSeries(const TChartSeries * series);<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitMainSTL.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitMainSTL.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
#include "UnitMainSTL.h"<br/>
#pragma hdrstop<br/>
<br/>
//---------------------------------------------------------------------------<br/>
//This STL compatible version can be compiled by<br/>
//#defining USE_STL_ONLY<br/>
<br/>
#pragma argsused<br/>
int main(int argc, char* argv[])<br/>
{<br/>
&nbsp;&nbsp;if (argc&lt;2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Please enter name of data file after file name,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "\ne.g. ProjectChrisWileySTL data.txt" &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (fileExists(argv[1])==false)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Please enter a VALID and EXISTING name of data file after file name." &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Parameters parameters = readParametersFromFile(argv[1]);<br/>
<br/>
&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString("NDEBUG defined. No debugging output.");<br/>
&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString("NDEBUG not defined.");<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;Simulation simulation(parameters);<br/>
&nbsp;&nbsp;//std::auto_ptr&lt;Simulation&gt; simulation(new Simulation(<br/>
&nbsp;&nbsp;return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
//#include "UnitRandom.h"<br/>
<br/>
#include "UnitMain.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormMain *FormMain;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormMain::TFormMain(TComponent* Owner)<br/>
&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][0] = "";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][0] = "Female" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][0] = "Male #1";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][0] = "Male #2";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][0] = "Male #3";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][0] = "Male #4";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][1] = "SpeciesValue";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][1] = "-1.0" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][1] = "-1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][1] = "-0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][1] = "0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][1] = "1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[0][2] = "Trait/Preference";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[1][2] = "1.0" ;<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[2][2] = "-1.0";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[3][2] = "-0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[4][2] = "0.5";<br/>
&nbsp;&nbsp;StringGridTest-&gt;Cells[5][2] = "1.0";<br/>
<br/>
&nbsp;&nbsp;//Fill in StringGridParameters<br/>
&nbsp;&nbsp;StringGridParameters-&gt;RowCount = 23;<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 0] = "Parameter";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 0] = "Value";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 1] = "Number of females";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 1] = "1000";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 2] = "Number of males";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 2] = "1000";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 3] = "Best-of-how-much";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 3] = "5";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 4] = "Assessing error A";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 4] = "0.001";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 5] = "Assessing error B";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][ 5] = "0.001";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 6] = "Mean trait A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 6] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 7] = "StdDev trait A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 7] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 8] = "Mean trait B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 8] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][ 9] = "StdDev trait B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][ 9] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][10] = "Mean preference A";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][10] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][11] = "StdDev preference A";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][11] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][12] = "Mean preference B";&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][12] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][13] = "StdDev preference B";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][13] = "0.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][14] = "Number of simulations"; StringGridParameters-&gt;Cells[1][14] = "1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][15] = "Number of generations"; StringGridParameters-&gt;Cells[1][15] = "1";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][16] = "Number of offspring";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][16] = "6";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][17] = "SurviveSpeciesAlpha";&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][17] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][18] = "SurviveSpeciesBeta";&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][18] = "10.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][19] = "SigmaSquared";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][19] = "1.0";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][20] = "Cost trait";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringGridParameters-&gt;Cells[1][20] = "0.00";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][21] = "Cost preference";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][21] = "0.00";<br/>
&nbsp;&nbsp;StringGridParameters-&gt;Cells[0][22] = "Mutation rate";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringGridParameters-&gt;Cells[1][22] = "0.00";<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonRunClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//Check the input in own scope<br/>
&nbsp;&nbsp;if (checkInput()==false) return;<br/>
<br/>
&nbsp;&nbsp;StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text = "Running simulation";<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcherSleeping.cur");<br/>
&nbsp;&nbsp;Refresh(); //To draw this text to the StatusBar<br/>
<br/>
&nbsp;&nbsp;emptyChart(ChartBias);<br/>
&nbsp;&nbsp;emptyChart(ChartMateTime);<br/>
&nbsp;&nbsp;emptyChart(ChartMateFraction);<br/>
&nbsp;&nbsp;emptyChart(ChartPopSize);<br/>
&nbsp;&nbsp;emptyChart(ChartTraitPreference);<br/>
<br/>
&nbsp;&nbsp;//Read parameters<br/>
&nbsp;&nbsp;Parameters parameters = readStringGrid();<br/>
&nbsp;&nbsp;parameters.matingSystem&nbsp;&nbsp; = (RadioGroupGamy-&gt;ItemIndex&nbsp;&nbsp;== 0 ? monogamy : polygyny);<br/>
<br/>
&nbsp;&nbsp;switch(RadioGroupFemaleSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: parameters.femaleSampling = bestOfNconspicific;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: parameters.femaleSampling = bestOfNextremeTrait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: parameters.femaleSampling = bestOfNclosestTrait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: parameters.femaleSampling = fixedThresholdConspicific;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: parameters.femaleSampling = fixedThresholdTraitSign;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: parameters.femaleSampling = fixedThresholdProbabilistic; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown index of RadioGroupTestSampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;parameters.densityDependentSelection = (RadioGroupDensityDependentSelection-&gt;ItemIndex == 0 ? afterMating : beforeMating );<br/>
<br/>
&nbsp;&nbsp;//Show parameters<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Clear();<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Number of males: " + IntToStr(parameters.nMales));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Number of females: " + IntToStr(parameters.nFemales));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Best of how much: " + IntToStr(parameters.bestOfHowMuch));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Assessing error A: " + FloatToStr(parameters.assessingErrorA));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Assessing error B: " + FloatToStr(parameters.assessingErrorB));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Mean trait A: " + FloatToStr(parameters.meanTraitA));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("StdDev trait A: " + FloatToStr(parameters.stdDevTraitA));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Mean trait males B: " + FloatToStr(parameters.meanTraitB));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("StdDev trait males B: " + FloatToStr(parameters.stdDevTraitB));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Mean preference A: " + FloatToStr(parameters.meanPreferenceA));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("StdDev preference A: " + FloatToStr(parameters.stdDevPreferenceA));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Mean preference males B: " + FloatToStr(parameters.meanPreferenceB));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("StdDev preference males B: " + FloatToStr(parameters.stdDevPreferenceB));<br/>
<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Number of simulation: " + IntToStr(parameters.nSimulations));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Number of generations: " + IntToStr(parameters.nGenerations));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Number of offspring per couple: " + IntToStr(parameters.nOffspring));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("SurviveSpeciesAlpha: " + FloatToStr(parameters.surviveSpeciesAlpha));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("SurviveSpeciesBeta: " + FloatToStr(parameters.surviveSpeciesBeta));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("SigmaSquared: " + FloatToStr(parameters.sigmaSquared));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Cost trait: " + FloatToStr(parameters.costTrait));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Cost preference: " + FloatToStr(parameters.costPreference));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Mutation rate: " + FloatToStr(parameters.mutationRate));<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add(parameters.matingSystem&nbsp;&nbsp;== monogamy ? "Mating system: monogamy" : "Mating system: polygyny" );<br/>
&nbsp;&nbsp;switch(parameters.femaleSampling)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Female sampling: Best-Of-N conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Female sampling: Best-Of-N extreme trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Female sampling: Best-Of-N closest trait");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Female sampling: Fixed threshold conspicific");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Female sampling: Fixed threshold trait sign");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add("Female sampling: Fixed threshold probabilistic");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;RichEdit1-&gt;Lines-&gt;Add(parameters.densityDependentSelection==beforeMating ? "Density dependent selection: before mating" : "Density dependent selection: after mating");<br/>
<br/>
&nbsp;&nbsp;//Start simulation<br/>
&nbsp;&nbsp;const double deltaFraction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionStep-&gt;Text.ToDouble() : 1.0);<br/>
&nbsp;&nbsp;const double fractionFrom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionFrom-&gt;Text.ToDouble() : EditFraction-&gt;Text.ToDouble());<br/>
&nbsp;&nbsp;const double fractionTo<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (PageControlSim-&gt;ActivePageIndex == 1 ? EditFractionTo-&gt;Text.ToDouble() : 1.0);<br/>
<br/>
&nbsp;&nbsp;std::string lastErrorMessage;<br/>
&nbsp;&nbsp;for (double fraction = fractionFrom; fraction &lt; fractionTo; fraction+=deltaFraction)<br/>
&nbsp;&nbsp;//double fraction = 0.9;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ProgressBarSim-&gt;Position = fraction * ProgressBarSim-&gt;Max;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ProgressBarSim-&gt;Refresh();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.fractionMaleA&nbsp;&nbsp; = fraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters.fractionFemaleA = fraction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//parameters.nGenerations = 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimulations = parameters.nSimulations;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;TimeSeries&gt; allTimeSeries; //Size 0, use push_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int simulation = 0; simulation &lt; nSimulations; ++simulation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Stick parameter in simulation and run it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::auto_ptr&lt;Simulation&gt; simulation(new Simulation(parameters));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//simulation-&gt;showPopulation(StringGridDebug);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simulation-&gt;execute();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Get the results from the sim<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//const TimeSeries thisSimTimeSeries = simulation-&gt;getTimeSeries();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//timeSeries.push_back(thisSimTimeSeries);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allTimeSeries.push_back(simulation-&gt;getTimeSeries());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastErrorMessage = simulation-&gt;mError;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Plot the average of the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimePoint&nbsp;&nbsp;timePointAverage = getAverageEndTimePoint(allTimeSeries);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const TimeSeries timeSeriesAverage = getAverageTimeSeries(allTimeSeries);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plotTimePoint(timePointAverage,fraction);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plotTimeSeries(timeSeriesAverage);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;setCursor("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text = toAnsiString(lastErrorMessage);<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==0) PlaySound("PiedFlycatcher.wav",0,SND_FILENAME | SND_ASYNC);<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
//Checks the input, returns true if all valid<br/>
bool TFormMain::checkInput()<br/>
{<br/>
&nbsp;&nbsp;int checkInt; bool check; double checkDouble;<br/>
&nbsp;&nbsp;//nFemales<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][1],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nFemales' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nFemales' should be positive"; return false; }<br/>
&nbsp;&nbsp;//nMales<br/>
&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][2],checkInt);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nMales' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'nMales' should be positive"; return false; }<br/>
&nbsp;&nbsp;//bestOfHowMuch<br/>
&nbsp;&nbsp;if (RadioGroupFemaleSampling-&gt;ItemIndex == 0) //If female uses bestOfHowMuch<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;check = TryStrToInt(StringGridParameters-&gt;Cells[1][3],checkInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'bestOfHowMuch' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (checkInt &lt;= 0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'bestOfHowMuch' should be bigger then 0"; return false; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//assessingError<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][4],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingError' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &lt; 0.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingError' should be positive"; return false; }<br/>
&nbsp;&nbsp;if (checkDouble &gt; 1.0) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'assessingError' should be positive"; return false; }<br/>
<br/>
&nbsp;&nbsp;//Mean trait males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][5],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean trait males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev trait males A<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][6],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev trait males A' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//Mean trait males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][7],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'Mean trait males B' is not a valid input"; return false; }<br/>
&nbsp;&nbsp;//StdDev trait males B<br/>
&nbsp;&nbsp;check = TryStrToFloat(StringGridParameters-&gt;Cells[1][8],checkDouble);<br/>
&nbsp;&nbsp;if (check == false) { StatusBarMain-&gt;Panels-&gt;Items[0]-&gt;Text="Parameter 'StdDev trait males B' is not a valid input"; return false; }<br/>
<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::plotTimePoint(const TimePoint&amp; timePoint, const double&amp; chartX)<br/>
{<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[0]-&gt;AddXY(chartX,timePoint.mateTally.calculateBiasA());<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[1]-&gt;AddXY(chartX,timePoint.mateTally.calculateBiasB());<br/>
&nbsp;&nbsp;ChartBias-&gt;Series[2]-&gt;AddXY(chartX,timePoint.mateTally.calculateFractionMixedPairs());<br/>
<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[0]-&gt;AddXY(chartX,timePoint.mateTally.getNmateAA());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[1]-&gt;AddXY(chartX,timePoint.mateTally.getNmateAB());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[2]-&gt;AddXY(chartX,timePoint.mateTally.getNmateBA());<br/>
&nbsp;&nbsp;ChartMateFraction-&gt;Series[3]-&gt;AddXY(chartX,timePoint.mateTally.getNmateBB());<br/>
<br/>
&nbsp;&nbsp;//ChartMateTime-&gt;Series[0]-&gt;AddXY(chartX,timePoint.mateTally.getNmateAA());<br/>
&nbsp;&nbsp;//ChartMateTime-&gt;Series[1]-&gt;AddXY(chartX,timePoint.mateTally.getNmateAB());<br/>
&nbsp;&nbsp;//ChartMateTime-&gt;Series[2]-&gt;AddXY(chartX,timePoint.mateTally.getNmateBA());<br/>
&nbsp;&nbsp;//ChartMateTime-&gt;Series[3]-&gt;AddXY(chartX,timePoint.mateTally.getNmateBB());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormMain::plotTimeSeries(const TimeSeries&amp; timeSeries)<br/>
{<br/>
&nbsp;&nbsp;emptyChart(ChartPopSize);<br/>
&nbsp;&nbsp;emptyChart(ChartMateTime);<br/>
&nbsp;&nbsp;const unsigned int nGenerations = timeSeries.timePoints.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nGenerations; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double iD = static_cast&lt;double&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[0]-&gt;AddXY(iD+0.60,timeSeries.timePoints[i].speciesTallyAfterDensityDependentSelection.getNfemalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[3]-&gt;AddXY(iD+0.60,timeSeries.timePoints[i].speciesTallyAfterDensityDependentSelection.getNfemalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[4]-&gt;AddXY(iD+0.60,timeSeries.timePoints[i].speciesTallyAfterDensityDependentSelection.getNmalesA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[7]-&gt;AddXY(iD+0.60,timeSeries.timePoints[i].speciesTallyAfterDensityDependentSelection.getNmalesB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartPopSize-&gt;Series[8]-&gt;AddXY(iD+0.60,timeSeries.timePoints[i].speciesTallyAfterDensityDependentSelection.getNall());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[0]-&gt;AddXY(iD,timeSeries.timePoints[i].mateTally.getNmateAA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[1]-&gt;AddXY(iD,timeSeries.timePoints[i].mateTally.getNmateAB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[2]-&gt;AddXY(iD,timeSeries.timePoints[i].mateTally.getNmateBA());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[3]-&gt;AddXY(iD,timeSeries.timePoints[i].mateTally.getNmateBB());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartMateTime-&gt;Series[4]-&gt;AddXY(iD,timeSeries.timePoints[i].mateTally.getNmateAll());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTraits = timeSeries.timePoints[i].traits.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nTraits; ++j) ChartTraitPreference-&gt;Series[0]-&gt;AddXY(iD,timeSeries.timePoints[i].traits[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nPreferences = timeSeries.timePoints[i].preferences.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nPreferences; ++j) ChartTraitPreference-&gt;Series[1]-&gt;AddXY(iD,timeSeries.timePoints[i].preferences[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSpeciesValues = timeSeries.timePoints[i].descents.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int j=0; j&lt;nSpeciesValues; ++j) ChartTraitPreference-&gt;Series[2]-&gt;AddXY(iD,timeSeries.timePoints[i].descents[j]);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Parameters TFormMain::readStringGrid() const<br/>
{<br/>
&nbsp;&nbsp;Parameters parameters;<br/>
&nbsp;&nbsp;parameters.nFemales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 1].ToInt();<br/>
&nbsp;&nbsp;parameters.nMales&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 2].ToInt();<br/>
&nbsp;&nbsp;parameters.bestOfHowMuch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 3].ToInt();<br/>
&nbsp;&nbsp;parameters.assessingErrorA&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 4].ToDouble();<br/>
&nbsp;&nbsp;parameters.assessingErrorB&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][ 5].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanTraitA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 6].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevTraitA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 7].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanTraitB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 8].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevTraitB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][ 9].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanPreferenceA&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][10].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevPreferenceA&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][11].ToDouble();<br/>
&nbsp;&nbsp;parameters.meanPreferenceB&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][12].ToDouble();<br/>
&nbsp;&nbsp;parameters.stdDevPreferenceB&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][13].ToDouble();<br/>
&nbsp;&nbsp;parameters.nSimulations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][14].ToInt();<br/>
&nbsp;&nbsp;parameters.nGenerations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][15].ToInt();<br/>
&nbsp;&nbsp;parameters.nOffspring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][16].ToInt();<br/>
&nbsp;&nbsp;parameters.surviveSpeciesAlpha = StringGridParameters-&gt;Cells[1][17].ToDouble();<br/>
&nbsp;&nbsp;parameters.surviveSpeciesBeta&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][18].ToDouble();<br/>
&nbsp;&nbsp;parameters.sigmaSquared&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][19].ToDouble();<br/>
&nbsp;&nbsp;parameters.costTrait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridParameters-&gt;Cells[1][20].ToDouble();<br/>
&nbsp;&nbsp;parameters.costPreference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][21].ToDouble();<br/>
&nbsp;&nbsp;parameters.mutationRate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][22].ToDouble();<br/>
&nbsp;&nbsp;return parameters;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void emptyChart(TChart* chart)<br/>
{<br/>
&nbsp;&nbsp;const int nSeries = chart-&gt;SeriesCount();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;chart-&gt;Series[i]-&gt;Clear();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonTestClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateFemaleSamplingBase&gt; femaleSampling;<br/>
&nbsp;&nbsp;switch(RadioGroupTestSampling-&gt;ItemIndex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: femaleSampling.reset(new StateFemaleSamplingBestOfNconspicific); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: femaleSampling.reset(new StateFemaleSamplingBestOfNextremeTrait); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: femaleSampling.reset(new StateFemaleSamplingBestOfNclosestTrait); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: femaleSampling.reset(new StateFemaleSamplingFixedThresholdConspicific); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: femaleSampling.reset(new StateFemaleSamplingFixedThresholdTraitSign); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: femaleSampling.reset(new StateFemaleSamplingFixedThresholdProbabilistic); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown index of RadioGroupTestSampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Parameters parameters = readStringGrid();<br/>
&nbsp;&nbsp;const double femaleSpeciesValue = StringGridTest-&gt;Cells[1][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue1&nbsp;&nbsp;= StringGridTest-&gt;Cells[2][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue2&nbsp;&nbsp;= StringGridTest-&gt;Cells[3][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue3&nbsp;&nbsp;= StringGridTest-&gt;Cells[4][1].ToDouble();<br/>
&nbsp;&nbsp;const double maleSpeciesValue4&nbsp;&nbsp;= StringGridTest-&gt;Cells[5][1].ToDouble();<br/>
&nbsp;&nbsp;const double femalePreference&nbsp;&nbsp; = StringGridTest-&gt;Cells[1][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[2][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[3][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[4][2].ToDouble();<br/>
&nbsp;&nbsp;const double maleTrait4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = StringGridTest-&gt;Cells[5][2].ToDouble();<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt; females = Bird::createTestFemales(parameters,femaleSpeciesValue, femalePreference);<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt; males = Bird::createTestMales(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue1, maleTrait1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue2, maleTrait2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue3, maleTrait3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maleSpeciesValue4, maleTrait4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;std::vector&lt;unsigned int&gt; histogramWinner(4);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;4; ++i) histogramWinner[i]=0;<br/>
<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;1000; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males,females[0],parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++(histogramWinner[winnerIndex]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;emptyChart(ChartTest);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(0.0,histogramWinner[0]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(1.0,histogramWinner[1]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(2.0,histogramWinner[2]);<br/>
&nbsp;&nbsp;ChartTest-&gt;Series[0]-&gt;AddXY(3.0,histogramWinner[3]);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormMain::ButtonTestSurvivalSpeciesClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;Clear();<br/>
&nbsp;&nbsp;const double alpha = StringGridParameters-&gt;Cells[1][17].ToDouble();<br/>
&nbsp;&nbsp;const double beta&nbsp;&nbsp;= StringGridParameters-&gt;Cells[1][18].ToDouble();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Clear();<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("const double y = 1.0 - alpha * std::exp(-beta*x*x)");<br/>
&nbsp;&nbsp;ChartTestProbabilities-&gt;Title-&gt;Text-&gt;Add("Alpha: " + FloatToStr(alpha) + ", Beta: " + FloatToStr(beta));<br/>
&nbsp;&nbsp;for (double x = -1.0; x&lt;1.0; x+=0.01)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double y = 1.0 - alpha * std::exp(-beta*x*x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ChartTestProbabilities-&gt;Series[0]-&gt;AddXY(x,y);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
void __fastcall TFormMain::FormMouseMove(TObject *Sender,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TShiftState Shift, int X, int Y)<br/>
{<br/>
&nbsp;&nbsp;TCursor myCursor = static_cast&lt;TCursor&gt;(22);<br/>
&nbsp;&nbsp;Screen-&gt;Cursors[22] = LoadCursorFromFile("CursorPiedFlycatcher.cur");<br/>
&nbsp;&nbsp;Cursor = myCursor;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
void __fastcall TFormMain::BitBtn1Click(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;if (BitBtn1-&gt;Tag==1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcher.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Glyph-&gt;LoadFromFile("PiedFlycatcherSleeping.bmp");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BitBtn1-&gt;Tag=1;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string toString(const String&amp; ansi)<br/>
{<br/>
&nbsp;&nbsp;const char * myChar = ansi.c_str();<br/>
&nbsp;&nbsp;const std::string myString = myChar;<br/>
&nbsp;&nbsp;return myString;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
String toAnsiString(const std::string&amp; myString)<br/>
{<br/>
&nbsp;&nbsp;const char * myChar = myString.c_str();<br/>
&nbsp;&nbsp;const String myAnsi = myChar;<br/>
&nbsp;&nbsp;return myAnsi;<br/>
}<br/>
*/<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitMainSTL.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitMainSTL.h" border = "1"><tr><td><code>
#ifndef UnitMainSTLH<br/>
#define UnitMainSTLH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;assert.h&gt;<br/>
<br/>
#include "UnitParameters.h"<br/>
#include "UnitSimulation.h"<br/>
#include "UnitHelperFunctions.h"<br/>
Parameters readParametersFromFile(const std::string&amp; fileName);<br/>
<br/>
#endif<br/>
<br/>
 <br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitMatingSystem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitMatingSystem.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitMatingSystem.h"<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemMonogamyFixedNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; debugMateTally(new MateTally);<br/>
<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;//Get the fraction of species A and B<br/>
&nbsp;&nbsp;const SpeciesTally speciesTally(males,females);<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;const unsigned int nMalesAwanted&nbsp;&nbsp; = static_cast&lt;double&gt;(parameters.nMales * speciesTally.getNallMalesA()) / static_cast&lt;double&gt;(speciesTally.getNallMales());<br/>
&nbsp;&nbsp;const unsigned int nMalesBwanted&nbsp;&nbsp; = static_cast&lt;double&gt;(parameters.nMales * speciesTally.getNallMalesB()) / static_cast&lt;double&gt;(speciesTally.getNallMales());<br/>
&nbsp;&nbsp;const unsigned int nFemalesAwanted = static_cast&lt;double&gt;(parameters.nFemales * speciesTally.getNfemalesA()) / static_cast&lt;double&gt;(speciesTally.getNallFemales());<br/>
&nbsp;&nbsp;const unsigned int nFemalesBwanted = static_cast&lt;double&gt;(parameters.nFemales * speciesTally.getNfemalesB()) / static_cast&lt;double&gt;(speciesTally.getNallFemales());<br/>
&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;unsigned int nMalesAwanted&nbsp;&nbsp; = parameters.getNmalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nMalesBwanted&nbsp;&nbsp; = parameters.getNmalesBwanted();<br/>
&nbsp;&nbsp;assert(nMalesAwanted + nMalesBwanted == parameters.nMales);<br/>
&nbsp;&nbsp;unsigned int nFemalesAwanted = parameters.getNfemalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nFemalesBwanted = parameters.getNfemalesBwanted();<br/>
&nbsp;&nbsp;assert(nFemalesAwanted + nFemalesBwanted == parameters.nFemales);<br/>
<br/>
&nbsp;&nbsp;const unsigned int nSpeciesAwanted = nMalesAwanted + nFemalesAwanted;<br/>
&nbsp;&nbsp;const unsigned int nSpeciesBwanted = nMalesBwanted + nFemalesBwanted;<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
<br/>
&nbsp;&nbsp;assert(females.size()&gt;0);<br/>
<br/>
&nbsp;&nbsp;//Create the couples<br/>
&nbsp;&nbsp;std::vector&lt; Couple &gt; couples;<br/>
&nbsp;&nbsp;for(unsigned int female = 0; female &lt; females.size() &amp;&amp; males.size() &gt; 0; /*nothing*/)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++female;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Form the std::pair from the lovers and store them in the std::vector couples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Couple couple(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;couples.push_back(couple);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Remove the couple from the desperate others<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.erase(&amp;males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.erase(&amp;females[female]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Let the couples produce offspring<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesA; //speciesA.reserve(nSpeciesAwanted);<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesB; //speciesB.reserve(nSpeciesBwanted);<br/>
&nbsp;&nbsp;const unsigned int nCouples = couples.size();<br/>
&nbsp;&nbsp;const unsigned int maxTries = (nSpeciesAwanted + nSpeciesBwanted) * (nSpeciesAwanted + nSpeciesBwanted);<br/>
&nbsp;&nbsp;unsigned int myTry = 0;<br/>
&nbsp;&nbsp;while(speciesA.size()!=nSpeciesAwanted || speciesB.size()!=nSpeciesBwanted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++myTry;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myTry==maxTries) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned int couple = 0; couple &lt; nCouples; ++couple)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(couples[couple].female,couples[couple].male,mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (birdy.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesA.size() &lt; nSpeciesAwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesA.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(couples[couple].female,couples[couple].male); //DEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesB.size() &lt; nSpeciesBwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesB.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Dot("Broke while loop in reproduction");<br/>
&nbsp;&nbsp;//Now the vectors of speciesA and speciesB are created,<br/>
&nbsp;&nbsp;//they have to be changed to vectors of males and females<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;if (myTry==maxTries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Create offspring of a failed simulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Easy! Just give the empty Offspring back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return offspring;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;assert(speciesA.size()==nSpeciesAwanted);<br/>
&nbsp;&nbsp;assert(speciesB.size()==nSpeciesBwanted);<br/>
&nbsp;&nbsp;//Females<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesAwanted; ++i) offspring.females.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesBwanted; ++i) offspring.females.push_back(speciesB[i]);<br/>
&nbsp;&nbsp;//Males<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesAwanted; i&lt;nSpeciesAwanted; ++i) offspring.males.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesBwanted; i&lt;nSpeciesBwanted; ++i) offspring.males.push_back(speciesB[i]);<br/>
<br/>
&nbsp;&nbsp;assert(offspring.females.size()==nFemalesAwanted+nFemalesBwanted);<br/>
&nbsp;&nbsp;assert(offspring.males.size()==nMalesAwanted+nMalesBwanted);<br/>
<br/>
&nbsp;&nbsp;//Dot("mateTally: "+mateTally.get());<br/>
&nbsp;&nbsp;//Dot("DebugTally: "+debugMateTally-&gt;get());<br/>
&nbsp;&nbsp;return offspring;<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemPolygynyFixedNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;//Get the fraction of species A and B<br/>
&nbsp;&nbsp;const SpeciesTally speciesTally(males,females);<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;const unsigned int nMalesAwanted&nbsp;&nbsp; = static_cast&lt;double&gt;(parameters.nMales * speciesTally.getNallMalesA()) / static_cast&lt;double&gt;(speciesTally.getNallMales());<br/>
&nbsp;&nbsp;const unsigned int nMalesBwanted&nbsp;&nbsp; = static_cast&lt;double&gt;(parameters.nMales * speciesTally.getNallMalesB()) / static_cast&lt;double&gt;(speciesTally.getNallMales());<br/>
&nbsp;&nbsp;const unsigned int nFemalesAwanted = static_cast&lt;double&gt;(parameters.nFemales * speciesTally.getNfemalesA()) / static_cast&lt;double&gt;(speciesTally.getNallFemales());<br/>
&nbsp;&nbsp;const unsigned int nFemalesBwanted = static_cast&lt;double&gt;(parameters.nFemales * speciesTally.getNfemalesB()) / static_cast&lt;double&gt;(speciesTally.getNallFemales());<br/>
&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;unsigned int nMalesAwanted&nbsp;&nbsp; = parameters.getNmalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nMalesBwanted&nbsp;&nbsp; = parameters.getNmalesBwanted();<br/>
&nbsp;&nbsp;assert(nMalesAwanted + nMalesBwanted == parameters.nMales);<br/>
&nbsp;&nbsp;unsigned int nFemalesAwanted = parameters.getNfemalesAwanted();<br/>
&nbsp;&nbsp;unsigned int nFemalesBwanted = parameters.getNfemalesBwanted();<br/>
&nbsp;&nbsp;assert(nFemalesAwanted + nFemalesBwanted == parameters.nFemales);<br/>
<br/>
&nbsp;&nbsp;const unsigned int nSpeciesAwanted = nMalesAwanted + nFemalesAwanted;<br/>
&nbsp;&nbsp;const unsigned int nSpeciesBwanted = nMalesBwanted + nFemalesBwanted;<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;assert(nFemales&gt;0);<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesA;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; speciesB;<br/>
<br/>
&nbsp;&nbsp;const unsigned int maxTries = (nSpeciesAwanted + nSpeciesBwanted) * (nSpeciesAwanted + nSpeciesBwanted);<br/>
&nbsp;&nbsp;unsigned int myTry = 0;<br/>
&nbsp;&nbsp;while(speciesA.size()!=nSpeciesAwanted || speciesB.size()!=nSpeciesBwanted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;++myTry;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myTry==maxTries) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned int female = 0; female &lt; nFemales; ++female)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(females[female],males[winnerIndex],mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (birdy.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesA.size() &lt; nSpeciesAwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesA.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Birdy is of speciesB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (speciesB.size() &lt; nSpeciesBwanted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //When we can use offspring of speciesA<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speciesB.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;Dot("Broke while loop in reproduction above line ");<br/>
<br/>
&nbsp;&nbsp;//Now the vectors of speciesA and speciesB are created,<br/>
&nbsp;&nbsp;//they have to be changed to vectors of males and females<br/>
<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;if (myTry==maxTries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Create offspring of a failed simulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Easy! Just give the empty Offspring back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return offspring;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;assert(speciesA.size()==nSpeciesAwanted);<br/>
&nbsp;&nbsp;assert(speciesB.size()==nSpeciesBwanted);<br/>
&nbsp;&nbsp;//Females<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesAwanted; ++i) offspring.females.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemalesBwanted; ++i) offspring.females.push_back(speciesB[i]);<br/>
&nbsp;&nbsp;//Males<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesAwanted; i&lt;nSpeciesAwanted; ++i) offspring.males.push_back(speciesA[i]);<br/>
&nbsp;&nbsp;for (unsigned int i=nFemalesBwanted; i&lt;nSpeciesBwanted; ++i) offspring.males.push_back(speciesB[i]);<br/>
<br/>
&nbsp;&nbsp;assert(offspring.females.size()==nFemalesAwanted+nFemalesBwanted);<br/>
&nbsp;&nbsp;assert(offspring.males.size()==nMalesAwanted+nMalesBwanted);<br/>
&nbsp;&nbsp;return offspring;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemMonogamyFreeNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; debugMateTally(new MateTally);<br/>
<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
&nbsp;&nbsp;assert(females.size()&gt;0);<br/>
<br/>
&nbsp;&nbsp;//Create the couples<br/>
&nbsp;&nbsp;std::vector&lt; Couple &gt; couples;<br/>
&nbsp;&nbsp;for(unsigned int female = 0; female &lt; females.size() &amp;&amp; males.size() &gt; 0; )<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++female;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Form the std::pair from the lovers and store them in the std::vector couples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Couple couple(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;couples.push_back(couple);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Remove the couple from the desperate others<br/>
&nbsp;&nbsp;&nbsp;&nbsp;males.erase(&amp;males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;females.erase(&amp;females[female]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Let the couples produce offspring<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;const unsigned int nCouples = couples.size();<br/>
&nbsp;&nbsp;for(unsigned int couple = 0; couple &lt; nCouples; ++couple)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nOffspring = parameters.nOffspring;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nOffspring; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(couples[couple].female,couples[couple].male,mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(couples[couple].female,couples[couple].male); //DEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(couples[couple].female,couples[couple].male);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::rand()%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.males.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.females.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Now the vectors of speciesA and speciesB are created,<br/>
&nbsp;&nbsp;//they have to be changed to vectors of males and females<br/>
&nbsp;&nbsp;//Dot("mateTally: "+mateTally.get());<br/>
&nbsp;&nbsp;//Dot("DebugTally: "+debugMateTally-&gt;get());<br/>
&nbsp;&nbsp;return offspring;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
Offspring StateMatingSystemPolygynyFreeNumberOffspring::mate(<br/>
&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;MateTally&amp; mateTally<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; debugMateTally(new MateTally);<br/>
&nbsp;&nbsp;assert(mateTally.isNull()==true);<br/>
&nbsp;&nbsp;//Get the fraction of species A and B<br/>
&nbsp;&nbsp;const double mutation = parameters.mutationRate;<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;assert(nFemales&gt;0);<br/>
&nbsp;&nbsp;Offspring offspring;<br/>
&nbsp;&nbsp;for(unsigned int female = 0; female &lt; nFemales; ++female)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let the female pick her favorite<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int winnerIndex = femaleSampling-&gt;getWinnerIndex(males, females[female], parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(winnerIndex &lt;= males.size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Dot("The index of the mate in vector 'males' is: " + IntToStr(winnerIndex));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (winnerIndex == males.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The female did not mate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters.femaleSampling!=bestOfNconspicific &amp;&amp; parameters.femaleSampling!=bestOfNextremeTrait &amp;&amp; parameters.femaleSampling!=bestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nOffspring = parameters.nOffspring;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Let them produce many offspring<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nOffspring; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find out whether he is a conspicific and put it in the results<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bird birdy(females[female],males[winnerIndex],mutation);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugMateTally-&gt;tally(females[female],males[winnerIndex]); //DEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mateTally.tally(females[female],males[winnerIndex]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (std::rand()%2==0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.males.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offspring.females.push_back(birdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return offspring;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitMatingSystem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitMatingSystem.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitMatingSystemH<br/>
#define UnitMatingSystemH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;iostream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
<br/>
<br/>
#include "UnitBird.h"<br/>
#include "UnitParameters.h"<br/>
#include "UnitFemaleSampling.h"<br/>
#include "UnitTallies.h"<br/>
#include "UnitHelperFunctions.h"<br/>
#include "UnitRandom.h"<br/>
<br/>
class StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemBase() {}<br/>
&nbsp;&nbsp;virtual std::string getMatingSystem() const = 0;<br/>
&nbsp;&nbsp;virtual Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) = 0;<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemMonogamyFixedNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemMonogamyFixedNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "MonogamyFixedNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemPolygynyFixedNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemPolygynyFixedNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "PolygynyFixedNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemMonogamyFreeNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemMonogamyFreeNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "MonogamyFreeNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class StateMatingSystemPolygynyFreeNumberOffspring : public StateMatingSystemBase<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;StateMatingSystemPolygynyFreeNumberOffspring() {}<br/>
&nbsp;&nbsp;std::string getMatingSystem() const { return "PolygynyFreeNumberOffspring"; }<br/>
&nbsp;&nbsp;Offspring mate(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Female&gt;&amp; females,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Male&gt;&amp; males,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Parameters&amp; parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StateFemaleSamplingBase&gt;&amp; femaleSampling,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MateTally&amp; tally<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitParameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitParameters.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitParameters.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
void Parameters::reset()<br/>
{<br/>
&nbsp;&nbsp; nFemales = 0;<br/>
&nbsp;&nbsp; nMales = 0;<br/>
&nbsp;&nbsp; fractionMaleA = 0.0;<br/>
&nbsp;&nbsp; fractionFemaleA = 0.0;<br/>
&nbsp;&nbsp; bestOfHowMuch = 0;<br/>
&nbsp;&nbsp; assessingErrorA = 0.0;<br/>
&nbsp;&nbsp; assessingErrorB = 0.0;<br/>
&nbsp;&nbsp; meanTraitA = 0.0;<br/>
&nbsp;&nbsp; meanTraitB = 0.0;<br/>
&nbsp;&nbsp; meanPreferenceA = 0.0;<br/>
&nbsp;&nbsp; meanPreferenceB = 0.0;<br/>
&nbsp;&nbsp; stdDevTraitA = 0.0;<br/>
&nbsp;&nbsp; stdDevTraitB = 0.0;<br/>
&nbsp;&nbsp; stdDevPreferenceA = 0.0;<br/>
&nbsp;&nbsp; stdDevPreferenceB = 0.0;<br/>
&nbsp;&nbsp; sigmaSquared = 0.0;<br/>
&nbsp;&nbsp; nSimulations = 0;<br/>
&nbsp;&nbsp; //simIndex = 0;<br/>
&nbsp;&nbsp; costTrait = 0.0;<br/>
&nbsp;&nbsp; costPreference = 0.0;<br/>
&nbsp;&nbsp; mutationRate = 0.0;<br/>
&nbsp;&nbsp; matingSystem = monogamy;<br/>
&nbsp;&nbsp; femaleSampling = bestOfNconspicific;<br/>
&nbsp;&nbsp; densityDependentSelection = afterMating;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNmalesAwanted() const<br/>
{<br/>
&nbsp;&nbsp;//return static_cast&lt;double&gt;(nMales) * fractionMaleA;<br/>
&nbsp;&nbsp;//return nMales * fractionMaleA;<br/>
&nbsp;&nbsp;const unsigned int result = nMales * fractionMaleA;<br/>
&nbsp;&nbsp;const unsigned int nMalesBwanted = getNmalesBwanted();<br/>
&nbsp;&nbsp;if (result+nMalesBwanted==nMales) return result;<br/>
&nbsp;&nbsp;else if (result+nMalesBwanted==nMales-1) return result+1;<br/>
&nbsp;&nbsp;else assert(!"Should not get here"); std::exit(1); return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNmalesBwanted() const<br/>
{<br/>
&nbsp;&nbsp;return nMales * (1.0-fractionMaleA);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNfemalesAwanted() const<br/>
{<br/>
&nbsp;&nbsp;//return static_cast&lt;double&gt;(nFemales) * fractionFemaleA;<br/>
&nbsp;&nbsp;//return nFemales * fractionFemaleA;<br/>
&nbsp;&nbsp;const unsigned int result = nFemales * fractionFemaleA;<br/>
&nbsp;&nbsp;const unsigned int nFemalesBwanted = getNfemalesBwanted();<br/>
&nbsp;&nbsp;if (result+nFemalesBwanted==nFemales) return result;<br/>
&nbsp;&nbsp;else if (result+nFemalesBwanted==nFemales-1) return result+1;<br/>
&nbsp;&nbsp;else assert(!"Should not get here"); std::exit(1); return 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
unsigned int Parameters::getNfemalesBwanted() const<br/>
{<br/>
&nbsp;&nbsp;//return static_cast&lt;double&gt;(nFemales) * (1.0-fractionFemaleA);<br/>
&nbsp;&nbsp;return nFemales * (1.0-fractionFemaleA);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Parameters::readFromFile(const std::string&amp; fileName)<br/>
{<br/>
&nbsp;&nbsp;assert(fileExists(fileName)==true);<br/>
&nbsp;&nbsp;std::ifstream in (fileName.c_str());<br/>
&nbsp;&nbsp;std::string myString;<br/>
&nbsp;&nbsp;int tempInt;<br/>
&nbsp;&nbsp;for (int i=0; !in.eof(); ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;in &gt;&gt; myString;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nGenerations")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nGenerations; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nFemales")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nFemales; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nMales")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nMales; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="fractionMaleA")&nbsp;&nbsp;&nbsp;&nbsp; { in &gt;&gt; fractionMaleA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="fractionFemaleA")&nbsp;&nbsp; { in &gt;&gt; fractionFemaleA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="bestOfHowMuch")&nbsp;&nbsp;&nbsp;&nbsp; { in &gt;&gt; bestOfHowMuch; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="assessingErrorA")&nbsp;&nbsp; { in &gt;&gt; assessingErrorA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="assessingErrorB")&nbsp;&nbsp; { in &gt;&gt; assessingErrorB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanTraitA")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; meanTraitA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanTraitB")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; meanTraitB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanPreferenceA")&nbsp;&nbsp; { in &gt;&gt; meanPreferenceA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="meanPreferenceB")&nbsp;&nbsp; { in &gt;&gt; meanPreferenceB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevTraitA")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; stdDevTraitA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevTraitB")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; stdDevTraitB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevPreferenceA") { in &gt;&gt; stdDevPreferenceA; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="stdDevPreferenceB") { in &gt;&gt; stdDevPreferenceB; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="sigmaSquared")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; sigmaSquared; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nSimulations")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nSimulations; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="nOffspring")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ in &gt;&gt; nOffspring; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="surviveSpeciesAlpha") { in &gt;&gt; surviveSpeciesAlpha; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="surviveSpeciesBeta")&nbsp;&nbsp;{ in &gt;&gt; surviveSpeciesBeta; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="costTrait")&nbsp;&nbsp;{ in &gt;&gt; costTrait; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="costPreference")&nbsp;&nbsp;{ in &gt;&gt; costPreference; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="mutationRate")&nbsp;&nbsp;{ in &gt;&gt; mutationRate; continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="matingSystem")&nbsp;&nbsp;{ in &gt;&gt; tempInt; matingSystem = static_cast&lt;enumMatingSystem&gt;(tempInt); continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="femaleSampling")&nbsp;&nbsp;{ in &gt;&gt; tempInt; femaleSampling = static_cast&lt;enumFemaleSampling&gt;(tempInt); continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (myString=="densityDependentSelection")&nbsp;&nbsp;{ in &gt;&gt; tempInt; densityDependentSelection = static_cast&lt;enumDensityDependentSelection&gt;(tempInt); continue; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown file parameter"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;in.close();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Parameters::writeToFile(const std::string&amp; fileName)<br/>
{<br/>
&nbsp;&nbsp;std::ofstream out (fileName.c_str());<br/>
&nbsp;&nbsp;out &lt;&lt; "nGenerations" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nGenerations &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nFemales" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nFemales &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nMales" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nMales &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "fractionMaleA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; fractionMaleA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "fractionFemaleA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; fractionFemaleA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "bestOfHowMuch" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; bestOfHowMuch &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "assessingErrorA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; assessingErrorA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "assessingErrorB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; assessingErrorB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanTraitA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; meanTraitA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanTraitB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; meanTraitB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanPreferenceA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; meanPreferenceA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "meanPreferenceB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; meanPreferenceB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevTraitA" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; stdDevTraitA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevTraitB" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; stdDevTraitB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevPreferenceA" &lt;&lt; '\t'&nbsp;&nbsp;&lt;&lt; stdDevPreferenceA &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "stdDevPreferenceB" &lt;&lt; '\t'&nbsp;&nbsp;&lt;&lt; stdDevPreferenceB &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "sigmaSquared" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; sigmaSquared &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nSimulations" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nSimulations &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "nOffspring" &lt;&lt; '\t'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; nOffspring &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "surviveSpeciesAlpha" &lt;&lt; '\t'&nbsp;&nbsp;&lt;&lt; surviveSpeciesAlpha &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "surviveSpeciesBeta" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; surviveSpeciesBeta &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "costTrait" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; costTrait &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "costPreference" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; costPreference &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "mutationRate" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; mutationRate &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "matingSystem" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; static_cast&lt;int&gt;(matingSystem) &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "femaleSampling" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; static_cast&lt;int&gt;(femaleSampling) &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out &lt;&lt; "densityDependentSelection" &lt;&lt; '\t'&nbsp;&nbsp; &lt;&lt; static_cast&lt;int&gt;(densityDependentSelection) &lt;&lt; '\n';<br/>
&nbsp;&nbsp;out.close();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitParameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitParameters.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitParametersH<br/>
#define UnitParametersH<br/>
//---------------------------------------------------------------------------<br/>
#include "UnitEnums.h"<br/>
#include "UnitHelperFunctions.h"<br/>
<br/>
class Parameters<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;unsigned int nGenerations;&nbsp;&nbsp;//Number of generations<br/>
&nbsp;&nbsp;unsigned int nFemales;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Number of females<br/>
&nbsp;&nbsp;unsigned int nMales;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Number of males<br/>
&nbsp;&nbsp;double fractionMaleA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Fraction of males being of species A<br/>
&nbsp;&nbsp;double fractionFemaleA;&nbsp;&nbsp;&nbsp;&nbsp; //Fraction of males being of species B<br/>
&nbsp;&nbsp;unsigned int bestOfHowMuch; //Value of N in Best-of-N<br/>
&nbsp;&nbsp;double assessingErrorA ;&nbsp;&nbsp;&nbsp;&nbsp;//The probability a female A assess a male wrong<br/>
&nbsp;&nbsp;double assessingErrorB;&nbsp;&nbsp;&nbsp;&nbsp; //The probability a female B assess a male wrong<br/>
&nbsp;&nbsp;double meanTraitA;<br/>
&nbsp;&nbsp;double meanTraitB;<br/>
&nbsp;&nbsp;double meanPreferenceA;<br/>
&nbsp;&nbsp;double meanPreferenceB;<br/>
&nbsp;&nbsp;double stdDevTraitA;<br/>
&nbsp;&nbsp;double stdDevTraitB;<br/>
&nbsp;&nbsp;double stdDevPreferenceA;<br/>
&nbsp;&nbsp;double stdDevPreferenceB;<br/>
&nbsp;&nbsp;double sigmaSquared;<br/>
&nbsp;&nbsp;unsigned int nSimulations; //Number of simulations<br/>
&nbsp;&nbsp;unsigned int nOffspring;&nbsp;&nbsp; //Number of offspring produced per couple<br/>
&nbsp;&nbsp;//unsigned int simIndex; //The simulation's index, or: the simIndex-th simulation that is being run<br/>
&nbsp;&nbsp;double surviveSpeciesAlpha;<br/>
&nbsp;&nbsp;double surviveSpeciesBeta;<br/>
&nbsp;&nbsp;double costTrait;<br/>
&nbsp;&nbsp;double costPreference;<br/>
&nbsp;&nbsp;double mutationRate;<br/>
&nbsp;&nbsp;enumMatingSystem matingSystem;&nbsp;&nbsp;&nbsp;&nbsp; //Monogamy/polygyny<br/>
&nbsp;&nbsp;enumFemaleSampling femaleSampling; //The way a female samples the male population<br/>
&nbsp;&nbsp;enumDensityDependentSelection densityDependentSelection;<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;unsigned int getNmalesAwanted() const;<br/>
&nbsp;&nbsp;unsigned int getNmalesBwanted() const;<br/>
&nbsp;&nbsp;unsigned int getNfemalesAwanted() const;<br/>
&nbsp;&nbsp;unsigned int getNfemalesBwanted() const;<br/>
&nbsp;&nbsp;void readFromFile(const std::string&amp; fileName);<br/>
&nbsp;&nbsp;void writeToFile(const std::string&amp; fileName);<br/>
};<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitRandom.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitRandom.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitRandom.h"<br/>
//---------------------------------------------------------------------------<br/>
long int rnd::idum;<br/>
int rnd::MBIG&nbsp;&nbsp;= 1000000000;<br/>
int rnd::MSEED = 161803398;<br/>
int rnd::MZ = 0;<br/>
double rnd::FAC = (1.0/MBIG);<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitRandom.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitRandom.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitRandomH<br/>
#define UnitRandomH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;math.h&gt;<br/>
<br/>
class rnd<br/>
{<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;static long int idum;<br/>
&nbsp;&nbsp;static int MBIG;<br/>
&nbsp;&nbsp;static int MSEED;<br/>
&nbsp;&nbsp;static int MZ;<br/>
&nbsp;&nbsp;static double FAC;<br/>
<br/>
<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;//Returns a uniform random value from 0.0 to 1.0<br/>
&nbsp;&nbsp;static double uniform()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static int inext,inextp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static long ma[56];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static int iff=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;long mj,mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int i,ii,k;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (idum &lt; 0 || iff == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iff=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj=MSEED-(idum &lt; 0 ? -idum : idum);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj %= MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[55]=mj;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=54;i++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii=(21*i) % 55;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[ii]=mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=mj-mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mk &lt; MZ) mk += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj=ma[ii];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (k=1;k&lt;=4;k++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=55;i++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[i] -= ma[1+(i+30) % 55];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ma[i] &lt; MZ) ma[i] += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inext=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inextp=31;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idum=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (++inext == 56) inext=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (++inextp == 56) inextp=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mj=ma[inext]-ma[inextp];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mj &lt; MZ) mj += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ma[inext]=mj;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return mj*FAC;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;static double gasdev()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static int iset=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static double gset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double fac,r,v1,v2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//double uniform();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;uniform();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;(iset == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1=2.0*uniform()-1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2=2.0*uniform()-1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=v1*v1+v2*v2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (r &gt;= 1.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac=sqrt(-2.0*log(r)/r);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gset=v1*fac;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iset=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return v2*fac;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iset=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return gset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Sets the seed for the random number sequence<br/>
&nbsp;&nbsp;static void SetSeed(const int&amp; seed)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;idum = long(-std::abs(seed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;100; i++) uniform();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Returns a random number from a gaussian distrubution<br/>
&nbsp;&nbsp;static double normal(const double&amp; mean,const double&amp; stdev)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return gasdev()*stdev + mean;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Returns a random integer from 0 to N<br/>
&nbsp;&nbsp;static int RandomNumber(const int&amp; N)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int out;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x=std::floor(uniform()*N);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;out=int (x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return out;<br/>
&nbsp;&nbsp;}<br/>
};<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitResults.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitResults.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitResults.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitResults.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitResults.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitResultsH<br/>
#define UnitResultsH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include "UnitTallies.h"<br/>
<br/>
class ResultsSingleton<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;static ResultsSingleton* instance()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mpInstance==0) mpInstance = new ResultsSingleton();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return mpInstance;<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;ResultsSingleton() {}<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;static ResultsSingleton* mpInstance;<br/>
};<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitSimulation.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitSimulation.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
#include "UnitSimulation.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
Simulation::Simulation(const Parameters&amp; parameters)<br/>
&nbsp;&nbsp;: mParameters(parameters),<br/>
&nbsp;&nbsp;mMateTally(new MateTally),<br/>
&nbsp;&nbsp;mError("Finished simulation without errors.")<br/>
{<br/>
&nbsp;&nbsp;//Copy parameters from mParameters<br/>
&nbsp;&nbsp;setMatingSystem(mParameters.matingSystem, mParameters.densityDependentSelection);<br/>
&nbsp;&nbsp;setFemaleSampling(mParameters.femaleSampling);<br/>
&nbsp;&nbsp;//Reset results<br/>
&nbsp;&nbsp;mMateTally-&gt;reset();<br/>
&nbsp;&nbsp;mMales = Bird::createMales(mParameters);<br/>
&nbsp;&nbsp;mFemales = Bird::createFemales(mParameters);<br/>
<br/>
&nbsp;&nbsp;//Shuffle the males and females<br/>
&nbsp;&nbsp;std::random_shuffle(mMales.begin()&nbsp;&nbsp;, mMales.end()&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;std::random_shuffle(mFemales.begin(), mFemales.end());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::execute()<br/>
{<br/>
&nbsp;&nbsp;const unsigned int nGenerations = mParameters.nGenerations;<br/>
&nbsp;&nbsp;mTimeSeries.timePoints.resize(nGenerations);<br/>
&nbsp;&nbsp;for (unsigned int generation=0; generation&lt;nGenerations; ++generation)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//log("Start of species selection. Nmales: " + IntToStr(mMales.size()) + ",Nfemales: " + IntToStr(mFemales.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyOffspring.tallySpecies(mFemales,mMales);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].getSample(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesSelection();&nbsp;&nbsp; //Selection on species, hybrids have disadvantage<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//log("Start of viabilitySelection. Nmales: " + IntToStr(mMales.size()) + ",Nfemales: " + IntToStr(mFemales.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyAfterSpeciesSelection.tallySpecies(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;viabilitySelection(); //Selection on trait, individuals with high trait have disadvantage<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//log("Selection before mating. Nmales: " + IntToStr(mMales.size()) + ",Nfemales: " + IntToStr(mFemales.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyAfterTraitSelection.tallySpecies(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool canDoSelection = mDensityDependentSelection-&gt;canDoSelection(mFemales,mMales,mParameters,mError);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (canDoSelection==false) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mDensityDependentSelection-&gt;doSelection(mFemales,mMales,mParameters);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mTimeSeries.timePoints[generation].speciesTallyAfterDensityDependentSelection.tallySpecies(mFemales,mMales);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Offspring offspring = mMatingSystem-&gt;mate(mMales,mFemales,mParameters,mFemaleSampling,mTimeSeries.timePoints[generation].mateTally);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::swap(mFemales, offspring.females);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::swap(mMales, offspring.males);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mFemales.size()==0) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mMales.size()==0) break;<br/>
<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Selection on species, hybrids have disadvantage<br/>
void Simulation::speciesSelection()<br/>
{<br/>
&nbsp;&nbsp;//Easy implementation: hybrids just die<br/>
&nbsp;&nbsp;for (unsigned int male = 0; male &lt; mMales.size(); ++male)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(male &lt; mMales.size() &amp;&amp; willDieSpecies(mMales[male])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(&amp;mMales[male]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(&amp;mMales.at(male));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;for (unsigned int female = 0; female &lt; mFemales.size(); ++female)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(female &lt; mFemales.size() &amp;&amp; willDieSpecies(mFemales[female])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(&amp;mFemales[female]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(&amp;mFemales.at(female));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Selection on trait, individuals with high trait have disadvantage<br/>
void Simulation::viabilitySelection()<br/>
{<br/>
&nbsp;&nbsp;//Easy implementation: hybrids just die<br/>
&nbsp;&nbsp;for (unsigned int male = 0; male &lt; mMales.size(); ++male)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(male &lt; mMales.size() &amp;&amp; willDieTrait(mMales[male])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(&amp;mMales[male]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMales.erase(&amp;mMales.at(male));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;for (unsigned int female = 0; female &lt; mFemales.size(); ++female)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while(female &lt; mFemales.size() &amp;&amp; willDiePreference(mFemales[female])==true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(&amp;mFemales[female]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemales.erase(&amp;mFemales.at(female));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//Kills the hybrids<br/>
bool Simulation::willDieSpecies(const Bird&amp; bird)<br/>
{<br/>
&nbsp;&nbsp;assert(bird.descent&gt;=-1.0 &amp;&amp; bird.descent&lt;=1.0);<br/>
&nbsp;&nbsp;const double chanceToSurvive<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= chanceToSurviveSpecies(bird.descent, mParameters.surviveSpeciesAlpha, mParameters.surviveSpeciesBeta);<br/>
&nbsp;&nbsp;//const double chanceToSurvive = 1.0 - (mParameters.surviveSpeciesAlpha *<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;std::exp(-mParameters.surviveSpeciesBeta * bird.descent * bird.descent));<br/>
&nbsp;&nbsp;assert(chanceToSurvive&gt;=0.0 &amp;&amp; chanceToSurvive&lt;=1.0);<br/>
&nbsp;&nbsp;//Dot("bird.descent: " + FloatToStr(bird.descent)<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;+ ", chance to survive: " + FloatToStr(chanceToSurvive));<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; chanceToSurvive) return true;<br/>
&nbsp;&nbsp;else return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool Simulation::willDieTrait(const Male&amp; male)<br/>
{<br/>
&nbsp;&nbsp;const double chanceToSurvive = chanceToSurviveTrait(male.trait, mParameters.costTrait);<br/>
&nbsp;&nbsp;//const double chanceToSurvive<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;= std::exp(-mParameters.costTrait * male.trait * male.trait);<br/>
&nbsp;&nbsp;assert(chanceToSurvive&gt;=0.0 &amp;&amp; chanceToSurvive&lt;=1.0);<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; chanceToSurvive) return true;<br/>
&nbsp;&nbsp;else return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool Simulation::willDiePreference(const Female&amp; female)<br/>
{<br/>
&nbsp;&nbsp;const double chanceToSurvive<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;= std::exp(-mParameters.costPreference * female.preference * female.preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= chanceToSurvivePreference(female.preference, mParameters.costPreference);<br/>
&nbsp;&nbsp;assert(chanceToSurvive&gt;=0.0 &amp;&amp; chanceToSurvive&lt;=1.0);<br/>
&nbsp;&nbsp;if (rnd::uniform() &gt; chanceToSurvive) return true;<br/>
&nbsp;&nbsp;else return false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::setMatingSystem(<br/>
&nbsp;&nbsp;const enumMatingSystem&amp; matingSystem,<br/>
&nbsp;&nbsp;const enumDensityDependentSelection&amp; selection)<br/>
{<br/>
&nbsp;&nbsp;setDensityDependentSelection(selection);<br/>
<br/>
&nbsp;&nbsp;switch(selection)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Selection after mating<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case afterMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(matingSystem)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case monogamy:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemMonogamyFixedNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case polygyny:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemPolygynyFixedNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown mating system"); std::exit(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Selection before mating<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case beforeMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(matingSystem)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case monogamy:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemMonogamyFreeNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case polygyny:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMatingSystem.reset(new StateMatingSystemPolygynyFreeNumberOffspring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unknown mating system"); std::exit(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown enumDensityDependentSelection"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot("Mating system set to: " + mMatingSystem-&gt;getMatingSystem());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::setFemaleSampling(const enumFemaleSampling&amp; femaleSampling)<br/>
{<br/>
&nbsp;&nbsp;switch(femaleSampling)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNconspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingBestOfNconspicific);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNextremeTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingBestOfNextremeTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case bestOfNclosestTrait:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingBestOfNclosestTrait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdConspicific:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingFixedThresholdConspicific);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdTraitSign:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingFixedThresholdTraitSign);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case fixedThresholdProbabilistic:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFemaleSampling.reset(new StateFemaleSamplingFixedThresholdProbabilistic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown female sampling"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot("Female sampling set to: " + mFemaleSampling-&gt;getFemaleSampling());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void Simulation::setDensityDependentSelection(const enumDensityDependentSelection&amp; selection)<br/>
{<br/>
&nbsp;&nbsp;switch(selection)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case beforeMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mDensityDependentSelection.reset(new StateDensityDependentSelectionBeforeMating);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case afterMating:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mDensityDependentSelection.reset(new StateDensityDependentSelectionAfterMating);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unknown enumDensityDependentSelection"); std::exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Dot("Density dependent selection set to: " + mDensityDependentSelection-&gt;getString());<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double Simulation::chanceToSurviveSpecies(const double&amp; descent, const double&amp; alpha, const double&amp; beta)<br/>
{<br/>
&nbsp;&nbsp;return 1.0 - (alpha * std::exp(-beta * descent * descent));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double Simulation::chanceToSurviveTrait(const double&amp; trait, const double&amp; costTrait)<br/>
{<br/>
&nbsp;&nbsp;return&nbsp;&nbsp;std::exp(-costTrait * trait * trait);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
inline double Simulation::chanceToSurvivePreference(const double&amp; preference, const double&amp; costPreference)<br/>
{<br/>
&nbsp;&nbsp;return&nbsp;&nbsp;std::exp(-costPreference * preference * preference);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitSimulation.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitSimulation.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitSimulationH<br/>
#define UnitSimulationH<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;math&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
<br/>
#include "UnitEnums.h"<br/>
#include "UnitParameters.h"<br/>
#include "UnitTallies.h"<br/>
#include "UnitHelperFunctions.h"<br/>
#include "UnitTimeSeries.h"<br/>
#include "UnitBird.h"<br/>
<br/>
//Forward declarations of States<br/>
class StateMatingSystemBase;<br/>
class StateFemaleSamplingBase;<br/>
class StateDensityDependentSelectionBase;<br/>
<br/>
class Simulation<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;std::string mError;<br/>
&nbsp;&nbsp;Simulation(const Parameters&amp;);<br/>
&nbsp;&nbsp;void execute();<br/>
&nbsp;&nbsp;TimeSeries getTimeSeries() const { return mTimeSeries; }<br/>
&nbsp;&nbsp;void setMatingSystem(const enumMatingSystem&amp;, const enumDensityDependentSelection&amp;);<br/>
<br/>
&nbsp;&nbsp;void setFemaleSampling(const enumFemaleSampling&amp;);<br/>
&nbsp;&nbsp;void setDensityDependentSelection(const enumDensityDependentSelection&amp;);<br/>
<br/>
&nbsp;&nbsp;//void showPopulation(TStringGrid * stringGrid) const;<br/>
&nbsp;&nbsp;static inline double chanceToSurviveSpecies(const double&amp; descent, const double&amp; alpha, const double&amp; beta);<br/>
&nbsp;&nbsp;static inline double chanceToSurviveTrait(const double&amp; trait, const double&amp; costTrait);<br/>
&nbsp;&nbsp;static inline double chanceToSurvivePreference(const double&amp; preference, const double&amp; costPreference);<br/>
<br/>
&nbsp;&nbsp;//Debugging<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;const Parameters mParameters;<br/>
<br/>
&nbsp;&nbsp;void speciesSelection();<br/>
&nbsp;&nbsp;void viabilitySelection();<br/>
&nbsp;&nbsp;bool willDieSpecies(const Bird&amp; bird);<br/>
&nbsp;&nbsp;bool willDiePreference(const Female&amp; female);<br/>
&nbsp;&nbsp;bool willDieTrait(const Male&amp; male);<br/>
<br/>
&nbsp;&nbsp;void mating();<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateMatingSystemBase&gt; mMatingSystem;<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateFemaleSamplingBase&gt; mFemaleSampling;<br/>
&nbsp;&nbsp;std::auto_ptr&lt;StateDensityDependentSelectionBase&gt; mDensityDependentSelection;<br/>
&nbsp;&nbsp;std::auto_ptr&lt;MateTally&gt; mMateTally;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; mMales;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; mFemales;<br/>
&nbsp;&nbsp;std::vector&lt;Bird&gt; mOffspring;<br/>
&nbsp;&nbsp;TimeSeries mTimeSeries;<br/>
};<br/>
<br/>
<br/>
#include "UnitFemaleSampling.h"<br/>
#include "UnitMatingSystem.h"<br/>
#include "UnitDensityDependentSelection.h"<br/>
<br/>
//void calculateTimePoint(const unsigned int&amp; generation, TimeSeries&amp; timeSeries, std::auto_ptr&lt;MateTally&gt;&amp; mateTally);<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitTallies.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitTallies.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
#include "UnitTallies.h"<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::reset()<br/>
{<br/>
&nbsp;&nbsp;nMateAA = 0;<br/>
&nbsp;&nbsp;nMateAB = 0;<br/>
&nbsp;&nbsp;nMateBA = 0;<br/>
&nbsp;&nbsp;nMateBB = 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::operator/=(const unsigned int&amp; intValue)<br/>
{<br/>
&nbsp;&nbsp;nMateAA/=intValue;<br/>
&nbsp;&nbsp;nMateAB/=intValue;<br/>
&nbsp;&nbsp;nMateBA/=intValue;<br/>
&nbsp;&nbsp;nMateBB/=intValue;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::operator+=(const MateTally&amp; mateTally)<br/>
{<br/>
&nbsp;&nbsp;nMateAA+=mateTally.nMateAA;<br/>
&nbsp;&nbsp;nMateAB+=mateTally.nMateAB;<br/>
&nbsp;&nbsp;nMateBA+=mateTally.nMateBA;<br/>
&nbsp;&nbsp;nMateBB+=mateTally.nMateBB;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
std::string MateTally::get() const<br/>
{<br/>
&nbsp;&nbsp;std::string result;<br/>
&nbsp;&nbsp;result+= "nMateAA: " + itoa(nMateAA);<br/>
&nbsp;&nbsp;result+= " ,nMateAB: " + itoa(nMateAB);<br/>
&nbsp;&nbsp;result+= " ,nMateBA: " + itoa(nMateBA);<br/>
&nbsp;&nbsp;result+= " ,nMateBB: " + itoa(nMateBB);<br/>
&nbsp;&nbsp;return result;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool MateTally::isNull() const<br/>
{<br/>
&nbsp;&nbsp;if ( nMateAA!=0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| nMateAB!=0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| nMateBA!=0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| nMateBB!=0) return false;<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void MateTally::tally(const Bird&amp; mother, const Bird&amp; father)<br/>
{<br/>
&nbsp;&nbsp;if (mother.species == piedFlycatcher)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (father.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateAA; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateAB; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (father.species == piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateBA; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ ++nMateBB; }<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
double MateTally::calculateBiasA() const<br/>
{<br/>
&nbsp;&nbsp;return (nMateAB + nMateBA == 0 ? 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: static_cast&lt;double&gt;(nMateAB) / static_cast&lt;double&gt;(nMateAB + nMateBA));<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
double MateTally::calculateBiasB() const<br/>
{<br/>
&nbsp;&nbsp;return (nMateAB + nMateBA == 0 ? 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: static_cast&lt;double&gt;(nMateBA) / static_cast&lt;double&gt;(nMateAB + nMateBA));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
double MateTally::calculateFractionMixedPairs() const<br/>
{<br/>
&nbsp;&nbsp;return (this-&gt;isNull()==true ? 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: static_cast&lt;double&gt;(nMateAB + nMateBA) / static_cast&lt;double&gt;(nMateAA + nMateAB + nMateBA + nMateBB));<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::tallySpecies(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males)<br/>
{<br/>
&nbsp;&nbsp;//Females first<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nFemales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const enumSpecies species = females[i].species;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (species==piedFlycatcher) ++(nFemalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nFemalesB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Tally the men<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nMales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const enumSpecies species = males[i].species;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (species==piedFlycatcher) ++(nMalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nMalesB);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;//Females first<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nFemales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double descent = females[i].descent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (descent &lt; -0.5)&nbsp;&nbsp;&nbsp;&nbsp; ++(nFemalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.0) ++(nFemaleHybridsA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.5) ++(nFemaleHybridsB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nFemalesB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Tally the men<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nMales; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double descent = males[i].descent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (descent &lt; -0.5)&nbsp;&nbsp;&nbsp;&nbsp; ++(nMalesA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.0) ++(nMaleHybridsA);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (descent &lt; 0.5) ++(nMaleHybridsB);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++(nMalesB);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*/<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::reset()<br/>
{<br/>
&nbsp;&nbsp;nMalesA = 0;<br/>
&nbsp;&nbsp;nMalesB = 0;<br/>
&nbsp;&nbsp;nFemalesA = 0;<br/>
&nbsp;&nbsp;nFemalesB = 0;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool SpeciesTally::isNull() const<br/>
{<br/>
&nbsp;&nbsp;if (nMalesA&gt;0) return false;<br/>
&nbsp;&nbsp;if (nMalesB&gt;0) return false;<br/>
&nbsp;&nbsp;if (nFemalesA&gt;0) return false;<br/>
&nbsp;&nbsp;if (nFemalesB&gt;0) return false;<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::operator+=(const SpeciesTally&amp; speciesTally)<br/>
{<br/>
&nbsp;&nbsp;nMalesA+=speciesTally.nMalesA;<br/>
&nbsp;&nbsp;nMalesB+=speciesTally.nMalesB;<br/>
&nbsp;&nbsp;nFemalesA+=speciesTally.nFemalesA;<br/>
&nbsp;&nbsp;nFemalesB+=speciesTally.nFemalesB;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void SpeciesTally::operator/=(const unsigned int&amp; intValue)<br/>
{<br/>
&nbsp;&nbsp;nMalesA/=intValue;<br/>
&nbsp;&nbsp;nMalesB/=intValue;<br/>
&nbsp;&nbsp;nFemalesA/=intValue;<br/>
&nbsp;&nbsp;nFemalesB/=intValue;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitTallies.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitTallies.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitTalliesH<br/>
#define UnitTalliesH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "UnitBird.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
class MateTally<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;MateTally() { reset(); }<br/>
&nbsp;&nbsp;void tally(const Bird&amp; mother, const Bird&amp; father);<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;std::string get() const;<br/>
&nbsp;&nbsp;bool isNull() const;<br/>
&nbsp;&nbsp;double calculateBiasA() const;<br/>
&nbsp;&nbsp;double calculateBiasB() const;<br/>
&nbsp;&nbsp;double calculateFractionMixedPairs() const;<br/>
<br/>
&nbsp;&nbsp;unsigned int getNmateAA() const { return nMateAA; } //Female A - male A<br/>
&nbsp;&nbsp;unsigned int getNmateAB() const { return nMateAB; } //Female A - male B<br/>
&nbsp;&nbsp;unsigned int getNmateBA() const { return nMateBA; } //Female B - male A<br/>
&nbsp;&nbsp;unsigned int getNmateBB() const { return nMateBB; } //Female B - male B<br/>
&nbsp;&nbsp;unsigned int getNmateAll() const { return nMateAA + nMateAB + nMateBA + nMateBB; }<br/>
<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; intValue);<br/>
&nbsp;&nbsp;void operator+=(const MateTally&amp;&nbsp;&nbsp;mateTally);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;unsigned int nMateAA; //Female A - male A<br/>
&nbsp;&nbsp;unsigned int nMateAB; //Female A - male B<br/>
&nbsp;&nbsp;unsigned int nMateBA; //Female B - male A<br/>
&nbsp;&nbsp;unsigned int nMateBB; //Female B - male B<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
class SpeciesTally<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;SpeciesTally() { reset(); }<br/>
&nbsp;&nbsp;SpeciesTally(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reset();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tallySpecies(females,males);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;bool isNull() const;<br/>
&nbsp;&nbsp;void tallySpecies(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males);<br/>
&nbsp;&nbsp;void operator+=(const SpeciesTally&amp; speciesTally);<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; intValue);<br/>
<br/>
&nbsp;&nbsp;//Plain retrieval<br/>
&nbsp;&nbsp;unsigned int getNmalesA()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nMalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;unsigned int getNmalesB()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nMalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;unsigned int getNfemalesA()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nFemalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;unsigned int getNfemalesB()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return nFemalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;//Some group retrieval<br/>
&nbsp;&nbsp;unsigned int getNallMalesA()&nbsp;&nbsp; const { return nMalesA; }<br/>
&nbsp;&nbsp;unsigned int getNallMalesB()&nbsp;&nbsp; const { return nMalesB; }<br/>
&nbsp;&nbsp;unsigned int getNallMales()&nbsp;&nbsp;&nbsp;&nbsp;const { return nMalesA + nMalesB; }<br/>
&nbsp;&nbsp;unsigned int getNallFemalesA() const { return nFemalesA; }<br/>
&nbsp;&nbsp;unsigned int getNallFemalesB() const { return nFemalesB; }<br/>
&nbsp;&nbsp;unsigned int getNallFemales()&nbsp;&nbsp;const { return nFemalesA + nFemalesB; }<br/>
&nbsp;&nbsp;unsigned int getNall()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return getNallFemales() + getNallMales(); }<br/>
<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;unsigned int getNallMalesA()&nbsp;&nbsp; const { return nMalesA + nMaleHybridsA; }<br/>
&nbsp;&nbsp;unsigned int getNallMalesB()&nbsp;&nbsp; const { return nMalesB + nMaleHybridsB; }<br/>
&nbsp;&nbsp;unsigned int getNallMales()&nbsp;&nbsp;&nbsp;&nbsp;const { return nMalesA + nMaleHybridsA + nMalesB + nMaleHybridsB; }<br/>
&nbsp;&nbsp;unsigned int getNallFemalesA() const { return nFemalesA + nFemaleHybridsA; }<br/>
&nbsp;&nbsp;unsigned int getNallFemalesB() const { return nFemalesB + nFemaleHybridsB; }<br/>
&nbsp;&nbsp;unsigned int getNallFemales()&nbsp;&nbsp;const { return nFemalesA + nFemaleHybridsA + nFemalesB + nFemaleHybridsB; }<br/>
&nbsp;&nbsp;unsigned int getNall()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const { return getNallFemales() + getNallMales(); }<br/>
&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;//The private variables it is all about<br/>
&nbsp;&nbsp;unsigned int nMalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &lt; -0.5<br/>
&nbsp;&nbsp;unsigned int nMalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &gt; 0.5<br/>
&nbsp;&nbsp;unsigned int nFemalesA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &lt; -0.5<br/>
&nbsp;&nbsp;unsigned int nFemalesB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SpeciesValue &gt; 0.5<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitThreeDotsChasing.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitThreeDotsChasing.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vcl.h&gt;<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitThreeDotsChasing.h"<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
#pragma resource "*.dfm"<br/>
TFormThreeDotsChasing *FormThreeDotsChasing;<br/>
//---------------------------------------------------------------------------<br/>
__fastcall TFormThreeDotsChasing::TFormThreeDotsChasing(TComponent* Owner)<br/>
&nbsp;&nbsp;: TForm(Owner)<br/>
{<br/>
&nbsp;&nbsp;points.resize(4);<br/>
&nbsp;&nbsp;std::srand(clock());<br/>
<br/>
&nbsp;&nbsp;FormResize(0);<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormThreeDotsChasing::ApplicationEvents1Idle(TObject *Sender, bool &amp;Done)<br/>
{<br/>
&nbsp;&nbsp;//++count;<br/>
&nbsp;&nbsp;//this-&gt;Caption = count;<br/>
<br/>
&nbsp;&nbsp;const char nPoints = points.size();<br/>
&nbsp;&nbsp;const short maxy = Image1-&gt;Height;<br/>
&nbsp;&nbsp;const short maxx = Image1-&gt;Width;<br/>
&nbsp;&nbsp;for (char i=0; i&lt;nPoints; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const char other = (i+1)%nPoints;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(other&gt;=0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(other&lt;nPoints);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].x &lt; points[other].x) ++(points[i].dx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else --(points[i].dx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].y &lt; points[other].y) ++(points[i].dy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else --(points[i].dy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].x+=points[i].dx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].x&lt;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].x=0; points[i].dx = -points[i].dx; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (points[i].x&gt;=maxx)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].x=maxx-1; points[i].dx = -points[i].dx; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].y+=points[i].dy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (points[i].y&lt;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].y=0; points[i].dy = -points[i].dy; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (points[i].y&gt;=maxy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ points[i].y=maxy-1; points[i].dy = -points[i].dy; }<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;unsigned char * pLine;<br/>
&nbsp;&nbsp;for (short y=0; y&lt;maxy; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pLine=static_cast&lt;unsigned char *&gt;(Image1-&gt;Picture-&gt;Bitmap-&gt;ScanLine[y]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (short x=0; x&lt;maxx; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexRedX&nbsp;&nbsp; = abs(x-points[0].x)%maxx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexRedY&nbsp;&nbsp; = abs(y-points[0].y)%maxy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexGreenX = abs(x-points[1].x)%maxx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexGreenY = abs(y-points[1].y)%maxy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexBlueX&nbsp;&nbsp;= abs(x-points[2].x)%maxx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const short indexBlueY&nbsp;&nbsp;= abs(y-points[2].y)%maxy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedX&nbsp;&nbsp; &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenX &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueX&nbsp;&nbsp;&gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedY&nbsp;&nbsp; &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenY &gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueY&nbsp;&nbsp;&gt;= 0 );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedX&nbsp;&nbsp; &lt; this-&gt;ClientWidth);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenX &lt; this-&gt;ClientWidth);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueX&nbsp;&nbsp;&lt; this-&gt;ClientWidth);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexRedY&nbsp;&nbsp; &lt; this-&gt;ClientHeight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexGreenY &lt; this-&gt;ClientHeight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indexBlueY&nbsp;&nbsp;&lt; this-&gt;ClientHeight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pLine[x*3+0]= distance[indexBlueX ][indexBlueY ]; //Blue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pLine[x*3+1]= distance[indexGreenX][indexGreenY]; //Green<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pLine[x*3+2]= distance[indexRedX&nbsp;&nbsp;][indexRedY&nbsp;&nbsp;]; //Red<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;this-&gt;Canvas-&gt;Draw(0,0,Image1-&gt;Picture-&gt;Graphic);<br/>
&nbsp;&nbsp;Done = false;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormThreeDotsChasing::FormClick(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;resetPoints();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TFormThreeDotsChasing::resetPoints()<br/>
{<br/>
&nbsp;&nbsp;const short width&nbsp;&nbsp;= this-&gt;ClientWidth;<br/>
&nbsp;&nbsp;const short height = this-&gt;ClientHeight;<br/>
&nbsp;&nbsp;const char nPoints = points.size();<br/>
&nbsp;&nbsp;for (int i=0; i&lt;nPoints; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].x = std::rand()%width;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].y = std::rand()%height;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].dx = (std::rand()%5)-2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points[i].dy = (std::rand()%5)-2;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void __fastcall TFormThreeDotsChasing::FormResize(TObject *Sender)<br/>
{<br/>
&nbsp;&nbsp;//Generate vectors for look-up table<br/>
&nbsp;&nbsp;const short width&nbsp;&nbsp;= this-&gt;ClientWidth;<br/>
&nbsp;&nbsp;const short height = this-&gt;ClientHeight;<br/>
<br/>
&nbsp;&nbsp;distance.resize(width);<br/>
&nbsp;&nbsp;for (int i=0; i&lt;width; ++i) distance[i].resize(height);<br/>
<br/>
&nbsp;&nbsp;//Generate look-up table<br/>
&nbsp;&nbsp;const double widthD&nbsp;&nbsp;= static_cast&lt;double&gt;(width);<br/>
&nbsp;&nbsp;const double heightD = static_cast&lt;double&gt;(height);<br/>
&nbsp;&nbsp;const double maxDist = sqrt( (widthD*widthD) + (heightD*heightD) );<br/>
&nbsp;&nbsp;for (int x=0; x&lt;width; ++x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int y=0; y&lt;height; ++y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double xD = static_cast&lt;double&gt;(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double yD = static_cast&lt;double&gt;(y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double dist = sqrt( (xD*xD) + (yD*yD) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//distance[x][y] = 256.0 * dist / maxDist;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance[x][y] = 255.0 * std::exp(-dist/150.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Points<br/>
&nbsp;&nbsp;resetPoints();<br/>
&nbsp;&nbsp;//Create image<br/>
&nbsp;&nbsp;Image1-&gt;Picture-&gt;Bitmap-&gt;Width&nbsp;&nbsp;= width;<br/>
&nbsp;&nbsp;Image1-&gt;Picture-&gt;Bitmap-&gt;Height = height;<br/>
<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitThreeDotsChasing.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitThreeDotsChasing.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitThreeDotsChasingH<br/>
#define UnitThreeDotsChasingH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;Classes.hpp&gt;<br/>
#include &lt;Controls.hpp&gt;<br/>
#include &lt;StdCtrls.hpp&gt;<br/>
#include &lt;Forms.hpp&gt;<br/>
#include &lt;AppEvnts.hpp&gt;<br/>
#include &lt;ExtCtrls.hpp&gt;<br/>
#include &lt;Graphics.hpp&gt;<br/>
//---------------------------------------------------------------------------<br/>
#define NDEBUG<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert&gt;<br/>
#include &lt;math&gt;<br/>
#include &lt;time&gt;<br/>
//---------------------------------------------------------------------------<br/>
class TFormThreeDotsChasing : public TForm<br/>
{<br/>
__published:	// IDE-managed Components<br/>
&nbsp;&nbsp;TImage *Image1;<br/>
&nbsp;&nbsp;TApplicationEvents *ApplicationEvents1;<br/>
&nbsp;&nbsp;void __fastcall ApplicationEvents1Idle(TObject *Sender, bool &amp;Done);<br/>
&nbsp;&nbsp;void __fastcall FormClick(TObject *Sender);<br/>
&nbsp;&nbsp;void __fastcall FormResize(TObject *Sender);<br/>
private:	// User declarations<br/>
public:		// User declarations<br/>
&nbsp;&nbsp;__fastcall TFormThreeDotsChasing(TComponent* Owner);<br/>
&nbsp;&nbsp;//int count;<br/>
&nbsp;&nbsp;std::vector&lt; std::vector&lt;unsigned char&gt; &gt; distance;<br/>
<br/>
&nbsp;&nbsp;struct Point<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;short x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;short y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char dx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char dy;<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;short abs(const short&amp; i) { return (i&lt;0 ? -i : i); }<br/>
&nbsp;&nbsp;std::vector&lt; Point &gt; points;<br/>
&nbsp;&nbsp;void resetPoints();<br/>
};<br/>
//---------------------------------------------------------------------------<br/>
extern PACKAGE TFormThreeDotsChasing *FormThreeDotsChasing;<br/>
//---------------------------------------------------------------------------<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitTimePoint.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitTimePoint.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitTimePoint.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
void TimePoint::reset()<br/>
{<br/>
&nbsp;&nbsp;traits.resize(0);<br/>
&nbsp;&nbsp;preferences.resize(0);<br/>
&nbsp;&nbsp;descents.resize(0);<br/>
&nbsp;&nbsp;mateTally.reset();<br/>
&nbsp;&nbsp;speciesTallyOffspring.reset();<br/>
&nbsp;&nbsp;speciesTallyAfterSpeciesSelection.reset();<br/>
&nbsp;&nbsp;speciesTallyAfterTraitSelection.reset();<br/>
&nbsp;&nbsp;speciesTallyAfterDensityDependentSelection.reset();<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
bool TimePoint::isNull() const<br/>
{<br/>
&nbsp;&nbsp;if (traits.size()&gt;0) return false;<br/>
&nbsp;&nbsp;if (preferences.size()&gt;0) return false;<br/>
&nbsp;&nbsp;if (descents.size()&gt;0) return false;<br/>
&nbsp;&nbsp;if (mateTally.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyOffspring.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyAfterSpeciesSelection.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyAfterTraitSelection.isNull()==false) return false;<br/>
&nbsp;&nbsp;if (speciesTallyAfterDensityDependentSelection.isNull()==false) return false;<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void TimePoint::getSample(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int sampleSize = 2;<br/>
&nbsp;&nbsp;//Get sample of female preferences<br/>
&nbsp;&nbsp;unsigned int nFemalesA = 0, nFemalesB = 0;<br/>
&nbsp;&nbsp;const unsigned int nFemales = females.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nFemales ; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (females[i].species==piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesA&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferences.push_back(females[i].preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(females[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nFemalesA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesB&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferences.push_back(females[i].preference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(females[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nFemalesB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (nFemalesA==sampleSize &amp;&amp; nFemalesB==sampleSize) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nFemalesA&lt;=sampleSize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nFemalesB&lt;=sampleSize);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Get sample of male traits<br/>
&nbsp;&nbsp;unsigned int nMalesA = 0, nMalesB = 0;<br/>
&nbsp;&nbsp;const unsigned int nMales = males.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;nMales ; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (males[i].species==piedFlycatcher)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesA&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traits.push_back(males[i].trait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(males[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nMalesA;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesB&lt;sampleSize)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traits.push_back(males[i].trait);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descents.push_back(males[i].descent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++nMalesB;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (nMalesA==sampleSize &amp;&amp; nMalesB==sampleSize) break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nMalesA&lt;=sampleSize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(nMalesB&lt;=sampleSize);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
//---------------------------------------------------------------------------<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitTimePoint.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitTimePoint.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitTimePointH<br/>
#define UnitTimePointH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;algorithm&gt;<br/>
#include "UnitTallies.h"<br/>
<br/>
class TimePoint<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;TimePoint() { reset(); }<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; traits;<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; preferences;<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; descents;<br/>
&nbsp;&nbsp;MateTally mateTally;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyOffspring;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyAfterSpeciesSelection;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyAfterTraitSelection;<br/>
&nbsp;&nbsp;SpeciesTally speciesTallyAfterDensityDependentSelection;<br/>
<br/>
&nbsp;&nbsp;void reset();<br/>
&nbsp;&nbsp;bool isNull() const;<br/>
&nbsp;&nbsp;void getSample(const std::vector&lt;Female&gt;&amp; females, const std::vector&lt;Male&gt;&amp; males);<br/>
<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; valueInt) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double value = static_cast&lt;double&gt;(valueInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyOffspring/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterSpeciesSelection/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterTraitSelection/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterDensityDependentSelection/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::random_shuffle(traits.begin(),traits.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::random_shuffle(preferences.begin(),preferences.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::random_shuffle(descents.begin(),descents.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;traits.resize(traits.size()/valueInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;preferences.resize(preferences.size()/valueInt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;descents.resize(descents.size()/valueInt);<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;void operator+=(const TimePoint&amp; timePoint) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mateTally+=timePoint.mateTally;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyOffspring+=timePoint.speciesTallyOffspring;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterSpeciesSelection+=timePoint.speciesTallyAfterSpeciesSelection;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterTraitSelection+=timePoint.speciesTallyAfterTraitSelection;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;speciesTallyAfterDensityDependentSelection+=timePoint.speciesTallyAfterDensityDependentSelection;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int traitSize = timePoint.traits.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;traitSize; ++i) traits.push_back(timePoint.traits[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int preferenceSize = timePoint.preferences.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;preferenceSize; ++i) preferences.push_back(timePoint.preferences[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int descentSize = timePoint.descents.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;descentSize; ++i) descents.push_back(timePoint.descents[i]);<br/>
&nbsp;&nbsp;}<br/>
};<br/>
<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitTimeSeries.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitTimeSeries.cpp" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#pragma hdrstop<br/>
<br/>
#include "UnitTimeSeries.h"<br/>
<br/>
//---------------------------------------------------------------------------<br/>
void getMeanAndStdErrorEndPoint(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimePoint&amp; mean, TimePoint&amp; stdError)<br/>
{<br/>
&nbsp;&nbsp;assert(mean.isNull()==true);<br/>
&nbsp;&nbsp;assert(stdError.isNull()==true);<br/>
<br/>
&nbsp;&nbsp;//Only set: biasA, biasB, fractionMixedPairs<br/>
<br/>
&nbsp;&nbsp;const unsigned int nTimeSeries = timeSeries.size();<br/>
&nbsp;&nbsp;for (unsigned i=0; i&lt;nTimeSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Get the index of the final index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int time = timeSeries[i].timePoints.size() - 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mean += timeSeries[i].timePoints[time];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;mean/=nTimeSeries;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
void getMeanAndStdErrorTimeSeries(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimeSeries&amp; mean, TimeSeries&amp; stdError)<br/>
{<br/>
&nbsp;&nbsp;assert(mean.isNull()==true);<br/>
&nbsp;&nbsp;mean = timeSeries[0];<br/>
&nbsp;&nbsp;const unsigned int nTimeSeries = timeSeries.size();<br/>
&nbsp;&nbsp;for (unsigned i=1; i&lt;nTimeSeries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Get the index of the final index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mean += timeSeries[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;mean/=nTimeSeries;<br/>
}<br/>
//---------------------------------------------------------------------------<br/>
<br/>
#pragma package(smart_init)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectChrisWiley/CppBuilderFinal/UnitTimeSeries.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectChrisWiley/CppBuilderFinal/UnitTimeSeries.h" border = "1"><tr><td><code>
//---------------------------------------------------------------------------<br/>
/*<br/>
&nbsp;&nbsp;The Chris Wiley Project, simulation on mixed-pair mating<br/>
&nbsp;&nbsp;Copyright (C) 2009&nbsp;&nbsp;Richel Bilderbeek<br/>
<br/>
&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
*/<br/>
//---------------------------------------------------------------------------<br/>
// From http://www.richelbilderbeek.nl<br/>
//---------------------------------------------------------------------------<br/>
#ifndef UnitTimeSeriesH<br/>
#define UnitTimeSeriesH<br/>
//---------------------------------------------------------------------------<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert.h&gt;<br/>
//#include &lt;algorithm&gt;<br/>
//#include &lt;math&gt;<br/>
//#include &lt;iterator&gt;<br/>
#include "UnitTimePoint.h"<br/>
<br/>
class TimeSeries<br/>
{<br/>
&nbsp;&nbsp;public:<br/>
&nbsp;&nbsp;std::vector&lt;TimePoint&gt; timePoints;<br/>
&nbsp;&nbsp;bool isNull() const<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (timePoints.size()&gt;0) return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;void operator+=(const TimeSeries&amp; timeSeries) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTimePoints = timePoints.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(timeSeries.timePoints.size()==nTimePoints);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nTimePoints; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timePoints[i]+=timeSeries.timePoints[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;void operator/=(const unsigned int&amp; valueInt) //For taking the average of multiple timepoints<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nTimePoints = timePoints.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned i=0; i&lt;nTimePoints; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timePoints[i]/=valueInt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
};<br/>
<br/>
void getMeanAndStdErrorEndPoint(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimePoint&amp; mean, TimePoint&amp; stdError);<br/>
void getMeanAndStdErrorTimeSeries(const std::vector&lt;TimeSeries&gt;&amp; timeSeries, TimeSeries&amp; mean, TimeSeries&amp; stdError);<br/>
<br/>
//TimeSeries getAverageTimeSeries(const std::vector&lt;TimeSeries&gt;&amp; timeSeries);<br/>
//TimePoint getAverageEndTimePoint(const std::vector&lt;TimeSeries&gt;&amp; timeSeries);<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
