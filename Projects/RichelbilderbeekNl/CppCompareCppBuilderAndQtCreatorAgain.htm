<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>Comparison of C++ Builder and Qt Creator again...</title>
  <meta name="description" content="C++ Comparison of C++ Builder and Qt Creator"/>
  <meta name="keywords" content="C++ compare comparison of C++ Builder and Qt Creator IDE Integrated Development Environment"/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppCompareCppBuilderAndQtCreatorAgain.htm">Comparison of C++ Builder and Qt Creator again...</a></h1>
<p>&nbsp;</p>
<p>This article is the successor of <a href="CppCompareCppBuilderAndQtCreator.htm">Comparison of C++ Builder and Qt Creator</a> and is written three months later (at the 23rd of Agust 2010).</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Quick facts chart</h2>
<p>&nbsp;</p>
<table border="1">
  <tr>
    <td><p><b>Criterium</b></p></td>
    <td><p><b><a href="CppBuilder.htm">C++ Builder</a> 6.0 Enterprise edition</b></p></td>
    <td><p><b><a href="CppQtCreator.htm">Qt Creator</a> 1.3.1</b></p></td>
  </tr>
  <tr>
    <td><p><b>Owner</b></p></td>
    <td><p><a href="http://www.embarcadero.com">Embarcadero Technologies</a></p></td>
    <td><p><a href="http://qt.nokia.com">Qt Development Frameworks</a></p></td>
  </tr>
  <tr>
    <td><p><b>Year of release</b></p></td>
    <td><p>2002</p></td>
    <td><p>2010</p></td>
  </tr>
  <tr>
    <td><p><b><a href="CppLicence.htm">Licence</a></b></p></td>
    <td><p>Proprietary</p></td>
    <td><p>GPL and commercial</p></td>
  </tr>
  <tr>
    <td><p><b>Supported operating systems </b></p></td>
    <td><p>Windows</p></td>
    <td><p>Linux, Mac, Windows</p></td>
  </tr>
  <tr>
    <td><p><b>How to deploy on other platform</b></p></td>
    <td><p>Use emulator on Windows executable</p></td>
    <td><p>Compile code on other platform</p></td>
  </tr>
  <tr>
    <td><p><b>Default supplied <a href="CppCompiler.htm">compiler</a></b></p></td>
    <td><p>Borland <a href="CppBcc32Exe.htm">BCC32.EXE</a> version 6.0.10.157</p></td>
    <td><p><a href="CppGpp.htm">G++</a> version 4.4.1</p></td>
  </tr>
  <tr>
    <td><p><b><a href="CppBoost.htm">Boost</a> <a href="CppCompiler.htm">compiler</a> support</b></p></td>
    <td><p>About 20-60%: <a href="CppBcc32Exe.htm">BCC32.EXE</a> is an unsupported <a href="CppCompiler.htm">compiler</a></p></td>
    <td><p>100% (can this be true?): <a href="CppGpp.htm">G++</a> is a supported <a href="CppCompiler.htm">compiler</a></p></td>
  </tr>
  <tr>
    <td><p><b>Supplied with <a href="CppLibrary.htm">libraries</a></b></p></td>
    <td><p><a href="CppClx.htm">CLX</a>, <a href="CppOpenGl.htm">OpenGL</a>, <a href="CppStl.htm">STL</a>, <a href="CppVcl.htm">VCL</a></p></td>
    <td><p><a href="CppOpenGl.htm">OpenGL</a>, <a href="CppStl.htm">STL</a>, <a href="CppQt.htm">Qt4</a></p></td>
  </tr>
  <tr>
    <td><p><b><a href="Cpp0x.htm">Cpp0x</a> adoption</b></p></td>
    <td><p>Pre-standard adoption (in RAD Studio)</p></td>
    <td><p>Adoption after publication of official <a href="Cpp0x.htm">Cpp0x</a> standard</p></td>
  </tr>
</table> 
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Discussion</h2>
<p>&nbsp;</p>
<p>Below, I discuss the three items I encountered most in detail: writing console applications, writing GUI applications and documentation needed to learn both <a href="CppIde.htm">IDEs</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Console applications</h3>
<p>&nbsp;</p>
<p>In the previous article, I stated that developing console applications in both <a href="CppIde.htm">IDE</a>'s was easy.
But not only does the <a href="CppQtCreator.htm">Qt Creator</a> support <a href="CppBoost.htm">Boost</a> fully (as far as I know), but 
an enormous amount of other <a href="CppLibrary.htm">libraries</a> as well. This boosts (no pun intended)
productivity heavily! I do know that Embaracadero is working on this, 
for <a href="CppBuilder.htm">C++ Builder</a>'s successor called for RAD Studio.</p>
<p>&nbsp;</p>
<p>What I did not highlight in the previous article, is that <a href="CppBuilder.htm">C++ Builder</a> and its
applications run under Windows only. Except for platform-specific <a href="CppLibrary.htm">libraries</a>,
I see no reason to limit oneself to Windows.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><a href="CppGui.htm">GUI</a> applications</h3>
<p>&nbsp;</p>
<p>In the previous article, I stated that the GUI designer in <a href="CppBuilder.htm">C++ Builder</a> was less cluttered with windows. 
To increase working space, I learned to set the Widget pane to 'Icon View', 
so I could push it to a width of two centimeters.
This does not work with the text-based sidebars on the right. 
I hope that in a future version, this sidebar can be hidden by a shortcut-key.</p>
<p>&nbsp;</p>
<p>I still believe that it is easier to learn <a href="CppBuilder.htm">C++ Builder</a>: 
one can use <a href="CppBuilder.htm">C++ Builder</a> without knowing how to design <a href="CppClass.htm">classes</a>. 
In <a href="CppQtCreator.htm">Qt Creator</a> one sometimes has implement sub-<a href="CppClass.htm">classes</a> and override behavior 
(for example, when one wants to imlement a clickable <a href="CppQLabel.htm">QLabel</a>). 
Although I believe this design choice of the Qt <a href="CppLibrary.htm">library</a> is good, 
I think it is more difficult for beginners: 
they will have to struggle with <a href="CppClass.htm">classes</a> first, 
before they will understand how to do this.</p>
<p>&nbsp;</p>
<p>What I did not mention earlier about the Qt and <a href="CppBuilder.htm">C++ Builder</a> architectures,
is that the Qt architecture is const-correct, unlike <a href="CppBuilder.htm">C++ Builder</a>. This
aspect makes it easier to understand Qt: a const method promises
not to modify its members. In <a href="CppBuilder.htm">C++ Builder</a>, this is not promised at all.</p>
<p>&nbsp;</p>
<p><a href="CppQLabel.htm">QLabel</a> is a QWidget to display both text and images. 
Why this is not seperated in two widgets remains unknown to me. 
And I discovered that <a href="CppQLabel.htm">QLabel</a> does not emit a signal when it is clicked. 
If <a href="CppQLabel.htm">QLabel</a> would only display text, I would agree with this design choice: 
a clickable label can be mimicked by a flat QButton. 
But I do wished that an image would emit a signal when clicked:
I use many images as flashy buttons. 
Personally, I would suggest two solutions to the problem:</p>
<ul>
  <li>(1) let <a href="CppQLabel.htm">QLabel</a> emit a signal when clicked, or</li>
  <li>(2) add a QImage widget that emits a signal when clicked</li>
</ul>
<p>&nbsp;</p>
<p>Adding a custom method to a dialog is still tedious in <a href="CppQtCreator.htm">Qt Creator</a>, but one gets used to it:</p>
<ul>
  <li>(1) add the declaration of the slot to the dialog's declaration, 
  for example 'private slots: void OnButtonClick();'</li>
  <li>(2) in the dialog constructor, connect a signal to this slot, 
  for example 'QObject::connect(ui->button,SIGNAL(clicked()),this,SLOT(OnButtonClick()));'</li>
  <li>(3) write down the method definition, 
  for example 'void Dialog::OnButtonClick() { /* your code */ }'</li>
</ul>
<p>In <a href="CppBuilder.htm">C++ Builder</a>r, this was done within three (really!) clicks: click on 'Events' of the Object Inspector,
then double-click on the signal you want to respond to.</p>
<p>&nbsp;</p>
<p>For the layout managent of the visual components,
I have learned to appreciate the work that all QLayouts do:
for simple layouts they do a great job.
But when I want to add certain constraints,
this still too often results in unexpected behaviour:
for example, I once had an application of which I could resize
the window to a bigger size, but it could not be resized to
a smaller surface.
So, I still think that the <a href="CppBuilder.htm">C++ Builder</a> TPanels
were more intuitive to use.</p>
<p>&nbsp;</p>
<p>
It hadn't occurred to me before, to note that <a href="CppQtCreator.htm">Qt Creator</a> does not have any non-visual QWidgets.
Sure, if a widget is visual by definition, this is logical.
But <a href="CppBuilder.htm">C++ Builder</a> supplied non-visual TComponents,
that could be placed on the window (but never be seen).
This has two advantages:</p>
<ul>
  <li>(1) it is easier, quicker and safer to manipulate widgets at design time.
For example, for the <a href="CppBuilder.htm">C++ Builder</a> TTimer, one can set the time, if it already runs, 
and which method gets called after timeout. From then on, the TTimer gets 
created and deleted by <a href="CppBuilder.htm">C++ Builder</a>. In <a href="CppQtCreator.htm">Qt Creator</a>, one have to write a QTimer
declaration, set its timeout, set if its started, connect it to a method,
and delete it, each by one line of code</li>
  <li>(2) a beginner can find the functionality needed and experiment with it.
  I find it hard to imagine how a beginner would discover to use a QTimer.
  In <a href="CppBuilder.htm">C++ Builder</a>, everybody will discover TTimer within the first hours</li>
</ul>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Documentation</h3>
<p>&nbsp;</p>
<p>I have learned that the Qt documentation is very good.
Note the word 'learned': the Qt documentation has a learning curve, due
to:</p>
<ul>
  <li>(1) when searching the documentation about a topic like '2D graphics', 
there are multiple ways (QPainter,QGraphicsView,<a href="CppQLabel.htm">QLabel</a>),
some ways using <a href="CppClass.htm">classes</a> that are connected to (for a beginner: too) many <a href="CppClass.htm">classes</a>, 
for example when trying to use QGraphicsView, QGraphicsScene and QGraphicsItem</li>
  <li>(2) if you do know the names, and/or do not understand to override virtual functions, 
for example 'paintEvent', it is unclear how to use some widgets. For example, if
you want to use a QPainter, the documentation states: 
'The common use of QPainter is inside a widget's paint event'.
Although the documentation subsequently shows how to override the method 'paintEvent',
I thought that 'paintEvent' was 'just a name'</li>
</ul>
<p>&nbsp;</p>
<p>So, if you understand the documentation of Qt, its content is as good as C++ Builder's.</p>
<p>&nbsp;</p>
<p>Still, there re two thingss:</p>
<ul>
  <li>(1) Because <a href="CppBuilder.htm">C++ Builder</a> is easier to learn (as I stated above), I nearly ever needed to use
its documentation for VCL <a href="CppClass.htm">classes</a></li>
  <li>(2) Unlike the Qt documentation, <a href="CppBuilder.htm">C++ Builder</a> also documents <a href="CppStl.htm">STL</a> classes</li>
</ul>
<p>&nbsp;</p>
<p>Summarizing this:</p>
<ul>
  <li>(1) The <a href="CppQtCreator.htm">Qt Creator</a> documentation documents its Qt <a href="CppClass.htm">classes</a> as well as <a href="CppBuilder.htm">C++ Builder</a> documents its VCL classes</li>
  <li>(2) The <a href="CppQtCreator.htm">Qt Creator</a> documentation takes time to understand, the <a href="CppBuilder.htm">C++ Builder</a> documentation is more intuitive</li>
  <li>(3) Unlike <a href="CppBuilder.htm">C++ Builder</a>, the <a href="CppQtCreator.htm">Qt Creator</a> documentation lacks <a href="CppStl.htm">STL</a> classes documentation</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Summary</h2>
<p>&nbsp;</p>
<table border="1">
  <tr>
    <td><p><b>Criterium</b></p></td>
    <td><p><b><a href="CppBuilder.htm">C++ Builder</a> 6.0 Enterprise edition</b></p></td>
    <td><p><b><a href="CppQtCreator.htm">Qt Creator</a> 1.3.1</b></p></td>
  </tr>
  <tr>
    <td><p><b>Development of console applications</b></p></td>
    <td><p>Similar, low <a href="CppBoost.htm">Boost</a> support</p></td>
    <td><p>Similar, high <a href="CppBoost.htm">Boost</a> support</p></td>
  </tr>
  <tr>
    <td><p><b>Initial <a href="CppMain.htm">main</a> <a href="CppFunction.htm">function</a> in console application</b></p></td>
    <td><p>Non-minimal, can be removed ruthlessly</p></td>
    <td><p>Non-minimal, can be removed ruthlessly</p></td>
  </tr>
  <tr>
    <td><p><b><a href="CppGui.htm">GUI</a> designer</b></p></td>
    <td><p>Plenty of screen space, all windows can be hidden in the same way, all windows have a shortcut key</p></td>
    <td><p>Screen cluttered with windows, different ways to hide and show most windows</p></td>
  </tr>
  <tr>
    <td><p><b>Ease of learning graphical <a href="CppLibrary.htm">library</a> used by <a href="CppGui.htm">GUI</a> designer</b></p></td>
    <td><p><a href="CppVcl.htm">VCL</a> has non-visual components (TTimer, for example) that a beginner can use without writing code</p></td>
    <td><p><a href="CppQt.htm">Qt</a> does not have non-visual widgets, so a QTimer's behavior must be written in code, which is harder and error-prone</p></td>
  </tr>
  <tr>
    <td><p><b>Component/widget architecture</b></p></td>
    <td><p>Clickable TLabel for labels, clickable <a href="CppTImage.htm">TImage</a> for images</p></td>
    <td><p>Non-clickable <a href="CppQLabel.htm">QLabel</a> for both labels and images</p></td>
  </tr>
  <tr>
    <td><p><b>Adding methods to dialogs</b></p></td>
    <td><p>Easy and transparent</p></td>
    <td><p>Tedious and less transparent</p></td>
  </tr>
  <tr>
    <td><p><b>Component/widget use/re-use and extension</b></p></td>
    <td><p>Basic by default, but also possible to reimplement <a href="CppVirtual.htm">virtual</a> <a href="CppMemberFunction.htm">member functions</a></p></td>
    <td><p>Reimplementation of <a href="CppVirtual.htm">virtual</a> <a href="CppMemberFunction.htm">member functions</a> with magic names and unknown functioning</p></td>
  </tr>
  <tr>
    <td><p><b>Layout management</b></p></td>
    <td><p>All Component have an Alignment property, use of TPanel as workhorses, TPanel works intuitively for complex custom behavior</p></td>
    <td><p>Layout managers with good default behavior, but less intuitive for more complex custom behavior</p></td>
  </tr>
  <tr>
    <td><p><b>Documentation</b></p></td>
    <td><p>VCL <a href="CppClass.htm">classes</a> well documented, easy to read the documentation, <a href="CppStl.htm">STL</a> fully documented</p></td>
    <td><p>Qt <a href="CppClass.htm">classes</a> well documented, it takes time to learn reading the documentation, no <a href="CppStl.htm">STL</a> documentation</p></td>
  </tr>
</table> 
<p>&nbsp;</p>
<p>My personal conclusion has remained the same:</p>
<ul>
  <li>(1) <a href="CppBuilder.htm">C++ Builder</a> is easier to learn</li>
  <li>(2) the extra effort learning <a href="CppQtCreator.htm">Qt Creator</a> is worth it, 
because <a href="CppQtCreator.htm">Qt Creator</a> is cross-platform and has a superior compiler</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!--
<h2>Post your feedback</h2>
<p>&nbsp;</p>
<p>Feel free to post your feedback about this article at <a href="http://www.programmersheaven.com/XXX">Programmer's Heaven</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p> -->
<h2><a href="CppReferences.htm">References</a></h2>
<p>&nbsp;</p>
<ol>
  <li><a href="http://doc.qt.nokia.com/4.6/classes.html">Nokia overview of all Qt classes</a></li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
</body>
</html>
