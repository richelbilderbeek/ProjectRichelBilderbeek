<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>TwoDigitNewick</title>
  <meta name="description" content="C++ TwoDigitNewick"/>
  <meta name="keywords" content="C++ TwoDigitNewick "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a></h1>
<p>&nbsp;</p>
<!-- This page is generated by CodeToHtml version 1.2.694 at Fri Jan  2 09:58:06 2015
 -->
<p><img src="PicStl.png" alt="STL"/><img src="PicQtCreator.png" alt="Qt Creator"/><img src="PicLubuntu.png" alt="Lubuntu"/></p>
<p>&nbsp;</p>
<p><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> is a <a href="CppNewick.htm">Newick</a> <a href="CppClass.htm">class</a>.</p>
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/CppTwoDigitNewick.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/CppTwoDigitNewick.pri" border = "1"><tr><td><code>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a><br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>derivative.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indexer.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indextable.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>s.cpp<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a>&nbsp;&nbsp;+= \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>derivative.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indexer.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indextable.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/<a href="CppTwoDigitNewick.htm">twodigitnewick</a>s.h<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a>/Licence.txt<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewick.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewick.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> TWODIGITNEWICK_H<br/>
<a href="CppDefine.htm">#define</a> TWODIGITNEWICK_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>derivative.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> contains all<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative that can be<br/>
<a href="CppComment.htm">///</a><a href="CppConstructor.htm">construct</a>ed from a phylogeny. For example,<br/>
<a href="CppComment.htm">///</a><b><a href="CppIf.htm">if</a></b> from a certain phylogeny three derived<br/>
<a href="CppComment.htm">///</a>phylogenies can be <a href="CppConstructor.htm">construct</a>ed, <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesData<br/>
<a href="CppComment.htm">///</a>will hold three elements<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>An empty <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a><br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/A TwoDogit<a href="CppNewick.htm">Newick</a> cannot be created without<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/its derivatives: a <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> IS its<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/derivatives in a way.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/sum_above_zero and sum_above_one are needed to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/calculate its denominator<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt;&amp; derivatives,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Empty <a href="CppReturn.htm">returns</a> !IsComplete<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt;&amp; GetDerivatives() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsComplete determines <b><a href="CppIf.htm">if</a></b> the <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppInitialize.htm">initialize</a>d <b><a href="CppCompl.htm">compl</a></b>etely<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsComplete() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsProbabilityKnown() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetDenominator() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetProbability() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> <a href="CppGetSum.htm">GetSum</a>TermsAboveOne() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> <a href="CppGetSum.htm">GetSum</a>TermsAboveZero() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetProbability(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p);<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> SetTheta(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_derivatives contains all the information<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/needed to get to <b><a href="CppThis.htm">this</a></b> <a href="CppNewick.htm">Newick</a>'s derivatives<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; m_derivatives;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_probability denotes the probability<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/a <a href="CppNewick.htm">Newick</a> exists.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/A negative value of m_probability denotes<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that it is not yet calculated.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_probability;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_denominator constant <b><a href="CppFor.htm">for</a></b> a <a href="CppNewick.htm">Newick</a>.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_denominator;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_sum_terms_above_zero;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_sum_terms_above_one;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppDouble.htm">double</a></b> sm_theta;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> CalculateDenominator(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPublic.htm">public</a></b>:<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppDouble.htm">double</a></b> CalculateProbability(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppNewick.htm">newick</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TWODIGITNEWICK_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewick.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewick.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indexer.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::sm_theta <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1.0;<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>()<br/>
&nbsp;&nbsp;: m_derivatives{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability(-1.0),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_denominator(-1.0),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_zero(-1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_one(-1)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;Empty());<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt;&amp; derivatives,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
&nbsp;&nbsp;: m_derivatives(derivatives),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability(-1.0),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_denominator(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CalculateDenominator(sum_above_zero,sum_above_one)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_zero(sum_above_zero),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_one(sum_above_one)<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::CalculateDenominator(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sm_theta <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (sum_above_one &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Invalid sum_above_one: " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sum_above_one <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> d<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_above_zero * (sum_above_zero <a href="CppOperatorMinus.htm">-</a> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (<a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(sum_above_one)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * sm_theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> d;<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::CalculateProbability(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppNewick.htm">newick</a>_str,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::IsUnary<a href="CppNewick.htm">Newick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(<a href="CppNewick.htm">newick</a>_str))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> <a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(<a href="CppNewick.htm">newick</a>_str)));<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::SetTheta(theta);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> n(<a href="CppNewick.htm">newick</a>_str);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer i(n,theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> i.GetProbability();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::Empty() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_derivatives.empty();<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::GetDenominator() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsComplete());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_denominator;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt;&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::GetDerivatives() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_derivatives;<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::GetProbability() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsProbabilityKnown());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_probability;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::<a href="CppGetSum.htm">GetSum</a>TermsAboveOne() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_sum_terms_above_one <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_sum_terms_above_one;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::<a href="CppGetSum.htm">GetSum</a>TermsAboveZero() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_sum_terms_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_sum_terms_above_zero;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.1";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v;<br/>
&nbsp;&nbsp;v.push_back("2010-08-22: <a href="CppVersion.htm">version</a> 1.0: initial <a href="CppVersion.htm">version</a>");<br/>
&nbsp;&nbsp;v.push_back("2011-02-20: <a href="CppVersion.htm">version</a> 1.1: added <a href="CppVersion.htm">version</a> history");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::IsComplete() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (!m_derivatives.empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_sum_terms_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_sum_terms_above_one&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::IsProbabilityKnown() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_probability <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::SetProbability(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (p &lt; 0.0 <a href="CppOperatorLogicalOr.htm">||</a> p &gt; 1.0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(p);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorLessEqual.htm">&lt;=</a> 1.00001);<br/>
&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> p;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::SetTheta(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(theta <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;sm_theta <a href="CppOperatorAssign.htm">=</a> theta;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::SetTheta(10.0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppCreateValidNewicks.htm">CreateValidNewicks</a>();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( <a href="CppNewick.htm">Newick</a>::<a href="CppCalcComplexity.htm">CalcComplexity</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;<a href="CppBigInt.htm">BigInteger</a>(1000000) )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppNewick.htm">Newick</a>::<a href="CppIsBinaryNewick.htm">IsBinaryNewick</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> n(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer(n,10.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewickderivative.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewickderivative.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> TWODIGITDERIVATIVE_H<br/>
<a href="CppDefine.htm">#define</a> TWODIGITDERIVATIVE_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative contains<br/>
<a href="CppComment.htm">///</a>the index of the derived phylogeny<br/>
<a href="CppComment.htm">///</a>and the value that must be changed<br/>
<a href="CppComment.htm">///</a>to get there. For example, <b><a href="CppIf.htm">if</a></b> <b><a href="CppFor.htm">for</a></b> a<br/>
<a href="CppComment.htm">///</a><b><a href="CppCompl.htm">compl</a></b>ex phylogeny (of unknown index)<br/>
<a href="CppComment.htm">///</a>a '3' must be changed to a '2' to get<br/>
<a href="CppComment.htm">///</a>to the phylogeny with index 42,<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivatives has an<br/>
<a href="CppComment.htm">///</a>m_derived_index of 42 and an<br/>
<a href="CppComment.htm">///</a>m_value_changed of 3.<br/>
<a href="CppComment.htm">///</a>For calculations it is important to know which value<br/>
<a href="CppComment.htm">///</a>has changed, some<a href="CppTime.htm">time</a>s with another.<br/>
<a href="CppComment.htm">///</a>If no other value changes, set m_other_value_changed to zero.<br/>
<a href="CppComment.htm">///</a>Some examples of <b><a href="CppUsing.htm">using</a></b> m_value_changed and m_other_value_changed:\n<br/>
<a href="CppComment.htm">///</a>(1,1) <a href="CppOperatorMinus.htm">-</a>&gt;&nbsp;&nbsp; (2), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 1\n<br/>
<a href="CppComment.htm">///</a>(1,2) <a href="CppOperatorMinus.htm">-</a>&gt;&nbsp;&nbsp; (3), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 2\n<br/>
<a href="CppComment.htm">///</a>(1,2) <a href="CppOperatorMinus.htm">-</a>&gt; (1,1), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>(1,3) <a href="CppOperatorMinus.htm">-</a>&gt;&nbsp;&nbsp; (4), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 3\n<br/>
<a href="CppComment.htm">///</a>(1,3) <a href="CppOperatorMinus.htm">-</a>&gt; (1,2), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 3 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>(2,3) <a href="CppOperatorMinus.htm">-</a>&gt; (1,3), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>(2,3) <a href="CppOperatorMinus.htm">-</a>&gt; (2,2), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 3 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>A valid <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative has either:\n<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed&nbsp;&nbsp;&gt; 0\n<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> m_value_changed&nbsp;&nbsp;&gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>This is checked at the <a href="CppConstructor.htm">constructor</a><br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative<br/>
{<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> derived_index,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_derived_index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_value_changed;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_other_value_changed;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TWODIGITDERIVATIVE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewickderivative.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewickderivative.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>derivative.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> derived_index,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed)<br/>
&nbsp;&nbsp;: m_derived_index(derived_index),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_value_changed(value_changed),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_other_value_changed(other_value_changed)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_derived_index &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_value_changed &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed&nbsp;&nbsp;&gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalOr.htm">||</a> (m_value_changed&nbsp;&nbsp;&gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0) );<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewickindexer.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewickindexer.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> TWODIGITNEWICKINDEXER_H<br/>
<a href="CppDefine.htm">#define</a> TWODIGITNEWICKINDEXER_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indextable.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>s.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppNewick.htm">Newick</a>Index <a href="CppConvert.htm">converts</a> <a href="CppAny.htm">any</a> <a href="CppNewick.htm">newick</a> to (X,Y)<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer <a href="CppConstructor.htm">constructor</a> does all the work<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer(<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> <a href="CppConstructor.htm">construct</a>s a full <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> from<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/the <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> at index i.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> is <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a> purposes only,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/as it's the idea to work with non-full determined<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/(that is: two-digit) <a href="CppNewick.htm">Newick</a>s<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> <a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetCalculatedToIndex() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_calculated_to_index; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetData allows a peek at the x-y ordered data<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable&amp; GetIndexTable() <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_index_table;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_index_table.CanGetIndex(x,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_index_table.GetIndex(x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Get<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s&amp; Get<a href="CppNewick.htm">Newick</a>s() <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_<a href="CppNewick.htm">newick</a>s;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetProbability <a href="CppReturn.htm">returns</a> the probability of the <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/given at the <a href="CppConstructor.htm">constructor</a><br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetProbability() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetReserved() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_reserved; }<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/After a leaf has been cut, then<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> TryToCalculateNew<a href="CppNewick.htm">Newick</a>s();<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UpdateCalculatedFromIndex();<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_calculated_to_index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_current_index;<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable m_index_table;<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s m_<a href="CppNewick.htm">newick</a>s;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_probability is the probability of the given <a href="CppNewick.htm">Newick</a>.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_probability is calculated in the <a href="CppConstructor.htm">constructor</a> of <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/and can be obtained by GetProbability.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_probability;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_reserved;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_theta;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Calculate the <a href="CppNewick.htm">Newick</a> probability of <a href="CppNewick.htm">Newick</a> (a,b).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Both a and b are simple, that is: no index<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppFor.htm">for</a></b> a <b><a href="CppCompl.htm">compl</a></b>ex <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> CalculateEwensProbability(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> a,<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> b) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CalculateReserved calculates the index<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that must be reserver<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> CalculateReserved(<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivatives(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleSimple(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesComplexComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetDeltaSumAboveZero calculates the delta in the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::m_sum_above_zero of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/when an old_value is changed.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetDeltaSumAboveZero(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> old_value) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetDeltaSumAboveOne calculates the delta in the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::m_sum_above_one of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/when an old_value is changed.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetDeltaSumAboveOne(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; d) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> GetDeltaSumAboveOne(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> old_value) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsSimple determines <b><a href="CppIf.htm">if</a></b> a <a href="CppNewick.htm">Newick</a> at index i is simple.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/A <a href="CppNewick.htm">Newick</a> is simple <b><a href="CppIf.htm">if</a></b> F=(X,Y) where X and Y are<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/less than the reserved index<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsSimple(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Feed the (x,y) indices of a <a href="CppNewick.htm">Newick</a> and obtain the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/summarized index.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Feed also obtains the derived <a href="CppNewick.htm">Newick</a>s.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Note that Feed must be fed simple <a href="CppNewick.htm">Newick</a>s first<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppInt.htm">int</a></b> Feed(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Summarize<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/TryToCalculateNew<a href="CppNewick.htm">Newick</a> tries to calculate the probability<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/of <a href="CppNewick.htm">Newick</a> with index i<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> TryToCalculateNew<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i);<br/>
<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>IsSimple determines <b><a href="CppIf.htm">if</a></b> a binary <a href="CppNewick.htm">Newick</a> is simple,<br/>
<a href="CppComment.htm">//</a>that is in the form '(X,Y)', where both X and Y are values<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsSimple(<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n);<br/>
<br/>
} <a href="CppComment.htm">//</a><b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TWODIGITNEWICKINDEXER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewickindexer.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewickindexer.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indexer.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStackH.htm">stack</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer <a href="CppConstructor.htm">constructor</a> does all the work<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
&nbsp;&nbsp;: m_calculated_to_index{CalculateReserved(n)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_index{CalculateReserved(n)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_index_table{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppNewick.htm">newick</a>s{CalculateReserved(n),theta},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability{-1.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_reserved{CalculateReserved(n)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_theta{theta}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_reserved <a href="CppOperatorEqual.htm">==</a> m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_index <a href="CppOperatorEqual.htm">==</a> m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the <a href="CppNewick.htm">Newick</a> is simple<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppNewick.htm">Newick</a>::IsSimple(n.Peek()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calculate the Ewens probability only<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(n.Peek(),theta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume all reserved <a href="CppNewick.htm">Newick</a>s from index 2 are <b><a href="CppCompl.htm">compl</a></b>ete<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=2; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Get<a href="CppNewick.htm">Newick</a>(i).IsComplete());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create all <a href="CppNewick.htm">Newick</a>s and derivatives, but <b><a href="CppDo.htm">do</a></b> not calculate their<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>probabilities yet<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v <a href="CppOperatorAssign.htm">=</a> n.Peek();<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b>(v.size()&gt;2) <a href="CppComment.htm">//</a>Find a leaf and cut it until the string is empty<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a leaf<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find index i (starting opening bracket) and j (closing bracket)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSize_t.htm">std::size_t</a> j <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i=0 ; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) <a href="CppComment.htm">//</a>Index of opening bracket<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[i]<a href="CppOperatorNotEqual.htm">!=</a><a href="CppNewick.htm">Newick</a>::bracket_open) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j=i+1; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[j]<a href="CppOperatorEqual.htm">==</a><a href="CppNewick.htm">Newick</a>::bracket_open) { j <a href="CppOperatorAssign.htm">=</a> 0; <b><a href="CppBreak.htm">break</a></b>; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[j]<a href="CppOperatorNotEqual.htm">!=</a><a href="CppNewick.htm">Newick</a>::bracket_close) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (j <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;0) <b><a href="CppContinue.htm">continue</a></b>; <a href="CppComment.htm">//</a>j cannot be 0 after previous <b><a href="CppFor.htm">for</a></b> loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find simplest leaf<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[i]<a href="CppOperatorEqual.htm">==</a><a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[j]<a href="CppOperatorEqual.htm">==</a><a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v_new(v.begin(),v.begin() <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> v[i+1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> v[i+2];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Feed it and obtain simpler index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Indices 0 and 1 cannot be <b><a href="CppCompl.htm">compl</a></b>ete, because<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>they don't have sensible derivates to <a href="CppPointer.htm">point</a> to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &lt; 2 <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(x).IsComplete());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &lt; 2 <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(y).IsComplete());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(x).<a href="CppGetSum.htm">GetSum</a>TermsAboveZero()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(y).<a href="CppGetSum.htm">GetSum</a>TermsAboveZero();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(x).<a href="CppGetSum.htm">GetSum</a>TermsAboveOne()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(y).<a href="CppGetSum.htm">GetSum</a>TermsAboveOne();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(Summarize<a href="CppNewick.htm">Newick</a>(x,y,saz,sao));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Replace leaf with simpler index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(v.begin() <a href="CppOperatorPlus.htm">+</a> j <a href="CppOperatorPlus.htm">+</a> 1, v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v_new));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v <a href="CppOperatorAssign.htm">=</a> v_new;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Now all <a href="CppNewick.htm">Newick</a>s are created, but <b><a href="CppDo.htm">do</a></b> not have their probabilities calculated<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_calculated_to_index <a href="CppOperatorEqual.htm">==</a> sz denotes that all <a href="CppNewick.htm">Newick</a>s'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>probabilities are calculated<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m_calculated_to_index <a href="CppOperatorNotEqual.htm">!=</a> sz)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Try to calculate <b><a href="CppIf.htm">if</a></b> <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a>s can be solved<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;TryToCalculateNew<a href="CppNewick.htm">Newick</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If all is well, there will be <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a>s known<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;UpdateCalculatedFromIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>When no <b><a href="CppNew.htm">new</a></b> probabilities are calculated,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>all <a href="CppNewick.htm">Newick</a>s are solved<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::CalculateReserved(<b><a href="CppConst.htm">const</a></b> <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a>&amp; n) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v <a href="CppOperatorAssign.htm">=</a> n.Peek();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of elements<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_elements<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdGreater.htm">std::greater</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),0));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> max_element <a href="CppOperatorAssign.htm">=</a> *<a href="CppStdMax_element.htm">std::max_element</a>(v.begin(),v.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: <a href="CppOperatorPlus.htm">+</a>1 needed?<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_elements <a href="CppOperatorPlus.htm">+</a> max_element <a href="CppOperatorPlus.htm">+</a> 1;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> <a href="CppConstructor.htm">construct</a>s a full <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> from<br/>
<a href="CppComment.htm">///</a>the <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> at index i.<br/>
<a href="CppComment.htm">///</a><a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> is <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a> purposes only,<br/>
<a href="CppComment.htm">///</a>as it's the idea to work with non-full determined<br/>
<a href="CppComment.htm">///</a>(that is: two-digit) <a href="CppNewick.htm">Newick</a>s<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::<a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i &lt; m_reserved)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppNewick.htm">Newick</a> '(0)' is not valid, so fake it as '(1)'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(i <a href="CppOperatorEqual.htm">==</a> 0 ? 1 : i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> n(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> index i in Indextable to get two digits<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppInt.htm">int</a></b>,<b><a href="CppInt.htm">int</a></b>&gt; p <a href="CppOperatorAssign.htm">=</a> m_index_table.Find(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p.first);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(v));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>As <b><a href="CppLong.htm">long</a></b> as there are not only reserved (that is: simple)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>values in v, replace those by their simplers<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;::<a href="CppIterator.htm">iterator</a> i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind_if.htm">std::find_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdGreater_equal.htm">std::greater_equal</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),m_reserved));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a> v.end()) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m_reserved);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a <b><a href="CppNew.htm">new</a></b> <a href="CppStdVector.htm">std::vector</a> from the v's begin to i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v_new( v.begin(),i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppInt.htm">int</a></b>,<b><a href="CppInt.htm">int</a></b>&gt; p <a href="CppOperatorAssign.htm">=</a> m_index_table.Find(*i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(p.first);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copy the remainder of v (from after i) to v_new<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(i+1,v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v_new));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(v,v_new);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(v));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppBinaryNewickVector.htm">BinaryNewickVector</a> n(v);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivatives(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Sum_above_one: " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sum_above_one <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsSimple(x))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsSimple(y))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleSimple(x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,y,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsSimple(y))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,x,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesComplexComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,y,sum_above_zero,sum_above_one);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleSimple(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorLessEqual.htm">&lt;=</a> y);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorLessEqual.htm">&lt;=</a> m_reserved <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorLessEqual.htm">&lt;=</a> m_reserved);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsSimple(x) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> IsSimple(y));<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x<a href="CppOperatorEqual.htm">==</a>1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y<a href="CppOperatorEqual.htm">==</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(1,1) <a href="CppOperatorMinus.htm">-</a>&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'2' has reserved index 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> derived_index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppThis.htm">this</a></b> derivative twice, because there are two ways<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>to change (1,1) <a href="CppOperatorMinus.htm">-</a>&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derived_index,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derived_index,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n(v,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (x<a href="CppOperatorEqual.htm">==</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(1,y) <a href="CppOperatorMinus.htm">-</a>&gt; { (1,y-1), (y+1) }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'1','y' and 'y-1' are reserved indices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; m_reserved);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create (1,y-1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> (y <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? 0 : y <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(x,y-1,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only y changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create (y+1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> y <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Note the reversal of 1 and y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> y; <a href="CppComment.htm">//</a>Note the reversal of 1 and y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n( v,x+y,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(x,y) <a href="CppOperatorMinus.htm">-</a>&gt; { (x-1,y), (x,y-1) }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'y','y-1','x' and 'x-1' are reserved indices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> x &lt; m_reserved);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; m_reserved);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; v;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao_left&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (x <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 2 : x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao_right <a href="CppOperatorAssign.htm">=</a> (y <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 2 : x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao_left&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao_right <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Derive (x-1,y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i_left&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(x-1,y,saz,sao_left );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed_left <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed_left <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only x changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_i_left,value_changed_left,other_value_changed_left));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Derive (x,y-1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i_right <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(x,y-1,saz,sao_right);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed_right <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed_right <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only y changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_i_right,value_changed_right,other_value_changed_right));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n(v,x+y,x+y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesSimpleComplex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsSimple(x) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !IsSimple(y));<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; v;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x<a href="CppOperatorGreaterEqual.htm">&gt;=</a>0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x&gt;1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m_reserved <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "So cannot work with y-1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> (x <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? sum_above_one <a href="CppOperatorMinus.htm">-</a> 2 : sum_above_one <a href="CppOperatorMinus.htm">-</a> 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(x-1,y,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only x changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppNewick.htm">newick</a>s.Empty(y));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: Find out why '<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesData&amp;' does not work<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> v_derived <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(y);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; i: v_derived.GetDerivatives())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i.m_derived_index &lt; m_<a href="CppNewick.htm">newick</a>s.Size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative index must be smaller than the number of derivatives");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(i.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( x,i.m_derived_index,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> i.m_other_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n( v,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesComplexComplex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!IsSimple(x) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !IsSimple(y));<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; v;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Get (X',Y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_<a href="CppNewick.htm">newick</a>s.Size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppNewick.htm">newick</a>s.Empty(x));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: Find out why '<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesData&amp;' does not work<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> v_derived <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; i: v_derived.GetDerivatives())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(i.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(y,i.m_derived_index,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> i.m_other_value_changed;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Get (X,Y')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_<a href="CppNewick.htm">newick</a>s.Size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppNewick.htm">newick</a>s.Empty(y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: Find out why '<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>DerivativesData&amp;' does not work<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> v_derived <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; i: v_derived.GetDerivatives())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(i.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(x,i.m_derived_index,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> i.m_other_value_changed;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n(v,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetDeltaSumAboveZero calculates the delta in the<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::m_sum_above_zero of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
<a href="CppComment.htm">///</a>when an old_value is changed.<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::GetDeltaSumAboveZero(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> old_value) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(old_value &gt; 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (old_value <a href="CppOperatorEqual.htm">==</a> 1 ? 0 : <a href="CppOperatorMinus.htm">-</a>1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetDeltaSumAboveOne calculates the delta in the<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>::m_sum_above_one of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
<a href="CppComment.htm">///</a>when an old_value is changed.<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::GetDeltaSumAboveOne(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; d) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> d.m_value_changed;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "GetDeltaSumAboveOne <b><a href="CppFor.htm">for</a></b> x " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> x <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x&nbsp;&nbsp;&gt; 2) <b><a href="CppReturn.htm">return</a></b> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorEqual.htm">==</a> 2) <b><a href="CppReturn.htm">return</a></b> <a href="CppOperatorMinus.htm">-</a>2;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (d.m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 1 ? 2 : 1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetProbability <a href="CppReturn.htm">returns</a> the probability of the <a href="CppBinaryNewickVector.htm">BinaryNewickVector</a><br/>
<a href="CppComment.htm">///</a>given at the <a href="CppConstructor.htm">constructor</a><br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::GetProbability() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_probability <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_probability <a href="CppOperatorLessEqual.htm">&lt;=</a> 1.00001);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_calculated_to_index <a href="CppOperatorEqual.htm">==</a> m_<a href="CppNewick.htm">newick</a>s.Size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume calculation is <b><a href="CppCompl.htm">compl</a></b>eted");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_probability;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>IsSimple determines <b><a href="CppIf.htm">if</a></b> an index is the index of<br/>
<a href="CppComment.htm">///</a>a simple <a href="CppNewick.htm">Newick</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::IsSimple(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> i &lt; m_reserved;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Allow <b><a href="CppFor.htm">for</a></b> recursion<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::Summarize<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure proper ordering<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &gt; y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Summarize<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,x,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorLessEqual.htm">&lt;=</a> y);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If index is known, <b><a href="CppReturn.htm">return</a></b> the index<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_index_table.CanGetIndex(x,y))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_index_table.GetIndex(x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i) <b><a href="CppReturn.htm">return</a></b> i;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A <b><a href="CppNew.htm">new</a></b> (x,y) pair is fed<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorLessEqual.htm">&lt;=</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_current_index;<br/>
&nbsp;&nbsp;m_index_table.SetIndex(x,y,i);<br/>
<br/>
&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_current_index;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n <a href="CppOperatorAssign.htm">=</a> Create<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivatives(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x,y,sum_above_zero,sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the <a href="CppNewick.htm">Newick</a> is simple<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and its probability can be calculated with<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>the Ewens formula<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &lt; m_reserved <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; m_reserved)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n.SetProbability(<a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(v,m_theta));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the user requests simple <a href="CppNewick.htm">Newick</a>s to be solved,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>perhaps the requested probability has just been calculated<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> n.GetProbability();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;m_<a href="CppNewick.htm">newick</a>s.Set<a href="CppNewick.htm">Newick</a>(i,n);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> i;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>TryToCalculateNew<a href="CppNewick.htm">Newick</a> tries to calculate the probability<br/>
<a href="CppComment.htm">///</a>of <a href="CppNewick.htm">Newick</a> with index i<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::TryToCalculateNew<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m_calculated_to_index);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i&nbsp;&nbsp;&lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: why cannot use '<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp;'?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\<a href="CppBug.htm">bug</a>: <b><a href="CppThis.htm">this</a></b> seems to give <a href="CppMemory.htm">memory</a> problems (and funny output)<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remember: m_calculated_to_index is not increased<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n.IsProbabilityKnown())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Already know the probability<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; derivatives <a href="CppOperatorAssign.htm">=</a> n.GetDerivatives();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> of all derivates the probability is known<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; derivative: derivatives)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!Get<a href="CppNewick.htm">Newick</a>(derivative.m_derived_index).IsProbabilityKnown())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Too bad, derived <a href="CppNewick.htm">Newick</a>'s probability is unknown<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Calculate constants and probability<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> p <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The denominator is that of the focal <a href="CppNewick.htm">Newick</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and not its derivative(s)<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> denominator <a href="CppOperatorAssign.htm">=</a> Get<a href="CppNewick.htm">Newick</a>(i).GetDenominator();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; derivative: derivatives)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Get<a href="CppNewick.htm">Newick</a>(derivative.m_derived_index).IsProbabilityKnown());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> c<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (derivative.m_value_changed <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? m_theta<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(derivative.m_value_changed) * <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(derivative.m_value_changed <a href="CppOperatorMinus.htm">-</a> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a> denominator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p_this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> c * Get<a href="CppNewick.htm">Newick</a>(derivative.m_derived_index).GetProbability();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p<a href="CppOperatorPlusAssign.htm">+=</a>p_this;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " has been calculated to have the probability of "<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> p;<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_<a href="CppNewick.htm">newick</a>s.Set<a href="CppNewick.htm">Newick</a>Probability(i,p);<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>TryToCalculateNew<a href="CppNewick.htm">Newick</a>s tries to calculate <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a> probabilities<br/>
<a href="CppComment.htm">///</a>\warning: m_calculated_to_index is not increased<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::TryToCalculateNew<a href="CppNewick.htm">Newick</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_calculated_to_index <a href="CppOperatorEqual.htm">==</a> sz denotes that all <a href="CppNewick.htm">Newick</a>s'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>probabilities are calculated<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_calculated_to_index <a href="CppOperatorLessEqual.htm">&lt;=</a> sz);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_calculated_to_index; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TryToCalculateNew<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Indexer::UpdateCalculatedFromIndex()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m_calculated_to_index &lt; sz)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_calculated_to_index &lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: find out why '<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp;' does not work<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(m_calculated_to_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n.IsProbabilityKnown())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "At index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m_calculated_to_index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " the probability is known\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_calculated_to_index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewickindextable.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewickindextable.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> TWODIGITNEWICKINDEXERTABLE_H<br/>
<a href="CppDefine.htm">#define</a> TWODIGITNEWICKINDEXERTABLE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable manages (X,Y) <a href="CppOperatorMinus.htm">-</a>&gt; index<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanGetIndex <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> GetIndex can be called with success<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanGetIndex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Find <a href="CppReturn.htm">returns</a> the x-y-coordinats of the <a href="CppNewick.htm">Newick</a> with index i<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppInt.htm">int</a></b>,<b><a href="CppInt.htm">int</a></b>&gt; Find(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get <a href="CppReturn.htm">returns</a> the internals of <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt;&amp; Get() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetIndex <a href="CppReturn.htm">returns</a> m_index_table[x][y]<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetIndex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetNumAllocated calculates the number of indices allocated<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumAllocated() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetNumUsed calculates the number of indices used<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumUsed() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set (x,y) to index z<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIndex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> z);<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_index_table is the index table that maps (x,y) to a value,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/so that m_index_table[x][y] equals that value<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; m_v;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TWODIGITNEWICKINDEXERTABLE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewickindextable.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewickindextable.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>indextable.h"<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">///</a>CanGetData <a href="CppReturn.htm">returns</a> is GetData can be called with success<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::CanGetIndex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> x &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v[x].size());<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Find <a href="CppReturn.htm">returns</a> the x-y-coordinats of the <a href="CppNewick.htm">Newick</a> with index i<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppInt.htm">int</a></b>,<b><a href="CppInt.htm">int</a></b>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::Find(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> maxx <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size());<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> x=0; x<a href="CppOperatorNotEqual.htm">!=</a>maxx; <a href="CppOperatorIncrement.htm">++</a>x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> maxy <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v[x].size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> y=0; y<a href="CppOperatorNotEqual.htm">!=</a>maxy; <a href="CppOperatorIncrement.htm">++</a>y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_v[x][y]<a href="CppOperatorEqual.htm">==</a>i) <b><a href="CppReturn.htm">return</a></b> <a href="CppStdMake_pair.htm">std::make_pair</a>(x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " not found in <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::Find\n";<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " not found in <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::Find";<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str());<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetIndex <a href="CppReturn.htm">returns</a> m_index_table[x][y]<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::GetIndex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanGetIndex(x,y));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v[x][y];<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetNumAllocated calculates the number of indices allocated<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::GetNumAllocated() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_allocated <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v: m_v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n_allocated<a href="CppOperatorPlusAssign.htm">+=</a><a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_allocated;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetNumUsed calculates the number of indices used<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::GetNumUsed() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_non_zero <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v: m_v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n_non_zero <a href="CppOperatorPlusAssign.htm">+=</a><a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdGreater.htm">std::greater</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),0));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_non_zero;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>SetIndex sets m_index_table[x][y] <a href="CppOperatorEqual.htm">==</a> z<br/>
<a href="CppComment.htm">///</a>and resized the m_index_table is necessary<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>IndexTable::SetIndex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> z)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does x have a proper <a href="CppStdVector.htm">std::vector</a>?<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v.resize(x <a href="CppOperatorPlus.htm">+</a> 1,<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v[x].size()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v[x].resize(y <a href="CppOperatorPlus.htm">+</a> 1,0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[x][y] <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(z &gt; 0);<br/>
&nbsp;&nbsp;m_v[x][y] <a href="CppOperatorAssign.htm">=</a> z;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[x][y] &gt; 0);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewicks.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewicks.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> TWODIGITNEWICKS_H<br/>
<a href="CppDefine.htm">#define</a> TWODIGITNEWICKS_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s manages TwoDigit<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s.<br/>
<a href="CppComment.htm">///</a>TwoDigit<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s manage F'(index) <a href="CppOperatorMinus.htm">-</a>&gt; { indices }<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s<br/>
{<br/>
&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_reserved, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Empty <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> m_v is empty<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set a <a href="CppNewick.htm">Newick</a> at index i<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\warning: <b><a href="CppDo.htm">do</a></b> not use push_back, because of recursive calls<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i, <b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; v);<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v.empty(); }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Empty <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> an index is empty<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get <a href="CppReturn.htm">returns</a> the internals of <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&gt;&amp; Get() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get<a href="CppNewick.htm">Newick</a> <a href="CppReturn.htm">returns</a> the <a href="CppNewick.htm">Newick</a> at index i.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i is checked <b><a href="CppFor.htm">for</a></b> its range.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Sets the derivatives of F(i) to { v }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetDerivatives(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i,<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; v);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the number of Derivatives<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set<a href="CppNewick.htm">Newick</a>Probability sets the probability of the <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/at index i to p<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set<a href="CppNewick.htm">Newick</a>Probability(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i,<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Size() <b><a href="CppConst.htm">const</a></b>;<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_derivatives contains <b><a href="CppFor.htm">for</a></b> every indexed <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/its derived indexed <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&gt; m_v;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TWODIGITNEWICKS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppTwoDigitNewick/twodigitnewicks.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppTwoDigitNewick/twodigitnewicks.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="ToolTestTwoDigitNewick.htm">TestTwoDigitNewick</a>, <a href="Tools.htm">tool</a> to test the two-digit-<a href="CppNewick.htm">Newick</a> architecture<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="ToolTestTwoDigitNewick.htm">ToolTestTwoDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTwoDigitNewick.htm">twodigitnewick</a>s.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppBinaryNewickVector.htm">binarynewickvector</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_reserved, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
&nbsp;&nbsp;: m_v{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create derivatives of simplest and reserved <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the <a href="CppNewick.htm">Newick</a> at index 0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;Set<a href="CppNewick.htm">Newick</a>(0,<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt;(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(),0,0));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Let i start at 1, because '(0)' is no valid <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=1; i<a href="CppOperatorNotEqual.htm">!=</a>n_reserved; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;There is no other value<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative(i-1,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> (i &gt; 1 ? i : 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> n(v,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i<a href="CppOperatorNotEqual.htm">!=</a>0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "'(0)' is no valid <a href="CppNewick.htm">Newick</a>");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n.SetProbability(<a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewick.htm">Newick</a>::<a href="CppCreateVector.htm">CreateVector</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppNewick.htm">Newick</a>::bracket_open),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppNewick.htm">Newick</a>::bracket_close)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theta));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;Set<a href="CppNewick.htm">Newick</a>(i,n);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (i &lt; 2 <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(i).IsComplete())<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "All <a href="CppNewick.htm">newick</a> with index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2 must be <b><a href="CppCompl.htm">compl</a></b>ete");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Empty <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> an index is empty<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s::Empty(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppThis.htm">this</a></b>-&gt;Size());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v[i].Empty();<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s::Get<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> i is in range<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i<a href="CppOperatorGreaterEqual.htm">&gt;=</a>0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppThis.htm">this</a></b>-&gt;Size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> <b><a href="CppReturn.htm">return</a></b>ed indices are okay<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; v <a href="CppOperatorAssign.htm">=</a> m_v[i];<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; j: v.GetDerivatives())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index &lt; <b><a href="CppThis.htm">this</a></b>-&gt;Size() );<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v[i];<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s::Set<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i, <b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> __LINE__ <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " <a href="CppOperatorMinus.htm">-</a> " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Allocate storage<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TODO: replace by push_back<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v.resize(i <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[m_v.size()-1].Empty());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppAdd.htm">Add</a>ing a <a href="CppNewick.htm">Newick</a> at index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[i].Empty());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>Derivative&amp; j: v.GetDerivatives())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot set a derivative index "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "bigger than the number of derivatives");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;m_v[i] <a href="CppOperatorAssign.htm">=</a> v;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s::Set<a href="CppNewick.htm">Newick</a>Probability(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i,<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i&nbsp;&nbsp;&lt; Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorLessEqual.htm">&lt;=</a> 1.0);<br/>
&nbsp;&nbsp;m_v[i].SetProbability(p);<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppTwoDigitNewick.htm">TwoDigitNewick</a>s::Size() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
