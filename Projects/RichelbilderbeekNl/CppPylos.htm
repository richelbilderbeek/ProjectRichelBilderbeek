<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>Pylos</title>
  <meta name="description" content="C++ Pylos"/>
  <meta name="keywords" content="C++ Pylos "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppPylos.htm">Pylos</a></h1>
<p>&nbsp;</p>
<!-- This page is generated by CodeToHtml version 1.1.636 at Sun Apr 27 13:00:10 2014
 -->
<p><img src="PicStl.png" alt="STL"/><img src="PicQtCreator.png" alt="Qt Creator"/><img src="PicLubuntu.png" alt="Lubuntu"/></p>
<p>&nbsp;</p>
<p>
  The <a href="CppPylos.htm">Pylos</a> <a href="CppClass.htm">classes</a>
  are used for the
  <a href="Games.htm">game</a> <a href="GamePylos.htm">Pylos</a>
  (also called 'Pyraos').
</p>
<p>&nbsp;</p>
<p>
  The <a href="CppPylos.htm">Pylos</a> <a href="CppClass.htm">classes</a>
  are tested by <a href="ToolTestPylos.htm">TestPylos page</a>.
</p>
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/CppPylos.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/CppPylos.pri" border = "1"><tr><td><code>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a><br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>board.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>coordinat.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>currentmovestate.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>game.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>move.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>mustremovestate.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>player.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>positionstate.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>winner.cpp<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a>&nbsp;&nbsp;+= \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>board.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>coordinat.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>currentmovestate.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>fwd.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>game.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>move.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>mustremovestate.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>player.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>positionstate.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/<a href="CppPylos.htm">pylos</a>winner.h<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppPylos.htm">CppPylos</a>/Licence.txt<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosboard.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosboard.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Board, <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> a <a href="CppPylos.htm">Pylos</a>/Phyraos board<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSBOARD_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSBOARD_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>fwd.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>move.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>winner.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>positionstate.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Text<a href="CppCanvas.htm">Canvas</a>;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Board<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;Position<a href="CppState.htm">State</a>&gt; &gt; Layer;<br/>
<br/>
&nbsp;&nbsp;Board() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Board() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanDo determines <b><a href="CppIf.htm">if</a></b> a <a href="CppPylos.htm">Pylos</a> notation move is valid<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanDo determines <b><a href="CppIf.htm">if</a></b> a <a href="CppPylos.htm">Pylos</a> move is valid<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDo(<b><a href="CppConst.htm">const</a></b> Move&amp; m, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanDoSomething specifies <b><a href="CppIf.htm">if</a></b> there is a possible move to <b><a href="CppDo.htm">do</a></b> <b><a href="CppFor.htm">for</a></b> a player<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoSomething(<b><a href="CppConst.htm">const</a></b> Player&amp; player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanRemove specifies <b><a href="CppIf.htm">if</a></b> one or<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/two marble(s) can be removed at the requested position(s).<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanRemove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanMove specifies the marble at the specified coordinat can be tranferred<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanMove specifies <b><a href="CppIf.htm">if</a></b> the marble can be tranferred to the <b><a href="CppNew.htm">new</a></b> (higher) position<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanTransfer(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanSet specifies <b><a href="CppIf.htm">if</a></b> a marble can be placed at the coordinat.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/It is chosen to let the client specify a player, to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/emphasise that a player's marble is placed, instead<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/of a Position<a href="CppState.htm">State</a>::empty<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Clone a derived <b><a href="CppClass.htm">class</a></b> of Board.<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; Clone() <b><a href="CppConst.htm">const</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Count counts the requested state at the specified coordinats<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Count(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; coordinats, <b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Count counts the requested state.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Valid states are empty, player1 and player2<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Count(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create a BoardAdvanced<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; CreateAdvancedBoard() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create a BoardBasic<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; CreateBasicBoard() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Do performs a move in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Do(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, <b><a href="CppConst.htm">const</a></b> Player player);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Do performs a <a href="CppPylos.htm">Pylos</a> move<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Do(<b><a href="CppConst.htm">const</a></b> Move&amp; m, <b><a href="CppConst.htm">const</a></b> Player player);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get <a href="CppReturn.htm">returns</a> the state of the requested location<br/>
&nbsp;&nbsp;Position<a href="CppState.htm">State</a> Get(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetAllPossibleMoves <a href="CppReturn.htm">returns</a> all moves valid <b><a href="CppFor.htm">for</a></b> the selected player<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; GetAllPossibleMoves(<b><a href="CppConst.htm">const</a></b> Player&amp; player) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetLayerSize <a href="CppReturn.htm">returns</a> how many marbles <b><a href="CppThis.htm">this</a></b> is wide/height.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/For example; layer 0 has 4x4 marbles, so GetLayerSize<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/will <b><a href="CppReturn.htm">return</a></b> 4.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetLayerSize(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Return the possible winner<br/>
&nbsp;&nbsp;Winner GetWinner() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/PlayRandom<a href="CppPylos.htm">Pylos</a>Game plays a random <a href="CppPylos.htm">Pylos</a> game and <a href="CppReturn.htm">returns</a> the winner.<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> Winner PlayRandom<a href="CppPylos.htm">Pylos</a>Game(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; board_original <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;()) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Remove removes one or two marbles.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Remove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v, <b><a href="CppConst.htm">const</a></b> Player player);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Restart sets the board in its initial position.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Restart();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set sets the state of the given location.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/must_remove is set to the MustRemove<a href="CppState.htm">State</a> who must remove one or two marbles.<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppVoid.htm">void</a></b> Set(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove) <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Display the board as a <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Display the board as a 2D <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; ToText() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Display the board as a 2D <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Text<a href="CppCanvas.htm">Canvas</a>&gt; ToText<a href="CppCanvas.htm">Canvas</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Transfer lets current player transfer his marble to a <b><a href="CppNew.htm">new</a></b>, higher position<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Transfer(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove);<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppProtected.htm">protected</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_board holds the board structure.\n<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_board[0]: bottom 4x4 layer\n<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_board[1]: 3x3 layer\n<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_board[2]: 2x2 layer\n<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_board[3]: top 1x1 layer<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Layer&gt; m_board;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanRemove specifies <b><a href="CppIf.htm">if</a></b> current player can remove<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/the marble at the requested position.<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanRemove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/RemoveMarble removes one marble.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Remove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player);<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CreateEmptyBoard created an empty board.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Layer&gt; CreateEmptyBoard() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CreateLayer creates an empty layer.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Layer CreateLayer(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Friends<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Board* x);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Board&amp; lhs, <b><a href="CppConst.htm">const</a></b> Board&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>A BoardAdvanced lets a player remove one or two marbles when<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> a player creates a 2x2 square of marbles of his/her color<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> a player creates a 1x4 (bottom layer) or 1x3 (one-but-bottom layer)<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;line of marbles of his/her color<br/>
<b><a href="CppStruct.htm">struct</a></b> BoardAdvanced : <b><a href="CppPublic.htm">public</a></b> Board<br/>
{<br/>
&nbsp;&nbsp;BoardAdvanced() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;~BoardAdvanced() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Clone a derived <b><a href="CppClass.htm">class</a></b> of Board.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; Clone() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Load loads a game in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Load(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Save saves the current game in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Save(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/ToStr <a href="CppConvert.htm">converts</a> <a href="CppPylos.htm">Pylos</a> its contents to a <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set sets the state of the given location.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/must_remove is set to <b><a href="CppTrue.htm">true</a></b> <b><a href="CppIf.htm">if</a></b> the current player is allowed<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/to remove one or two marbles.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove);<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(BoardAdvanced* x);<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>A BoardBasic lets a player remove one or two marbles when<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> a player creates a 2x2 square of marbles of his/her color<br/>
<b><a href="CppStruct.htm">struct</a></b> BoardBasic : <b><a href="CppPublic.htm">public</a></b> Board<br/>
{<br/>
&nbsp;&nbsp;BoardBasic() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;~BoardBasic() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Clone a derived <b><a href="CppClass.htm">class</a></b> of <a href="CppPylos.htm">Pylos</a>.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; Clone() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Load loads a game in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Load(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Save saves the current game in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Save(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/ToStr <a href="CppConvert.htm">converts</a> <a href="CppPylos.htm">Pylos</a> its contents to a <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set sets the state of the given location.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/must_remove is set to <b><a href="CppTrue.htm">true</a></b> <b><a href="CppIf.htm">if</a></b> the current player is allowed<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/to remove one or two marbles.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(BoardBasic* x);<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>A BoardBeginner lets a player remove one or two marbles when<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> never<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Board&amp; lhs, <b><a href="CppConst.htm">const</a></b> Board&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Board&amp; lhs, <b><a href="CppConst.htm">const</a></b> Board&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os,<b><a href="CppConst.htm">const</a></b> Board&amp; p) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSBOARD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosboard.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosboard.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Board, <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> a <a href="CppPylos.htm">Pylos</a>/Phyraos board<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>board.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>coordinat.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>move.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>mustremovestate.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>positionstate.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>winner.h"<br/>
<a href="CppInclude.htm">#include</a> "textcanvas.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> PYLOSGAME_H<br/>
#error <a href="CppPylos.htm">pylos</a>::Game must not be defined <b><a href="CppFor.htm">for</a></b> a <a href="CppPylos.htm">pylos</a>::Board<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Board() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
&nbsp;&nbsp;: m_board(CreateEmptyBoard())<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume correct board sizes<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[0].size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[0][0].size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[0][1].size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[0][2].size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[0][3].size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[1].size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[1][0].size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[1][1].size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[1][2].size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[2].size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[2][0].size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[2][1].size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[3].size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board[3][0].size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppPylos.htm">pylos</a>::Move&amp; m, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.IsValid());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_move.size()<a href="CppOperatorEqual.htm">==</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Placement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!CanSet(m.m_move[0],player)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.m_move.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!CanTransfer(m.m_move[0],m.m_move[1],player)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make a copy <a href="CppPylos.htm">Pylos</a><br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; p <a href="CppOperatorAssign.htm">=</a> Clone();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume cloning succeeded");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p.get() <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppThis.htm">this</a></b> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume clone is in different <a href="CppMemory.htm">memory</a> location");<br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> DEBUG_TEMP_CHECK_27364864984376597625482762367528<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> DEBUG_TEMP_CHECK_27364864984376597625482762367528<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(*p <a href="CppOperatorNotEqual.htm">!=</a> *<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(*p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(*<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*p <a href="CppOperatorEqual.htm">==</a> *<b><a href="CppThis.htm">this</a></b> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assumes clone is identical");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do the move<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_move.size()<a href="CppOperatorEqual.htm">==</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;Set(m.m_move[0],player,must_remove);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;Transfer(m.m_move[0],m.m_move[1],must_remove);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> marbles need to be removed<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Move must not lack one/two marbles to be removed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_remove.empty()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Must remove marbles<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p-&gt;CanRemove(m.m_remove,player);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Must not remove marbles, so the move is valid <b><a href="CppIf.htm">if</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_remove is empty<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m.m_remove.empty();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CanDo(<a href="CppPylos.htm">pylos</a>::Move(s),player);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanDoSomething(<b><a href="CppConst.htm">const</a></b> Player&amp; player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !GetAllPossibleMoves(player).empty();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanRemove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> v.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorEqual.htm">==</a> 1) <b><a href="CppReturn.htm">return</a></b> CanRemove(v[0],player);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Disallow selecting the same marble twice<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[0] <a href="CppOperatorEqual.htm">==</a> v[1]) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Disallow selecting empty spots<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( Get(v[0]) <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::empty<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> Get(v[1]) <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::empty) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Disallow selecting marbles of different colors<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(v[0]) <a href="CppOperatorNotEqual.htm">!=</a> Get(v[1])) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Keep one ordering, c2 must be above c1<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[0].GetLayer() <a href="CppOperatorEqual.htm">==</a> v[1].GetLayer())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CanRemove(v[0],player) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> CanRemove(v[1],player);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[0].GetLayer() &gt; v[1].GetLayer())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; w(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(w[0],w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CanRemove(w,player);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">Assert</a> proper ordering<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[0].GetLayer() &lt; v[1].GetLayer());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the top marble cannot be removed,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>the lower cannot either<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!CanRemove(v[1],player)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The bottom marble can be removed <b><a href="CppIf.htm">if</a></b> above are only empty spots, or only the top marble<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Clone the board, remove the top marble of the clone and test <b><a href="CppIf.htm">if</a></b> the bottom marble can be removed<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;Clone();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanRemove(v[1],player));<br/>
&nbsp;&nbsp;b-&gt;Remove(v[1],player);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> b-&gt;CanRemove(v[0],player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanRemove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot remove an empty spot<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(c)<a href="CppOperatorEqual.htm">==</a>Position<a href="CppState.htm">State</a>::empty) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot remove marble of another player<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(c)<a href="CppOperatorNotEqual.htm">!=</a>ToPosition<a href="CppState.htm">State</a>(player)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot remove from top layer, because then the player at the top has already won<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (c.GetLayer() <a href="CppOperatorEqual.htm">==</a> 3) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A marble can be removed <b><a href="CppIf.htm">if</a></b> all positions above are empty<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a> GetAbove(c);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Count(v,Position<a href="CppState.htm">State</a>::empty) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot transfer an empty spot<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(c)<a href="CppOperatorEqual.htm">==</a>Position<a href="CppState.htm">State</a>::empty) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot transfer marble of other color<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(c)<a href="CppOperatorNotEqual.htm">!=</a>ToPosition<a href="CppState.htm">State</a>(player)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot transfer from top layer, because then the player at the top has already won<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (c.GetLayer() <a href="CppOperatorEqual.htm">==</a> 3) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A marble can be transferred <b><a href="CppIf.htm">if</a></b> all positions above are empty<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a> GetAbove(c);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Count(v,Position<a href="CppState.htm">State</a>::empty) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The source and target must differ<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (from <a href="CppOperatorEqual.htm">==</a> to) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The to position must be higher<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (from.GetLayer() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> to.GetLayer()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The from position must be the player<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(from) <a href="CppOperatorNotEqual.htm">!=</a> ToPosition<a href="CppState.htm">State</a>(player)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The to position must be empty<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(to) <a href="CppOperatorNotEqual.htm">!=</a> Position<a href="CppState.htm">State</a>::empty) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer the marble by cloning the board, removing it and placing it<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;Clone();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(player <a href="CppOperatorEqual.htm">==</a> ToPlayer(b-&gt;Get(from))); <a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a>ed check <b><a href="CppFor.htm">for</a></b> line below<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Player player <a href="CppOperatorAssign.htm">=</a> ToPlayer(b-&gt;Get(from)); <a href="CppComment.htm">//</a>Removed<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanRemove(from,player));<br/>
&nbsp;&nbsp;b-&gt;Remove(from,player);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> b-&gt;CanSet(to,player);<br/>
}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player) <b><a href="CppConst.htm">const</a></b><br/>
<a href="CppPreElse.htm">#else</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CanSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player) <b><a href="CppConst.htm">const</a></b><br/>
<a href="CppEndif.htm">#endif</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(player <a href="CppOperatorEqual.htm">==</a> Player::player1 <a href="CppOperatorLogicalOr.htm">||</a> player <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>Prevent <a href="CppCompiler.htm">compiler</a> from complaining<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(c) <a href="CppOperatorNotEqual.htm">!=</a> Position<a href="CppState.htm">State</a>::empty) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Player can always place a marble at an empty spot at the bottom<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (c.GetLayer() <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Player wants to place a marbles at non-bottom layer,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>which is valid <b><a href="CppIf.htm">if</a></b> none of the spots below are empty<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a> GetBelow(c);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Count(v,Position<a href="CppState.htm">State</a>::empty) <a href="CppOperatorEqual.htm">==</a> 0;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Count(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; coordinats, <b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdCount_if.htm">std::count_if</a>(coordinats.begin(),coordinats.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,state](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Get(c) <a href="CppOperatorEqual.htm">==</a> state;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Count(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppPylos.htm">pylos</a>::GetAllCoordinats();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Count(v,state);<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateAdvancedBoard() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateBasicBoard() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Layer&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateEmptyBoard() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Layer&gt; v;<br/>
&nbsp;&nbsp;v.push_back(CreateLayer(4));<br/>
&nbsp;&nbsp;v.push_back(CreateLayer(3));<br/>
&nbsp;&nbsp;v.push_back(CreateLayer(2));<br/>
&nbsp;&nbsp;v.push_back(CreateLayer(1));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Layer <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateLayer(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(sz <a href="CppOperatorLessEqual.htm">&lt;=</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(sz);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sz &gt; 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;Position<a href="CppState.htm">State</a>&gt; &gt; (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sz,<a href="CppStdVector.htm">std::vector</a>&lt;Position<a href="CppState.htm">State</a>&gt;(sz,Position<a href="CppState.htm">State</a>::empty));<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Do(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, <b><a href="CppConst.htm">const</a></b> Player player)<br/>
{<br/>
&nbsp;&nbsp;Do(<a href="CppPylos.htm">pylos</a>::Move(s),player);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Do(<b><a href="CppConst.htm">const</a></b> <a href="CppPylos.htm">pylos</a>::Move&amp; m, <b><a href="CppConst.htm">const</a></b> Player player)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDo(m,player));<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_move.size() <a href="CppOperatorEqual.htm">==</a> 1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;Set(m.m_move[0],player,must_remove);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Transfer(m.m_move[0],m.m_move[1],must_remove);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!m.m_remove.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(m.m_remove.begin(),m.m_remove.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,&amp;must_remove,player](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove(c,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Position<a href="CppState.htm">State</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Get(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Just checking, a <a href="CppConstructor.htm">construct</a>ed Coordinat should pass all <a href="CppAssert.htm">assert</a>s<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.IsValid());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.IsValid());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetLayer() &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_board.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_board.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetX() &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_board[c.GetLayer()].size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_board[c.GetLayer()].empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetY() &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_board[c.GetLayer()][c.GetX()].size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board[c.GetLayer()][c.GetX()][c.GetY()];<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::GetAllPossibleMoves(<b><a href="CppConst.htm">const</a></b> Player&amp; player) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppPylos.htm">pylos</a>::GetAllCoordinats();<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; w;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> j <a href="CppOperatorAssign.htm">=</a> v.end();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> i <a href="CppOperatorAssign.htm">=</a> v.begin(); i<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> set<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppThis.htm">this</a></b>-&gt;CanSet(*i,player))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;Get(*i) <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::empty);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CanDo(i-&gt;ToStr(),player))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> simple set (that is, without removal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(Move(i-&gt;ToStr()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check first removal coordinat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> r1 <a href="CppOperatorAssign.htm">=</a> v.begin(); r1<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>r1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check one-marble remove<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CanDo(Move( {*i}, {*r1} ),player))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(Move( {*i}, {*r1} ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check two-marble remove<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> r2 <a href="CppOperatorAssign.htm">=</a> r1; r2<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>r2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (r1 <a href="CppOperatorEqual.htm">==</a> r2) <b><a href="CppContinue.htm">continue</a></b>; <a href="CppComment.htm">//</a>Checked by CanDo<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CanDo(Move( {*i}, {*r1,*r2} ),player)) w.push_back(Move( {*i}, {*r1,*r2} ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> transfer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (<b><a href="CppThis.htm">this</a></b>-&gt;CanTransfer(*i,player))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;Get(*i) <a href="CppOperatorEqual.htm">==</a> ToPosition<a href="CppState.htm">State</a>(player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> to <a href="CppOperatorAssign.htm">=</a> i; to<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>to)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CanDo(Move( {*i,*to}, {} ),player))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> simple transfer (that is, without removal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(Move( {*i,*to}, {} ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check first removal coordinat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> r1 <a href="CppOperatorAssign.htm">=</a> v.begin(); r1<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>r1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check one-marble remove<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CanDo(Move( {*i,*to}, {*r1} ),player))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(Move( {*i,*to}, {*r1} ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check two-marble remove<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> r2 <a href="CppOperatorAssign.htm">=</a> r1; r2<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>r2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (r1 <a href="CppOperatorEqual.htm">==</a> r2) <b><a href="CppContinue.htm">continue</a></b>; <a href="CppComment.htm">//</a>Checked by CanDo<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CanDo(Move( {*i,*to}, {*r1,*r2} ),player)) w.push_back(Move( {*i,*to}, {*r1,*r2} ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::GetLayerSize(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(layer <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(layer &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_board.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_board[layer].size());<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "2.0";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v;<br/>
&nbsp;&nbsp;v.push_back("2012-05-05: <a href="CppVersion.htm">version</a> 2.0: initial release <a href="CppVersion.htm">version</a>");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Winner <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::GetWinner() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Get(Coordinat(3,0,0)) <a href="CppOperatorNotEqual.htm">!=</a> Position<a href="CppState.htm">State</a>::empty)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (Get(Coordinat(3,0,0)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::player1: <b><a href="CppReturn.htm">return</a></b> Winner::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::player2: <b><a href="CppReturn.htm">return</a></b> Winner::player2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>: <a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Count(Position<a href="CppState.htm">State</a>::player1)<a href="CppOperatorEqual.htm">==</a>15&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !CanDoSomething(Player::player1)) <b><a href="CppReturn.htm">return</a></b> Winner::player2;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Count(Position<a href="CppState.htm">State</a>::player2)<a href="CppOperatorEqual.htm">==</a>15&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !CanDoSomething(Player::player2)) <b><a href="CppReturn.htm">return</a></b> Winner::player1;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Winner::none;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Winner <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::PlayRandom<a href="CppPylos.htm">Pylos</a>Game(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; board_original) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; board;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (board_original)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;board <a href="CppOperatorAssign.htm">=</a> board_original-&gt;Clone();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateBasicBoard();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Player player <a href="CppOperatorAssign.htm">=</a> Player::player1;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (board-&gt;GetWinner() <a href="CppOperatorNotEqual.htm">!=</a> Winner::none)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> board-&gt;GetWinner();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use random move from GetAllPossibleMoves<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; v <a href="CppOperatorAssign.htm">=</a> board-&gt;GetAllPossibleMoves(player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;board-&gt;Do(v[i],player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do not always toggle the player<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> 2) Toggle(player);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Remove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player)<br/>
<a href="CppPreElse.htm">#else</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Remove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c, <b><a href="CppConst.htm">const</a></b> Player player)<br/>
<a href="CppEndif.htm">#endif</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanRemove(c,player));<br/>
&nbsp;&nbsp;m_board[c.GetLayer()][c.GetX()][c.GetY()] <a href="CppOperatorAssign.htm">=</a> Position<a href="CppState.htm">State</a>::empty;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Remove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v, <b><a href="CppConst.htm">const</a></b> Player player)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanRemove(v,player));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Proper ordering: v[0] must be marble above<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> v[0].GetLayer() &lt; v[1].GetLayer())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; w(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(w[0],w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Remove(w,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">Assert</a> proper ordering<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> v[0].GetLayer() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> v[1].GetLayer());<br/>
&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,player](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove(c,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <b><a href="CppOperatorEqual.htm">operator==</a></b>");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoardBasic a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoardBasic b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorEqual.htm">==</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a.Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b.Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorEqual.htm">==</a> b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorEqual.htm">operator==</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoardAdvanced a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoardAdvanced b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorEqual.htm">==</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a.Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b.Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorEqual.htm">==</a> b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoardAdvanced a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoardBasic b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a.Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b.Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Game::Clone of GameBasic");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(a-&gt;Clone());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; c(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Game::Clone of GameAdvanced");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(a-&gt;Clone());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; c(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Clone of played GameBasic");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(a-&gt;Clone());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Clone of played BoardAdvanced");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(a-&gt;Clone());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test conversion of Board to text");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,1,0)",Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,1,0)",Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X O . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,1,1)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,1,1)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(a-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X O . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". X . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,1)",Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,0,1)",Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(a-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X O . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"O X . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(1,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(1,0,0)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(a-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X O . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" X . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"O X . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,2,0)",Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,2,0)",Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(a-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X O O .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" X . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"O X . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,2,1)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,2,1)",Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(a-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"X O O .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" X . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"O X X .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . .\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" . . . \n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;". . . ."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> b-&gt;ToStr());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test horizontal detection of line in both boards");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,1,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,1,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove); <a href="CppComment.htm">//</a>Basic does not test <b><a href="CppFor.htm">for</a></b> lines<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,1,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,1,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove); <a href="CppComment.htm">//</a>Basic does not test <b><a href="CppFor.htm">for</a></b> lines<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test horizontal detection of line in both boards");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,1)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,1)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,2)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,2)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,3)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,3)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove); <a href="CppComment.htm">//</a>Basic does not test <b><a href="CppFor.htm">for</a></b> lines<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,0)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,1)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,1)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,3)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,3)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove); <a href="CppComment.htm">//</a>Basic does not test <b><a href="CppFor.htm">for</a></b> lines<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test block detection of line in both boards");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a(<b><a href="CppNew.htm">new</a></b> BoardAdvanced);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b(<b><a href="CppNew.htm">new</a></b> BoardBasic);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,1,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,1,0)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,1)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,1)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,1,1)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,1,1)"),Player::player1,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,3)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,3)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,3)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,3)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,2)"),Player::player2,must_remove); <a href="CppAssert.htm">assert</a>( must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Board test transfer of marbles");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,0)"),Player::player2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,0,0)"),Player::player2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,0)-&gt;(0,0,1)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,0,0)-&gt;(0,0,1)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,0)-&gt;(0,0,1)"),Player::player2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,0,0)-&gt;(0,0,1)"),Player::player2));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Board test stacking by setting");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(0,0,0)"), Coordinat("(0,1,0)"), Coordinat("(0,2,0)"), Coordinat("(0,3,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(0,3,1)"), Coordinat("(0,2,1)"), Coordinat("(0,1,1)"), Coordinat("(0,0,1)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(0,0,2)"), Coordinat("(0,1,2)"), Coordinat("(0,2,2)"), Coordinat("(0,3,2)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(0,3,3)"), Coordinat("(0,2,3)"), Coordinat("(0,1,3)"), Coordinat("(0,0,3)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(1,0,0)"), Coordinat("(1,1,0)"), Coordinat("(1,2,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(1,0,1)"), Coordinat("(1,1,1)"), Coordinat("(1,2,1)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(1,0,2)"), Coordinat("(1,1,2)"), Coordinat("(1,2,2)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(2,0,0)"), Coordinat("(2,1,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(2,0,1)"), Coordinat("(2,1,1)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat("(3,0,0)")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Player player <a href="CppOperatorAssign.htm">=</a> Player::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a,b,&amp;player](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanSet(c,player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanSet(c,player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(c,player,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(c,player,must_remove); <a href="CppAssert.htm">assert</a>(!must_remove);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toggle(player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetWinner() <a href="CppOperatorNotEqual.htm">!=</a> Winner::none);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetWinner() <a href="CppOperatorNotEqual.htm">!=</a> Winner::none);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Board test #2");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; v <a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,0,0)"), Move("(0,0,1)"), Move("(0,1,1)"), Move("(0,1,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(1,0,0)"), Move("(0,0,2)"), Move("(0,1,2)"), Move("(0,2,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,2,2)"), Move("(0,3,0)")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Player player <a href="CppOperatorAssign.htm">=</a> Player::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a,b,&amp;player](<b><a href="CppConst.htm">const</a></b> Move&amp; m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!a-&gt;CanDo(m,player)) <a href="CppTRACE.htm">TRACE</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b-&gt;CanDo(m,player)) <a href="CppTRACE.htm">TRACE</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo(m,player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanDo(m,player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(m,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(m,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toggle(player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,2,1)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,2,1) !(0,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(1,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(0,0,0) !(1,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,2,1) !(0,1,1)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(0,1,1) !(1,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,1,1)"),Player::player1));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,2,1)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,2,1) !(0,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(1,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(0,0,0) !(1,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,2,1) !(0,1,1)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(0,1,1) !(1,0,0)"),Player::player1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,1,1)"),Player::player1));<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Board test #3");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; v <a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,0,0)"), Move("(0,1,0)"), Move("(0,0,1)"), Move("(0,1,1)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,0,2)"), Move("(0,1,2)")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Player player <a href="CppOperatorAssign.htm">=</a> Player::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a,b,&amp;player](<b><a href="CppConst.htm">const</a></b> Move&amp; m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!a-&gt;CanDo(m,player)) <a href="CppTRACE.htm">TRACE</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b-&gt;CanDo(m,player)) <a href="CppTRACE.htm">TRACE</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo(m,player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanDo(m,player));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(m,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(m,player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toggle(player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,0,2)-&gt;(1,0,0)"),Player::player1)); <a href="CppComment.htm">//</a>1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,1)-&gt;(1,0,1)"),Player::player1)); <a href="CppComment.htm">//</a>2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,0)-&gt;(0,2,0)"),Player::player1)); <a href="CppComment.htm">//</a>3<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,0,2)-&gt;(1,0,0)"),Player::player1)); <a href="CppComment.htm">//</a>1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,0,1)-&gt;(1,0,1)"),Player::player1)); <a href="CppComment.htm">//</a>2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,0,0)-&gt;(0,2,0)"),Player::player1)); <a href="CppComment.htm">//</a>3<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::GetAllPossibleMoves simple transfer");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 16);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 16);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 16);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 16);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,0)"),Player::player1); <a href="CppComment.htm">//</a>1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 15);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 15);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 15);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 15);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,1)"),Player::player2); <a href="CppComment.htm">//</a>2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,1)"),Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,1,1)"),Player::player1); <a href="CppComment.htm">//</a>3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,1,1)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,1,0)"),Player::player2); <a href="CppComment.htm">//</a>4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,1,0)"),Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;Count(Position<a href="CppState.htm">State</a>::player1) <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;Count(Position<a href="CppState.htm">State</a>::player1) <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;Count(Position<a href="CppState.htm">State</a>::player2) <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;Count(Position<a href="CppState.htm">State</a>::player2) <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 13); <a href="CppComment.htm">//</a>13<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 13); <a href="CppComment.htm">//</a>12 on bottom layer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 13); <a href="CppComment.htm">//</a>1 on one-but-buttom layer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 13);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,2,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,2,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,2,1)"),Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,2,1)"),Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;Get(Coordinat(0,2,1)) <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;Get(Coordinat(0,2,1)) <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 14); <a href="CppComment.htm">//</a>13<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 14); <a href="CppComment.htm">//</a>10 on bottom layer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 14); <a href="CppComment.htm">//</a>2 on one-but-buttom layer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 14); <a href="CppComment.htm">//</a>2 transfers<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::GetAllPossibleMoves simple remove");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicBoard();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,1)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,1)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,1,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,1,0)"),Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>After placing (0,1,1), there are one (4 ways) or two marbles (6 ways) to be removed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Next to <b><a href="CppThis.htm">this</a></b>, there are 12 empty spots<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 22);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player1).size() <a href="CppOperatorEqual.htm">==</a> 22);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 13);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetAllPossibleMoves(Player::player2).size() <a href="CppOperatorEqual.htm">==</a> 13);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Filling up 5 basic <a href="CppPylos.htm">Pylos</a> boards randomly");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::PlayRandom<a href="CppPylos.htm">Pylos</a>Game(<a href="CppPylos.htm">pylos</a>::Board::CreateBasicBoard());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Filling up 5 advanced <a href="CppPylos.htm">Pylos</a> boards randomly");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::PlayRandom<a href="CppPylos.htm">Pylos</a>Game(<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::CreateAdvancedBoard());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Filling up 5 <a href="CppPylos.htm">Pylos</a> boards randomly");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::PlayRandom<a href="CppPylos.htm">Pylos</a>Game();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;ToText();<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> s;<br/>
&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),[&amp;s](<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; t) { s <a href="CppOperatorPlusAssign.htm">+=</a> t; s <a href="CppOperatorPlusAssign.htm">+=</a> '\n'; } );<br/>
&nbsp;&nbsp;s.resize( s.size() <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::ToText() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v(7,<a href="CppStdString.htm">std::string</a>(7,' '));<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> 0; layer<a href="CppOperatorNotEqual.htm">!=</a>4; <a href="CppOperatorIncrement.htm">++</a>layer)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> y=0; y<a href="CppOperatorNotEqual.htm">!=</a>4-layer; <a href="CppOperatorIncrement.htm">++</a>y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> x=0; x<a href="CppOperatorNotEqual.htm">!=</a>4-layer; <a href="CppOperatorIncrement.htm">++</a>x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x_co <a href="CppOperatorAssign.htm">=</a> layer <a href="CppOperatorPlus.htm">+</a> (x * 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y_co <a href="CppOperatorAssign.htm">=</a> layer <a href="CppOperatorPlus.htm">+</a> (y * 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(layer,x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetLayer() <a href="CppOperatorEqual.htm">==</a> layer);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> c_old <a href="CppOperatorAssign.htm">=</a> v[y_co][x_co];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> c_new <a href="CppOperatorAssign.htm">=</a> ToChar(Get(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Higher empty positions must not overwrite occupied lower ones<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (c_new <a href="CppOperatorEqual.htm">==</a> ToChar(Position<a href="CppState.htm">State</a>::empty)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ( c_old <a href="CppOperatorEqual.htm">==</a> ToChar(Position<a href="CppState.htm">State</a>::player1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> c_old <a href="CppOperatorEqual.htm">==</a> ToChar(Position<a href="CppState.htm">State</a>::player2) ) )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v[y_co][x_co] <a href="CppOperatorAssign.htm">=</a> c_new;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::Text<a href="CppCanvas.htm">Canvas</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::ToText<a href="CppCanvas.htm">Canvas</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Text<a href="CppCanvas.htm">Canvas</a>&gt; canvas {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Text<a href="CppCanvas.htm">Canvas</a>(7,7)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> 0; layer<a href="CppOperatorNotEqual.htm">!=</a>4; <a href="CppOperatorIncrement.htm">++</a>layer)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> y=0; y<a href="CppOperatorNotEqual.htm">!=</a>4-layer; <a href="CppOperatorIncrement.htm">++</a>y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> x=0; x<a href="CppOperatorNotEqual.htm">!=</a>4-layer; <a href="CppOperatorIncrement.htm">++</a>x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x_co <a href="CppOperatorAssign.htm">=</a> layer <a href="CppOperatorPlus.htm">+</a> (x * 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y_co <a href="CppOperatorAssign.htm">=</a> layer <a href="CppOperatorPlus.htm">+</a> (y * 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(layer,x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetLayer() <a href="CppOperatorEqual.htm">==</a> layer);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> c_old <a href="CppOperatorAssign.htm">=</a> canvas-&gt;GetChar(x_co,y_co);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> c_new <a href="CppOperatorAssign.htm">=</a> ToChar(Get(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Higher empty positions must not overwrite occupied lower ones<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (c_new <a href="CppOperatorEqual.htm">==</a> ToChar(Position<a href="CppState.htm">State</a>::empty)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ( c_old <a href="CppOperatorEqual.htm">==</a> ToChar(Position<a href="CppState.htm">State</a>::player1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> c_old <a href="CppOperatorEqual.htm">==</a> ToChar(Position<a href="CppState.htm">State</a>::player2) ) )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas-&gt;PutChar(x_co,y_co,c_new);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> canvas;<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board::Transfer(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state <a href="CppOperatorAssign.htm">=</a> Get(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(state<a href="CppOperatorNotEqual.htm">!=</a>Position<a href="CppState.htm">State</a>::empty);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player <a href="CppOperatorAssign.htm">=</a> ToPlayer(state);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanTransfer(from,player));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanSet(to,player));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanTransfer(from,to,player));<br/>
&nbsp;&nbsp;Remove(from,player);<br/>
&nbsp;&nbsp;Set(to,player,must_remove);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Board&amp; lhs, <b><a href="CppConst.htm">const</a></b> Board&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Determine <b><a href="CppIf.htm">if</a></b> types are equal<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppTypeid.htm">typeid</a></b>(lhs)<a href="CppOperatorNotEqual.htm">!=</a><b><a href="CppTypeid.htm">typeid</a></b>(rhs)) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.m_board <a href="CppOperatorEqual.htm">==</a> rhs.m_board;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Board&amp; lhs, <b><a href="CppConst.htm">const</a></b> Board&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs<a href="CppOperatorEqual.htm">==</a>rhs);<br/>
}<br/>
<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os,<b><a href="CppConst.htm">const</a></b> Board&amp; p) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;os <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p.ToStr();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> os;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::BoardAdvanced::BoardAdvanced() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
&nbsp;&nbsp;: Board()<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::BoardAdvanced::Clone() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;BoardAdvanced * <b><a href="CppConst.htm">const</a></b> p <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNew.htm">new</a></b> BoardAdvanced;<br/>
&nbsp;&nbsp;p-&gt;m_board <a href="CppOperatorAssign.htm">=</a> m_board;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; sp(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*sp <a href="CppOperatorEqual.htm">==</a> *<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> sp;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::BoardAdvanced::Set(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player,<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanSet(c,player));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state <a href="CppOperatorAssign.htm">=</a> ToPosition<a href="CppState.htm">State</a>(player);<br/>
&nbsp;&nbsp;m_board[c.GetLayer()][c.GetX()][c.GetY()] <a href="CppOperatorAssign.htm">=</a> state;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Get(c)<a href="CppOperatorEqual.htm">==</a>state);<br/>
<br/>
&nbsp;&nbsp;must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> squares<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; Square;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Square&gt; v <a href="CppOperatorAssign.htm">=</a> GetSquares(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() &lt; 5);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> do_<b><a href="CppReturn.htm">return</a></b> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,&amp;do_<b><a href="CppReturn.htm">return</a></b>,state](<b><a href="CppConst.htm">const</a></b> Square&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!do_<b><a href="CppReturn.htm">return</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> success <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(s.begin(),s.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,&amp;success,state](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success) { <b><a href="CppIf.htm">if</a></b> (Get(d)<a href="CppOperatorNotEqual.htm">!=</a>state) { success <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>; } }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success) { do_<b><a href="CppReturn.htm">return</a></b> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (do_<b><a href="CppReturn.htm">return</a></b>) { must_remove <a href="CppOperatorAssign.htm">=</a> ToMustRemove<a href="CppState.htm">State</a>(player); <b><a href="CppReturn.htm">return</a></b>; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> lines<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; Line;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Line&gt; v <a href="CppOperatorAssign.htm">=</a> GetLines(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/There will be zero (layer 2 and 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/or two lines (layer 0 and 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 0 <a href="CppOperatorLogicalOr.htm">||</a> v.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdFind_if.htm">std::find_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,state](<b><a href="CppConst.htm">const</a></b> Line&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdFind_if.htm">std::find_if</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.begin(),s.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,state](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Get(d)<a href="CppOperatorNotEqual.htm">!=</a>state;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) <a href="CppOperatorEqual.htm">==</a> s.end();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) <a href="CppOperatorNotEqual.htm">!=</a> v.end()) { must_remove <a href="CppOperatorAssign.htm">=</a> ToMustRemove<a href="CppState.htm">State</a>(player); <b><a href="CppReturn.htm">return</a></b>; }<br/>
&nbsp;&nbsp;}<br/>
<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::BoardBasic::BoardBasic() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
&nbsp;&nbsp;: Board()<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Board&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::BoardBasic::Clone() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;BoardBasic * <b><a href="CppConst.htm">const</a></b> p <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNew.htm">new</a></b> BoardBasic;<br/>
&nbsp;&nbsp;p-&gt;m_board <a href="CppOperatorAssign.htm">=</a> m_board;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; sp(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*sp <a href="CppOperatorEqual.htm">==</a> *<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> sp;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::BoardBasic::Set(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player,<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a>&amp; must_remove)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanSet(c,player));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state <a href="CppOperatorAssign.htm">=</a> ToPosition<a href="CppState.htm">State</a>(player);<br/>
&nbsp;&nbsp;m_board[c.GetLayer()][c.GetX()][c.GetY()] <a href="CppOperatorAssign.htm">=</a> state;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Get(c)<a href="CppOperatorEqual.htm">==</a>state);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> squares<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; Square;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Square&gt; v <a href="CppOperatorAssign.htm">=</a> GetSquares(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdFind_if.htm">std::find_if</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,state](<b><a href="CppConst.htm">const</a></b> Square&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdFind_if.htm">std::find_if</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.begin(),s.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>,state](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Get(d) <a href="CppOperatorNotEqual.htm">!=</a> state;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) <a href="CppOperatorEqual.htm">==</a> s.end();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) <a href="CppOperatorNotEqual.htm">!=</a> v.end())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;must_remove <a href="CppOperatorAssign.htm">=</a> ToMustRemove<a href="CppState.htm">State</a>(player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pyloscoordinat.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pyloscoordinat.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Coordinat, <a href="CppPylos.htm">Pylos</a>/Phyraos coordinat <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSCOORDINAT_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSCOORDINAT_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Coordinat<br/>
{<br/>
&nbsp;&nbsp;Coordinat(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Construct</a> a Coordinat from a <a href="CppStdString.htm">std::string</a>.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/For example, (0,1,2) is the coordinat Z=0=bottom,X=1=leftmost-but-one,Y=2=frontmost-but-two<br/>
&nbsp;&nbsp;Coordinat(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the layer or Z-coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/0: bottom 4x4 layer, 3: top 1x1 layer<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetLayer() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_layer; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> coordinat its X coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/0: Left<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetX() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_x; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> coordinat its Y coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/0: Top<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetY() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_y; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsValid <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> the proposed coordinat is a valid <a href="CppPylos.htm">Pylos</a> coordinat<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> IsValid(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsValid <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> coordinat is a valid <a href="CppPylos.htm">Pylos</a> coordinat<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsValid() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/ToStr() <a href="CppConvert.htm">converts</a> the coordinat to a <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/of the form '(layer,x,y)'.<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_layer;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_x;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_y;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; lhs, <b><a href="CppConst.htm">const</a></b> Coordinat&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; lhs, <b><a href="CppConst.htm">const</a></b> Coordinat&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os,<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>GetAbove <a href="CppReturn.htm">returns</a> the coordinats physically<br/>
<a href="CppComment.htm">///</a>above the entered coordinat<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; GetAbove(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
<a href="CppComment.htm">///</a>GetAll<a href="CppPylos.htm">Pylos</a>Coordinats <a href="CppReturn.htm">returns</a> all possible <a href="CppPylos.htm">Pylos</a>Coordinats<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; GetAllCoordinats() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>GetBelow <a href="CppReturn.htm">returns</a> the four coordinats physically<br/>
<a href="CppComment.htm">///</a>below the entered coordinat<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; GetBelow(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
<a href="CppComment.htm">///</a>GetLines <a href="CppReturn.htm">returns</a> the possible 2x2 squares around the coordinat<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; &gt; GetLines(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
<a href="CppComment.htm">///</a>GetRandom<a href="CppPylos.htm">Pylos</a>Coordinat <a href="CppReturn.htm">returns</a> a random valid <a href="CppPylos.htm">Pylos</a>Coordinat<br/>
<b><a href="CppConst.htm">const</a></b> Coordinat GetRandomCoordinat() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>GetSquares <a href="CppReturn.htm">returns</a> the possible 2x2 squares around the coordinat<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; &gt; GetSquares(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSCOORDINAT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pyloscoordinat.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pyloscoordinat.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Coordinat, <a href="CppPylos.htm">Pylos</a>/Phyraos coordinat <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>coordinat.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::Coordinat(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
&nbsp;&nbsp;: m_layer(layer),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x(x),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y(y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsValid(layer,x,y));<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::Coordinat(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;: m_layer{<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(s.at(1))},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x{<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(s.at(3))},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y{<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(s.at(5))}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorEqual.htm">==</a> 7);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!IsValid(m_layer,m_x,m_y)) { <a href="CppTRACE.htm">TRACE</a>(s); }<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsValid(m_layer,m_x,m_y));<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> layer <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> layer &lt; 4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> x <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> x &lt; 4-layer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; 4-layer;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::GetAllCoordinats() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> z=0; z<a href="CppOperatorNotEqual.htm">!=</a>4; <a href="CppOperatorIncrement.htm">++</a>z)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> y=0; y<a href="CppOperatorNotEqual.htm">!=</a>4-z; <a href="CppOperatorIncrement.htm">++</a>y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> x=0; x<a href="CppOperatorNotEqual.htm">!=</a>4-z; <a href="CppOperatorIncrement.htm">++</a>x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(Coordinat(z,x,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 30);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "2.0";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2012-05-05: <a href="CppVersion.htm">version</a> 2.0: initial release <a href="CppVersion.htm">version</a>"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsValid(m_layer,m_x,m_y);<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(m_layer)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> ","<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(m_x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> ","<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(m_y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> ")";<br/>
<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::GetAbove(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> c.GetLayer() <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> c.GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> c.GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Just get all coordinats<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid(layer,x-0,y-0)) v.push_back(Coordinat(layer,x-0,y-0));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid(layer,x-0,y-1)) v.push_back(Coordinat(layer,x-0,y-1));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid(layer,x-1,y-0)) v.push_back(Coordinat(layer,x-1,y-0));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid(layer,x-1,y-1)) v.push_back(Coordinat(layer,x-1,y-1));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::GetBelow(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.IsValid());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.GetLayer()<a href="CppOperatorNotEqual.htm">!=</a>0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> c.GetLayer() <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> c.GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> c.GetY();<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v;<br/>
&nbsp;&nbsp;v.push_back(Coordinat(layer,x+0,y+0));<br/>
&nbsp;&nbsp;v.push_back(Coordinat(layer,x+1,y+0));<br/>
&nbsp;&nbsp;v.push_back(Coordinat(layer,x+0,y+1));<br/>
&nbsp;&nbsp;v.push_back(Coordinat(layer,x+1,y+1));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat&gt; &gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::GetLines(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; Line;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Line&gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> c.GetLayer();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (layer <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalOr.htm">||</a> layer <a href="CppOperatorEqual.htm">==</a> 3) <b><a href="CppReturn.htm">return</a></b> v;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> c.GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> c.GetY();<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Line horizontal;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Line vertical;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>4-layer; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horizontal.push_back(Coordinat(layer,i,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertical.push_back(Coordinat(layer,x,i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(horizontal.size()) <a href="CppOperatorEqual.htm">==</a> 4-layer);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(vertical.size()) <a href="CppOperatorEqual.htm">==</a> 4-layer);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(horizontal);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(vertical);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::GetRandomCoordinat() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> ( <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> 4;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> ( <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> (4 <a href="CppOperatorMinus.htm">-</a> layer);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> ( <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> (4 <a href="CppOperatorMinus.htm">-</a> layer);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::IsValid(layer,x,y));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Coordinat(layer,x,y);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat&gt; &gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::GetSquares(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; Square;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Square&gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> layer <a href="CppOperatorAssign.htm">=</a> c.GetLayer();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(layer <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(layer &lt; 4);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> c.GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> c.GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> 4 <a href="CppOperatorMinus.htm">-</a> layer;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Square s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-0,y-0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-0,y-1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-1,y-0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-1,y-1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorPlus.htm">+</a> 1 &lt; sz <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Square s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+0,y-0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+0,y-1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+1,y-0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+1,y-1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorPlus.htm">+</a> 1 &lt; sz)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Square s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-0,y+0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-0,y+1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-1,y+0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x-1,y+1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorPlus.htm">+</a> 1 &lt; sz <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorPlus.htm">+</a> 1 &lt; sz)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Square s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+0,y+0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+0,y+1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+1,y+0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.push_back(Coordinat(layer,x+1,y+1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Coordinat::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppPylos.htm">Pylos</a>Coordinat <a href="CppOperator.htm">operators</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c1(0,2,2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c2(0,2,3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c3(0,3,2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c1_too(0,2,2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c1 <a href="CppOperatorNotEqual.htm">!=</a> c2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c1 <a href="CppOperatorNotEqual.htm">!=</a> c3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c1 <a href="CppOperatorEqual.htm">==</a> c1_too);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c2 <a href="CppOperatorNotEqual.htm">!=</a> c3);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Coordinat GetBelow <a href="CppFunction.htm">function</a> on (1,0,1)");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> GetBelow(Coordinat(1,0,1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,0,1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,0,2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,1,1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,1,2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Coordinat GetBelow <a href="CppFunction.htm">function</a> on (1,0,2)");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> GetBelow(Coordinat(1,0,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,0,2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,0,3))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,1,2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(0,1,3))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Coordinat GetAbove <a href="CppFunction.htm">function</a> on (0,0,0)");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> GetAbove(Coordinat(0,0,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(1,0,0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Coordinat GetAbove <a href="CppFunction.htm">function</a> on (0,1,2)");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> GetAbove(Coordinat(0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(1,0,1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(1,0,2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(1,1,1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(1,1,2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Coordinat GetAbove <a href="CppFunction.htm">function</a> on (1,2,1)");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> GetAbove(Coordinat(1,2,1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(2,1,0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(2,1,1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Coordinat GetAbove <a href="CppFunction.htm">function</a> on (2,0,0)");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> GetAbove(Coordinat(2,0,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdFind.htm">std::find</a>(v.begin(),v.end(),Coordinat(3,0,0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> v.end());<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; lhs, <b><a href="CppConst.htm">const</a></b> Coordinat&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.GetLayer() <a href="CppOperatorEqual.htm">==</a> rhs.GetLayer()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetX() <a href="CppOperatorEqual.htm">==</a> rhs.GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetY() <a href="CppOperatorEqual.htm">==</a> rhs.GetY();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; lhs, <b><a href="CppConst.htm">const</a></b> Coordinat&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os,<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;os <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> c.ToStr();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pyloscurrentmovestate.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pyloscurrentmovestate.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>, <a href="CppPylos.htm">Pylos</a>/Phyraos current move state <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSCURRENTMOVESTATE_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSCURRENTMOVESTATE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>coordinat.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>move.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>mustremovestate.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<a href="CppComment.htm">///</a>CurrentMove<a href="CppState.htm">State</a> contains the state of the current Move.<br/>
<a href="CppComment.htm">///</a>CurrentMove<a href="CppState.htm">State</a> is used by <a href="CppPylos.htm">pylos</a>::Game, to incrementally keep track of the<br/>
<a href="CppComment.htm">///</a>ongoing move<br/>
<b><a href="CppStruct.htm">struct</a></b> CurrentMove<a href="CppState.htm">State</a><br/>
{<br/>
&nbsp;&nbsp;CurrentMove<a href="CppState.htm">State</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the current Move in process<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Move&amp; GetMove() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_current_move; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppIf.htm">if</a></b> the first part of the move has taken place and<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppIf.htm">if</a></b> the current player must remove one or two marbles<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> GetMustRemove() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Is it unknown what kind of Move <b><a href="CppThis.htm">this</a></b> is?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsMoveUnknown() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsMoveMove() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsMovePlace() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Restart() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set a complete Move directly<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetMove(<b><a href="CppConst.htm">const</a></b> Move&amp; move);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the transfer part of a move,enabling<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetMoveTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from, <b><a href="CppConst.htm">const</a></b> Coordinat&amp; to);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetMoveSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the duty of one or none of the players<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetMustRemove(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a> must_remove);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRemove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v);<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;Move m_current_move;<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> m_must_remove;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> CurrentMove<a href="CppState.htm">State</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> CurrentMove<a href="CppState.htm">State</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSCURRENTMOVESTATE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pyloscurrentmovestate.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pyloscurrentmovestate.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>, <a href="CppPylos.htm">Pylos</a>/Phyraos current move state <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>currentmovestate.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::CurrentMove<a href="CppState.htm">State</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
&nbsp;&nbsp;: m_current_move{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_must_remove(MustRemove<a href="CppState.htm">State</a>::no)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsMoveUnknown());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(IsRemoveUnknown());<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "2.0";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2012-05-05: <a href="CppVersion.htm">version</a> 2.0: initial release <a href="CppVersion.htm">version</a>"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::IsMoveMove() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_move.size() &lt; 3);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_current_move.m_move.size() <a href="CppOperatorEqual.htm">==</a> 2;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::IsMovePlace() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_move.size() &lt; 3);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_current_move.m_move.size() <a href="CppOperatorEqual.htm">==</a> 1;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::IsMoveUnknown() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_move.size() &lt; 3);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_current_move.m_move.size() <a href="CppOperatorEqual.htm">==</a> 0;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::MustRemove<a href="CppState.htm">State</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::GetMustRemove() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_must_remove;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::Restart() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;m_current_move <a href="CppOperatorAssign.htm">=</a> Move();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsMoveUnknown());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::SetMove(<b><a href="CppConst.htm">const</a></b> Move&amp; move)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_move.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_remove.empty());<br/>
&nbsp;&nbsp;m_current_move <a href="CppOperatorAssign.htm">=</a> move;<br/>
&nbsp;&nbsp;m_must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::SetMoveTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from, <b><a href="CppConst.htm">const</a></b> Coordinat&amp; to)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsMoveUnknown());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_move.empty());<br/>
&nbsp;&nbsp;m_current_move.m_move.push_back(from);<br/>
&nbsp;&nbsp;m_current_move.m_move.push_back(to);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::SetMoveSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsMoveUnknown());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move.m_move.empty());<br/>
&nbsp;&nbsp;m_current_move.m_move.push_back(c);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::SetMustRemove(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a> must_remove)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(must_remove <a href="CppOperatorEqual.htm">==</a> MustRemove<a href="CppState.htm">State</a>::player2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp; m_must_remove <a href="CppOperatorEqual.htm">==</a> MustRemove<a href="CppState.htm">State</a>::player1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot set duty to remove from player 1 to player 2");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(must_remove <a href="CppOperatorEqual.htm">==</a> MustRemove<a href="CppState.htm">State</a>::player1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp; m_must_remove <a href="CppOperatorEqual.htm">==</a> MustRemove<a href="CppState.htm">State</a>::player2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot set duty to remove from player 2 to player 1");<br/>
&nbsp;&nbsp;m_must_remove <a href="CppOperatorAssign.htm">=</a> must_remove;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::SetRemove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;m_current_move.m_remove <a href="CppOperatorAssign.htm">=</a> v;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppPylos.htm">Pylos</a>CurrentMove<a href="CppState.htm">State</a>");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(0,1,1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.IsMoveUnknown());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!s.GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.SetMoveSet(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!s.IsMoveUnknown());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppPylos.htm">pylos</a>::Move m <a href="CppOperatorAssign.htm">=</a> s.GetMove();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.m_move.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.m_move[0] <a href="CppOperatorEqual.htm">==</a> c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.m_remove.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s.Restart();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPylos.htm">pylos</a>::CurrentMove<a href="CppState.htm">State</a> t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorEqual.htm">==</a> t);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> CurrentMove<a href="CppState.htm">State</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> CurrentMove<a href="CppState.htm">State</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.GetMustRemove() <a href="CppOperatorEqual.htm">==</a> rhs.GetMustRemove()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetMove() <a href="CppOperatorEqual.htm">==</a> rhs.GetMove();<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosfwd.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosfwd.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>fwd.h, <a href="CppForwardDeclaration.htm">forward declaration</a>s of <a href="CppPylos.htm">Pylos</a>/Phyraos <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSFWD_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSFWD_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Player;<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Position<a href="CppState.htm">State</a>;<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> MustRemove<a href="CppState.htm">State</a>;<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppQt.htm">Qt</a>Sprites;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSFWD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosgame.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosgame.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Game, <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> a game of <a href="CppPylos.htm">Pylos</a>/Phyraos<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSGAME_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSGAME_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>board.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>currentmovestate.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>fwd.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>positionstate.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>winner.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppPylos.htm">Pylos</a> is a <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> storing a <a href="CppPylos.htm">Pylos</a> game.<br/>
<a href="CppComment.htm">///</a><a href="Games.htm">Games</a> can be player in:\n<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> <a href="CppPylos.htm">Pylos</a> notation: (Can)Do\n<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> <b><a href="CppUsing.htm">using</a></b> Coordinats: (Can)Place, (Can)Move, (Can)Remove\n<br/>
<a href="CppComment.htm">///</a><a href="Games.htm">Games</a> can also be saved and loaded.<br/>
<b><a href="CppStruct.htm">struct</a></b> Game<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppCopyConstructor.htm">Copy constructor</a><br/>
&nbsp;&nbsp;Game(<b><a href="CppConst.htm">const</a></b> Game&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an <a href="CppPylos.htm">Pylos</a> game in the starting position.<br/>
&nbsp;&nbsp;Game(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; board);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create a mid-game <a href="CppPylos.htm">Pylos</a>.<br/>
&nbsp;&nbsp;Game(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; board,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player current_player,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppPylos.htm">pylos</a>::Move&gt;&amp; move_history,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CurrentMove<a href="CppState.htm">State</a>&gt;&amp; current_move);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanDo determines <b><a href="CppIf.htm">if</a></b> a <a href="CppPylos.htm">Pylos</a> notation move is valid<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanDo determines <b><a href="CppIf.htm">if</a></b> a <a href="CppPylos.htm">Pylos</a> move is valid<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppPylos.htm">pylos</a>::Move&amp; m) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanRemove specifies <b><a href="CppIf.htm">if</a></b> current player can remove one or<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/two marble(s) at the requested position(s).<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanRemove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanSet tests <b><a href="CppIf.htm">if</a></b> the current player can be set at the Coordinat<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanTransfer specifies <b><a href="CppIf.htm">if</a></b> current player can transfer<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/the marble at the specified coordinat <b><a href="CppFor.htm">for</a></b> movement<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanTransfer specifies <b><a href="CppIf.htm">if</a></b> current player can transfer his marble<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/to a <b><a href="CppNew.htm">new</a></b>, higher position<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanTransfer(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an advanced game at its initial position<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; CreateAdvancedGame();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create a basic game at its initial position<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; CreateBasicGame();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Do performs a move in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Do(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Do performs a <a href="CppPylos.htm">Pylos</a> move<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Do(<b><a href="CppConst.htm">const</a></b> Move&amp; m);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetAllPossibleMoves <a href="CppReturn.htm">returns</a> all moves valid <b><a href="CppFor.htm">for</a></b> the active player<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; GetAllPossibleMoves() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetBoard <a href="CppReturn.htm">returns</a> the board.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; GetBoard() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_board; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the current move's state<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CurrentMove<a href="CppState.htm">State</a>&gt; GetCurrentMove() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_current_move; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetCurrentTurn <a href="CppReturn.htm">returns</a> whose turn it is now<br/>
&nbsp;&nbsp;Player GetCurrentTurn() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppPylos.htm">pylos</a>::Move&gt;&amp; GetMoveHistory() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_move_history;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/MustRemove <a href="CppReturn.htm">returns</a> whether the current player<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/must remove one or two marbles<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> GetMustRemove() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetWinner <a href="CppReturn.htm">returns</a> the winner.<br/>
&nbsp;&nbsp;Winner GetWinner() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsValid <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> the current <a href="CppPylos.htm">Pylos</a> game is valid<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsValid() <b><a href="CppConst.htm">const</a></b>; <a href="CppComment.htm">//</a>?Not used?<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Load loads a game in <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Load(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/PlayRandom<a href="CppPylos.htm">Pylos</a>Game plays a random <a href="CppPylos.htm">Pylos</a> game and <a href="CppReturn.htm">returns</a> the winner.<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> Winner PlayRandomGame(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; board <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;());<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Remove lets the current player remove one or two marbles<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Remove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Restart sets the game in its initial position.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Restart();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set <a href="CppMake.htm">make</a>s m_current_players place his marble<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/at the specified position. After Place,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/MustRemoveMarbles must be called to determine <b><a href="CppIf.htm">if</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/the current player must remove some marbles<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/ToStr <a href="CppConvert.htm">converts</a> Game its contents to a <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Transfer lets current player tranfer his marble to a <b><a href="CppNew.htm">new</a></b>, higher position<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Transfer(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;Game() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; m_board;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CurrentMove<a href="CppState.htm">State</a>&gt; m_current_move;<br/>
&nbsp;&nbsp;Player m_current_player;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppPylos.htm">pylos</a>::Move&gt; m_move_history;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanRemove specifies <b><a href="CppIf.htm">if</a></b> current player can remove<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/the marble at the requested position.<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanRemove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Remove lets the current player remove one marble.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Remove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test the Game <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/TogglePlayer toggles between player1 and player2 and saves the current<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/move to the move history<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> TogglePlayer();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Game&amp; lhs, <b><a href="CppConst.htm">const</a></b> Game&amp; rhs);<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Game&amp; lhs, <b><a href="CppConst.htm">const</a></b> Game&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Game&amp; lhs, <b><a href="CppConst.htm">const</a></b> Game&amp; rhs);<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os,<b><a href="CppConst.htm">const</a></b> Game&amp; p);<br/>
<br/>
<a href="CppComment.htm">///</a>CanLoad<a href="CppPylos.htm">Pylos</a> determines <b><a href="CppIf.htm">if</a></b> loading a <a href="CppPylos.htm">Pylos</a> game from file<br/>
<a href="CppComment.htm">///</a>will be successfull<br/>
<b><a href="CppBool.htm">bool</a></b> CanLoad<a href="CppPylos.htm">Pylos</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; filename);<br/>
<br/>
<a href="CppComment.htm">///</a>Load<a href="CppPylos.htm">Pylos</a> loads a <a href="CppPylos.htm">Pylos</a> game from file<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; Load<a href="CppPylos.htm">Pylos</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; filename);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSGAME_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosgame.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosgame.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Game, <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> a game of <a href="CppPylos.htm">Pylos</a>/Phyraos<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>game.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>board.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>currentmovestate.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>move.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Game(<b><a href="CppConst.htm">const</a></b> Game&amp; rhs)<br/>
&nbsp;&nbsp;: m_board(rhs.m_board-&gt;Clone()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_move(<b><a href="CppNew.htm">new</a></b> CurrentMove<a href="CppState.htm">State</a>(*rhs.m_current_move)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_player(rhs.m_current_player),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_move_history(rhs.m_move_history)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_board);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_move <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_current_move);<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Game(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; &amp;board)<br/>
&nbsp;&nbsp;: m_board(board),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_move(<b><a href="CppNew.htm">new</a></b> CurrentMove<a href="CppState.htm">State</a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_player(Player::player1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_move_history{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppPylos.htm">pylos</a>::Move&amp; m) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanDo(m,m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanDo(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanDo(s,m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanRemove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_board-&gt;Get(c) <a href="CppOperatorNotEqual.htm">!=</a> m_current_player) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanRemove( <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,c), m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanRemove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!v.empty());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;Get(c) <a href="CppOperatorNotEqual.htm">!=</a> m_current_player;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;) &gt; 0) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanRemove(v, m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanSet(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanSet(c,m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_board-&gt;Get(c) <a href="CppOperatorNotEqual.htm">!=</a> GetCurrentTurn()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanTransfer(c,m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CanTransfer(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_board-&gt;Get(from) <a href="CppOperatorNotEqual.htm">!=</a> GetCurrentTurn()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;CanTransfer(from,to,m_current_player);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Do(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!CanDo(s)) <a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDo(s));<br/>
&nbsp;&nbsp;Do(<a href="CppPylos.htm">pylos</a>::Move(s));<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Do(<b><a href="CppConst.htm">const</a></b> <a href="CppPylos.htm">pylos</a>::Move&amp; m)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDo(m));<br/>
&nbsp;&nbsp;m_board-&gt;Do(m,m_current_player);<br/>
&nbsp;&nbsp;m_current_move-&gt;SetMove(m);<br/>
&nbsp;&nbsp;TogglePlayer();<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CreateAdvancedGame()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; board(Board::CreateAdvancedBoard());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt;(<b><a href="CppNew.htm">new</a></b> Game(board));<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::CreateBasicGame()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt; board(Board::CreateBasicBoard());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt;(<b><a href="CppNew.htm">new</a></b> Game(board));<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::GetAllPossibleMoves() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;GetAllPossibleMoves(m_current_player);<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Player <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::GetCurrentTurn() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_current_player;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "2.0";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2010-09-19: <a href="CppVersion.htm">version</a> 0.1: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2010-09-21: <a href="CppVersion.htm">version</a> 0.2: use of Coordinat",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2010-09-21: <a href="CppVersion.htm">version</a> 0.3: added Move",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2010-09-22: <a href="CppVersion.htm">version</a> 1.0: fixed <a href="CppBug.htm">bug</a> in Coordinat, added move history",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2012-05-05: <a href="CppVersion.htm">version</a> 2.0: major achitectural rewrite"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Winner <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::GetWinner() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_board-&gt;GetWinner();<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::MustRemove<a href="CppState.htm">State</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::GetMustRemove() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_current_move-&gt;GetMustRemove();<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Winner <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::PlayRandomGame(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Board&gt;&amp; board)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; p;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (board)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p.reset(<b><a href="CppNew.htm">new</a></b> Game(board-&gt;Clone()));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.reset(<b><a href="CppNew.htm">new</a></b> Game(Board::CreateAdvancedBoard()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.reset(<b><a href="CppNew.htm">new</a></b> Game(Board::CreateBasicBoard()));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (p-&gt;GetWinner() <a href="CppOperatorNotEqual.htm">!=</a> Winner::none)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p-&gt;GetWinner();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Choose <a href="CppAlgorithm.htm">algorithm</a> to draw next move<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use random move from GetAllPossibleMoves<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; v <a href="CppOperatorAssign.htm">=</a> p-&gt;GetAllPossibleMoves();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>(v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;Do(v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use random coordinats and random responses<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c <a href="CppOperatorAssign.htm">=</a> GetRandomCoordinat();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (p-&gt;CanTransfer(c))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppPylos.htm">pylos</a>::Coordinat&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppPylos.htm">pylos</a>::GetAllCoordinats();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdRandom_shuffle.htm">std::random_shuffle</a>(v.begin(),v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (p-&gt;CanTransfer(c,v[i]))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;Transfer(c,v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (p-&gt;CanSet(c))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;Set(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (p-&gt;GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(GetRandomCoordinat());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> 2) v.push_back(GetRandomCoordinat());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (p-&gt;CanRemove(v)) p-&gt;Remove(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Remove(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board-&gt;Get(c)<a href="CppOperatorEqual.htm">==</a>m_current_player);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,c),m_current_player));<br/>
&nbsp;&nbsp;m_board-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,c),m_current_player);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\warning: <b><a href="CppDo.htm">do</a></b> not allow these lines: <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/is an internal <a href="CppFunction.htm">function</a> used by<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Remove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_must_remove <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TogglePlayer();<br/>
<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Remove(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot call RemoveMarbles(c), because <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>also toggles the player<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanRemove(v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> v.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board-&gt;Get(v[0]) <a href="CppOperatorEqual.htm">==</a> m_current_player);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> m_board-&gt;Get(v[1]) <a href="CppOperatorEqual.htm">==</a> m_current_player);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> v[0] <a href="CppOperatorNotEqual.htm">!=</a> v[1]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Proper ordering: v[0] must be marble above<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> v[0].GetLayer() &lt; v[1].GetLayer())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; w(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(w[0],w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Remove(w); <a href="CppComment.htm">//</a>Call the same <a href="CppMemberFunction.htm">member function</a> with different order<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">Assert</a> proper ordering<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> v[0].GetLayer() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> v[1].GetLayer());<br/>
&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>](<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_board-&gt;Get(c)<a href="CppOperatorEqual.htm">==</a>m_current_player);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;Remove(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Three lines below must be executed exactly once per move<br/>
&nbsp;&nbsp;m_current_move-&gt;SetRemove(v);<br/>
&nbsp;&nbsp;m_current_move-&gt;SetMustRemove(MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;TogglePlayer();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Set(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!CanSet(c)) <a href="CppTRACE.htm">TRACE</a>(c);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set is always done as the first part of a Move<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanSet(c));<br/>
<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> GetMustRemove();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!must_remove <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Player must not remove a marble when placing a <b><a href="CppNew.htm">new</a></b> one");<br/>
&nbsp;&nbsp;m_board-&gt;Set(c,m_current_player,must_remove);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no) m_current_move-&gt;SetMustRemove(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ToMustRemove<a href="CppState.htm">State</a>(m_current_player));<br/>
<br/>
&nbsp;&nbsp;m_current_move-&gt;SetMoveSet(c);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player <a href="CppOperatorAssign.htm">=</a> ToPlayer(m_board-&gt;Get(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_move-&gt;SetMustRemove(ToMustRemove<a href="CppState.htm">State</a>(player));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If player must not remove another marble,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>his/her turn is over<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TogglePlayer();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::<b><a href="CppOperatorEqual.htm">operator==</a></b> <b><a href="CppFor.htm">for</a></b> different game types");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,0,0)");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::<b><a href="CppOperatorEqual.htm">operator==</a></b> <b><a href="CppFor.htm">for</a></b> same game types");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do("(0,0,0)");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do("(0,0,0)");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test basic Game dynamics <b><a href="CppUsing.htm">using</a></b> Set and Remove");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1 22<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1 22<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Only advanced game must detect player 1's line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Both games must detect player 2's square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,2,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,2,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>BoardAdvanced responds to the creation of a line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,3)")); <a href="CppComment.htm">//</a>Line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,3)")); <a href="CppComment.htm">//</a>Line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1); <a href="CppComment.htm">//</a>No toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>Toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;GetCurrentMove()-&gt;GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,0,0)"))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,0,0)"))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>Toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>BoardAdvanced and BoardBasic respond to the creation of a square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,1)")); <a href="CppComment.htm">//</a>Square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,1)")); <a href="CppComment.htm">//</a>Square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>No toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>No toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentMove()-&gt;GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentMove()-&gt;GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)"))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)"))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Clone of GameBasic");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b(<b><a href="CppNew.htm">new</a></b> Game(*a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; c <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Clone of GameAdvanced");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b(<b><a href="CppNew.htm">new</a></b> Game(*a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; c <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Clone of played GameBasic");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b(<b><a href="CppNew.htm">new</a></b> Game(*a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,1,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Clone of played BoardAdvanced");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b(<b><a href="CppNew.htm">new</a></b> Game(*a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,1,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test basic Game dynamics <b><a href="CppUsing.htm">using</a></b> full moves");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1 22<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 1 22<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Only advanced game must detect player 1's line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Both games must detect player 2's square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,3,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,3,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,2,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,2,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,2,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,2,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>BoardAdvanced responds to the creation of a line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo("(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanDo("(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,0) !(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,1) !(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,2) !(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo("(0,0,3) !(0,0,3) !(0,0,3)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,3) !(0,0,0)")); <a href="CppComment.htm">//</a>Line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,3)")); <a href="CppComment.htm">//</a>Line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>BoardAdvanced and BoardBasic respond to the creation of a square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Set(Coordinat("(0,3,1)")); <a href="CppComment.htm">//</a>Square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Set(Coordinat("(0,3,1)")); <a href="CppComment.htm">//</a>Square<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>No toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player2); <a href="CppComment.htm">//</a>No toggle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentMove()-&gt;GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentMove()-&gt;GetMustRemove() <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)"))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanRemove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)"))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,Coordinat("(0,3,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;GetCurrentMove()-&gt;GetMustRemove());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetCurrentTurn() <a href="CppOperatorEqual.htm">==</a> Player::player1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Game history");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 12..<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 34..<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 56..<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 7...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test that in basic play, no marbles must be removed. Test that in advanced play, marbles must be removed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetMoveHistory().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetMoveHistory().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; v <a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,0,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,1,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,0,1)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,1,1)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(1,0,0)")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> j <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>j; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetMoveHistory().size() <a href="CppOperatorEqual.htm">==</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetMoveHistory().size() <a href="CppOperatorEqual.htm">==</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;GetMoveHistory()[i] <a href="CppOperatorEqual.htm">==</a> v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;GetMoveHistory()[i] <a href="CppOperatorEqual.htm">==</a> v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Game test #1");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 12..<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 34..<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 56..<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> 7...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test that in basic play, no marbles must be removed. Test that in advanced play, marbles must be removed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,0)")); <a href="CppComment.htm">//</a>1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,1,0)")); <a href="CppComment.htm">//</a>2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,1,0)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,1)")); <a href="CppComment.htm">//</a>3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,1,1)")); <a href="CppComment.htm">//</a>4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,1,1)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,0,2)")); <a href="CppComment.htm">//</a>5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,0,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(Move("(0,1,2)")); <a href="CppComment.htm">//</a>6<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(Move("(0,1,2)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,0,3)"))); <a href="CppComment.htm">//</a>7<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,0,3) !(0,0,3)"))); <a href="CppComment.htm">//</a>7<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,0,3)")));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Game test #2");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> ....<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> ....<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> ....<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> ....<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test that in basic play, no marbles must be removed. Test that in advanced play, marbles must be removed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; a <a href="CppOperatorAssign.htm">=</a> CreateAdvancedGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Game&gt; b <a href="CppOperatorAssign.htm">=</a> CreateBasicGame();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Move&gt; v <a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,0,0)"), Move("(0,0,1)"), Move("(0,1,1)"), Move("(0,1,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(1,0,0)"), Move("(0,0,2)"), Move("(0,1,2)"), Move("(0,2,0)"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move("(0,2,2)"), Move("(0,3,0)")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[a,b](<b><a href="CppConst.htm">const</a></b> Move&amp; m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!a-&gt;CanDo(m)) <a href="CppTRACE.htm">TRACE</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b-&gt;CanDo(m)) <a href="CppTRACE.htm">TRACE</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a-&gt;CanDo(m));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b-&gt;CanDo(m));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-&gt;Do(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;Do(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,2,1)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,2,1) !(0,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(1,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(0,0,0) !(1,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!a-&gt;CanDo(Move("(0,2,1) !(0,1,1)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(0,1,1) !(1,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,1,1)")));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,2,1)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,2,1) !(0,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(1,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(0,0,0) !(1,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!b-&gt;CanDo(Move("(0,2,1) !(0,1,1)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(0,1,1) !(1,0,0)")));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b-&gt;CanDo(Move("(0,2,1) !(1,0,0) !(0,1,1)")));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Playing 5 random basic <a href="CppPylos.htm">Pylos</a> games");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::PlayRandomGame(<a href="CppPylos.htm">pylos</a>::Board::CreateBasicBoard());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Playing 5 random advanced <a href="CppPylos.htm">Pylos</a> games");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::PlayRandomGame(<a href="CppPylos.htm">pylos</a>::Board::CreateAdvancedBoard());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Playing 5 random <a href="CppPylos.htm">Pylos</a> games");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::PlayRandomGame();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::TogglePlayer()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_current_move-&gt;GetMustRemove()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "First the current player must remove one or two marbles");<br/>
&nbsp;&nbsp;m_move_history.push_back(m_current_move-&gt;GetMove());<br/>
&nbsp;&nbsp;m_current_move.reset(<b><a href="CppNew.htm">new</a></b> CurrentMove<a href="CppState.htm">State</a>);<br/>
&nbsp;&nbsp;m_current_player <a href="CppOperatorAssign.htm">=</a> (m_current_player <a href="CppOperatorEqual.htm">==</a> Player::player1 ? Player::player2 : Player::player1);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Game::Transfer(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat&amp; to)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanTransfer(from,to));<br/>
<br/>
&nbsp;&nbsp;m_board-&gt;Remove(<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;(1,from),m_current_player);<br/>
&nbsp;&nbsp;MustRemove<a href="CppState.htm">State</a> must_remove <a href="CppOperatorAssign.htm">=</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
&nbsp;&nbsp;m_board-&gt;Set(to,m_current_player,must_remove);<br/>
<br/>
&nbsp;&nbsp;m_current_move-&gt;SetMoveTransfer(from,to);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (must_remove <a href="CppOperatorNotEqual.htm">!=</a> MustRemove<a href="CppState.htm">State</a>::no)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Player player <a href="CppOperatorAssign.htm">=</a> ToPlayer(m_board-&gt;Get(to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_current_move-&gt;SetMustRemove(ToMustRemove<a href="CppState.htm">State</a>(player));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If player must not remove another marble,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>his/her turn is over<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TogglePlayer();<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Game&amp; lhs, <b><a href="CppConst.htm">const</a></b> Game&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs.m_board&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> *rhs.m_board<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp; *lhs.m_current_move&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> *rhs.m_current_move<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;&nbsp;&nbsp;lhs.m_current_player <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;rhs.m_current_player<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;&nbsp;&nbsp;lhs.m_move_history&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;rhs.m_move_history;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Game&amp; lhs, <b><a href="CppConst.htm">const</a></b> Game&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosmove.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosmove.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Move, <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> a <a href="CppPylos.htm">Pylos</a>/Phyraos move<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSMOVE_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSMOVE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>coordinat.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppPylos.htm">Pylos</a>Move encapsulates a <a href="CppPylos.htm">Pylos</a> move.<br/>
<a href="CppComment.htm">///</a>A <a href="CppPylos.htm">Pylos</a> move starts with either<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> placing (Set) a <b><a href="CppNew.htm">new</a></b> marble or<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> moving (Transfer) an existing marble to a higher location<br/>
<a href="CppComment.htm">///</a>Both a Set and a Transfer can results in that the player must<br/>
<a href="CppComment.htm">///</a>remove either one or two marbles.<br/>
<b><a href="CppStruct.htm">struct</a></b> Move<br/>
{<br/>
&nbsp;&nbsp;Move();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Move is <a href="CppConstructor.htm">construct</a>ed from all the members it will hold<br/>
&nbsp;&nbsp;Move(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; moving,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; removing);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Move is <a href="CppConstructor.htm">construct</a>ed from <a href="CppPylos.htm">Pylos</a> notation<br/>
&nbsp;&nbsp;Move(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b> its <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> Move is valid<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsValid() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/What m_move is, depends on its size:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_move.size() <a href="CppOperatorEqual.htm">==</a> 1: placement at m_move[0]<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_move.size() <a href="CppOperatorEqual.htm">==</a> 2: move from m_move[0] to m_move[1]<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; m_move;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt; m_remove;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Move&amp; lhs, <b><a href="CppConst.htm">const</a></b> Move&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> Move&amp; m) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSMOVE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosmove.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosmove.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Move, <b><a href="CppClass.htm">class</a></b> <b><a href="CppFor.htm">for</a></b> a <a href="CppPylos.htm">Pylos</a>/Phyraos move<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>move.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>coordinat.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::Move()<br/>
&nbsp;&nbsp;: m_move{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_remove{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::Move(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; moving,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Coordinat&gt;&amp; removing)<br/>
&nbsp;&nbsp;: m_move{moving},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_remove{removing}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_move.empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "In every move a marble must be placed or transferred");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_move.size() <a href="CppOperatorLessEqual.htm">&lt;=</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_remove.size() <a href="CppOperatorLessEqual.htm">&lt;=</a> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "At most two marbles are removed in a move");<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::Move(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;: m_move{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_remove{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.size() <a href="CppOperatorEqual.htm">==</a> 7<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> s.size() <a href="CppOperatorEqual.htm">==</a> 16<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> s.size() <a href="CppOperatorEqual.htm">==</a> 25<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> s.size() <a href="CppOperatorEqual.htm">==</a> 34)) <a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read first coordinat<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.size() <a href="CppOperatorEqual.htm">==</a> 7<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> s.size() <a href="CppOperatorEqual.htm">==</a> 16<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> s.size() <a href="CppOperatorEqual.htm">==</a> 25<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> s.size() <a href="CppOperatorEqual.htm">==</a> 34);<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(s.substr(0,7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_move.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() <a href="CppOperatorEqual.htm">==</a> 7) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppFor.htm">for</a></b> transfer with/without removal '(Z,X,Y)-&gt;(Z,X,Y)'<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[7] <a href="CppOperatorEqual.htm">==</a> '-' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[8] <a href="CppOperatorEqual.htm">==</a> '&gt;')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(s.substr(9,7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_move.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() <a href="CppOperatorEqual.htm">==</a> 16) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppFor.htm">for</a></b> place and single removal '(Z,X,Y) !(Z,X,Y)'<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[7] <a href="CppOperatorEqual.htm">==</a> ' ' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[8] <a href="CppOperatorEqual.htm">==</a> '!')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(s.substr(9,7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_remove.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() <a href="CppOperatorEqual.htm">==</a> 16) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppFor.htm">for</a></b> transfer with single removal '(Z,X,Y)-&gt;(Z,X,Y) !(Z,X,Y)'<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s[16] <a href="CppOperatorEqual.htm">==</a> ' ' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[17] <a href="CppOperatorEqual.htm">==</a> '!');<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(s.substr(18,7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_remove.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() <a href="CppOperatorEqual.htm">==</a> 25) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppFor.htm">for</a></b> transfer with <b><a href="CppDouble.htm">double</a></b> removal '(Z,X,Y)-&gt;(Z,X,Y) !(Z,X,Y) !(Z,X,Y)'<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s[25] <a href="CppOperatorEqual.htm">==</a> ' ' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[26] <a href="CppOperatorEqual.htm">==</a> '!');<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat c(s.substr(27,7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_remove.push_back(c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorEqual.htm">==</a> 34);<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "2.0";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2012-05-05: <a href="CppVersion.htm">version</a> 2.0: initial release <a href="CppVersion.htm">version</a>"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::IsValid() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_move.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_move.size() <a href="CppOperatorLessEqual.htm">&lt;=</a> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_remove.size() <a href="CppOperatorLessEqual.htm">&lt;=</a> 2;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Test Moves");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPylos.htm">pylos</a>::Move m;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m.IsValid() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "An empty move is invalid");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPylos.htm">pylos</a>::Move n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m <a href="CppOperatorEqual.htm">==</a> n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_move.push_back(Coordinat(0,0,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n.m_move.push_back(Coordinat(0,0,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m <a href="CppOperatorEqual.htm">==</a> n);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Valid Moves<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"(0,0,0)",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"(0,0,0) !(0,0,0)",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"(0,0,0) !(0,0,0) !(0,0,0)",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"(0,0,0)-&gt;(0,0,0)",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"(0,0,0)-&gt;(0,0,0) !(0,0,0)",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"(0,0,0)-&gt;(0,0,0) !(0,0,0) !(0,0,0)",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Move m(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>OK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCatch.htm">catch</a></b> (<a href="CppStdException.htm">std::exception</a>&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Move::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!(m_move.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> m_move.size() <a href="CppOperatorEqual.htm">==</a> 2)) <a href="CppTRACE.htm">TRACE</a>(m_move.size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_move.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> m_move.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> m_move[0].ToStr();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_move.size() <a href="CppOperatorEqual.htm">==</a> 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s<a href="CppOperatorPlusAssign.htm">+=</a>"-&gt;";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s<a href="CppOperatorPlusAssign.htm">+=</a>m_move[1].ToStr();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_remove.empty()) <b><a href="CppReturn.htm">return</a></b> s;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_remove.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalOr.htm">||</a> m_remove.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;s<a href="CppOperatorPlusAssign.htm">+=</a>" !";<br/>
&nbsp;&nbsp;s<a href="CppOperatorPlusAssign.htm">+=</a>m_remove[0].ToStr();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_remove.size() <a href="CppOperatorEqual.htm">==</a> 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s<a href="CppOperatorPlusAssign.htm">+=</a>" !";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s<a href="CppOperatorPlusAssign.htm">+=</a>m_remove[0].ToStr();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Move&amp; lhs, <b><a href="CppConst.htm">const</a></b> Move&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.m_move <a href="CppOperatorEqual.htm">==</a> rhs.m_move<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.m_remove <a href="CppOperatorEqual.htm">==</a> rhs.m_remove;<br/>
}<br/>
<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> Move&amp; m) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;os <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.ToStr();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosmustremovestate.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosmustremovestate.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::MustRemove<a href="CppState.htm">State</a>, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the state of a removal<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSMUSTREMOVESTATE_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSMUSTREMOVESTATE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>fwd.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<a href="CppComment.htm">///</a>After placing (Set) or moving (Transfer) a marble, the MustRemove<a href="CppState.htm">State</a><br/>
<a href="CppComment.htm">///</a>will be removed. These are:<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> no: no marbles need to be removed before next player's move<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> player1: player1 has to remove one or two marbles. This is determined<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;by the player that places or moves his/her marbles.<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> player2: player2 has to remove one or two marbles. This is determined<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;by the player that places or moves his/her marbles.<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> MustRemove<a href="CppState.htm">State</a> { player1, player2, no };<br/>
MustRemove<a href="CppState.htm">State</a> ToMustRemove<a href="CppState.htm">State</a>(<b><a href="CppConst.htm">const</a></b> Player&amp; player);<br/>
<a href="CppStdString.htm">std::string</a> ToStr(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a> state);<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a>&amp; state, <b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a>&amp; player);<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a>&amp; state, <b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a>&amp; player);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>!(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a>&amp; state);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSMUSTREMOVESTATE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosmustremovestate.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosmustremovestate.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::MustRemove<a href="CppState.htm">State</a>, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the state of a removal<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>mustremovestate.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<br/>
<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::MustRemove<a href="CppState.htm">State</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::ToMustRemove<a href="CppState.htm">State</a>(<b><a href="CppConst.htm">const</a></b> Player&amp; player)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (player)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Player::player1: <b><a href="CppReturn.htm">return</a></b> MustRemove<a href="CppState.htm">State</a>::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Player::player2: <b><a href="CppReturn.htm">return</a></b> MustRemove<a href="CppState.htm">State</a>::player2;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Unknown value <b><a href="CppFor.htm">for</a></b> Player");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Unknown value <b><a href="CppFor.htm">for</a></b> Player");<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::ToStr(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a> state)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (state)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> MustRemove<a href="CppState.htm">State</a>::player1: <b><a href="CppReturn.htm">return</a></b> "player1";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> MustRemove<a href="CppState.htm">State</a>::player2: <b><a href="CppReturn.htm">return</a></b> "player2";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> MustRemove<a href="CppState.htm">State</a>::no: <b><a href="CppReturn.htm">return</a></b> "no";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Unknown value <b><a href="CppFor.htm">for</a></b> MustRemove<a href="CppState.htm">State</a>");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Unknown value <b><a href="CppFor.htm">for</a></b> MustRemove<a href="CppState.htm">State</a>");<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperator.htm">operator</a></b>!(<b><a href="CppConst.htm">const</a></b> MustRemove<a href="CppState.htm">State</a>&amp; state)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> state <a href="CppOperatorEqual.htm">==</a> MustRemove<a href="CppState.htm">State</a>::no;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosplayer.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosplayer.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Player, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the players<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSPLAYER_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSPLAYER_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>fwd.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>positionstate.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Player { player1, player2 };<br/>
<a href="CppComment.htm">///</a>Toggles between the two players<br/>
<b><a href="CppVoid.htm">void</a></b> Toggle(Player&amp; player);<br/>
<a href="CppComment.htm">///</a><a href="CppConvert.htm">Convert</a> a Position<a href="CppState.htm">State</a> to Player<br/>
Player ToPlayer(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Player&amp; player, <b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Player&amp; player, <b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSPLAYER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylosplayer.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylosplayer.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Player, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the players<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>positionstate.h"<br/>
<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Toggle(Player&amp; player)<br/>
{<br/>
&nbsp;&nbsp;player <a href="CppOperatorAssign.htm">=</a> (player <a href="CppOperatorEqual.htm">==</a> Player::player1 ? Player::player2 : Player::player1);<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Player <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::ToPlayer(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (state)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::player1: <b><a href="CppReturn.htm">return</a></b> Player::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::player2: <b><a href="CppReturn.htm">return</a></b> Player::player2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>: <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Cannot <a href="CppConvert.htm">convert</a> <b><a href="CppThis.htm">this</a></b> Position<a href="CppState.htm">State</a> to a Player");<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Player&amp; player, <b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (player)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Player::player1: <b><a href="CppReturn.htm">return</a></b> state <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Player::player2: <b><a href="CppReturn.htm">return</a></b> state <a href="CppOperatorEqual.htm">==</a> Position<a href="CppState.htm">State</a>::player2;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Player&amp; player, <b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(player<a href="CppOperatorEqual.htm">==</a>state);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylospositionstate.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylospositionstate.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Position<a href="CppState.htm">State</a>, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the state of a position<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSPOSITIONSTATE_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSPOSITIONSTATE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>fwd.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Position<a href="CppState.htm">State</a> { player1, player2, empty };<br/>
Position<a href="CppState.htm">State</a> ToPosition<a href="CppState.htm">State</a>(<b><a href="CppConst.htm">const</a></b> Player&amp; player);<br/>
<b><a href="CppChar.htm">char</a></b> ToChar(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state, <b><a href="CppConst.htm">const</a></b> Player&amp; player);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state, <b><a href="CppConst.htm">const</a></b> Player&amp; player);<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>!(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a>&amp; state);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSPOSITIONSTATE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pylospositionstate.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pylospositionstate.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Position<a href="CppState.htm">State</a>, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the state of a position<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>positionstate.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>player.h"<br/>
<br/>
<br/>
<b><a href="CppChar.htm">char</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::ToChar(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (state)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::empty: <b><a href="CppReturn.htm">return</a></b> '.';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::player1: <b><a href="CppReturn.htm">return</a></b> 'X';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Position<a href="CppState.htm">State</a>::player2: <b><a href="CppReturn.htm">return</a></b> 'O';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Unknown Position<a href="CppState.htm">State</a> in ToChar");<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::Position<a href="CppState.htm">State</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::ToPosition<a href="CppState.htm">State</a>(<b><a href="CppConst.htm">const</a></b> Player&amp; player)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (player)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Player::player1: <b><a href="CppReturn.htm">return</a></b> Position<a href="CppState.htm">State</a>::player1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Player::player2: <b><a href="CppReturn.htm">return</a></b> Position<a href="CppState.htm">State</a>::player2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDefault.htm">default</a></b>: <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Cannot <a href="CppConvert.htm">convert</a> <b><a href="CppThis.htm">this</a></b> Player to a Position<a href="CppState.htm">State</a>");<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state, <b><a href="CppConst.htm">const</a></b> Player&amp; player)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> player <a href="CppOperatorEqual.htm">==</a> state;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Position<a href="CppState.htm">State</a> state, <b><a href="CppConst.htm">const</a></b> Player&amp; player)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> player <a href="CppOperatorNotEqual.htm">!=</a> state;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pyloswinner.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pyloswinner.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Winner, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the winner<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> PYLOSWINNER_H<br/>
<a href="CppDefine.htm">#define</a> PYLOSWINNER_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">pylos</a> {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Winner { player1, player2, none };<br/>
<a href="CppStdString.htm">std::string</a> ToStr(<b><a href="CppConst.htm">const</a></b> Winner winner);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppPylos.htm">Pylos</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> PYLOSWINNER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppPylos/pyloswinner.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppPylos/pyloswinner.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppPylos.htm">pylos</a>::Winner, <a href="CppPylos.htm">Pylos</a> <b><a href="CppEnumClass.htm">enum class</a></b> <b><a href="CppFor.htm">for</a></b> the winner<br/>
Copyright (C) 2010-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppPylos.htm">CppPylos</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppPylos.htm">pylos</a>winner.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppPylos.htm">pylos</a>::ToStr(<b><a href="CppConst.htm">const</a></b> Winner winner)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (winner)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Winner::player1: <b><a href="CppReturn.htm">return</a></b> "player1";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Winner::player2: <b><a href="CppReturn.htm">return</a></b> "player2";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Winner::none: <b><a href="CppReturn.htm">return</a></b> "none";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Cannot <a href="CppConvert.htm">convert</a> <b><a href="CppThis.htm">this</a></b> Winner to a <a href="CppStdString.htm">std::string</a>");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Cannot <a href="CppConvert.htm">convert</a> <b><a href="CppThis.htm">this</a></b> Winner to a <a href="CppStdString.htm">std::string</a>");<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
