<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>ManyDigitNewick</title>
  <meta name="description" content="C++ ManyDigitNewick"/>
  <meta name="keywords" content="C++ ManyDigitNewick "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppManyDigitNewick.htm">ManyDigitNewick</a></h1>
<p>&nbsp;</p>
<!-- This page is generated by CodeToHtml version 1.2.694 at Fri Jan  2 09:56:22 2015
 -->
<p><img src="PicStl.png" alt="STL"/><img src="PicQtCreator.png" alt="Qt Creator"/><img src="PicLubuntu.png" alt="Lubuntu"/></p>
<p>&nbsp;</p>
<p>
  A <a href="CppNewick.htm">Newick</a> <a href="CppClass.htm">class</a>.
</p>
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/CppManyDigitNewick.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/CppManyDigitNewick.pri" border = "1"><tr><td><code>
<a href="CppQmakeDefines.htm">DEFINES</a> += DEBUG_SKIP_SAZ_AND_SAO<br/>
<br/>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a><br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>coordinat.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>derivative.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>indexer.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>indextable.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>s.cpp<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a>&nbsp;&nbsp;+= \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>coordinat.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>derivative.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>indexer.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>indextable.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/<a href="CppManyDigitNewick.htm">manydigitnewick</a>s.h \<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>/Licence.txt<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewick.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewick.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> MANYDIGITNEWICK_H<br/>
<a href="CppDefine.htm">#define</a> MANYDIGITNEWICK_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>derivative.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a> contains all<br/>
<a href="CppComment.htm">///</a>M<a href="CppAny.htm">any</a>DigitDerivative that can be<br/>
<a href="CppComment.htm">///</a><a href="CppConstructor.htm">construct</a>ed from a phylogeny. For example,<br/>
<a href="CppComment.htm">///</a><b><a href="CppIf.htm">if</a></b> from a certain phylogeny three derived<br/>
<a href="CppComment.htm">///</a>phylogenies can be <a href="CppConstructor.htm">construct</a>ed, M<a href="CppAny.htm">any</a>DigitDerivativesData<br/>
<a href="CppComment.htm">///</a>will hold three elements.<br/>
<a href="CppComment.htm">///</a>The <a href="CppAlgorithm.htm">algorithm</a> is described at<br/>
<a href="CppComment.htm">///</a>http://www.richelbilderbeek.nl/<a href="CppTwoDigitNewick.htm">CppTwoDigitNewick</a><a href="CppAlgorithm.htm">Algorithm</a>.htm<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">///</a>The meat of the code is in <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::CalculateProbability<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative Derivative;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>An empty <a href="CppManyDigitNewick.htm">ManyDigitNewick</a><br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/A <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> cannot be created without<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/its derivatives: a <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> IS its<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/derivatives in a way.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/sum_above_zero and sum_above_one are needed to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/calculate its denominator<br/>
&nbsp;&nbsp;<b><a href="CppExplicit.htm">explicit</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Derivative&gt;&amp; derivatives,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Empty <a href="CppReturn.htm">returns</a> !IsComplete<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Derivative&gt;&amp; GetDerivatives() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsComplete determines <b><a href="CppIf.htm">if</a></b> the <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppInitialize.htm">initialize</a>d <b><a href="CppCompl.htm">compl</a></b>etely<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsComplete() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsProbabilityKnown() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetDenominator() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetProbability() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> <a href="CppGetSum.htm">GetSum</a>TermsAboveOne() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> <a href="CppGetSum.htm">GetSum</a>TermsAboveZero() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetProbability(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p);<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> SetTheta(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_derivatives contains all the information<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/needed to get to <b><a href="CppThis.htm">this</a></b> <a href="CppNewick.htm">Newick</a>'s derivatives<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Derivative&gt; m_derivatives;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_probability denotes the probability<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/a <a href="CppNewick.htm">Newick</a> exists.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/A negative value of m_probability denotes<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that it is not yet calculated.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_probability;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_denominator constant <b><a href="CppFor.htm">for</a></b> a <a href="CppNewick.htm">Newick</a>.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_denominator;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_sum_terms_above_zero;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_sum_terms_above_one;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppDouble.htm">double</a></b> sm_theta;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> CalculateDenominator(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPublic.htm">public</a></b>:<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppDouble.htm">double</a></b> CalculateProbability(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppNewick.htm">newick</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TWODIGITNEWICK_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewick.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewick.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCmathH.htm">cmath</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewickVector.htm">newickvector</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>indexer.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::sm_theta <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1.0;<br/>
<br/>
<a href="CppComment.htm">///</a>Create an empty MyDigit<a href="CppNewick.htm">Newick</a>, to have a<br/>
<a href="CppComment.htm">///</a><b><a href="CppDefault.htm">default</a></b> contructor<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>()<br/>
&nbsp;&nbsp;: m_probability(-1.0),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_denominator(-1.0),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_zero(-1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_one(-1)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;Empty());<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative&gt;&amp; derivatives,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
&nbsp;&nbsp;: m_derivatives(derivatives),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability(-1.0),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_denominator(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CalculateDenominator(sum_above_zero,sum_above_one)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_zero(sum_above_zero),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sum_terms_above_one(sum_above_one)<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::CalculateDenominator(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sm_theta <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (sum_above_one &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Invalid sum_above_one: " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sum_above_one <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> d<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_above_zero * (sum_above_zero <a href="CppOperatorMinus.htm">-</a> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (<a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(sum_above_one)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * sm_theta);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> d;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Calculates the probability <b><a href="CppFor.htm">for</a></b> a certain <a href="CppNewick.htm">Newick</a><br/>
<a href="CppComment.htm">///</a>with a certain theta. This is the <a href="CppMain.htm">main</a> (helper)<br/>
<a href="CppComment.htm">///</a><a href="CppFunction.htm">function</a>.<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::CalculateProbability(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppNewick.htm">newick</a>_str,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>_FUNC();<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::SetTheta(theta);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppNewickVector.htm">NewickVector</a> n(<a href="CppNewick.htm">newick</a>_str);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer i(n,theta);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> i.GetProbability();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::Empty() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_derivatives.empty();<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::GetDenominator() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsComplete());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_denominator;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative&gt;&amp;<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::GetDerivatives() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_derivatives;<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::GetProbability() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsProbabilityKnown());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_probability;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::<a href="CppGetSum.htm">GetSum</a>TermsAboveOne() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_sum_terms_above_one <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_sum_terms_above_one;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::<a href="CppGetSum.htm">GetSum</a>TermsAboveZero() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!(m_sum_terms_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "BREAKPOINT";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_sum_terms_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_sum_terms_above_zero;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.1";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2010-08-22: <a href="CppVersion.htm">version</a> 1.0: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2011-02-20: <a href="CppVersion.htm">version</a> 1.1: added <a href="CppVersion.htm">version</a> history"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>A <b><a href="CppCompl.htm">compl</a></b>ete <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> has (hopefully) all its<br/>
<a href="CppComment.htm">///</a>derivatives present, as well as its sums of terms<br/>
<a href="CppComment.htm">///</a>above zero and one.<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::IsComplete() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (!m_derivatives.empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_sum_terms_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_sum_terms_above_one&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::IsProbabilityKnown() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_probability <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::SetProbability(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorLessEqual.htm">&lt;=</a> 1.0000001);<br/>
&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> p;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::SetTheta(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(theta <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;sm_theta <a href="CppOperatorAssign.htm">=</a> theta;<br/>
}<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta <a href="CppOperatorAssign.htm">=</a> 10.0;<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::SetTheta(theta);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::<a href="CppCreateValidNewicks.htm">CreateValidNewicks</a>();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( <a href="CppNewick.htm">Newick</a>::<a href="CppCalcComplexity.htm">CalcComplexity</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppStringToNewick.htm">StringToNewick</a>(s))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;<a href="CppBigInt.htm">BigInteger</a>(10000) )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::CalculateProbability(s,theta);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickcoordinat.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickcoordinat.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> MANYDIGITNEWICKCOORDINAT_H<br/>
<a href="CppDefine.htm">#define</a> MANYDIGITNEWICKCOORDINAT_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat is an <a href="CppAny.htm">any</a>-dimensional<br/>
<a href="CppComment.htm">///</a>coordinat with its indices sorted.<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat<br/>
{<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; ToVector() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> AllSimple(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> threshold_index) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> <a href="CppIsSorted.htm">IsSorted</a>() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsValid() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; m_v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; Sort(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v);<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> MANYDIGITNEWICKCOORDINAT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickcoordinat.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickcoordinat.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>coordinat.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFunctionalH.htm">functional</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v)<br/>
&nbsp;&nbsp;: m_v(Sort(v))<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsValid()&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume all indices in a M<a href="CppAny.htm">any</a>DigitCoordinat are positive");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppIsSorted.htm">IsSorted</a>() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume that all indices are sorted");<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>AllSimple <a href="CppReturn.htm">returns</a> whether it contains simple indices only.<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::m_reserved determines <b><a href="CppThis.htm">this</a></b>:<br/>
<a href="CppComment.htm">///</a>a value of '7' might be the <a href="CppNewick.htm">Newick</a> frequency of '7' <b><a href="CppIf.htm">if</a></b><br/>
<a href="CppComment.htm">///</a>threshold_index equals '9'. If the threshold_index equals '5', however,<br/>
<a href="CppComment.htm">///</a>'7' might be a summarization of '(2,2)'.<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat::AllSimple(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> threshold_index) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCount_if.htm">std::count_if</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_v.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdLess.htm">std::less</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),threshold_index))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size());<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppIsSorted.htm">IsSorted</a> checks <b><a href="CppIf.htm">if</a></b> a <a href="CppStdVector.htm">std::vector</a> is sorted.<br/>
<a href="CppComment.htm">///</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppIsSorted.htm">IsSorted</a>.htm<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat::<a href="CppIsSorted.htm">IsSorted</a>() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdAdjacent_find.htm">std::adjacent_find</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdGreater.htm">std::greater</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;()) <a href="CppOperatorEqual.htm">==</a> m_v.end();<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>IsValid <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> all indices are valid, that is, positive and<br/>
<a href="CppComment.htm">///</a>non-zero.<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat::IsValid() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCount_if.htm">std::count_if</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_v.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_v.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdLess_equal.htm">std::less_equal</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> 0;<br/>
<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat::Sort(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdSort.htm">std::sort</a>(v.begin(),v.end());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickderivative.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickderivative.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> MANYDIGITDERIVATIVE_H<br/>
<a href="CppDefine.htm">#define</a> MANYDIGITDERIVATIVE_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a>M<a href="CppAny.htm">any</a>DigitDerivative contains<br/>
<a href="CppComment.htm">///</a>the index of the derived phylogeny<br/>
<a href="CppComment.htm">///</a>and the value that must be changed<br/>
<a href="CppComment.htm">///</a>to get there. For example, <b><a href="CppIf.htm">if</a></b> <b><a href="CppFor.htm">for</a></b> a<br/>
<a href="CppComment.htm">///</a><b><a href="CppCompl.htm">compl</a></b>ex phylogeny (of unknown index)<br/>
<a href="CppComment.htm">///</a>a '3' must be changed to a '2' to get<br/>
<a href="CppComment.htm">///</a>to the phylogeny with index 42,<br/>
<a href="CppComment.htm">///</a>M<a href="CppAny.htm">any</a>DigitDerivatives has an<br/>
<a href="CppComment.htm">///</a>m_derived_index of 42 and an<br/>
<a href="CppComment.htm">///</a>m_value_changed of 3.<br/>
<a href="CppComment.htm">///</a>For calculations it is important to know which value<br/>
<a href="CppComment.htm">///</a>has changed, some<a href="CppTime.htm">time</a>s with another.<br/>
<a href="CppComment.htm">///</a>If no other value changes, set m_other_value_changed to zero.<br/>
<a href="CppComment.htm">///</a>Some examples of <b><a href="CppUsing.htm">using</a></b> m_value_changed and m_other_value_changed:\n<br/>
<a href="CppComment.htm">///</a>(1,1) <a href="CppOperatorMinus.htm">-</a>&gt;&nbsp;&nbsp; (2), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 1\n<br/>
<a href="CppComment.htm">///</a>(1,2) <a href="CppOperatorMinus.htm">-</a>&gt;&nbsp;&nbsp; (3), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 2\n<br/>
<a href="CppComment.htm">///</a>(1,2) <a href="CppOperatorMinus.htm">-</a>&gt; (1,1), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>(1,3) <a href="CppOperatorMinus.htm">-</a>&gt;&nbsp;&nbsp; (4), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 3\n<br/>
<a href="CppComment.htm">///</a>(1,3) <a href="CppOperatorMinus.htm">-</a>&gt; (1,2), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 3 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>(2,3) <a href="CppOperatorMinus.htm">-</a>&gt; (1,3), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>(2,3) <a href="CppOperatorMinus.htm">-</a>&gt; (2,2), then m_value_changed <a href="CppOperatorEqual.htm">==</a> 3 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>A valid M<a href="CppAny.htm">any</a>DigitDerivative has either:\n<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed&nbsp;&nbsp;&gt; 0\n<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> m_value_changed&nbsp;&nbsp;&gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0\n<br/>
<a href="CppComment.htm">///</a>This is checked at the <a href="CppConstructor.htm">constructor</a>.\n<br/>
<a href="CppComment.htm">///</a>Because there are at highest two values that change, <b><a href="CppFor.htm">for</a></b> both a\n<br/>
<a href="CppComment.htm">///</a><a href="CppTwoDigitNewick.htm">TwoDigitNewick</a> and <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, the same Derivative can be used.<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative<br/>
{<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> derived_index,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_derived_index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_value_changed;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_other_value_changed;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> MANYDIGITDERIVATIVE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickderivative.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickderivative.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>derivative.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> derived_index,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed)<br/>
&nbsp;&nbsp;: m_derived_index(derived_index),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_value_changed(value_changed),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_other_value_changed(other_value_changed)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_derived_index &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_value_changed &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_value_changed <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed&nbsp;&nbsp;&gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalOr.htm">||</a> (m_value_changed&nbsp;&nbsp;&gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 0) );<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickindexer.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickindexer.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> MANYDIGITNEWICKINDEXER_H<br/>
<a href="CppDefine.htm">#define</a> MANYDIGITNEWICKINDEXER_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>coordinat.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>derivative.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>indextable.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>s.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppMultiVector.htm">multivector</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewickVector.htm">newickvector</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer <a href="CppConvert.htm">converts</a> <a href="CppAny.htm">any</a> <a href="CppNewick.htm">newick</a> to (X,Y,...)<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative Derivative;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer <a href="CppConstructor.htm">constructor</a> does all the work<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer(<b><a href="CppConst.htm">const</a></b> <a href="CppNewickVector.htm">NewickVector</a>&amp; n, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> <a href="CppConstructor.htm">construct</a>s a full <a href="CppNewickVector.htm">NewickVector</a> from<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/the <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> at index i.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> is <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a> purposes only,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/as it's the idea to work with non-full determined<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/(that is: two-digit) <a href="CppNewick.htm">Newick</a>s<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppNewickVector.htm">NewickVector</a> <a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetCalculatedToIndex() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_calculated_to_index; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetData allows a peek at the data<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitIndexTable&amp; GetIndexTable() <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_index_table;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; indices) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s&amp; Get<a href="CppNewick.htm">Newick</a>s() <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_<a href="CppNewick.htm">newick</a>s;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetProbability <a href="CppReturn.htm">returns</a> the probability of the <a href="CppNewickVector.htm">NewickVector</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/given at the <a href="CppConstructor.htm">constructor</a><br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetProbability() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetReserved() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_reserved; }<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/After a leaf has been cut, then<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> TryToCalculateNew<a href="CppNewick.htm">Newick</a>s();<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UpdateCalculatedFromIndex();<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;M<a href="CppAny.htm">any</a>DigitIndexTable m_index_table;<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s m_<a href="CppNewick.htm">newick</a>s;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_theta;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_reserved;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_current_index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_calculated_to_index;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_probability is the probability of the given <a href="CppNewick.htm">Newick</a>.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_probability is calculated in the <a href="CppConstructor.htm">constructor</a> of <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/and can be obtained by GetProbability.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_probability;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Calculate the <a href="CppNewick.htm">Newick</a> probability of <a href="CppNewick.htm">Newick</a> (a,b).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Both a and b are simple, that is: no index<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppFor.htm">for</a></b> a <b><a href="CppCompl.htm">compl</a></b>ex <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> CalculateEwensProbability(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> a,<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> b) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CalculateReserved calculates the index<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that must be reserver<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> CalculateReserved(<b><a href="CppConst.htm">const</a></b> <a href="CppNewickVector.htm">NewickVector</a>&amp; n) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> CreateM<a href="CppAny.htm">any</a>DigitDerivatives(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat&amp; coordinat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetDeltaSumAboveZero calculates the delta in the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::m_sum_above_zero of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/when an old_value is changed.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetDeltaSumAboveZero(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> old_value) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetDeltaSumAboveOne calculates the delta in the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::m_sum_above_one of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/when an old_value is changed.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetDeltaSumAboveOne(<b><a href="CppConst.htm">const</a></b> Derivative&amp; d) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> GetDeltaSumAboveOne(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> old_value) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/IsSimple determines <b><a href="CppIf.htm">if</a></b> a <a href="CppNewick.htm">Newick</a> at index i is simple.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/A <a href="CppNewick.htm">Newick</a> is simple <b><a href="CppIf.htm">if</a></b> F=(X,Y) where X and Y are<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/less than the reserved index<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsSimple(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Feed the (x,y) indices of a <a href="CppNewick.htm">Newick</a> and obtain the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/summarized index.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Feed also obtains the derived <a href="CppNewick.htm">Newick</a>s.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Note that Feed must be fed simple <a href="CppNewick.htm">Newick</a>s first<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppInt.htm">int</a></b> Feed(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Summarize<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat&amp; coordinat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/TryToCalculateNew<a href="CppNewick.htm">Newick</a> tries to calculate the probability<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/of <a href="CppNewick.htm">Newick</a> with index i<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> TryToCalculateNew<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppIsSorted.htm">IsSorted</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v);<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>MANYDIGITNEWICKINDEXER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickindexer.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickindexer.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>indexer.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStackH.htm">stack</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewickVector.htm">newickvector</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer <a href="CppConstructor.htm">constructor</a> does all the work<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppNewickVector.htm">NewickVector</a>&amp; n,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
&nbsp;&nbsp;: m_<a href="CppNewick.htm">newick</a>s(CalculateReserved(n),theta),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_theta(theta),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_reserved(CalculateReserved(n)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability(-1.0)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>_FUNC();<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(m_reserved));<br/>
<br/>
&nbsp;&nbsp;m_current_index <a href="CppOperatorAssign.htm">=</a> m_reserved;<br/>
<br/>
&nbsp;&nbsp;m_calculated_to_index <a href="CppOperatorAssign.htm">=</a> m_reserved;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_reserved <a href="CppOperatorEqual.htm">==</a> m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_current_index <a href="CppOperatorEqual.htm">==</a> m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the <a href="CppNewick.htm">Newick</a> is simple<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppNewick.htm">Newick</a>::IsSimple(n.Peek()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calculate the Ewens probability only<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> <a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(n.Peek(),theta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume all reserved <a href="CppNewick.htm">Newick</a>s from index 2 are <b><a href="CppCompl.htm">compl</a></b>ete<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=2; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Get<a href="CppNewick.htm">Newick</a>(i).IsComplete());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create all <a href="CppNewick.htm">Newick</a>s and derivatives, but <b><a href="CppDo.htm">do</a></b> not calculate their<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>probabilities yet<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v <a href="CppOperatorAssign.htm">=</a> n.Peek();<br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> DEBUG_DO_THIS_ONLY_ONE<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG_DO_THIS_ONLY_ONE<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b>(v.size()&gt;2) <a href="CppComment.htm">//</a>Find a leaf and cut it until the string is empty<br/>
&nbsp;&nbsp;<a href="CppPreElse.htm">#else</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only once!<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a leaf<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find index i (starting opening bracket) and j (closing bracket)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSize_t.htm">std::size_t</a> j <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i=0 ; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) <a href="CppComment.htm">//</a>Index of opening bracket<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[i]<a href="CppOperatorNotEqual.htm">!=</a><a href="CppNewick.htm">Newick</a>::bracket_open) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j=i+1; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[j]<a href="CppOperatorEqual.htm">==</a><a href="CppNewick.htm">Newick</a>::bracket_open) { j <a href="CppOperatorAssign.htm">=</a> 0; <b><a href="CppBreak.htm">break</a></b>; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v[j]<a href="CppOperatorNotEqual.htm">!=</a><a href="CppNewick.htm">Newick</a>::bracket_close) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (j <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppContinue.htm">continue</a></b>; <a href="CppComment.htm">//</a>j cannot be 0 after previous <b><a href="CppFor.htm">for</a></b> loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find simplest leaf<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[i]<a href="CppOperatorEqual.htm">==</a><a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[j]<a href="CppOperatorEqual.htm">==</a><a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v_new(v.begin(),v.begin() <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(v_new));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> v[i+1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> v[i+2];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; values(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.begin() <a href="CppOperatorPlus.htm">+</a> i <a href="CppOperatorPlus.htm">+</a> 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.begin() <a href="CppOperatorPlus.htm">+</a> j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG_SKIP_SAZ_AND_SAO<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value: values)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(value));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(value &lt; 2 <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(value).IsComplete());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(!<b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(value).Empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saz<a href="CppOperatorPlusAssign.htm">+=</a><b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(value).<a href="CppGetSum.htm">GetSum</a>TermsAboveZero();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sao<a href="CppOperatorPlusAssign.htm">+=</a><b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(value).<a href="CppGetSum.htm">GetSum</a>TermsAboveOne();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Feed it and obtain simpler index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Indices 0 and 1 cannot be <b><a href="CppCompl.htm">compl</a></b>ete, because<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>they don't have sensible derivates to <a href="CppPointer.htm">point</a> to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(Summarize<a href="CppNewick.htm">Newick</a>(values,saz,sao));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Replace leaf with simpler index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(v.begin() <a href="CppOperatorPlus.htm">+</a> j <a href="CppOperatorPlus.htm">+</a> 1, v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v_new));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v <a href="CppOperatorAssign.htm">=</a> v_new;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> DEBUG_ONLY_INITIAL_INDICES_FIRST<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG_ONLY_INITIAL_INDICES_FIRST<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Now all <a href="CppNewick.htm">Newick</a>s are created, but <b><a href="CppDo.htm">do</a></b> not have their probabilities calculated<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_calculated_to_index <a href="CppOperatorEqual.htm">==</a> sz denotes that all <a href="CppNewick.htm">Newick</a>s'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>probabilities are calculated<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m_calculated_to_index <a href="CppOperatorNotEqual.htm">!=</a> sz)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Try to calculate <b><a href="CppIf.htm">if</a></b> <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a>s can be solved<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;TryToCalculateNew<a href="CppNewick.htm">Newick</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If all is well, there will be <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a>s known<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;UpdateCalculatedFromIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>When no <b><a href="CppNew.htm">new</a></b> probabilities are calculated,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>all <a href="CppNewick.htm">Newick</a>s are solved<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::CalculateReserved(<b><a href="CppConst.htm">const</a></b> <a href="CppNewickVector.htm">NewickVector</a>&amp; n) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v <a href="CppOperatorAssign.htm">=</a> n.Peek();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of elements<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_elements<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdGreater.htm">std::greater</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),0));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> max_element <a href="CppOperatorAssign.htm">=</a> *<a href="CppStdMax_element.htm">std::max_element</a>(v.begin(),v.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: <a href="CppOperatorPlus.htm">+</a>1 needed?<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_elements <a href="CppOperatorPlus.htm">+</a> max_element <a href="CppOperatorPlus.htm">+</a> 1;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> <a href="CppConstructor.htm">construct</a>s a full <a href="CppNewickVector.htm">NewickVector</a> from<br/>
<a href="CppComment.htm">///</a>the <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> at index i.<br/>
<a href="CppComment.htm">///</a><a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a> is <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a> purposes only,<br/>
<a href="CppComment.htm">///</a>as it's the idea to work with non-full determined<br/>
<a href="CppComment.htm">///</a>(that is: two-digit) <a href="CppNewick.htm">Newick</a>s<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppNewickVector.htm">NewickVector</a> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::<a href="CppConstructor.htm">Construct</a><a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i &lt; m_reserved)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppNewick.htm">Newick</a> '(0)' is not valid, so fake it as '(1)'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(i <a href="CppOperatorEqual.htm">==</a> 0 ? 1 : i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppNewickVector.htm">NewickVector</a> n(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> index i in Indextable to get two digits<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; p <a href="CppOperatorAssign.htm">=</a> m_index_table.Find(i).ToVector();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(p.begin(),p.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(v));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>As <b><a href="CppLong.htm">long</a></b> as there are not only reserved (that is: simple)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>values in v, replace those by their simplers<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;::<a href="CppIterator.htm">iterator</a> i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind_if.htm">std::find_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdGreater_equal.htm">std::greater_equal</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),m_reserved));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a> v.end()) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m_reserved);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a <b><a href="CppNew.htm">new</a></b> <a href="CppStdVector.htm">std::vector</a> from the v's begin to i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v_new( v.begin(),i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; p <a href="CppOperatorAssign.htm">=</a> m_index_table.Find(*i).ToVector();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p.size() <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "For now...");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(p[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(p[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v_new.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copy the remainder of v (from after i) to v_new<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(i+1,v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v_new));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(v,v_new);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNewick.htm">Newick</a>::<a href="CppIsNewick.htm">IsNewick</a>(v));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppNewickVector.htm">NewickVector</a> n(v);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Create a <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> (to be stored at 'coordinat')<br/>
<a href="CppComment.htm">///</a>by <a href="CppConstructor.htm">construct</a>ing its derivatives, SAZ and SAO.<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">///</a>Note that 'coordinat' serves two<br/>
<a href="CppComment.htm">///</a>purposes in <b><a href="CppThis.htm">this</a></b> context: the coordinat { 5,6,7 } denotes a<br/>
<a href="CppComment.htm">///</a>trinary <a href="CppNewick.htm">Newick</a>, consisting of the simple or summarized indices<br/>
<a href="CppComment.htm">///</a>'5', '6' and '7'. If all three indices are simple (that is, below m_reserved),<br/>
<a href="CppComment.htm">///</a>the coordinat { 5,6,7 } denotes the <a href="CppNewick.htm">Newick</a> '(5,6,7)'. If, <b><a href="CppFor.htm">for</a></b> example all three<br/>
<a href="CppComment.htm">///</a>indices are <b><a href="CppCompl.htm">compl</a></b>ex (that is, equal of greater than m_reserved), the coordinat<br/>
<a href="CppComment.htm">///</a>{ 5,6,7 } might denote the <a href="CppNewick.htm">Newick</a> '((1,1),(1,2),(1,3))'.<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">///</a>Allow <b><a href="CppFor.htm">for</a></b> recursion<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::CreateM<a href="CppAny.htm">any</a>DigitDerivatives(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat&amp; coordinat, <a href="CppComment.htm">//</a>two purposes!<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>_FUNC();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(coordinat.<a href="CppIsSorted.htm">IsSorted</a>());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(coordinat.IsValid());<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; indices <a href="CppOperatorAssign.htm">=</a> coordinat.ToVector();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_indices <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(indices.size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative&gt; ds;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppInt.htm">int</a></b> i=0;i<a href="CppOperatorNotEqual.htm">!=</a>n_indices;<a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(i));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> f <a href="CppOperatorAssign.htm">=</a> indices[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(f));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>((f<a href="CppOperatorEqual.htm">==</a>1 <a href="CppOperatorLogicalOr.htm">||</a> !m_<a href="CppNewick.htm">newick</a>s.Empty(f)) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume each single/<a href="ToolLoose.htm">loose</a> value/frequency exists");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain <b><a href="CppThis.htm">this</a></b> single/<a href="ToolLoose.htm">loose</a> <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>( indices[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Of <b><a href="CppThis.htm">this</a></b> single/<a href="ToolLoose.htm">loose</a> <a href="CppNewick.htm">Newick</a>, obtain its derivatives<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>and chain those with the other members of the <b><a href="CppCompl.htm">compl</a></b>ete <a href="CppNewick.htm">Newick</a>/Coordinat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative&amp; d: n.GetDerivatives())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG_SKIP_SAZ_AND_SAO<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(d.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPreElse.htm">#else</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; new_indices <a href="CppOperatorAssign.htm">=</a> indices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_indices[i] <a href="CppOperatorAssign.htm">=</a> d.m_derived_index;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>(new_indices,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> d.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> d.m_other_value_changed;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds.push_back(<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>(ds,sum_above_zero,sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsSimple(x))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsSimple(y))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateM<a href="CppAny.htm">any</a>DigitDerivativesSimpleSimple(x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateM<a href="CppAny.htm">any</a>DigitDerivativesSimpleComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,y,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsSimple(y))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateM<a href="CppAny.htm">any</a>DigitDerivativesSimpleComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,x,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateM<a href="CppAny.htm">any</a>DigitDerivativesComplexComplex(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,y,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::CreateM<a href="CppAny.htm">any</a>DigitDerivativesSimpleSimple(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorLessEqual.htm">&lt;=</a> y);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorLessEqual.htm">&lt;=</a> m_reserved <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorLessEqual.htm">&lt;=</a> m_reserved);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsSimple(x) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> IsSimple(y));<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x<a href="CppOperatorEqual.htm">==</a>1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y<a href="CppOperatorEqual.htm">==</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(1,1) <a href="CppOperatorMinus.htm">-</a>&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'2' has reserved index 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;M<a href="CppAny.htm">any</a>DigitDerivative&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> derived_index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppThis.htm">this</a></b> derivative twice, because there are two ways<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>to change (1,1) <a href="CppOperatorMinus.htm">-</a>&gt; 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M<a href="CppAny.htm">any</a>DigitDerivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derived_index,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M<a href="CppAny.htm">any</a>DigitDerivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;derived_index,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n(v,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (x<a href="CppOperatorEqual.htm">==</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(1,y) <a href="CppOperatorMinus.htm">-</a>&gt; { (1,y-1), (y+1) }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'1','y' and 'y-1' are reserved indices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; m_reserved);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;M<a href="CppAny.htm">any</a>DigitDerivative&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create (1,y-1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> (y <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? 0 : y <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { x,y-1 } ,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only y changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(M<a href="CppAny.htm">any</a>DigitDerivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create (y+1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> y <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Note the reversal of 1 and y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> y; <a href="CppComment.htm">//</a>Note the reversal of 1 and y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(M<a href="CppAny.htm">any</a>DigitDerivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n( v,x+y,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(x,y) <a href="CppOperatorMinus.htm">-</a>&gt; { (x-1,y), (x,y-1) }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'y','y-1','x' and 'x-1' are reserved indices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> x &lt; m_reserved);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &gt; 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; m_reserved);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;M<a href="CppAny.htm">any</a>DigitDerivative&gt; v;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao_left&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (x <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 2 : x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao_right <a href="CppOperatorAssign.htm">=</a> (y <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 2 : x <a href="CppOperatorPlus.htm">+</a> y <a href="CppOperatorMinus.htm">-</a> 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao_left&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao_right <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Derive (x-1,y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i_left&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { x-1,y } ,saz,sao_left );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed_left <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed_left <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only x changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M<a href="CppAny.htm">any</a>DigitDerivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_i_left,value_changed_left,other_value_changed_left));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Derive (x,y-1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i_right <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { x,y-1 } ,saz,sao_right);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed_right <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed_right <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only y changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M<a href="CppAny.htm">any</a>DigitDerivative(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_i_right,value_changed_right,other_value_changed_right));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n(v,x+y,x+y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::CreateM<a href="CppAny.htm">any</a>DigitDerivativesSimpleComplex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsSimple(x) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !IsSimple(y));<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;M<a href="CppAny.htm">any</a>DigitDerivative&gt; v;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x<a href="CppOperatorGreaterEqual.htm">&gt;=</a>0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x&gt;1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m_reserved <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "So cannot work with y-1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> (x <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> 1 ? sum_above_one <a href="CppOperatorMinus.htm">-</a> 2 : sum_above_one <a href="CppOperatorMinus.htm">-</a> 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { x-1,y } ,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;Only x changed<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(M<a href="CppAny.htm">any</a>DigitDerivative(i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppNewick.htm">newick</a>s.Empty(y));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: Find out why '<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitDerivativesData&amp;' does not work<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> v_derived <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(y);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitDerivative&amp; i: v_derived.GetDerivatives())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i.m_derived_index &lt; m_<a href="CppNewick.htm">newick</a>s.Size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "M<a href="CppAny.htm">any</a>DigitDerivative index must be smaller than the number of derivatives");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(i.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { x,i.m_derived_index } ,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> i.m_other_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(M<a href="CppAny.htm">any</a>DigitDerivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n( v,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::CreateM<a href="CppAny.htm">any</a>DigitDerivativesComplexComplex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!IsSimple(x) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !IsSimple(y));<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;M<a href="CppAny.htm">any</a>DigitDerivative&gt; v;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Get (X',Y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_<a href="CppNewick.htm">newick</a>s.Size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppNewick.htm">newick</a>s.Empty(x));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: Find out why '<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitDerivativesData&amp;' does not work<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> v_derived <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitDerivative&amp; i: v_derived.GetDerivatives())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(i.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { y,i.m_derived_index } ,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> i.m_other_value_changed;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(M<a href="CppAny.htm">any</a>DigitDerivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Get (X,Y')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_<a href="CppNewick.htm">newick</a>s.Size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppNewick.htm">newick</a>s.Empty(y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>\todo: Find out why '<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitDerivativesData&amp;' does not work<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> v_derived <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> M<a href="CppAny.htm">any</a>DigitDerivative&amp; i: v_derived.GetDerivatives())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsaz <a href="CppOperatorAssign.htm">=</a> delta sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsaz <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveZero(i.m_value_changed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dsao <a href="CppOperatorAssign.htm">=</a> delta sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> dsao <a href="CppOperatorAssign.htm">=</a> GetDeltaSumAboveOne(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> sum_above_zero <a href="CppOperatorPlus.htm">+</a> dsaz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> sum_above_one <a href="CppOperatorPlus.htm">+</a> dsao;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(saz &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sao <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> d_i <a href="CppOperatorAssign.htm">=</a> Summarize<a href="CppNewick.htm">Newick</a>( { x,i.m_derived_index } ,saz,sao);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i.m_value_changed;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: check that guess is right, that <b><a href="CppUsing.htm">using</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i.m_other_value_changed is better than '0'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> i.m_other_value_changed;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(M<a href="CppAny.htm">any</a>DigitDerivative(d_i,value_changed,other_value_changed));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n(v,sum_above_zero,sum_above_one);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">///</a>GetDeltaSumAboveZero calculates the delta in the<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::m_sum_above_zero of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
<a href="CppComment.htm">///</a>when an old_value is changed.<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::GetDeltaSumAboveZero(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> old_value) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(old_value &gt; 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (old_value <a href="CppOperatorEqual.htm">==</a> 1 ? 0 : <a href="CppOperatorMinus.htm">-</a>1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetDeltaSumAboveOne calculates the delta in the<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>::m_sum_above_one of a <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a><br/>
<a href="CppComment.htm">///</a>when an old_value is changed.<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::GetDeltaSumAboveOne(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative&amp; d) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> d.m_value_changed;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "GetDeltaSumAboveOne <b><a href="CppFor.htm">for</a></b> x " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> x <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x &gt; 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x&nbsp;&nbsp;&gt; 2) <b><a href="CppReturn.htm">return</a></b> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorEqual.htm">==</a> 2) <b><a href="CppReturn.htm">return</a></b> <a href="CppOperatorMinus.htm">-</a>2;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (d.m_other_value_changed <a href="CppOperatorEqual.htm">==</a> 1 ? 2 : 1);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; indices) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_index_table.CanGetIndex(indices));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_index_table.GetIndex(indices);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Get<a href="CppNewick.htm">Newick</a>(i);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::GetProbability() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_probability <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_probability <a href="CppOperatorLessEqual.htm">&lt;=</a> 1.00001);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG_SKIP_SAZ_AND_SAO<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_calculated_to_index <a href="CppOperatorEqual.htm">==</a> m_<a href="CppNewick.htm">newick</a>s.Size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume calculation is <b><a href="CppCompl.htm">compl</a></b>eted");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_probability;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>IsSimple determines <b><a href="CppIf.htm">if</a></b> an index is the index of<br/>
<a href="CppComment.htm">///</a>a simple <a href="CppNewick.htm">Newick</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::IsSimple(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> i &lt; m_reserved;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Summarize<a href="CppNewick.htm">Newick</a> summarizes a <a href="CppNewick.htm">Newick</a> of <a href="CppAny.htm">any</a> arity<br/>
<a href="CppComment.htm">///</a>to a single index. Note that 'coordinat' serves two<br/>
<a href="CppComment.htm">///</a>purposes in <b><a href="CppThis.htm">this</a></b> context: the coordinat { 5,6,7 } denotes a<br/>
<a href="CppComment.htm">///</a>trinary <a href="CppNewick.htm">Newick</a>, consisting of the simple or summarized indices<br/>
<a href="CppComment.htm">///</a>'5', '6' and '7'. If all three indices are simple (that is, below m_reserved),<br/>
<a href="CppComment.htm">///</a>the coordinat { 5,6,7 } denotes the <a href="CppNewick.htm">Newick</a> '(5,6,7)'. If, <b><a href="CppFor.htm">for</a></b> example all three<br/>
<a href="CppComment.htm">///</a>indices are <b><a href="CppCompl.htm">compl</a></b>ex (that is, equal of greater than m_reserved), the coordinat<br/>
<a href="CppComment.htm">///</a>{ 5,6,7 } might denote the <a href="CppNewick.htm">Newick</a> '((1,1),(1,2),(1,3))'.<br/>
<a href="CppComment.htm">///</a>Allow <b><a href="CppFor.htm">for</a></b> recursion<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::Summarize<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat&amp; coordinat, <a href="CppComment.htm">//</a>two purposes!<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_zero,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sum_above_one)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> DEBUG_SKIP_SAZ_AND_SAO<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero &gt;&nbsp;&nbsp;0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Coordinat already assume all values are non-zero<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and positive.<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(coordinat.<a href="CppIsSorted.htm">IsSorted</a>()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "To prevent duplicates, Coordinat is sorted");<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If index is known, <b><a href="CppReturn.htm">return</a></b> the index<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_index_table.CanGetIndex(coordinat))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_index_table.GetIndex(coordinat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i) <b><a href="CppReturn.htm">return</a></b> i;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A <b><a href="CppNew.htm">new</a></b> coordinat is fed<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_current_index;<br/>
&nbsp;&nbsp;m_index_table.SetIndex(coordinat,i);<br/>
<br/>
&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_current_index;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_zero <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sum_above_one&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n <a href="CppOperatorAssign.htm">=</a> CreateM<a href="CppAny.htm">any</a>DigitDerivatives(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;coordinat,sum_above_zero,sum_above_one);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the <a href="CppNewick.htm">Newick</a> is simple<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and its probability can be calculated with<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>the Ewens formula<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>This can be done <b><a href="CppIf.htm">if</a></b> all indices are reserved<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>OLD: <b><a href="CppIf.htm">if</a></b> (x &lt; m_reserved <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y &lt; m_reserved)<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (coordinat.AllSimple(m_reserved))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_open);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(coordinat.ToVector().begin(),coordinat.ToVector().end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppNewick.htm">Newick</a>::bracket_close);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n.SetProbability(<a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(v,m_theta));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the user requests simple <a href="CppNewick.htm">Newick</a>s to be solved,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>perhaps the requested probability has just been calculated<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> n.GetProbability();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;m_<a href="CppNewick.htm">newick</a>s.Set<a href="CppNewick.htm">Newick</a>(i,n);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> i;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>TryToCalculateNew<a href="CppNewick.htm">Newick</a> tries to calculate the probability<br/>
<a href="CppComment.htm">///</a>of <a href="CppNewick.htm">Newick</a> with index i<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::TryToCalculateNew<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m_calculated_to_index);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i&nbsp;&nbsp;&lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: why cannot use '<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp;'?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\<a href="CppBug.htm">bug</a>: <b><a href="CppThis.htm">this</a></b> seems to give <a href="CppMemory.htm">memory</a> problems (and funny output)<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remember: m_calculated_to_index is not increased<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n.IsProbabilityKnown())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Already know the probability<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Derivative&gt; derivatives <a href="CppOperatorAssign.htm">=</a> n.GetDerivatives();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> of all derivates the probability is known<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> Derivative&amp; derivative: derivatives)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!Get<a href="CppNewick.htm">Newick</a>(derivative.m_derived_index).IsProbabilityKnown())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Too bad, derived <a href="CppNewick.htm">Newick</a>'s probability is unknown<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Calculate constants and probability<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> p <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The denominator is that of the focal <a href="CppNewick.htm">Newick</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and not its derivative(s)<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> denominator <a href="CppOperatorAssign.htm">=</a> Get<a href="CppNewick.htm">Newick</a>(i).GetDenominator();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> Derivative&amp; derivative: derivatives)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Get<a href="CppNewick.htm">Newick</a>(derivative.m_derived_index).IsProbabilityKnown());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> c<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (derivative.m_value_changed <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? m_theta<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(derivative.m_value_changed) * <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(derivative.m_value_changed <a href="CppOperatorMinus.htm">-</a> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a> denominator;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p_this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> c * Get<a href="CppNewick.htm">Newick</a>(derivative.m_derived_index).GetProbability();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p<a href="CppOperatorPlusAssign.htm">+=</a>p_this;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " has been calculated to have the probability of "<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;m_probability <a href="CppOperatorAssign.htm">=</a> p;<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_<a href="CppNewick.htm">newick</a>s.Set<a href="CppNewick.htm">Newick</a>Probability(i,p);<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>TryToCalculateNew<a href="CppNewick.htm">Newick</a>s tries to calculate <b><a href="CppNew.htm">new</a></b> <a href="CppNewick.htm">Newick</a> probabilities<br/>
<a href="CppComment.htm">///</a>\warning: m_calculated_to_index is not increased<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::TryToCalculateNew<a href="CppNewick.htm">Newick</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_calculated_to_index <a href="CppOperatorEqual.htm">==</a> sz denotes that all <a href="CppNewick.htm">Newick</a>s'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>probabilities are calculated<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_calculated_to_index <a href="CppOperatorLessEqual.htm">&lt;=</a> sz);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> m_calculated_to_index; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TryToCalculateNew<a href="CppNewick.htm">Newick</a>(i);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Indexer::UpdateCalculatedFromIndex()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Size();<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m_calculated_to_index &lt; sz)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_calculated_to_index &lt; m_<a href="CppNewick.htm">newick</a>s.Size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\todo: find out why '<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp;' does not work<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> m_<a href="CppNewick.htm">newick</a>s.Get<a href="CppNewick.htm">Newick</a>(m_calculated_to_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n.IsProbabilityKnown())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "At index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m_calculated_to_index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " the probability is known\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_calculated_to_index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickindextable.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickindextable.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> MANYDIGITINDEXTABLE_H<br/>
<a href="CppDefine.htm">#define</a> MANYDIGITINDEXTABLE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppMultiVector.htm">multivector</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>coordinat.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a>M<a href="CppAny.htm">any</a>DigitIndexTable manages (X,Y) <a href="CppOperatorMinus.htm">-</a>&gt; index<br/>
<b><a href="CppStruct.htm">struct</a></b> M<a href="CppAny.htm">any</a>DigitIndexTable<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat Coordinat;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/CanGetIndex <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> GetIndex can be called with success<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanGetIndex(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; indices) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Find <a href="CppReturn.htm">returns</a> the x-y-coordinats of the <a href="CppNewick.htm">Newick</a> with index i<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is a linear (in <b><a href="CppThis.htm">this</a></b> <b><a href="CppCase.htm">case</a></b>, relatively <a href="CppTime.htm">time</a>-intensive) <a href="CppMemberFunction.htm">member function</a>.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Coordinat Find(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get <a href="CppReturn.htm">returns</a> the internals of M<a href="CppAny.htm">any</a>DigitIndexTable<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; Get() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetIndex <a href="CppReturn.htm">returns</a> m_index_table[x][y]<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetIndex(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; indices) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetNumAllocated calculates the number of indices allocated<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> GetNumAllocated() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/GetNumUsed calculates the number of indices used<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> GetNumUsed() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set (x,y) to index z<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIndex(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; coordinat, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value);<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_index_table is the index table that maps (x,y) to a value,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/so that m_index_table[x][y] equals that value<br/>
&nbsp;&nbsp;<a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; m_v;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; FindInternal(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; indices,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value);<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> MANYDIGITINDEXTABLE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewickindextable.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewickindextable.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>indextable.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppComment.htm">///</a>CanGetData <a href="CppReturn.htm">returns</a> is GetData can be called with success<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::CanGetIndex(<b><a href="CppConst.htm">const</a></b> Coordinat&amp; coordinat) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v.CanRetrieve(coordinat.ToVector());<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::Find(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check indices<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> begin <a href="CppOperatorAssign.htm">=</a> m_v.PeekIndices().begin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> end&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> m_v.PeekIndices().end();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> x <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(begin,end,value);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x<a href="CppOperatorNotEqual.htm">!=</a>end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index_found <a href="CppOperatorAssign.htm">=</a> <a href="CppStdDistance.htm">std::distance</a>(begin,x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index_found <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index_found &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.PeekIndices().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Coordinat( { index_found } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <a href="CppMultiVector.htm">MultiVector</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt;&amp; mvs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> m_v.Peek<a href="CppMultiVector.htm">MultiVector</a>s();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> size <a href="CppOperatorAssign.htm">=</a> mvs.size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>size; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> result<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> FindInternal(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(1,i),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mvs[i],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!result.empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Coordinat(result);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Value " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> value <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " not found in <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::Find";<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str());<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::FindInternal(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; indices,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check indices<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> begin <a href="CppOperatorAssign.htm">=</a> v.PeekIndices().begin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> end&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> v.PeekIndices().end();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> x <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(begin,end,value);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x<a href="CppOperatorNotEqual.htm">!=</a>end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index_found <a href="CppOperatorAssign.htm">=</a> <a href="CppStdDistance.htm">std::distance</a>(begin,x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index_found <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index_found &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.PeekIndices().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; result <a href="CppOperatorAssign.htm">=</a> indices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(index_found);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <a href="CppMultiVector.htm">MultiVector</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b>&amp; mvs <a href="CppOperatorAssign.htm">=</a> v.Peek<a href="CppMultiVector.htm">MultiVector</a>s();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> size <a href="CppOperatorAssign.htm">=</a> mvs.size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>size; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; indices_deeper <a href="CppOperatorAssign.htm">=</a> indices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;indices_deeper.push_back(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> result<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> FindInternal(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indices_deeper,mvs[i],value);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!result.empty()) <b><a href="CppReturn.htm">return</a></b> result;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;();<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetIndex <a href="CppReturn.htm">returns</a> m_index_table[x][y]<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::GetIndex(<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat&amp; indices) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanGetIndex(indices));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v.Retrieve(indices.ToVector());<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>GetNumAllocated calculates the number of indices allocated<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::GetNumAllocated() <b><a href="CppConst.htm">const</a></b><br/>
<a href="CppComment.htm">//</a>{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_allocated <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v: m_v.Peek<a href="CppMultiVector.htm">MultiVector</a>s())<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;n_allocated<a href="CppOperatorPlusAssign.htm">+=</a><a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;}<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_allocated;<br/>
<a href="CppComment.htm">//</a>}<br/>
<br/>
<a href="CppComment.htm">///</a>GetNumUsed calculates the number of indices used<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::GetNumUsed() <b><a href="CppConst.htm">const</a></b><br/>
<a href="CppComment.htm">//</a>{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_non_zero <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppMultiVector.htm">MultiVector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; v: m_v.Peek<a href="CppMultiVector.htm">MultiVector</a>s())<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;n_non_zero <a href="CppOperatorPlusAssign.htm">+=</a><br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCount_if.htm">std::count_if</a>(<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.PeekIndices().begin(),<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.PeekIndices().end(),<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdGreater.htm">std::greater</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(),0));<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;}<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_non_zero;<br/>
<a href="CppComment.htm">//</a>}<br/>
<br/>
<a href="CppComment.htm">///</a>SetIndex sets m_index_table[x][y] <a href="CppOperatorEqual.htm">==</a> z<br/>
<a href="CppComment.htm">///</a>and resized the m_index_table is necessary<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::M<a href="CppAny.htm">any</a>DigitIndexTable::SetIndex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Coordinat&amp; indices,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(value &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;!m_v.CanRetrieve(indices.ToVector())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> m_v.Retrieve(indices.ToVector()) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;m_v.Store(indices.ToVector(),value);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v.Retrieve(indices.ToVector()) <a href="CppOperatorEqual.htm">==</a> value);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewicks.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewicks.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> MANYDIGITNEWICKS_H<br/>
<a href="CppDefine.htm">#define</a> MANYDIGITNEWICKS_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>.h"<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s manages M<a href="CppAny.htm">any</a>Digit<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s.<br/>
<a href="CppComment.htm">///</a>M<a href="CppAny.htm">any</a>Digit<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s manage F'(index) <a href="CppOperatorMinus.htm">-</a>&gt; { indices }<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>Derivative Derivative;<br/>
<br/>
&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_reserved, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Empty <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> m_v is empty<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set a <a href="CppNewick.htm">Newick</a> at index i<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/\warning: <b><a href="CppDo.htm">do</a></b> not use push_back, because of recursive calls<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i, <b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; v);<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v.empty(); }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Empty <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> an index is empty<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get <a href="CppReturn.htm">returns</a> the internals of <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&gt;&amp; Get() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get<a href="CppNewick.htm">Newick</a> <a href="CppReturn.htm">returns</a> the <a href="CppNewick.htm">Newick</a> at index i.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/i is checked <b><a href="CppFor.htm">for</a></b> its range.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; Get<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Sets the derivatives of F(i) to { v }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetDerivatives(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i,<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; v);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the number of Derivatives<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set<a href="CppNewick.htm">Newick</a>Probability sets the probability of the <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/at index i to p<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Set<a href="CppNewick.htm">Newick</a>Probability(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i,<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> Size() <b><a href="CppConst.htm">const</a></b>;<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_derivatives contains <b><a href="CppFor.htm">for</a></b> every indexed <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/its derived indexed <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&gt; m_v;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> MANYDIGITNEWICKS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppManyDigitNewick/manydigitnewicks.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppManyDigitNewick/manydigitnewicks.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>, <a href="CppNewick.htm">Newick</a> <b><a href="CppClass.htm">class</a></b><br/>
Copyright (C) 2011-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program.If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppManyDigitNewick.htm">CppManyDigitNewick</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>s.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewick.htm">newick</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppManyDigitNewick.htm">manydigitnewick</a>derivative.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppNewickVector.htm">newickvector</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_reserved, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> theta)<br/>
&nbsp;&nbsp;: m_v{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create derivatives of simplest and reserved <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the <a href="CppNewick.htm">Newick</a> at index 0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;Set<a href="CppNewick.htm">Newick</a>(0,<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>(<a href="CppStdVector.htm">std::vector</a>&lt;M<a href="CppAny.htm">any</a>DigitDerivative&gt;(M<a href="CppAny.htm">any</a>DigitDerivative(),0,0));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the <a href="CppNewick.htm">Newick</a> at index 1<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;Set<a href="CppNewick.htm">Newick</a>(1,<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>(<a href="CppStdVector.htm">std::vector</a>&lt;Derivative&gt;(),1,0));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Let i start at 1, because '(0)' is no valid <a href="CppNewick.htm">Newick</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=2; i<a href="CppOperatorNotEqual.htm">!=</a>n_reserved; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Derivative&gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value_changed <a href="CppOperatorAssign.htm">=</a> i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> other_value_changed <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>&lt;There is no other value<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(Derivative(i-1,value_changed,other_value_changed));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>saz <a href="CppOperatorAssign.htm">=</a> sum above zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saz <a href="CppOperatorAssign.htm">=</a> i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sao <a href="CppOperatorAssign.htm">=</a> sum above one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sao <a href="CppOperatorAssign.htm">=</a> (i &gt; 1 ? i : 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppManyDigitNewick.htm">ManyDigitNewick</a> n(v,saz,sao);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n.SetProbability(<a href="CppNewick.htm">Newick</a>::CalcProbabilitySimple<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppNewick.htm">Newick</a>::bracket_open),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppNewick.htm">Newick</a>::bracket_close)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theta));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;Set<a href="CppNewick.htm">Newick</a>(i,n);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (i &lt; 2 <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppNewick.htm">Newick</a>(i).IsComplete())<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "All <a href="CppNewick.htm">newick</a> with index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2 must be <b><a href="CppCompl.htm">compl</a></b>ete");<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Empty(1));<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Empty <a href="CppReturn.htm">returns</a> <b><a href="CppIf.htm">if</a></b> an index is empty<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s::Empty(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppThis.htm">this</a></b>-&gt;Size());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v[i].Empty();<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s::Get<a href="CppNewick.htm">Newick</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> i is in range<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i<a href="CppOperatorGreaterEqual.htm">&gt;=</a>0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppThis.htm">this</a></b>-&gt;Size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> <b><a href="CppReturn.htm">return</a></b>ed indices are okay<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; v <a href="CppOperatorAssign.htm">=</a> m_v[i];<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> Derivative&amp; j: v.GetDerivatives())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index &lt; <b><a href="CppThis.htm">this</a></b>-&gt;Size() );<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_v[i];<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s::Set<a href="CppNewick.htm">Newick</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i, <b><a href="CppConst.htm">const</a></b> <a href="CppManyDigitNewick.htm">ManyDigitNewick</a>&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>_FUNC();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Allocate storage<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TODO: replace by push_back<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v.resize(i <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[m_v.size()-1].Empty());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppAdd.htm">Add</a>ing a <a href="CppNewick.htm">Newick</a> at index " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_v[i].Empty());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> Derivative&amp; j: v.GetDerivatives())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j.m_derived_index &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot set a derivative index "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "bigger than the number of derivatives");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;m_v[i] <a href="CppOperatorAssign.htm">=</a> v;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s::Set<a href="CppNewick.htm">Newick</a>Probability(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i,<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> p)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i&nbsp;&nbsp;&lt; Size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p <a href="CppOperatorLessEqual.htm">&lt;=</a> 1.0);<br/>
&nbsp;&nbsp;m_v[i].SetProbability(p);<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppManyDigitNewick.htm">ManyDigitNewick</a>s::Size() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_v.size());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
