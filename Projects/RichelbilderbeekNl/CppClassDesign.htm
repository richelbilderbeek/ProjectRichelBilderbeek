<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>class design</title>
  <meta name="description" content="C++ class design"/>
  <meta name="keywords" content="C++ class design how to write"/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppClassDesign.htm">Class design</a></h1>
<p>&nbsp;</p>
<p>The design of a <a href="CppClass.htm">class</a>.</p>
<p>&nbsp;</p>
<p>Although entire books are written on this subject, here some <a href="CppAdvice.htm">advice</a> from some experts:</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>General</h2>
<p>&nbsp;</p>
<ul>
  <li>
    Represent concepts as classes [28]
  </li>
  <li>
    Be clear what <a href="CppClassType.htm">kind of class</a> you're writing [10]
  </li>
  <li>
    Follow a good <a href="CppFunctionDesign.htm">function design</a>. Note: many points of 
    <a href="CppAdvice.htm">advice</a>!
  </li>
  <li>
    Follow a good <a href="CppMemberFunctionDesign.htm">member function design</a>. Note: 
    many points of <a href="CppAdvice.htm">advice</a>!
  </li>
  <li>
    Treat <a href="CppClassDesign.htm">class design</a> as type design [2]
  </li>
  <li>
    Make classes as atomic as possible; that is, give each class a single, clear purpose [36]
  </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Choosing a <a href="CppClassType.htm">class type</a></h2>
<p>&nbsp;</p>
<ul>
  <li>
    Prefer minimal <a href="CppClass.htm">classes</a> to monolithic classes [11]
  </li>
  <li>
    Prefer a <a href="CppConcreteType.htm">concrete type</a> over more complicated classes 
    and over <a href="CppPod.htm">POD</a>s, as a <a href="CppConcreteType.htm">concrete type</a> 
    is the simplest kind of class [31]
  </li>
  <li>
    Use <a href="CppAbstractBaseClass.htm">abstract classes</a> to focus design on the provision 
    of clean <a href="CppInterface.htm">interfaces</a> [32]
  </li>
  <li>
    Use <a href="CppPod.htm">POD</a>s only when it really is just data and 
    no <a href="CppInvariant.htm">invariant</a> is meaningful for the data members [30]
  </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="CppInterface.htm">Interface</a></h2>
<p>&nbsp;</p>
<ul>
  <li>
    Seperate the <a href="CppInterface.htm">interface</a> of a <a href="CppClass.htm">class</a> from its 
    <a href="CppImplementation.htm">implementation</a> [29]: allow the user not to know what 
    kind of <a href="CppDataType.htm">data types</a> you used in the 
    <a href="CppPrivate.htm">private</a> section of your class
  </li>
  <li>
    Make <a href="CppInterface.htm">interfaces</a> easy to use correctly and hard to use incorrectly [1]
  </li>
  <li>
    Start with a minimal <a href="CppInterface.htm">interface</a> to a class, as small and simple 
    as you need to solve the problem at hand [37]
  </li>
  <li>
    Don't try to anticipate all the ways that your class might be used [37]
  </li>
  <li>
    Be aware that once a class is in use you cannot shrink the 
    <a href="CppInterface.htm">interface</a> without disturbing client code [37]
  </li>
  <li>
    <a href="CppDeclaration.htm">Declare</a> <a href="CppMemberVariable.htm">member variables</a> 
    <a href="CppPrivate.htm">private</a> [5,9,19,27], except in <a href="CppPod.htm">POD</a>s [19]
  </li>
  <li>
    Use <a href="CppHelperFunction.htm">helper functions</a> when type conversion should 
    apply to all parameters [7]
  </li>
  <li>
    Consider support for a non-throwing <a href="CppSwap.htm">swap</a> [8]
  </li>
  <li>
    Use <a href="CppAbstractClass.htm">abstract classes</a> to specify <a href="CppInterface.htm">interfaces</a> [32]
  </li>
  <li>
    Use <a href="CppAbstractClass.htm">abstract classes</a> to keep implementation details out of <a href="CppInterface.htm">interfaces</a> [32]
  </li>
  <li>
    Prefer providing abstract <a href="CppInterface.htm">interfaces</a> [14]
  </li>

<!-- Inheritance -->

  <li>
    Prefer <a href="CppComposition.htm">composition</a> to <a href="CppInheritance.htm">inheritance</a> [12]
  </li>
  <li>
    Avoid inheriting from <a href="CppClass.htm">classes</a> that were not designed to be <a href="CppBaseClass.htm">base classes</a> [13]
  </li>
  <li>
    Public inheritance is substitutability. Inherit, not te reuse, but to be reused [15]
  </li>
  <li>
    Practice safe overriding [16]
  </li>
  <li>
    Consider making virtual functions nonpublic, and public functions nonvirtual [17]
  </li>
  <li>
    Don't give away your internals [20]
  </li>
<!-- Testing -->
  <li>
    Write the <a href="CppTest.htm">test</a> code first [34,35]
  </li>
  <li>
    Keep the <a href="CppTest.htm">test</a> code with the <a href="CppClass.htm">class</a> to be tested [34]
  </li>
  <li>
    Write the <a href="CppTest.htm">test</a> code to verify that 
    your <a href="CppClassDesign.htm">class design</a> is complete [35]
  </li>

<!-- Misc -->
  <li>
    <a href="CppPimpl.htm">Pimpl</a> judiciously [21]
  </li>
  <li>
    Always provide <a href="CppNew.htm">new</a> and <a href="CppDelete.htm">delete</a> together [23]
  </li>
  <li>
    If you provide any class-specific new, provide all of the standard forms (plain, in-place, and nothrow) [24]
  </li>
  <li>
    Avoid providing implicit conversions [18]
  </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="CppReferences.htm">References</a></h2>
<p>&nbsp;</p>
<ol>
  <li><!--  1 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 18: Make interfaces easy to use correctly and hard to use incorrectly.</li>
  <li><!--  2 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 19: Treat class design as type design.</li>
  <li><!--  3 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 20: Prefer pass-by-reference-to-const to pass-by-value.</li>
  <li><!--  4 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 21: Don't try to return a reference when you must return an object.</li>
  <li><!--  5 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 22: Declare data members private.</li>
  <li><!--  6 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 23: Prefer non-member non-friend functions to member functions.</li>
  <li><!--  7 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 24: Declare non-member functions when type conversion should apply to all parameters</li>
  <li><!--  8 --><a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C++ (3rd edition). ISBN: 0-321-33487-6. Item 25: Consider support for a non-throwing swap.</li>
  <li><!--  9 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 11: 'Hide information'.</li>
  <li><!-- 10 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 32: 'Be clear what kind of class you're writing'.</li>
  <li><!-- 11 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 33: 'Prefer minimal classes to monolithic classes'.</li>
  <li><!-- 12 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 34: 'Prefer composition to inheritance'.</li>
  <li><!-- 13 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 35: 'Avoid inheriting from classes that were not designed to be base classes'.</li>
  <li><!-- 14 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 36: 'Prefer providing abstract interfaces'.</li>
  <li><!-- 15 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 37: 'Public inheritance is substitutability. Inherit, not te reuse, but to be reused'.</li>
  <li><!-- 16 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 38: 'Practive safe overriding'.</li>
  <li><!-- 17 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 39: 'Consider making virtual functions nonpublic, and public functions nonvirtual'.</li>
  <li><!-- 18 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 40: 'Avoid providing implicit conversions'.</li>
  <li><!-- 19 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 41: 'Make data members private, except in behaviourless aggregates (C-style structs).</li>
  <li><!-- 20 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 42: 'Don't give away your internals'.</li>
  <li><!-- 21 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 43: 'Pimpl judiciously'.</li>
  <li><!-- 22 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 44: 'Prefer writing nonmember nonfriend functions'</li>
  <li><!-- 23 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 45: 'Always provide new and delete together'.</li>
  <li><!-- 24 --><a href="CppHerbSutter.htm">Herb Sutter</a>, <a href="CppAndreiAlexandrescu.htm">Andrei Alexandrescu</a>. C++ coding standards: 101 rules, guidelines, and best practices. 2005. ISBN: 0-32-111358-6. Chapter 46: 'If you provide any class-specific new, provide all of the standard forms (plain, in-place, and nothrow)'.</li>
  <li><!-- 25 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>'s C++ glossary: http://www.research.att.com/~bs/glossary.html#Gclass</p>
  <li><!-- 26 -->C++. International Standard. ISO/IEC 14882. Second edition. Paragraph 14.1.2.</li>
  <li><!-- 27 --><a href="CppJohnLakos.htm">John Lakos</a>. Large-Scale C++ Software Design. 1996. ISBN: 0-201-63362-0.</li>
  <li><!-- 28 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 16.4. Advice. page 479: '[1] Represent concepts as classes'</li>
  <li><!-- 29 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 16.4. Advice. page 479: '[2] Seperate the interface of a class from its implementation'</li>
  <li><!-- 30 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 16.4. Advice. page 479: '[3] Use public data (structs) only when it really is just data and no invariant is meaningful for the data members'</li>
  <li><!-- 31 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 16.4. Advice. page 479: '[7] A concrete type is the simplest kind of class. Where applicable, prefer a concrete type over more complicated classes and over plain data structures'</li>
  <li><!-- 32 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 20.7. Advice. page 611: '[6] Use abstract classes to focus design on the provision of clean interfaces'</li>
  <li><!-- 33 --><a href="CppBjarneStroustrup.htm">Bjarne Stroustrup</a>. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 20.7. Advice. page 611: '[7] Use abstract classes to keep implementation details out of interfaces'</li>
  <li><!-- 34 --><a href="CppBruceEckel.htm">Bruce Eckel</a>. Thinking in C++, second edition, volume 1. 2000. ISBN: 0-13-979809-9. Chapter B: Programming Guidelines. Item 11: 'Write the test code first (before you write the class), and keep it with the class. Automate the running of your tests through a makefile or similar tool. This way, any changes can be automatically verified by running the test code, and you’ll immediately discover errors. Because you know that you have the safety net of your test framework, you will be bolder about making sweeping changes when you discover the need. Remember that the greatest improvements in languages come from the built-in testing that type checking, exception handling, etc., provide, but those features take you only so far. You must go the rest of the way in creating a robust system by filling in the tests that verify features that are specific to your class or program.'</li>
  <li><!-- 35 --><a href="CppBruceEckel.htm">Bruce Eckel</a>. Thinking in C++, second edition, volume 1. 2000. ISBN: 0-13-979809-9. Chapter B: Programming Guidelines. Item 12: 'Write the test code first (before you write the class) in order to verify that your class design is complete. If you can’t write test code, you don’t know what your class looks like. In addition, the act of writing the test code will often flush out additional features or constraints that you need in the class – these features or constraints don’t always appear during analysis and design.'</li>
  <li><!-- 36 --><a href="CppBruceEckel.htm">Bruce Eckel</a>. Thinking in C++, second edition, volume 1. 2000. ISBN: 0-13-979809-9. Chapter B: Programming Guidelines. Item 14: 'Make classes as atomic as possible; that is, give each class a single, clear purpose. If your classes or your system design grows too complicated, break complex classes into simpler ones. The most obvious indicator of this is sheer size: if a class is big, chances are it’s doing too much and should be broken up.'</li>
  <li><!-- 37 --><a href="CppBruceEckel.htm">Bruce Eckel</a>. Thinking in C++, second edition, volume 1. 2000. ISBN: 0-13-979809-9. Chapter B: Programming Guidelines. Item 23: 'Less is more. Start with a minimal interface to a class, as small and simple as you need to solve the problem at hand, but don’t try to anticipate all the ways that your class might be used. As the class is used, you’ll discover ways you must expand the interface. However, once a class is in use you cannot shrink the interface without disturbing client code. If you need to add more functions, that’s fine; it won’t disturb code, other than forcing recompiles. But even if new member functions replace the functionality of old ones, leave the existing interface alone (you can combine the functionality in the underlying implementation if you want). If you need to expand the interface of an existing function by adding more arguments, leave the existing arguments in their current order, and put default values on all of the new arguments; this way you won’t disturb any existing calls to that function.'</li>

</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
</body>
</html>
