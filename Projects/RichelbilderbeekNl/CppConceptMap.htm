<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>ConceptMap</title>
  <meta name="description" content="C++ ConceptMap"/>
  <meta name="keywords" content="C++ ConceptMap "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppConceptMap.htm">ConceptMap</a></h1>
<p>&nbsp;</p>
<!-- This page is generated by CodeToHtml version 1.1.578 at Thu Jan 16 06:21:10 2014
 -->
<p><img src="PicStl.png" alt="STL"/><img src="PicQtCreator.png" alt="Qt Creator"/><img src="PicLubuntu.png" alt="Lubuntu"/><img src="PicWindows.png" alt="Windows"/></p>
<p>&nbsp;</p>
<p>
  <a href="CppConceptMap.htm">ConceptMap</a> is a <a href="CppClass.htm">class</a>
  for a concept map.
</p>
<p>&nbsp;</p>
<p>
  <a href="CppConceptMap.htm">ConceptMap</a> is used in, among others,
  the <a href="Tools.htm">tool</a> <a href="ToolTestConceptMap.htm">TestConceptMap</a>
  and the <a href="Projects.htm">project</a> <a href="ProjectBrainweaver.htm">Brainweaver</a>.
</p>
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/CppConceptMap.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/CppConceptMap.pri" border = "1"><tr><td><code>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a><br/>
<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/Licence.txt<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapfwd.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternodefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcompetency.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconcept.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconceptfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedgefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexample.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamples.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplesfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnodefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaphelper.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedge.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommand.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapelement.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>factory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewconceptmap.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewnode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeleteconceptmap.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandlosefocus.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocuswithcoordinat.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocusrandom.h<br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternodefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcompetency.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconcept.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconceptfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedge.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedgefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexample.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamples.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplesfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnodefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaphelper.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaptestconceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaptestconcept.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommand.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapelement.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>factory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewconceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewnode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeleteconceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandlosefocus.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocuswithcoordinat.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocusrandom.cpp<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmap.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmap.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPTMAP_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPTMAP_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMapFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A concept map<br/>
<a href="CppComment.htm">///</a>Its <a href="CppInterface.htm">interface</a> is based on nodes and edges<br/>
<a href="CppComment.htm">///</a>Use ConceptMap<a href="CppWidget.htm">Widget</a> to work with commands<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMap<br/>
{<br/>
&nbsp;&nbsp;ConceptMap(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;ConceptMap&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> an Edge, assumes that the nodes it <a href="CppPointer.htm">point</a>s to are in the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>Edge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> a node, always works<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>Node(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> ConceptMap can be <a href="CppConstructor.htm">construct</a>ed successfully<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> Can<a href="CppConstructor.htm">Construct</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Prepend the <a href="CppQuestion.htm">question</a> as a first node, before adding the supplied nodes<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; CreateNodes(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create all sub-conceptmaps<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Note that CreateSubs()[0] is the concept map around the focal <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; CreateSubs() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete an edge<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteEdge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete a node and all the edges connected to it<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Check <b><a href="CppIf.htm">if</a></b> the ConceptMap is empty<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Find the CenterNode, <b><a href="CppIf.htm">if</a></b> <a href="CppAny.htm">any</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; FindCenterNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNode&gt; FindCenterNode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the edges<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; &gt;&nbsp;&nbsp;GetEdges() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&gt; &gt;&amp; GetEdges() { <b><a href="CppReturn.htm">return</a></b> m_edges; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the focal node (always at index zero)<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFocalNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetFocalNode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the nodes<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt;&nbsp;&nbsp;GetNodes() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; &gt;&amp; GetNodes() { <b><a href="CppReturn.htm">return</a></b> m_nodes; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the focus <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> Get<a href="CppQuestion.htm">Question</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Similar to <b><a href="CppOperatorEqual.htm">operator==</a></b>, except that the GUI member variables aren't checked <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> HasSameContent(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> ConceptMap&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Check <b><a href="CppIf.htm">if</a></b> there are no nulls in the edges and nodes<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsValid() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Put the CenterNode (<b><a href="CppIf.htm">if</a></b> present) first<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Sort(<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Sort(<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a ConceptMap from an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; c);<br/>
<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The edges<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt; m_edges;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The nodes<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; m_nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">constructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> ConceptMapFactory<br/>
&nbsp;&nbsp;ConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Nodes[0] must be the focal <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;ConceptMap(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges <a href="CppOperatorAssign.htm">=</a> {});<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create a concept map from a cluster<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> TO_ADD_TO_PROJECTBRAINWEAVER<br/>
&nbsp;&nbsp;ConceptMap(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Cluster&gt;&amp; cluster);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/To <a href="CppMake.htm">make</a> the <a href="CppCompiler.htm">compiler</a> use the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; FindCenterNodeConst() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> FindCenterNode(); }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/To <a href="CppMake.htm">make</a> the <a href="CppCompiler.htm">compiler</a> use the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFocalNodeConst() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> GetFocalNode(); }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> ConceptMapFactory;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;~ConceptMap() {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(ConceptMap* x);<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>Count the number of CenterNodes<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> regular concept map: 1, the focus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> sub-concept map: 0 or 1, <b><a href="CppIf.htm">if</a></b> the focus is connected to the sub's focus node<br/>
<b><a href="CppInt.htm">int</a></b> CountCenterNodes(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Count the number of Edges connected to a CenterNodes<br/>
<b><a href="CppInt.htm">int</a></b> CountCenterNodeEdges(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> ConceptMap&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> ConceptMap&amp; rhs);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPTMAP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmap.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSetH.htm">set</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFunctionalH.htm">functional</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "conceptmapcluster.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::ConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>)<br/>
&nbsp;&nbsp;: m_edges( {} ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes(CreateNodes(<a href="CppQuestion.htm">question</a>, {} ))<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(m_nodes,m_edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppQuestion.htm">Question</a>() <a href="CppOperatorEqual.htm">==</a> <a href="CppQuestion.htm">question</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(FindCenterNode()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume a CenterNode at the center of ConceptMap");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsCenterNode(FindCenterNode())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume a CenterNode at the center of ConceptMap");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::ConceptMap(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt;&amp; edges)<br/>
&nbsp;&nbsp;: m_edges(edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes(nodes)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(nodes,edges))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_nodes <a href="CppOperatorAssign.htm">=</a> nodes.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ": " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Node::To<a href="CppXml.htm">Xml</a>(nodes[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_edges <a href="CppOperatorAssign.htm">=</a> edges.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge <a href="CppOperatorAssign.htm">=</a> edges[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> const_nodes <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ": " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Edge::To<a href="CppXml.htm">Xml</a>(edge,const_nodes) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(nodes,edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;Get<a href="CppQuestion.htm">Question</a>() <a href="CppOperatorEqual.htm">==</a> nodes[0]-&gt;GetConcept()-&gt;GetName());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;CenterNode&gt;(nodes[0]) <a href="CppOperatorLogicalOr.htm">||</a> !<a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;CenterNode&gt;(nodes[0]))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A sub concept map may not have a center node");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TO_ADD_TO_PROJECTBRAINWEAVER<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::ConceptMap(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Cluster&gt;&amp; cluster)<br/>
&nbsp;&nbsp;: m_edges{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes(CreateNodes(<a href="CppQuestion.htm">question</a>, {} ))<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; &gt;&amp; v <a href="CppOperatorAssign.htm">=</a> cluster-&gt;Get();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n <a href="CppOperatorAssign.htm">=</a> <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node <a href="CppOperatorAssign.htm">=</a> cmap::NodeFactory::Create(v[i],x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.push_back(node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorEqual.htm">==</a> m_nodes.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume the ConceptMap has as much nodes as the cluster has concepts <a href="CppOperatorPlus.htm">+</a> one focal <a href="CppQuestion.htm">question</a>");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>TO_ADD_TO_PROJECTBRAINWEAVER<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::<a href="CppAdd.htm">Add</a>Edge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "First enter the node <b><a href="CppThis.htm">this</a></b> edge originates from");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "First enter the node <b><a href="CppThis.htm">this</a></b> edge targets to");<br/>
&nbsp;&nbsp;m_edges.push_back(edge);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::<a href="CppAdd.htm">Add</a>Node(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;m_nodes.push_back(node);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt;&amp; edges)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppTrace.htm">trace</a>_verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (<a href="CppQuestion.htm">question</a>.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot <a href="CppConstructor.htm">construct</a> empty <a href="CppQuestion.htm">question</a>s") <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> first node, which is the focal <a href="CppQuestion.htm">question</a>, does not have examples<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nodes.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("A concept map must have at least one node"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(nodes[0]-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The center node CAN have examples, when the center node is the focal node of a sub-concept map<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppIf.htm">if</a></b> (!nodes[0]-&gt;GetConcept()-&gt;GetExamples().empty()) { <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> all edges are in range<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_invalid <a href="CppOperatorAssign.htm">=</a> <a href="CppCount_if.htm">std::count_if</a>(edges.begin(), edges.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[n_nodes](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &amp; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetTo() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> n_nodes <a href="CppOperatorLogicalOr.htm">||</a> edge-&gt;GetFrom() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> n_nodes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_invalid)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> there are 'two-way' edges, that is, one edge going from A to B<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and another edge going from B to A<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges <a href="CppOperatorAssign.htm">=</a> edges.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &amp; a <a href="CppOperatorAssign.htm">=</a> edges[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> a_from <a href="CppOperatorAssign.htm">=</a> a-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> a_to&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> a-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=i+1; j<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorNotEqual.htm">!=</a> j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; n_edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &amp; b <a href="CppOperatorAssign.htm">=</a> edges[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a.get() <a href="CppOperatorNotEqual.htm">!=</a> b.get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume different <a href="CppPointer.htm">pointer</a>s");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> b_from <a href="CppOperatorAssign.htm">=</a> b-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> b_to&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> b-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (a_from.get() <a href="CppOperatorEqual.htm">==</a> b_from.get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> a_to.get() <a href="CppOperatorEqual.htm">==</a> b_to.get())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Cannot have two edges from the same node to the same node");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (a_from.get() <a href="CppOperatorEqual.htm">==</a> b_to.get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> a_to.get() <a href="CppOperatorEqual.htm">==</a> b_from.get())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Cannot have two edges from the same node to the same node");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If there is a CenterNode, it must be at index 0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_nodes <a href="CppOperatorAssign.htm">=</a> nodes.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsCenterNode(nodes[i]))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorNotEqual.htm">!=</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Cannot have a center node at an index other than zero");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::CreateNodes(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::ExamplesFactory::Create(), <a href="CppComment.htm">//</a>No examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFalse.htm">false</a></b>, <a href="CppComment.htm">//</a>Is not complex<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>1, <a href="CppComment.htm">//</a>No rated complexity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>1, <a href="CppComment.htm">//</a>No rated concreteness<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>1&nbsp;&nbsp;<a href="CppComment.htm">//</a>No rated specificity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::CenterNode&gt; center_node <a href="CppOperatorAssign.htm">=</a> cmap::CenterNodeFactory::Create(concept,0,0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node);<br/>
&nbsp;&nbsp;v.push_back(center_node);<br/>
&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(nodes.begin(),nodes.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> nodes.size() <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::CreateSubs() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_nodes.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must have a at least one node");<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; focal_node: m_nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_node);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Collect all edges connected top the focal node (which is m_nodes[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; nodes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt; edges;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(focal_node);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; focal_edge: m_edges)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppIf.htm">if</a></b> (focal_edge-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> focal_node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(focal_edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_edge-&gt;GetTo() <a href="CppOperatorNotEqual.htm">!=</a> focal_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(focal_edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (focal_edge-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> focal_node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(focal_edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_edge-&gt;GetFrom() <a href="CppOperatorNotEqual.htm">!=</a> focal_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(focal_edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!nodes.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Put CenterNode in front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind_if.htm">std::find_if</a>(nodes.begin(),nodes.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node) { <b><a href="CppReturn.htm">return</a></b> IsCenterNode(node); } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end()) { <a href="CppSwap.htm">std::swap</a>(*nodes.begin(),*iter); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(nodes,edges) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Only <a href="CppConstructor.htm">construct</a> valid concept maps");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<b><a href="CppNew.htm">new</a></b> ConceptMap(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(CountCenterNodes(concept_map) <a href="CppOperatorEqual.htm">==</a> 0 <a href="CppOperatorLogicalOr.htm">||</a> concep_map-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::DeleteEdge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(m_edges.begin(),m_edges.end(),edge) <a href="CppOperatorNotEqual.htm">!=</a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The edge must exist");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(m_edges.begin(),m_edges.end(),edge) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Every edge is unique");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_edges_before <a href="CppOperatorAssign.htm">=</a> m_edges.size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copied from http://www.richelbilderbeek.nl/CppVector.htm<br/>
&nbsp;&nbsp;m_edges.erase(<a href="CppRemove.htm">std::remove</a>(m_edges.begin(),m_edges.end(),edge),m_edges.end());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_edges_after <a href="CppOperatorAssign.htm">=</a> m_edges.size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_edges_before <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> n_edges_after);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),node) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Every node is unique");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_nodes_before <a href="CppOperatorAssign.htm">=</a> m_nodes.size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete all edges going to <b><a href="CppThis.htm">this</a></b> node<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; to_be_deleted;<br/>
&nbsp;&nbsp;<a href="CppCopy_if.htm">std::copy_if</a>(m_edges.begin(),m_edges.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(to_be_deleted),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[node](<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> node <a href="CppOperatorLogicalOr.htm">||</a> edge-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge: to_be_deleted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;DeleteEdge(edge);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the node itself<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copied from http://www.richelbilderbeek.nl/CppVector.htm<br/>
&nbsp;&nbsp;m_nodes.erase(<a href="CppRemove.htm">std::remove</a>(m_nodes.begin(),m_nodes.end(),node),m_nodes.end());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_nodes_after <a href="CppOperatorAssign.htm">=</a> m_nodes.size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_nodes_before <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> n_nodes_after);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Empty() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_nodes.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_edges.empty();<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::FindCenterNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind_if.htm">std::find_if</a>(m_nodes.begin(),m_nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsCenterNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; center_node;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (iter <a href="CppOperatorEqual.htm">==</a> m_nodes.end())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!center_node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;center_node <a href="CppOperatorAssign.htm">=</a> <a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(*iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> center_node;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::FindCenterNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calls the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a> of <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s [1]<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1] <a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C<a href="CppOperatorIncrement.htm">++</a> (3rd edition). ISBN: 0-321-33487-6.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;Item 3, paragraph 'Avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s'<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; center_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDynamic_cast.htm">dynamic_cast</a></b>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap*&gt;(<b><a href="CppThis.htm">this</a></b>)-&gt;FindCenterNodeConst() <a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppConst.htm">const</a></b> because <a href="CppCompiler.htm">compiler</a> cannt find the right <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoost.htm">boost</a>::const_<a href="CppPointer.htm">pointer</a>_cast&lt;CenterNode&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;center_node<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetEdges() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppAdd.htm">Add</a>Const(m_edges);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetFocalNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_nodes.empty());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_nodes[0];<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetFocalNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calls the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a> of <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s [1]<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1] <a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C<a href="CppOperatorIncrement.htm">++</a> (3rd edition). ISBN: 0-321-33487-6.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;Item 3, paragraph 'Avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s'<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; focal_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDynamic_cast.htm">dynamic_cast</a></b>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap*&gt;(<b><a href="CppThis.htm">this</a></b>)-&gt;GetFocalNodeConst() <a href="CppComment.htm">//</a><a href="CppCompiler.htm">Compiler</a> cannot distinguish <a href="CppMemberFunction.htm">member functions</a> by type<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoost.htm">boost</a>::const_<a href="CppPointer.htm">pointer</a>_cast&lt;Node&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;focal_node<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetNodes() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppAdd.htm">Add</a>Const(m_nodes);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Get<a href="CppQuestion.htm">Question</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_nodes.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_nodes[0]-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A Concept Map CAN have examples at node[0]: when it is a sub-cluster<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(m_nodes[0]-&gt;GetConcept()-&gt;GetExamples().size() <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_nodes[0]-&gt;GetConcept()-&gt;GetName();<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.1";<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-xx-xx: <a href="CppVersion.htm">Version</a> 1.0: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-12-23: <a href="CppVersion.htm">Version</a> 1.1: started <a href="CppVersion.htm">version</a>ing"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::HasSameContent(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppTrace.htm">trace</a>_verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get<a href="CppQuestion.htm">Question</a>() <a href="CppOperatorNotEqual.htm">!=</a> rhs.Get<a href="CppQuestion.htm">Question</a>())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("<a href="CppQuestion.htm">Question</a>s differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetEdges().size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetEdges().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Number of edges differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetNodes().size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetNodes().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Number of nodes differ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(lhs.GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(rhs.GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppFunction.htm">Function</a> to compare Concept <a href="CppSmartPointer.htm">smart pointer</a>s<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; ConstConceptPtr;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdFunction.htm">std::function</a>&lt;<b><a href="CppBool.htm">bool</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)&gt; concept_cmp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> [](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs &lt; *rhs;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Same Concepts<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt; nodes_lhs <a href="CppOperatorAssign.htm">=</a> lhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_lhs(concept_cmp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(nodes_lhs.begin(),nodes_lhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_lhs,concepts_lhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConstConceptPtr concept <a href="CppOperatorAssign.htm">=</a> node-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt; nodes_rhs <a href="CppOperatorAssign.htm">=</a> rhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_rhs(concept_cmp);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(nodes_rhs.begin(),nodes_rhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_rhs,concepts_rhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppMismatch.htm">std::mismatch</a>(concepts_lhs.begin(),concepts_lhs.end(),concepts_rhs.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; a,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *a <a href="CppOperatorEqual.htm">==</a> *b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> <a href="CppMake_pair.htm">std::make_pair</a>(concepts_lhs.end(),concepts_rhs.end()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Node concepts differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Same Edges<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; edges_lhs <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_lhs(concept_cmp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(edges_lhs.begin(),edges_lhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_lhs,concepts_lhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; edges_rhs <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_rhs(concept_cmp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(edges_rhs.begin(),edges_rhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_rhs,concepts_rhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppMismatch.htm">std::mismatch</a>(concepts_lhs.begin(),concepts_lhs.end(),concepts_rhs.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; a,<b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *a <a href="CppOperatorEqual.htm">==</a> *b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> <a href="CppMake_pair.htm">std::make_pair</a>(concepts_lhs.end(),concepts_rhs.end()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Edge concepts differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> <b><a href="CppFor.htm">for</a></b> each edge a same 'from' and 'to' concept can be found<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdTuple.htm">std::tuple</a>&lt;<a href="CppString.htm">std::string</a>,<a href="CppString.htm">std::string</a>,<a href="CppString.htm">std::string</a>&gt; FakeEdge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;FakeEdge&gt; FakeEdges;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetEdges().size() <a href="CppOperatorEqual.htm">==</a> rhs.GetEdges().size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FakeEdges v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_node <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges()[i]-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> str_from <a href="CppOperatorAssign.htm">=</a> from_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> str_mid <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges()[i]-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_node <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges()[i]-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> str_to <a href="CppOperatorAssign.htm">=</a> to_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only <b><a href="CppIf.htm">if</a></b> arrow is reversed, reverse the fake edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetEdges()[i]-&gt;HasHeadArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (lhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> lhs.GetEdges()[i]-&gt;HasHeadArrow())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two-way or zero-way arrow, add it in both directions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Normal arrow<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size()) <a href="CppOperatorGreaterEqual.htm">&gt;=</a> sz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FakeEdges w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_node <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges()[i]-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> str_from <a href="CppOperatorAssign.htm">=</a> from_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> str_mid <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges()[i]-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_node <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges()[i]-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> str_to <a href="CppOperatorAssign.htm">=</a> to_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only <b><a href="CppIf.htm">if</a></b> arrow is reversed, reverse the fake edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rhs.GetEdges()[i]-&gt;HasHeadArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (rhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> rhs.GetEdges()[i]-&gt;HasHeadArrow())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two-way or zero-way arrow, add it in both directions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Normal arrow<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::<a href="CppMake.htm">make</a>_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w.size()) <a href="CppOperatorGreaterEqual.htm">&gt;=</a> sz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorNotEqual.htm">!=</a> w.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSort.htm">std::sort</a>(v.begin(),v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSort.htm">std::sort</a>(w.begin(),w.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v <a href="CppOperatorNotEqual.htm">!=</a> w)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> REALLY_SHOW_ME_THIS_7364894385876473475934758934753<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> REALLY_SHOW_ME_THIS_7364894385876473475934758934753<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "[" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (i+1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "/" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sz <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "]: ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;0&gt;(v[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;1&gt;(v[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;2&gt;(v[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") , ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;0&gt;(w[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;1&gt;(w[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;2&gt;(w[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ")";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::IsValid() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node: m_nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Node is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge: m_edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Edge is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!edge-&gt;GetTo())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetTo() is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!edge-&gt;GetFrom())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetFrom() is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorNotEqual.htm">!=</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetTo() <a href="CppPointer.htm">point</a>s to node not in the concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorNotEqual.htm">!=</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetFrom() <a href="CppPointer.htm">point</a>s to node not in the concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Sort(<br/>
&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> w(v);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> w.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> i <a href="CppOperatorAssign.htm">=</a> <a href="CppFind_if.htm">std::find_if</a>(w.begin(),w.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorNotEqual.htm">!=</a> w.end())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSwap.htm">std::swap</a>(*i,*w.begin());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(*w.begin()));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Sort(<br/>
&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> w(v);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> w.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> i <a href="CppOperatorAssign.htm">=</a> <a href="CppFind_if.htm">std::find_if</a>(w.begin(),w.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorNotEqual.htm">!=</a> w.end())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSwap.htm">std::swap</a>(*i,*w.begin());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;CenterNode&gt;(*w.begin()));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; map)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;concept_map&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;nodes&gt;";<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt;&amp; nodes <a href="CppOperatorAssign.htm">=</a> map-&gt;GetNodes();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; node: nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Node::To<a href="CppXml.htm">Xml</a>(node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/nodes&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;edges&gt;";<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt;&amp; edges <a href="CppOperatorAssign.htm">=</a> map-&gt;GetEdges();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge: edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Edge::To<a href="CppXml.htm">Xml</a>(edge,nodes);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/edges&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/concept_map&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 27);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,13) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;concept_map&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 14,14) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/concept_map&gt;"));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CountCenterNodes(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> conceptmap-&gt;GetNodes();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cnt <a href="CppOperatorAssign.htm">=</a> <a href="CppCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsCenterNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt &lt; 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A concept map can have one or zero (a sub-conceptmap) center nodes");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> cnt;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CountCenterNodeEdges(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes <a href="CppOperatorAssign.htm">=</a> CountCenterNodes(conceptmap);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_center_nodes &lt; 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A concept map can have one or zero (a sub-conceptmap) center nodes");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_center_nodes <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppReturn.htm">return</a></b> 0;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> conceptmap-&gt;GetEdges();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cnt <a href="CppOperatorAssign.htm">=</a> <a href="CppCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsConnectedToCenterNode(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> cnt;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Compare nodes<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt; lhs_nodes <a href="CppOperatorAssign.htm">=</a> lhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt; rhs_nodes <a href="CppOperatorAssign.htm">=</a> rhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs_nodes.size() <a href="CppOperatorNotEqual.htm">!=</a> rhs_nodes.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEqual.htm">std::equal</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBegin.htm">std::begin</a>(lhs_nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEnd.htm">std::end</a>(&nbsp;&nbsp;lhs_nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBegin.htm">std::begin</a>(rhs_nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; lhs_node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; rhs_node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs_node <a href="CppOperatorEqual.htm">==</a> *rhs_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Compare edges<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; lhs_edges <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; rhs_edges <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs_edges.size() <a href="CppOperatorNotEqual.htm">!=</a> rhs_edges.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEqual.htm">std::equal</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBegin.htm">std::begin</a>(lhs_edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEnd.htm">std::end</a>(&nbsp;&nbsp;lhs_edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBegin.htm">std::begin</a>(rhs_edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; lhs_edge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; rhs_edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs_edge <a href="CppOperatorEqual.htm">==</a> *rhs_edge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternode.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCENTERNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCENTERNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>The focal <a href="CppQuestion.htm">question</a> of a ConceptMap<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> Every ConceptMap usually has one CenterNode<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> Every sub concept-map has none or one CenterNode<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;(a sub concet-map has a focal node instead)<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNode : <b><a href="CppPublic.htm">public</a></b> Node<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;~CenterNode() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(CenterNode* x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">construct</a>ion, except <b><a href="CppFor.htm">for</a></b> NodeFactory<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppStruct.htm">struct</a></b> CenterNodeFactory;<br/>
&nbsp;&nbsp;CenterNode() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppExplicit.htm">explicit</a></b> CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0);<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>Returns <b><a href="CppTrue.htm">true</a></b> <b><a href="CppIf.htm">if</a></b> Node is of derived <b><a href="CppClass.htm">class</a></b> type CenterNode<br/>
<a href="CppComment.htm">///</a>Returns <b><a href="CppTrue.htm">true</a></b> <b><a href="CppIf.htm">if</a></b> Node is Node<br/>
<b><a href="CppBool.htm">bool</a></b> IsCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCENTERNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternode.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::CenterNode::CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
&nbsp;&nbsp;: Node(concept,x,y)<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::IsCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(node).get();<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternodefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternodefactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCENTERNODEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCENTERNODEFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNodeFactory<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; examples <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;&amp; node);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCENTERNODEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternodefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternodefactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::CenterNode&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> cmap::CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept,x,y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*concept <a href="CppOperatorEqual.htm">==</a> *node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::CenterNode&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory::Create(name,examples),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::CenterNode&gt;&amp; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; new_concept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptFactory::DeepCopy(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_concept);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node-&gt;GetConcept() <a href="CppOperatorEqual.htm">==</a> *new_concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::CenterNode&gt; new_node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(new_concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetX(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node <a href="CppOperatorEqual.htm">==</a> *new_node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> new_node;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommand.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommand.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMAND_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMAND_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Command can be used to <b><a href="CppDo.htm">do</a></b> and undo commands to a concept map <a href="CppWidget.htm">Widget</a><br/>
<a href="CppComment.htm">///</a>Command must use a <a href="CppWidget.htm">Widget</a>* because a <a href="CppWidget.htm">Widget</a> will call a Command with <b><a href="CppThis.htm">this</a></b>:<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;some_command-&gt;CanDo(<b><a href="CppThis.htm">this</a></b>);<br/>
<a href="CppComment.htm">///</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Command() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> CanDoCommand(<a href="CppWidget.htm">widget</a>.get()); }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommand(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> { DoCommand(<a href="CppWidget.htm">widget</a>.get()); }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Hook<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Hook<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
};<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMAND_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommand.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommand.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">//</a>Don't include ConceptMap, use <a href="CppWidget.htm">Widget</a> its mostly-<b><a href="CppPrivate.htm">private</a></b>-except-<b><a href="CppFor.htm">for</a></b>-Command <a href="CppInterface.htm">interface</a> only<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command::CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CanDoCommandSpecific(<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command::DoCommand(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(<a href="CppWidget.htm">widget</a>));<br/>
&nbsp;&nbsp;DoCommandSpecific(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>2; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;DoCommandSpecific(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewconceptmap.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewconceptmap.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDCREATENEWCONCEPTMAP_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDCREATENEWCONCEPTMAP_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Start a <b><a href="CppNew.htm">new</a></b> concept map<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is no existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandCreateNewConceptMap : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandCreateNewConceptMap() : m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandCreateNewConceptMap(<b><a href="CppConst.htm">const</a></b> CommandCreateNewConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandCreateNewConceptMap&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandCreateNewConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandCreateNewConceptMap() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "create <b><a href="CppNew.htm">new</a></b> concept map"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDCREATENEWCONCEPTMAP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewconceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewconceptmap.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewconceptmap.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewConceptMap::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewConceptMap::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; new_map {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create("...")<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_map);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(new_map);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewConceptMap::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; empty_map;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(empty_map);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewnode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewnode.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDCREATENEWNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDCREATENEWNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Start a <b><a href="CppNew.htm">new</a></b> node<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is an existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandCreateNewNode : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandCreateNewNode() : m_node{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandCreateNewNode(<b><a href="CppConst.htm">const</a></b> CommandCreateNewNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandCreateNewNode&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandCreateNewNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandCreateNewNode() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "create <b><a href="CppNew.htm">new</a></b> node"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_node;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDCREATENEWNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewnode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewnode.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewnode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewNode::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewNode::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_node <a href="CppOperatorAssign.htm">=</a> m_<a href="CppWidget.htm">widget</a>-&gt;CreateNewNode();<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_node);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewNode::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;DeleteNode(m_node);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_node <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeleteconceptmap.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeleteconceptmap.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDDELETECONCEPTMAP_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDDELETECONCEPTMAP_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Delete a concept map<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is an existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandDeleteConceptMap : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandDeleteConceptMap() : m_deleted_concept_map{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandDeleteConceptMap(<b><a href="CppConst.htm">const</a></b> CommandDeleteConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandDeleteConceptMap&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandDeleteConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandDeleteConceptMap() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "<b><a href="CppDelete.htm">delete</a></b> concept map"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m_deleted_concept_map;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDDELETECONCEPTMAP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeleteconceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeleteconceptmap.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeleteconceptmap.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteConceptMap::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(m_<a href="CppWidget.htm">widget</a>) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(m_deleted_concept_map));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot <b><a href="CppDelete.htm">delete</a></b> a concept map, when<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> the command already has deleted one, so its internals are non-<b><a href="CppNullptr.htm">nullptr</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> the offered <a href="CppWidget.htm">widget</a> has no concept map<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteConceptMap::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommandSpecific(<a href="CppWidget.htm">widget</a>));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct pre state<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Before executing the command,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>CommandDeleteConceptMap its internals (m_<a href="CppWidget.htm">widget</a> and m_conceptmap)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>should both be <b><a href="CppNullptr.htm">nullptr</a></b><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Before deleting a <a href="CppWidget.htm">Widget</a> its ConceptMap,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"CommandDeleteConceptMap::m_<a href="CppWidget.htm">widget</a> must be <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_deleted_concept_map);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_deleted_concept_map <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(m);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct post state<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_deleted_concept_map);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteConceptMap::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct pre state<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_deleted_concept_map);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(m_deleted_concept_map);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; empty_map;<br/>
&nbsp;&nbsp;m_deleted_concept_map <a href="CppOperatorAssign.htm">=</a> empty_map;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct post state<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_deleted_concept_map);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandfactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>CommandFactory creates Commands<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandFactory<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; &gt; CreateTestCommands() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandfactory.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeleteconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandlosefocus.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocusrandom.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocuswithcoordinat.h"<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::CommandFactory::CreateTestCommands() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; &gt; v;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewConceptMap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandDeleteConceptMap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandLoseFocus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandSetFocusRandom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandSetFocusWithCoordinat(0,0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandDeleteNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandlosefocus.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandlosefocus.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDLOSEFOCUS_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDLOSEFOCUS_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Lose focus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> opposite of SetFocus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandLoseFocus : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandLoseFocus() : m_old_focus{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandLoseFocus(<b><a href="CppConst.htm">const</a></b> CommandLoseFocus&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandLoseFocus&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandLoseFocus&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandLoseFocus() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "lose focus"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;Node * m_old_focus;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDLOSEFOCUS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandlosefocus.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandlosefocus.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandlosefocus.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandLoseFocus::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetFocus();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandLoseFocus::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> command<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;m_focus;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandLoseFocus::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> command<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> m_old_focus;<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_old_focus);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocusrandom.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocusrandom.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSRANDOM_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSRANDOM_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Set focus with a coordinat<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> opposite of LoseFocus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> SetFocus does not care <b><a href="CppIf.htm">if</a></b> there currently is something in focus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandSetFocusRandom : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandSetFocusRandom() : m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandSetFocusRandom(<b><a href="CppConst.htm">const</a></b> CommandSetFocusRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandSetFocusRandom&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandSetFocusRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandSetFocusRandom() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "set focus random"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSRANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocusrandom.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocusrandom.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocusrandom.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusRandom::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalOr.htm">||</a> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The concept map must contain at least one node<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusRandom::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetRandomNode().get();<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusRandom::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Lose focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorLogicalOr.htm">||</a> m_<a href="CppWidget.htm">widget</a>-&gt;m_focus); <a href="CppComment.htm">//</a>Might have restored previous focus<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSWITHCOORDINAT_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSWITHCOORDINAT_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Set focus with a coordinat<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> opposite of LoseFocus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> SetFocus does not care <b><a href="CppIf.htm">if</a></b> there currently is something in focus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandSetFocusWithCoordinat : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandSetFocusWithCoordinat(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: m_<a href="CppWidget.htm">widget</a>{}, m_x(x), m_y(y) {}<br/>
&nbsp;&nbsp;CommandSetFocusWithCoordinat(<b><a href="CppConst.htm">const</a></b> CommandSetFocusWithCoordinat&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandSetFocusWithCoordinat&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandSetFocusWithCoordinat&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandSetFocusWithCoordinat() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "set focus with coordinat"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_x;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_y;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSWITHCOORDINAT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocuswithcoordinat.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusWithCoordinat::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;FindNodeAt(m_x,m_y).get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusWithCoordinat::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;FindNodeAt(m_x,m_y).get();<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusWithCoordinat::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Lose focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorLogicalOr.htm">||</a> m_<a href="CppWidget.htm">widget</a>-&gt;m_focus); <a href="CppComment.htm">//</a><a href="CppWidget.htm">Widget</a> might have had focus<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcompetency.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcompetency.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMPETENCY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMPETENCY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Competency<br/>
{<br/>
&nbsp;&nbsp;un<a href="CppInitialize.htm">initialize</a>d <a href="CppOperatorAssign.htm">=</a> 0,&nbsp;&nbsp; <a href="CppComment.htm">//</a>Not yet set<br/>
&nbsp;&nbsp;profession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>NL: 'Beroepsdomein'<br/>
&nbsp;&nbsp;organisations,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>NL: 'Organisaties'<br/>
&nbsp;&nbsp;social_surroundings, <a href="CppComment.htm">//</a>NL: 'Sociale omgeving'<br/>
&nbsp;&nbsp;target_audience,&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>NL 'Doelgroep'<br/>
&nbsp;&nbsp;ti_knowledge,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'Technical Instrumental', NL: 'Technische instrumentele kennis'<br/>
&nbsp;&nbsp;prof_growth,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Professionele groei<br/>
&nbsp;&nbsp;misc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>NL: 'Overig'<br/>
};<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;Competency&gt; GetAllCompetencies();<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> CompetencyToDutchStr(<b><a href="CppConst.htm">const</a></b> Competency competency);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMPETENCY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcompetency.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcompetency.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Competency&gt; <a href="CppRibi.htm">ribi</a>::cmap::GetAllCompetencies()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::profession,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::organisations,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::social_surroundings,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::target_audience,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::ti_knowledge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::prof_growth,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::misc<br/>
&nbsp;&nbsp;};<br/>
<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::CompetencyToDutchStr(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency type)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d: <b><a href="CppReturn.htm">return</a></b> "[Ongeinitialiseerd]";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::profession: <b><a href="CppReturn.htm">return</a></b> "Kennis van het beroepsdomein";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::organisations: <b><a href="CppReturn.htm">return</a></b> "Kennis van de organisatie";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::social_surroundings: <b><a href="CppReturn.htm">return</a></b> "Kennis van de sociale omgeving";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::target_audience: <b><a href="CppReturn.htm">return</a></b> "Kennis van de doelgroep";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::ti_knowledge: <b><a href="CppReturn.htm">return</a></b> "Technisch instrumentele kennis";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::prof_growth: <b><a href="CppReturn.htm">return</a></b> "Kennis van de eigen persoon";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competency::misc: <b><a href="CppReturn.htm">return</a></b> "Overige";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppLogic_error.htm">std::logic_error</a>("Unknown <a href="CppRibi.htm">ribi</a>::cmap::Competency");<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconcept.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconcept.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPT_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPT_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A Concept is a <b><a href="CppClass.htm">class</a></b> that has a name and examples<br/>
<b><a href="CppStruct.htm">struct</a></b> Concept<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block copying, as <b><a href="CppQtSignals.htm">signals</a></b> cannot be copied<br/>
&nbsp;&nbsp;Concept(<b><a href="CppConst.htm">const</a></b> Concept&amp; other) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Concept&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Concept&amp; other) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Read concept from a <a href="CppString.htm">std::string</a> read from file<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the examples of the concept, e.g. 'Plato', 'Aristotle'<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; GetExamples() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; GetExamples() { <b><a href="CppReturn.htm">return</a></b> m_examples; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated the name of <b><a href="CppThis.htm">this</a></b> concept as being an addition to the complexity?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is something different than m_rating_complexity:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_is_complex can be used to help the assessor determine a m_rating_complexity,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/but m_rating_complexity is the <b><a href="CppFinal.htm">final</a></b> and complete rating<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsComplex() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_complex; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the name of the concept, e.g. 'Philosphy'<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; GetName() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_name; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> complexity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetRatingComplexity() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_rating_complexity; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> concreteness<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetRatingConcreteness() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_rating_concreteness; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> specificity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetRatingSpecificity() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_rating_specificity; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated the name of <b><a href="CppThis.htm">this</a></b> concept as being an addition to the complexity?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is something different than m_rating_complexity:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_is_complex can be used to help the assessor determine a m_rating_complexity,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/but m_rating_complexity is the <b><a href="CppFinal.htm">final</a></b> and complete rating<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsComplex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex) { m_is_complex <a href="CppOperatorAssign.htm">=</a> is_complex; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the examples are changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Concept*)&gt; m_signal_examples_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the name is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Concept*)&gt; m_signal_name_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the rating of the complexity is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Concept*)&gt; m_signal_rating_complexity_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the rating of the complexity is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Concept*)&gt; m_signal_rating_concreteness_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the rating of the specificity is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Concept*)&gt; m_signal_rating_specificity_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> Concept to a <a href="CppString.htm">std::string</a> to write to file<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; t);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>ConceptMapConceptEditDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>ConceptMapDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>RateConceptDialogNewName;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>ConceptMapTestConceptItemDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>ConceptMapTestEdgeItemDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>ConceptMapTestNodeItemDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>Edge;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>Node;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>RateExamplesDialogNewName;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>StudentMenuDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>TestEditConceptMapDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>TestRateConceptMapDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>TestEdgeItemDialog;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppQt.htm">Qt</a>TestNodeItemDialog;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the examples<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetExamples(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; examples);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the name<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetName(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> complexity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRatingComplexity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> concreteness<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRatingConcreteness(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> specificity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRatingSpecificity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Examples of the concept, e.g. 'Plato', 'Aristotle'<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; m_examples;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated the name of <b><a href="CppThis.htm">this</a></b> concept as being an addition to the complexity?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is something different than m_rating_complexity:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_is_complex can be used to help the assessor determine a m_rating_complexity,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/but m_rating_complexity is the <b><a href="CppFinal.htm">final</a></b> and complete rating<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_complex;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The name of the concept, e.g. 'Philosphy'<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a> m_name;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> complexity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_rating_complexity;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> concreteness<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_rating_concreteness;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> specificity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_rating_specificity;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use checked_delete <b><a href="CppFor.htm">for</a></b> <a href="CppDestructor.htm">destructor</a><br/>
&nbsp;&nbsp;~Concept() {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Concept* x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Let only ConceptFactory <a href="CppConstructor.htm">construct</a> Concepts<br/>
&nbsp;&nbsp;Concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> ConceptFactory;<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> Concept&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> Concept&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">///</a>Two Concept <a href="CppInstance.htm">instances</a> are ordered as follows:<br/>
<a href="CppComment.htm">///</a>(1) Alphabetically on the name<br/>
<a href="CppComment.htm">///</a>(2) (<b><a href="CppIf.htm">if</a></b> the names are equal) On their Examples<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> Concept&amp; rhs);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconcept.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconcept.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Concept::Concept(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity)<br/>
&nbsp;&nbsp;: m_signal_examples_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_name_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_complexity_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_concreteness_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_specificity_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_examples{examples},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_complex{is_complex},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_name{name},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_complexity{rating_complexity},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_concreteness{rating_concreteness},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_specificity{rating_specificity}<br/>
<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity&nbsp;&nbsp; <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity&nbsp;&nbsp; <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity&nbsp;&nbsp;<a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::Concept::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 19);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,9) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;concept&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/concept&gt;"));<br/>
<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a> name;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; examples;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rating_complexity&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2; <a href="CppComment.htm">//</a>Not even unrated (which has <a href="CppOperatorMinus.htm">-</a>1 as its value)<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rating_concreteness&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2; <a href="CppComment.htm">//</a>Not even unrated (which has <a href="CppOperatorMinus.htm">-</a>1 as its value)<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rating_specificity&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2; <a href="CppComment.htm">//</a>Not even unrated (which has <a href="CppOperatorMinus.htm">-</a>1 as its value)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_name<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;name&gt;.*&lt;/name&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;name <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_examples<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;examples&gt;.*&lt;/examples&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "&lt;examples&gt;*.&lt;/examples&gt; must be present once in a Concept");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;examples <a href="CppOperatorAssign.htm">=</a> Examples::From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_is_complex<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;concept_is_complex&gt;.*&lt;/concept_is_complex&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "(&lt;is_complex&gt;.*&lt;/is_complex&gt;) must be present once per Concept");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_complex <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_rating_complexity<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;complexity&gt;.*&lt;/complexity&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "(&lt;complexity&gt;.*&lt;/complexity&gt;) must be present once per Concept");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_complexity <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_rating_concreteness<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;concreteness&gt;.*&lt;/concreteness&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_concreteness <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_rating_specificity<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;specificity&gt;.*&lt;/specificity&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_specificity <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ConceptFactory::Create(name,examples,is_complex,rating_complexity,rating_concreteness,rating_specificity);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::Concept::GetExamples() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_examples);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt; p(m_examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetExamples(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt;&amp; examples)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (examples <a href="CppOperatorNotEqual.htm">!=</a> m_examples)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_examples <a href="CppOperatorAssign.htm">=</a> examples;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_examples_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetName(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;GetExamples());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (name <a href="CppOperatorNotEqual.htm">!=</a> m_name)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_name <a href="CppOperatorAssign.htm">=</a> name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_name_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetRatingComplexity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_rating_complexity <a href="CppOperatorNotEqual.htm">!=</a> rating_complexity)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_complexity <a href="CppOperatorAssign.htm">=</a> rating_complexity;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_complexity_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetRatingConcreteness(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_rating_concreteness <a href="CppOperatorNotEqual.htm">!=</a> rating_concreteness)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_concreteness <a href="CppOperatorAssign.htm">=</a> rating_concreteness;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_concreteness_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetRatingSpecificity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_rating_specificity <a href="CppOperatorNotEqual.htm">!=</a> rating_specificity)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_specificity <a href="CppOperatorAssign.htm">=</a> rating_specificity;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_specificity_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Concept::To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; &amp;c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;concept&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;name&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetName();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/name&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; Examples::To<a href="CppXml.htm">Xml</a>(c-&gt;GetExamples());<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;concept_is_complex&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetIsComplex();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/concept_is_complex&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;complexity&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetRatingComplexity();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/complexity&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;concreteness&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetRatingConcreteness();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/concreteness&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;specificity&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetRatingSpecificity();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/specificity&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/concept&gt;";<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 19);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,9) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;concept&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/concept&gt;"));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt; lhs_examples <a href="CppOperatorAssign.htm">=</a> lhs.GetExamples();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs_examples);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt; rhs_examples <a href="CppOperatorAssign.htm">=</a> rhs.GetExamples();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs_examples);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lhs_examples&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> *rhs_examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetIsComplex()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> rhs.GetIsComplex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetName()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetRatingComplexity()&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetRatingComplexity()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetRatingConcreteness() <a href="CppOperatorEqual.htm">==</a> rhs.GetRatingConcreteness()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetRatingSpecificity()&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> rhs.GetRatingSpecificity();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetName() &lt; rhs.GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetName() &gt; rhs.GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetExamples() &lt; *rhs.GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetExamples() <a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*lhs.GetExamples() <a href="CppOperatorEqual.htm">==</a> *rhs.GetExamples());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingComplexity() &lt; rhs.GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingComplexity() &gt; rhs.GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingConcreteness() &lt; rhs.GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingConcreteness() &gt; rhs.GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.GetRatingSpecificity() &lt; rhs.GetRatingSpecificity();<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetName() &lt; rhs-&gt;GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetName() &gt; rhs-&gt;GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetExamples() &lt; rhs-&gt;GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetExamples() <a href="CppOperatorNotEqual.htm">!=</a> rhs-&gt;GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs-&gt;GetExamples() <a href="CppOperatorEqual.htm">==</a> rhs-&gt;GetExamples());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingComplexity() &lt; rhs-&gt;GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingComplexity() &gt; rhs-&gt;GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingConcreteness() &lt; rhs-&gt;GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingConcreteness() &gt; rhs-&gt;GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs-&gt;GetRatingSpecificity() &lt; rhs-&gt;GetRatingSpecificity();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(lhs) &lt; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(lhs) &lt; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(lhs) &lt; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(rhs);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconceptfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconceptfactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPTFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPTFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppArrayH.htm">array</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppArray.htm">array</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Creates Concepts<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptFactory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Default and complete Create <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name <a href="CppOperatorAssign.htm">=</a> "...",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; examples <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Like a Concept deep-<a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; concept);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain some testing concepts<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; &gt; GetTests();<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPTFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconceptfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconceptfactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rating_specificity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(concept-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*examples <a href="CppOperatorEqual.htm">==</a> *concept-&gt;GetExamples());<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetName(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetIsComplex(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetRatingComplexity(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetRatingConcreteness(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetRatingSpecificity());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*concept <a href="CppOperatorEqual.htm">==</a> *q);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">//</a>Do not create <b><a href="CppThis.htm">this</a></b> <a href="CppVersion.htm">version</a>: it will lead to ambiguities<br/>
<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt;&amp; examples)<br/>
<a href="CppComment.htm">//</a>{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Create(name,ExamplesFactory::Create(examples));<br/>
<a href="CppComment.htm">//</a>}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; v,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt;&amp; p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.first,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(w);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_specificity);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::GetTests()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; &gt; v;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; examples <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept without examples", examples, <b><a href="CppFalse.htm">false</a></b>, 0, 1, 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with one example", { { "Only example", cmap::Competency::profession } }, 1, 2, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with two examples", { { "First example", cmap::Competency::organisations }, { "Second example", cmap::Competency::social_surroundings } }, 2, 0, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with three examples", { { "Example 1 of 3", cmap::Competency::target_audience }, { "Example 2 of 3", cmap::Competency::ti_knowledge }, { "Example 3 of 3", cmap::Competency::prof_growth } }, 0, 1, 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with four Roman examples", { { "Example I/IV", cmap::Competency::misc }, { "Example II/IV", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d }, { "Example III/IV", cmap::Competency::profession }, { "Example III/IV", cmap::Competency::social_surroundings } }, 1, 2, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Very <b><a href="CppLong.htm">long</a></b> multi-line concept with four Roman examples that also each span multiple lines, that is, eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example I/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::misc", cmap::Competency::misc },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example II/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example III/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::profession", cmap::Competency::profession },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example III/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::social_surroundings", cmap::Competency::social_surroundings }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 1, 2, 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount_if.htm">std::count_if</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> !p; } ) <a href="CppOperatorEqual.htm">==</a> 0); <a href="CppComment.htm">//</a>FIX 2012-01-02<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(<a href="CppAll_of.htm">std::all_of</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> p; } ));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[0]-&gt;GetExamples());<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedge.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedge.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEDGE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEDGE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapelement.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> EdgeFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>An Edge is the GUI-independent part of the edges used in <a href="CppQt.htm">Qt</a>ConceptMap.<br/>
<a href="CppComment.htm">///</a>An Edge goes from one Node to another, which must a different Node<br/>
<b><a href="CppStruct.htm">struct</a></b> Edge : <b><a href="CppPublic.htm">public</a></b> Element<br/>
{<br/>
&nbsp;&nbsp;Edge(<b><a href="CppConst.htm">const</a></b> Edge&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Edge&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Edge&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt; GetConcept() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_concept; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt; GetConcept()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <b><a href="CppReturn.htm">return</a></b> m_concept; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the Node <b><a href="CppThis.htm">this</a></b> edge originates from<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFrom() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_from; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetFrom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <b><a href="CppReturn.htm">return</a></b> m_from; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the Node index <b><a href="CppThis.htm">this</a></b> edge goes to<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetTo() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_to; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetTo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <b><a href="CppReturn.htm">return</a></b> m_to; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the x coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetX() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_x; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the y coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetY() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_y; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Does the edge have an arrow at the head?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> HasHeadArrow() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_head_arrow; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Similar to <b><a href="CppOperatorEqual.htm">operator==</a></b>, except that the coordinats are not checked<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> HasSameContent(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Does the edge have an arrow at the tail?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> HasTailArrow() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_tail_arrow; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the concept<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetConcept(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept) { m_concept <a href="CppOperatorAssign.htm">=</a> concept; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the Node index <b><a href="CppThis.htm">this</a></b> edge originates from<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetFrom(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set <b><a href="CppIf.htm">if</a></b> the head has an arrow<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetHeadArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_head_arrow);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the coordinat of the concept at the center of the node<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetPos(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) { SetX(x); SetY(y); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set <b><a href="CppIf.htm">if</a></b> the tail has an arrow<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetTailArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_tail_arrow);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the Node index <b><a href="CppThis.htm">this</a></b> edge goes to<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetTo(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the x coordinat of the concept at the center of the node<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the y coordinat of the concept at the center of the node<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> an Edge from an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The <a href="CppContainer.htm">container</a> of nodes is needed to <a href="CppConvert.htm">convert</a> the 'to' and 'from'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/field to indices<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt;&amp; nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when an Edge attribute has changed<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (<b><a href="CppConst.htm">const</a></b> Edge*)&gt; m_signal_edge_changed;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Concept on the Edge<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; m_concept;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Node index <b><a href="CppThis.htm">this</a></b> edge originates from<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Cannot be an index, see [1] below<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_from;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Is there an arrowhead at the 'to' node?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_head_arrow;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Is there an arrowhead at the 'from' node?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_tail_arrow;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Node index <b><a href="CppThis.htm">this</a></b> edge goes to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Cannot be an index, see [1] below<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_to;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The x-coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_x;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The y-coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_y;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged();<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;Edge() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;~Edge() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Edge* x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">constructor</a>, except <b><a href="CppFor.htm">for</a></b> EdgeFactory<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> EdgeFactory;<br/>
&nbsp;&nbsp;Edge(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; &amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow);<br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> IsConnectedToCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Notes:<br/>
/<a href="CppComment.htm">//</a> [1] Node::m_from and Node::m_to cannot be indices, because of the desired copying behavior<br/>
/<a href="CppComment.htm">//</a> of Edge: when copying an edge, it is natural that it keeps <a href="CppPointer.htm">point</a>ing to the same nodes.<br/>
/<a href="CppComment.htm">//</a> When <b><a href="CppUsing.htm">using</a></b> <a href="CppPointer.htm">pointer</a>s, <b><a href="CppThis.htm">this</a></b> will work. Indices, on the other hand, are context-specific:<br/>
/<a href="CppComment.htm">//</a> Example: imagine a concept map like <b><a href="CppThis.htm">this</a></b>:<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> NodeA Edge1 NodeB Edge2 NodeC<br/>
/<a href="CppComment.htm">//</a> [0] [1] [2]<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> In <b><a href="CppThis.htm">this</a></b> example, Edge2 goes from [1] to [2]<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> A sub-concept map will be (when NodeC is the focal node):<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> NodeB Edge2 NodeC<br/>
/<a href="CppComment.htm">//</a> [0] [1]<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> In <b><a href="CppThis.htm">this</a></b> example, Edge2 goes from [0] to [1]! Due to <b><a href="CppThis.htm">this</a></b>, the same Edge2 cannot behave identical in the different contexts<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Indices are only used when saving and loading<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEDGE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedge.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedge.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Edge::Edge(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; &amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow)<br/>
&nbsp;&nbsp;: m_signal_edge_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_concept(concept),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_from(from),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_head_arrow(head_arrow),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_tail_arrow(tail_arrow),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_to(to),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x(concept_x),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y(concept_y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_concept);<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Subscribe to all Concept <b><a href="CppQtSignals.htm">signals</a></b> to re-<b><a href="CppEmit.htm">emit</a></b> m_signal_edge_changed<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_name_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_examples_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_complexity_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_concreteness_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_specificity_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged()<br/>
{<br/>
&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetFrom(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_from <a href="CppOperatorNotEqual.htm">!=</a> from)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_from <a href="CppOperatorAssign.htm">=</a> from;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetHeadArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_head_arrow)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_head_arrow <a href="CppOperatorNotEqual.htm">!=</a> has_head_arrow)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_head_arrow <a href="CppOperatorAssign.htm">=</a> has_head_arrow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetTailArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_tail_arrow)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_tail_arrow <a href="CppOperatorNotEqual.htm">!=</a> has_tail_arrow)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_tail_arrow <a href="CppOperatorAssign.htm">=</a> has_tail_arrow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetTo(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_to <a href="CppOperatorNotEqual.htm">!=</a> to)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_to <a href="CppOperatorAssign.htm">=</a> to;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_x <a href="CppOperatorNotEqual.htm">!=</a> x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_y <a href="CppOperatorNotEqual.htm">!=</a> y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test member variables<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Edge::Test");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nodes <a href="CppOperatorAssign.htm">=</a> Node::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(nodes.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_from <a href="CppOperatorAssign.htm">=</a> nodes[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_to&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> nodes[1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge: EdgeFactory::GetTests(node_from,node_to))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; c <a href="CppOperatorAssign.htm">=</a> cmap::EdgeFactory::DeepCopy(edge,node_from,node_to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*edge <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> *node_from);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> *nodes[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> *node_to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> *nodes[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> To<a href="CppXml.htm">Xml</a>(c,<a href="CppAdd.htm">Add</a>Const(nodes));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; d <a href="CppOperatorAssign.htm">=</a> cmap::EdgeFactory::From<a href="CppXml.htm">Xml</a>(s,nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*c <a href="CppOperatorNotEqual.htm">!=</a> *d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(To<a href="CppXml.htm">Xml</a>(c,<a href="CppAdd.htm">Add</a>Const(nodes)));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(To<a href="CppXml.htm">Xml</a>(d,<a href="CppAdd.htm">Add</a>Const(nodes)));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Edge::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Edge::To<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt;&amp; nodes)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;edge&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Concept::To<a href="CppXml.htm">Xml</a>(edge-&gt;GetConcept());<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetTo());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> from_index <a href="CppOperatorAssign.htm">=</a> <a href="CppDistance.htm">std::distance</a>(nodes.begin(),from_iter);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> to_index <a href="CppOperatorAssign.htm">=</a> <a href="CppDistance.htm">std::distance</a>(nodes.begin(),to_iter);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index &lt; <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_index &lt; <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index <a href="CppOperatorNotEqual.htm">!=</a> to_index);<br/>
<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;from&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> from_index <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/from&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;head_arrow&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;HasHeadArrow() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/head_arrow&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;tail_arrow&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;HasTailArrow() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/tail_arrow&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;to&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> to_index <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/to&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;x&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/x&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;y&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/y&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/edge&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,6) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;edge&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/edge&gt;"));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::IsConnectedToCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(IsCenterNode(edge-&gt;GetFrom()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> IsCenterNode(edge-&gt;GetTo()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "An Edge cannot be connected to two CenterNodes");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsCenterNode(edge-&gt;GetFrom()) <a href="CppOperatorLogicalOr.htm">||</a> IsCenterNode(edge-&gt;GetTo());<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetConcept()); <a href="CppAssert.htm">assert</a>(rhs.GetConcept());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetConcept()&nbsp;&nbsp; <a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetConcept()) <a href="CppTRACE.htm">TRACE</a>("Concept differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetFrom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetFrom()) <a href="CppTRACE.htm">TRACE</a>("From node differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetTo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetTo()) <a href="CppTRACE.htm">TRACE</a>("To node differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( lhs.GetX()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetX()) <a href="CppTRACE.htm">TRACE</a>("X differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( lhs.GetY()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetY()) <a href="CppTRACE.htm">TRACE</a>("Y differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( lhs.HasHeadArrow() <a href="CppOperatorNotEqual.htm">!=</a> rhs.HasHeadArrow()) <a href="CppTRACE.htm">TRACE</a>("Has head arrow differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( lhs.HasTailArrow() <a href="CppOperatorNotEqual.htm">!=</a> rhs.HasTailArrow()) <a href="CppTRACE.htm">TRACE</a>("Has tail arrow differs");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *lhs.GetConcept()&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> *rhs.GetConcept()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *lhs.GetFrom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> *rhs.GetFrom()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *lhs.GetTo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> *rhs.GetTo()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.GetX()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.GetY()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.HasHeadArrow() <a href="CppOperatorEqual.htm">==</a> rhs.HasHeadArrow()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.HasTailArrow() <a href="CppOperatorEqual.htm">==</a> rhs.HasTailArrow();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Edge&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedgefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedgefactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEDGEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEDGEFACTORY_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> EdgeFactory<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The nodes need to be the deepcopied ones<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain an Edge from an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/You need the real nodes to connect the edge to<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; From<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get testing edges connecting the two supplied nodes<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt; GetTests(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to);<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEDGEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedgefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedgefactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; p(<b><a href="CppNew.htm">new</a></b> Edge(concept,concept_x,concept_y,from,tail_arrow,to,head_arrow));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetConcept()-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::DeepCopy(edge-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; p <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetX(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetY(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;HasTailArrow(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;HasHeadArrow()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*edge <a href="CppOperatorEqual.htm">==</a> *p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::From<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,6) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;edge&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/edge&gt;"));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;concept&gt;.*&lt;/concept&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept <a href="CppOperatorAssign.htm">=</a> Concept::From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_from<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> from <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;from&gt;.*&lt;/from&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;from <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_head_arrow<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> head_arrow <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;head_arrow&gt;.*&lt;/head_arrow&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;head_arrow <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_tail_arrow<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> tail_arrow <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;tail_arrow&gt;.*&lt;/tail_arrow&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tail_arrow <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_to<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> to <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;to&gt;.*&lt;/to&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;to <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;x&gt;.*&lt;/x&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_y<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;y&gt;.*&lt;/y&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from &lt; <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to&nbsp;&nbsp; &lt; <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,x,y,nodes[from],tail_arrow,nodes[to],head_arrow));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::GetTests(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> test_concepts <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests();<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; result;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept: test_concepts)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,1.2,3.4,from,<b><a href="CppFalse.htm">false</a></b>,to,<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,0,2,<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,0,3,<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,1,2,<b><a href="CppFalse.htm">false</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,1,3,<b><a href="CppFalse.htm">false</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,2,3,<b><a href="CppFalse.htm">false</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapelement.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapelement.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPELEMENT_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPELEMENT_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>A focusable element of a concept map, which is either a Node or an Edge<br/>
<b><a href="CppStruct.htm">struct</a></b> Element<br/>
{<br/>
&nbsp;&nbsp;Element() {}<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Element() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPELEMENT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapelement.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapelement.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapelement.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexample.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexample.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ExampleFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A concept (on a node or an edge) can have examples<br/>
<b><a href="CppStruct.htm">struct</a></b> Example<br/>
{<br/>
&nbsp;&nbsp;Example(<b><a href="CppConst.htm">const</a></b> Example&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Example&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Example&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a cmap::Competency to a <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> CompetencyToStr(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an example from <a href="CppXml.htm">XML</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the competency, as might be judged by an assessor<br/>
&nbsp;&nbsp;cmap::Competency GetCompetency() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_competency; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the complexity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsComplex() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_complex; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the concreteness?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsConcrete() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_concrete; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the specificity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsSpecific() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_specific; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the text of the example<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; GetText() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_text; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the competency<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetCompetency(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the complexity?<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsComplex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex) { m_is_complex <a href="CppOperatorAssign.htm">=</a> is_complex; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the concreteness?<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsConcrete(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete) { m_is_concrete <a href="CppOperatorAssign.htm">=</a> is_concrete; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the specificity?<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsSpecific(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific) { m_is_specific <a href="CppOperatorAssign.htm">=</a> is_specific; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the text<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetText(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; text);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a <a href="CppString.htm">std::string</a> to a cmap::Competency<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> cmap::Competency StrToCompetency(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> Example to a <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; t);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when SetCompetency changes the competency<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_competency_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when SetText changes the text<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_text_changed;<br/>
<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The competency, as might be judged by an assessor<br/>
&nbsp;&nbsp;cmap::Competency m_competency;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the complexity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_complex;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the concreteness?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_concrete;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the specificity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_specific;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The text of the example<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/For example: 'Plato', 'When I was a kid', 'As I did on holiday'<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a> m_text;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the competency with a string<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetCompetencyAsStr(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use checked_delete only<br/>
&nbsp;&nbsp;~Example() {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Example* x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Only let ExampleFactory create Example <a href="CppInstance.htm">instances</a><br/>
&nbsp;&nbsp;Example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency competency <a href="CppOperatorAssign.htm">=</a> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> ExampleFactory;<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexample.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexample.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Example::Example(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency competency,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_signal_competency_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_text_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_competency(competency),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_complex(is_complex),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_concrete(is_concrete),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_specific(is_specific),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_text(text)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::CompetencyToStr(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (competency)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d: <b><a href="CppReturn.htm">return</a></b> "un<a href="CppInitialize.htm">initialize</a>d";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::profession: <b><a href="CppReturn.htm">return</a></b> "profession";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::organisations: <b><a href="CppReturn.htm">return</a></b> "organisations";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::social_surroundings: <b><a href="CppReturn.htm">return</a></b> "social_surroundings";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::target_audience: <b><a href="CppReturn.htm">return</a></b> "target_audience";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::ti_knowledge: <b><a href="CppReturn.htm">return</a></b> "ti_knowledge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::prof_growth: <b><a href="CppReturn.htm">return</a></b> "prof_growth";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::misc: <b><a href="CppReturn.htm">return</a></b> "misc";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppLogic_error.htm">std::logic_error</a>("<a href="CppRibi.htm">ribi</a>::cmap::Example::CompetencyToStr: unknown Competency");<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example&gt; <a href="CppRibi.htm">ribi</a>::cmap::Example::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 17);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,9) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;example&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/example&gt;"));<br/>
<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a> text;<br/>
&nbsp;&nbsp;cmap::Competency competency <a href="CppOperatorAssign.htm">=</a> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_concrete <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_specific <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>competency<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;competency&gt;.*&lt;/competency&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;competency <a href="CppOperatorAssign.htm">=</a> StrToCompetency(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>is_complex<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;is_complex&gt;.*&lt;/is_complex&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_complex <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>is_concrete<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;is_concrete&gt;.*&lt;/is_concrete&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_concrete <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>is_specific<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;is_specific&gt;.*&lt;/is_specific&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_specific <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>text<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;text&gt;.*&lt;/text&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "&lt;text&gt;.*&lt;/text&gt; must be present once in an Example");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;text <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> cmap::ExampleFactory::Create(text,competency,is_complex,is_concrete,is_specific);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetCompetency(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_competency <a href="CppOperatorNotEqual.htm">!=</a> competency)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_competency <a href="CppOperatorAssign.htm">=</a> competency;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_competency_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetText(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; text)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_text <a href="CppOperatorNotEqual.htm">!=</a> text)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_text <a href="CppOperatorAssign.htm">=</a> text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_text_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Competency <a href="CppRibi.htm">ribi</a>::cmap::Example::StrToCompetency(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "un<a href="CppInitialize.htm">initialize</a>d") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "profession") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::profession;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "organisations") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::organisations;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "social_surroundings") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::social_surroundings;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "target_audience") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::target_audience;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "ti_knowledge") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::ti_knowledge;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "prof_growth") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::prof_growth;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "misc") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::misc;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppLogic_error.htm">std::logic_error</a>("<a href="CppRibi.htm">ribi</a>::cmap::Example::StrToCompetency: unknown string");<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Starting <a href="CppRibi.htm">ribi</a>::cmap::Example::Test");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test of <b><a href="CppOperatorEqual.htm">operator==</a></b> and <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(cmap::ExampleFactory::GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; a <a href="CppOperatorAssign.htm">=</a> cmap::ExampleFactory::GetTests().at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example&gt; b <a href="CppOperatorAssign.htm">=</a> cmap::ExampleFactory::GetTests().at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; c <a href="CppOperatorAssign.htm">=</a> cmap::ExampleFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example&gt; d <a href="CppOperatorAssign.htm">=</a> cmap::ExampleFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*d,*c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*d,*d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*c)); <a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*c)); <a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*a)); <a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*d,*a)); <a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*d,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*c)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*c)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*a)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*d,*a)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*d,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> unrated and rated examples are noticed as different<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; a <a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; b <a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; c <a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create("1",Competency::un<a href="CppInitialize.htm">initialize</a>d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( <b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*a)); <a href="CppAssert.htm">assert</a>( <b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*b)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*a,*c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( <b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*a)); <a href="CppAssert.htm">assert</a>( <b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*b)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*b,*c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*a)); <a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*b)); <a href="CppAssert.htm">assert</a>( <b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*c));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> between <a href="CppString.htm">std::string</a> and competency<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;Competency&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::profession,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::organisations,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::social_surroundings,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::target_audience,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::ti_knowledge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::prof_growth,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::misc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> cmap::Competency&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::CompetencyToStr(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;Competency&gt; x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(w.begin(),w.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(x),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::StrToCompetency(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> between <b><a href="CppClass.htm">class</a></b> and <a href="CppXml.htm">XML</a>, test <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(<a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::To<a href="CppXml.htm">Xml</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; f(Example::From<a href="CppXml.htm">Xml</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*e,*f));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(<a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; e <a href="CppOperatorAssign.htm">=</a> v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::To<a href="CppXml.htm">Xml</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; f <a href="CppOperatorAssign.htm">=</a> v[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::To<a href="CppXml.htm">Xml</a>(f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*e,*f));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorEqual.htm">==</a> t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*e,*f));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorNotEqual.htm">!=</a> t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Example::Test finished successfully");<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;example&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;text&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetText();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/text&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;competency&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; CompetencyToStr(c-&gt;GetCompetency());<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/competency&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;is_complex&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetIsComplex();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/is_complex&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;is_concrete&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetIsConcrete();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/is_concrete&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;is_specific&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; c-&gt;GetIsSpecific();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/is_specific&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/example&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 17);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,9) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;example&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/example&gt;"));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetText() <a href="CppOperatorEqual.htm">==</a> rhs.GetText()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetCompetency() <a href="CppOperatorEqual.htm">==</a> rhs.GetCompetency();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rhs);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetText() &lt; rhs-&gt;GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetText() &gt; rhs-&gt;GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs-&gt;GetCompetency() &lt; rhs-&gt;GetCompetency();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rhs);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetText() &gt; rhs-&gt;GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetText() &lt; rhs-&gt;GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs-&gt;GetCompetency() &gt; rhs-&gt;GetCompetency();<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplefactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLEFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ExampleFactory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an example from string and <b><a href="CppEnum.htm">enum</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency&amp; competency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,&nbsp;&nbsp; <a href="CppComment.htm">//</a>DEFAULT<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,&nbsp;&nbsp;<a href="CppComment.htm">//</a>DEFAULT<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>); <a href="CppComment.htm">//</a>DEFAULT<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create examples <b><a href="CppFor.htm">for</a></b> strings<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Note that all cmap::Competency values are set to un<a href="CppInitialize.htm">initialize</a>d<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; CreateExamples(<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; GetTests();<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplefactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency&amp; competency,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;competency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_concrete,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_specific<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> example;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::GetTests()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 0",Competency::profession),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 1",Competency::organisations),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 2",Competency::social_surroundings),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 3",Competency::target_audience),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 4",Competency::ti_knowledge),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 5",Competency::prof_growth),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 6",Competency::misc),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("",Competency::un<a href="CppInitialize.htm">initialize</a>d),<br/>
&nbsp;&nbsp;};<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamples.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamples.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLES_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLES_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppContainer.htm">Container</a> of Example <a href="CppInstance.htm">instances</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Examples<br/>
{<br/>
&nbsp;&nbsp;Examples(<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v);<br/>
&nbsp;&nbsp;Examples(<b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Examples&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; &gt;&amp; Get() { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; Get() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; &amp;c);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Something of one of the examples was changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Examples*)&gt; m_signal_examples_changed;<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;~Examples() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; &gt; m_v;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; example);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/All <b><a href="CppQtSignals.htm">signals</a></b> <a href="CppEmit.htm">emitted</a> from the examples are connected to <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> OnExampleChanged();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Correct <a href="CppFriend.htm">befriending</a>, from http://richelbilderbeek.nl/CppChecked_delete.htm<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Examples* x);<br/>
};<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> Examples&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> Examples&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">///</a>Two cmap::Examples <a href="CppInstance.htm">instances</a> are sorted as follows:<br/>
<a href="CppComment.htm">///</a>(1) By their number of examples<br/>
<a href="CppComment.htm">///</a>(2) (<b><a href="CppIf.htm">if</a></b> the sizes are equal) Alphabetically on the first different example<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> Examples&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamples.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamples.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/bind.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/lambda/lambda.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Examples::Examples(<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v)<br/>
&nbsp;&nbsp;: m_signal_examples_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v(v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(m_v.begin(),m_v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; example)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_competency_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;Examples::OnExampleChanged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_text_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;Examples::OnExampleChanged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount_if.htm">std::count_if</a>(m_v.begin(),m_v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; e) { <b><a href="CppReturn.htm">return</a></b> !e; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) <a href="CppOperatorEqual.htm">==</a> 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "All Example <a href="CppInstance.htm">instances</a> must be <a href="CppInitialize.htm">initialize</a>d");<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples::<a href="CppAdd.htm">Add</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; example)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Connect the example<br/>
&nbsp;&nbsp;example-&gt;m_signal_competency_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;Examples::OnExampleChanged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;example-&gt;m_signal_text_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBind.htm">boost::bind</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;Examples::OnExampleChanged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> the example and notify <b><a href="CppThis.htm">this</a></b> change<br/>
&nbsp;&nbsp;m_v.push_back(example);<br/>
&nbsp;&nbsp;m_signal_examples_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::Examples::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 20);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,10) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;examples&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 11,11) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/examples&gt;"));<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; &gt; examples;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_<a href="CppQuestion.htm">question</a>s<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;example&gt;.*&lt;/example&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(examples),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Example::From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ExamplesFactory::Create(examples);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::Examples::Get() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppAdd.htm">Add</a>Const(m_v);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples::OnExampleChanged()<br/>
{<br/>
&nbsp;&nbsp;m_signal_examples_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Examples::Test");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test of <b><a href="CppOperatorEqual.htm">operator==</a></b> and <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ExamplesFactory::GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; a <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::GetTests().at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples&gt; b <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::GetTests().at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; c <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples&gt; d <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> between <b><a href="CppClass.htm">class</a></b> and <a href="CppXml.htm">XML</a>, test <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ExamplesFactory::GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt;&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> Examples::To<a href="CppXml.htm">Xml</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; f(Examples::From<a href="CppXml.htm">Xml</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ExamplesFactory::GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt;&amp; e <a href="CppOperatorAssign.htm">=</a> v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> Examples::To<a href="CppXml.htm">Xml</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt;&amp; f <a href="CppOperatorAssign.htm">=</a> v[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> Examples::To<a href="CppXml.htm">Xml</a>(f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( s <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( s <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> unrated and rated examples are noticed as different<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; a <a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; b <a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; c <a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create("1",Competency::un<a href="CppInitialize.htm">initialize</a>d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; v; v.push_back(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; w; w.push_back(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; x; x.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; d <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; e <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; f <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *e); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *d); <a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *e); <a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*f <a href="CppOperatorNotEqual.htm">!=</a> *d); <a href="CppAssert.htm">assert</a>(*f <a href="CppOperatorNotEqual.htm">!=</a> *e); <a href="CppAssert.htm">assert</a>(*f <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Examples::Test finished successfully");<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Examples::To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt; &amp;c)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;examples&gt;";<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; examples <a href="CppOperatorAssign.htm">=</a> c-&gt;GetExamples();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> example <a href="CppOperatorAssign.htm">=</a> c-&gt;Get();<br/>
&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(example.begin(),example.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[&amp;s](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; t)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Example::To<a href="CppXml.htm">Xml</a>(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/examples&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 20);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,10) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;examples&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 11,11) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/examples&gt;"));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.Get().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().empty()) { <a href="CppAssert.htm">assert</a>(rhs.Get().empty()); <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> lhs.Get();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; w <a href="CppOperatorAssign.htm">=</a> rhs.Get();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppEqual.htm">std::equal</a>(v.begin(),v.end(),w.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; a, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *a <a href="CppOperatorEqual.htm">==</a> *b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().size() &lt; rhs.Get().size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().size() &gt; rhs.Get().size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.Get().size() <a href="CppOperatorEqual.htm">==</a> rhs.Get().size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> lhs.Get().size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get()[i] &lt; rhs.Get()[i]) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get()[i] &gt; rhs.Get()[i]) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplesfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplesfactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLESFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLESFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ExamplesFactory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Constructor</a> like<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Copy-<a href="CppConstructor.htm">constructor</a> like<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; examples);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; &gt; GetTests();<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLESFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplesfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplesfactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; examples(<b><a href="CppNew.htm">new</a></b> Examples( {} ));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> examples;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; examples)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; p <a href="CppOperatorAssign.htm">=</a> Create(examples-&gt;Get());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; p(<b><a href="CppNew.htm">new</a></b> Examples(v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create(p-&gt;GetText(),p-&gt;GetCompetency());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; examples(<b><a href="CppNew.htm">new</a></b> Examples(w));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> examples;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt;&amp; p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory::Create(p.first,p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; q <a href="CppOperatorAssign.htm">=</a> Create(w);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
}<br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::GetTests()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; is <a href="CppOperatorAssign.htm">=</a> { {0}, {1}, {0,1,2,3}, {} };<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; &gt; v;<br/>
&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(is.begin(),is.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(v),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; js)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(js.begin(),js.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>&amp; j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; p<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapfactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPTMAPFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPTMAPFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppArrayH.htm">array</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Factory <b><a href="CppClass.htm">class</a></b> to create ConceptMaps<br/>
<a href="CppComment.htm">///</a>ConceptMapFactory is the only <b><a href="CppClass.htm">class</a></b> <b><a href="CppUsing.htm">using</a></b> the ConceptMap <a href="CppConstructor.htm">constructor</a><br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMapFactory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create an empty-as-can-get ConceptMap<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; focal_<a href="CppQuestion.htm">question</a>);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges <a href="CppOperatorAssign.htm">=</a> {});<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; map);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain a ConceptMap from an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get all the other tests as one vector<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; GetAllTests();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the documented heteromorphous test concept maps<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the documented complex homomorphous test concept maps<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the documented simple homomorphous test concept maps<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPTMAPFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapfactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "<a href="CppFileIo.htm">fileio</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt;&amp; edges)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!nodes.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;( IsCenterNode(nodes[0]) <a href="CppOperatorLogicalOr.htm">||</a> !IsCenterNode(nodes[0]) )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The first node in a (sub)ConceptMap can be, but does not have to be a CenterNode");<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; p(<b><a href="CppNew.htm">new</a></b> ConceptMap(nodes,edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;IsValid());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; focal_<a href="CppQuestion.htm">question</a>)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A single-node ConceptMap contains only the focal <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; focal_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create(focal_<a href="CppQuestion.htm">question</a>)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_node);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; nodes <a href="CppOperatorAssign.htm">=</a> { focal_node };<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(nodes.at(0));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; p <a href="CppOperatorAssign.htm">=</a> Create(nodes);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;IsValid());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!p-&gt;GetNodes().empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;FindCenterNode() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A ConceptMap must have a CenterNode");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; map)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!map) <b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt;();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map-&gt;IsValid() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a valid original");<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Deep-copy the center node <b><a href="CppIf.htm">if</a></b> present<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Deep-copy the non-center nodes<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt; nodes <a href="CppOperatorAssign.htm">=</a> map-&gt;GetNodes();<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; new_nodes;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; node: nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; new_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::CenterNode&gt; center_node<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> <a href="CppDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::CenterNode&gt;(node))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_node <a href="CppOperatorAssign.htm">=</a> cmap::CenterNodeFactory::DeepCopy(center_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_node <a href="CppOperatorAssign.htm">=</a> cmap::NodeFactory::DeepCopy(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*new_node,*node));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new_nodes.push_back(new_node);<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Deep-copy the edges<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; edges <a href="CppOperatorAssign.htm">=</a> map-&gt;GetEdges();<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; new_edges;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge: edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the <b><a href="CppNew.htm">new</a></b> from node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> from_index <a href="CppOperatorAssign.htm">=</a> <a href="CppDistance.htm">std::distance</a>(nodes.begin(),from_iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index &lt; <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(new_nodes.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from <a href="CppOperatorAssign.htm">=</a> new_nodes[from_index];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the <b><a href="CppNew.htm">new</a></b> to node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> to_index <a href="CppOperatorAssign.htm">=</a> <a href="CppDistance.htm">std::distance</a>(nodes.begin(),to_iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_index &lt; <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(new_nodes.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to <a href="CppOperatorAssign.htm">=</a> new_nodes[to_index];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index <a href="CppOperatorNotEqual.htm">!=</a> to_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; new_edge <a href="CppOperatorAssign.htm">=</a> cmap::EdgeFactory::DeepCopy(edge,from,to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*new_edge,*edge));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new_edges.push_back(new_edge);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; p <a href="CppOperatorAssign.htm">=</a> Create(new_nodes,new_edges);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*p <a href="CppOperatorEqual.htm">==</a> *map <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( p <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;map <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a deep copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;IsValid() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a valid copy");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> &amp;s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 27);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,13) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;concept_map&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 14,14) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/concept_map&gt;"));<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;concept_map&gt; ... &lt;/concept_map&gt; string<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;concept_map&gt;.*&lt;/concept_map&gt;)"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Strip the &lt;concept_map&gt; tags<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> concept_map_str <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; nodes;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;nodes&gt; ... &lt;/nodes&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; w<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(concept_map_str,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;nodes&gt;.*&lt;/nodes&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Strip the &lt;nodes&gt; tags<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> nodes_str <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;concept&gt; ... &lt;/concept&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(nodes_str,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;node&gt;.*&lt;/node&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(x.begin(),x.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&amp;nodes](<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back( Node::From<a href="CppXml.htm">Xml</a>(s) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!nodes.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Replace the first node by its CenterNode equivalent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; old_node <a href="CppOperatorAssign.htm">=</a> nodes[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept <a href="CppOperatorAssign.htm">=</a> old_node-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> old_node-&gt;GetX();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> old_node-&gt;GetY();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::CenterNode&gt; center_node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> cmap::CenterNode(concept,x,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes[0] <a href="CppOperatorAssign.htm">=</a> center_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*old_node <a href="CppOperatorEqual.htm">==</a> *center_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; edges;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;edges&gt; ... &lt;/edges&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; w<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(concept_map_str,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;edges&gt;.*&lt;/edges&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Strip the &lt;edges&gt; tags<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> nodes_str <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;edge&gt; ... &lt;/edge&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(nodes_str,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;edge&gt;.*&lt;/edge&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s: x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge <a href="CppOperatorAssign.htm">=</a> EdgeFactory::From<a href="CppXml.htm">Xml</a>(s,nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<b><a href="CppNew.htm">new</a></b> ConceptMap(nodes,edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( !concept_map-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A file's ConceptMap has at least one node");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;FindCenterNode() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A file's ConceptMap must have a CenterNode");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept_map;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetAllTests()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; v;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(w.begin(),w.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(w.begin(),w.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(w.begin(),w.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> empty concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; Nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; v(20);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount_if.htm">std::count_if</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> p; } ) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[0]: as-empty-as-can-get concept map (X <a href="CppOperatorAssign.htm">=</a> focal <a href="CppQuestion.htm">question</a>_<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[0]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[1]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[2]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[2]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[3]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("edge_a concept"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_d,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[3]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[4]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("edge_a concept"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_d,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[4]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[5]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("1"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_d,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[5]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[6]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("1"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_d,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[6]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[7]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[7]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[8]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge_a(cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[8]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[9]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; edge_a(cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[9]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[10]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[10]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[11]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[11]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[12]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[12]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[13]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("2"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[13]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[14]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("2"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[14]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[15]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create("B", { {"B-1",cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} },0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("C", { {"C-1",cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"C-2",cmap::Competency::misc}},-1,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("D", { {"D-1",cmap::Competency::misc},{"D-2",cmap::Competency::misc},{"D-3",cmap::Competency::misc}},-1,-1,-1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_e(cmap::NodeFactory::Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_h(cmap::ConceptFactory::Create("2",{{"2-I",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3",{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_i(cmap::ConceptFactory::Create("4",{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_j(cmap::ConceptFactory::Create("5",{{"5-I",cmap::Competency::misc},{"5-II",cmap::Competency::misc},{"5-III",cmap::Competency::misc},{"5-IV",cmap::Competency::misc} } ));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_h,3.4,5.6,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_i,4.5,6.7,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_j,5.6,7.8,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(15)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[16]: complex rated concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create("B", { {"B-1: profession",cmap::Competency::profession} },0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("C", { {"C-1: organisations",cmap::Competency::organisations},{"C-2: social_surroundings",cmap::Competency::social_surroundings}},2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("D", { {"D-1: target_audience",cmap::Competency::target_audience},{"D-2: ti_knowledge",cmap::Competency::ti_knowledge},{"D-3: prof_growth",cmap::Competency::prof_growth},{"D-4: misc",cmap::Competency::misc}},0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_e(cmap::NodeFactory::Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_h(cmap::ConceptFactory::Create("2",{{"2-I",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3",{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_i(cmap::ConceptFactory::Create("4",{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_j(cmap::ConceptFactory::Create("5",{{"5-I",cmap::Competency::misc},{"5-II",cmap::Competency::misc},{"5-III",cmap::Competency::misc},{"5-IV",cmap::Competency::misc} } ));<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_h,3.4,5.6,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_i,4.5,6.7,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_j,5.6,7.8,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(16)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[17]: complex rated concept map with many examples<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create("B",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-P",cmap::Competency::profession},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-O",cmap::Competency::organisations},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-S",cmap::Competency::social_surroundings},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TA",cmap::Competency::target_audience},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TK",cmap::Competency::ti_knowledge},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-PG",cmap::Competency::prof_growth},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-M",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("C",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {"C-1: organisations",cmap::Competency::organisations},{"C-2: social_surroundings",cmap::Competency::social_surroundings}},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("D",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {"D-1: target_audience",cmap::Competency::target_audience},{"D-2: ti_knowledge",cmap::Competency::ti_knowledge},{"D-3: prof_growth",cmap::Competency::prof_growth},{"D-4: misc",cmap::Competency::misc}},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_e(cmap::NodeFactory::Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"2-I",cmap::Competency::misc}}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_h(cmap::ConceptFactory::Create("2",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"2-I",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_i(cmap::ConceptFactory::Create("4",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_j(cmap::ConceptFactory::Create("5",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"5-I",cmap::Competency::misc},{"5-II",cmap::Competency::misc},{"5-III",cmap::Competency::misc},{"5-IV",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_h,3.4,5.6,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_i,4.5,6.7,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_j,5.6,7.8,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(17)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[18]: complex rated concept map with many <b><a href="CppLong.htm">long</a></b> concept names and examples<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"B: This is a concept that has all types of competencies as its examples, each example name being multiple lines as well",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-P: <b><a href="CppThis.htm">this</a></b> is B its first example (out of seven) and it is categorized as a competency in the profession domain",cmap::Competency::profession},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-O: <b><a href="CppThis.htm">this</a></b> is B its second example (out of seven) and it is categorized as a competency in the organisation domain",cmap::Competency::organisations},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-S: <b><a href="CppThis.htm">this</a></b> is B its third example (out of seven) and it is categorized as a competency in the social surroundings domain",cmap::Competency::social_surroundings},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TA: <b><a href="CppThis.htm">this</a></b> is B its fourth example (out of seven) and it is categorized as a competency in the target audience domain",cmap::Competency::target_audience},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TK: <b><a href="CppThis.htm">this</a></b> is B its fifth example (out of seven) and it is categorized as a competency in the technical instrumental knowledge domain",cmap::Competency::ti_knowledge},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-PG: <b><a href="CppThis.htm">this</a></b> is B its sixth example (out of seven) and it is categorized as a competency in the professional growth domain",cmap::Competency::prof_growth},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-M: <b><a href="CppThis.htm">this</a></b> is B its seventh example (out of seven) and it is categorized as a competency in the misc domain",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"C: This is a concept that has only two of the seven types of competencies as its examples, each example name being multiple lines as well",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"C-O: <b><a href="CppThis.htm">this</a></b> is C its first example (out of two) and it is categorized as a competency in the organisation domain",cmap::Competency::organisations},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"C-S: <b><a href="CppThis.htm">this</a></b> is C its second example (out of two) and it is categorized as a competency in the social surroundings domain",cmap::Competency::social_surroundings}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"D: This is a concept that has only four of the seven types of competencies as its examples, each example name being multiple lines as well",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-TA: <b><a href="CppThis.htm">this</a></b> is D its first example (out of four) and it is categorized as a competency in the target audience domain",cmap::Competency::target_audience},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-TK: <b><a href="CppThis.htm">this</a></b> is D its second example (out of four) and it is categorized as a competency in the technical instrumental knowledge domain",cmap::Competency::ti_knowledge},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-PG: <b><a href="CppThis.htm">this</a></b> is D its third example (out of four) and it is categorized as a competency in the professional growth domain",cmap::Competency::prof_growth},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-M: <b><a href="CppThis.htm">this</a></b> is D its fourth example (out of four) and it is categorized as a competency in the misc domain",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_e(cmap::NodeFactory::Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X: This is the center node concept that can have no examples, oterwise each of its example name would be multiple lines"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A: This is a concept that has none of all types of competencies as its examples, oterwise each of its example name would be multiple lines"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1: the first description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{"2-I: <b><a href="CppThis.htm">this</a></b> misc example ",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_h(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"2: the second description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"2-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3: the third description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"3-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"3-II: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_i(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"4: the fourth description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"4-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"4-II: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"4-III: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_j(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"5: the fifth description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-II: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-III: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-IV: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_h,3.4,5.6,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_i,4.5,6.7,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_j,5.6,7.8,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(18)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[19]: complex rated concept map with all nodes connected<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create("B", { {"B-1: profession",cmap::Competency::profession} },0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("C", { {"C-1: organisations",cmap::Competency::organisations},{"C-2: social_surroundings",cmap::Competency::social_surroundings}},2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("D", { {"D-1: target_audience",cmap::Competency::target_audience},{"D-2: ti_knowledge",cmap::Competency::ti_knowledge},{"D-3: prof_growth",cmap::Competency::prof_growth},{"D-4: misc",cmap::Competency::misc}},0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_e(cmap::NodeFactory::Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_h(cmap::ConceptFactory::Create("2",{{"2-I",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3",{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_i(cmap::ConceptFactory::Create("4",{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} } ));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Concepts connected to the center should never be visible<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_j(cmap::ConceptFactory::Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_k(cmap::ConceptFactory::Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_l(cmap::ConceptFactory::Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_m(cmap::ConceptFactory::Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_n(cmap::ConceptFactory::Create("..."));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_h,3.4,5.6,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_i,4.5,6.7,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_j,5.6,7.8,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_k,6.7,8.9,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_l,7.8,9.0,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_m,8.9,0.1,nodes.at(0),<b><a href="CppTrue.htm">true</a></b> ,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(19)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; Nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; v;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[0] (note: same as heteromorphous[11])<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[2]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[3]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[4]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[5]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[6] (note: same as heteromorphous[11], yet arrows reversed<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[7]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[8]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_a(cmap::ConceptFactory::Create("X"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_b(cmap::ConceptFactory::Create("B"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create("A"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("C"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_a(cmap::NodeFactory::Create(concept_a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_b(cmap::NodeFactory::Create(concept_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[9]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_a(cmap::ConceptFactory::Create("X"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_b(cmap::ConceptFactory::Create("B"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_c(cmap::ConceptFactory::Create("C"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_d(cmap::ConceptFactory::Create("A"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_a(cmap::NodeFactory::Create(concept_a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_b(cmap::NodeFactory::Create(concept_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_c(cmap::NodeFactory::Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node_d(cmap::NodeFactory::Create(concept_d));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[10]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[11]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_e(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_f(cmap::ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept_g(cmap::ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_e,1.2,3.4,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_f,2.3,4.5,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::EdgeFactory::Create(concept_g,3.4,5.6,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 12);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; Nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; v(6);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount_if.htm">std::count_if</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> p; } ) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[0]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[0] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[1] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[2]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[2] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[3]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[3] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[4]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[4] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[5]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::CenterNodeFactory::Create("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::NodeFactory::Create("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[5] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapfwd.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapfwd.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPFWD_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPFWD_H<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> <a href="CppQRegExp.htm">QRegExp</a>;<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> <a href="CppQTimer.htm">QTimer</a>;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNode;<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNodeFactory;<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> Cluster; <a href="CppComment.htm">//</a>Remove <b><a href="CppFor.htm">for</a></b> now, must be added at <a href="ProjectBrainweaver.htm">ProjectBrainweaver</a> later<br/>
<b><a href="CppStruct.htm">struct</a></b> Command;<br/>
<b><a href="CppStruct.htm">struct</a></b> Concept;<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptFactory;<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMap;<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMapFactory;<br/>
<b><a href="CppStruct.htm">struct</a></b> Edge;<br/>
<b><a href="CppStruct.htm">struct</a></b> EdgeFactory;<br/>
<b><a href="CppStruct.htm">struct</a></b> Element;<br/>
<b><a href="CppStruct.htm">struct</a></b> Example;<br/>
<b><a href="CppStruct.htm">struct</a></b> Examples;<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> File;<br/>
<b><a href="CppStruct.htm">struct</a></b> Node;<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppWidget.htm">Widget</a>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPFWD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaphelper.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaphelper.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPHELPER_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPHELPER_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppArrayH.htm">array</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppArray.htm">array</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/con<a href="CppVersion.htm">version</a>/cast.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppQRegExp.htm">QRegExp</a>;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a>Help adding constness a bit<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> T&gt; &gt; <a href="CppAdd.htm">Add</a>Const(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;T&gt; &gt; v)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> T&gt; &gt; w(v.begin(),v.end());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> w.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) { <a href="CppAssert.htm">assert</a>(v[i] <a href="CppOperatorEqual.htm">==</a> w[i]); }<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Help adding constness a bit<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppConst.htm">const</a></b> T *&gt; <a href="CppAdd.htm">Add</a>Const(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;T *&gt; v)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppConst.htm">const</a></b> T *&gt; w(v.begin(),v.end());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> w.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) { <a href="CppAssert.htm">assert</a>(v[i] <a href="CppOperatorEqual.htm">==</a> w[i]); }<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Obtain all possible selections of a <a href="CppVector.htm">std::vector</a>, preserving the ordering of its elements<br/>
<a href="CppComment.htm">///</a>Examples:<br/>
/<a href="CppComment.htm">//</a> {&nbsp;&nbsp;&nbsp;&nbsp; } <a href="CppOperatorMinus.htm">-</a>&gt; { {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
/<a href="CppComment.htm">//</a> {1&nbsp;&nbsp;&nbsp;&nbsp;} <a href="CppOperatorMinus.htm">-</a>&gt; { {}, {1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
/<a href="CppComment.htm">//</a> {1,2&nbsp;&nbsp;} <a href="CppOperatorMinus.htm">-</a>&gt; { {}, {1}, {2},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1,2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
/<a href="CppComment.htm">//</a> {1,2,3} <a href="CppOperatorMinus.htm">-</a>&gt; { {}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3} }<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/GetPermutations.htm<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;T&gt; &gt; <a href="CppGetCombinations.htm">GetCombinations</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;T&gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;T&gt; &gt; result;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_combinations <a href="CppOperatorAssign.htm">=</a> (1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sz);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_combinations; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;T&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j) &amp; i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(w);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Obtain the Pythagorian distance from two delta's<br/>
<a href="CppComment.htm">//</a>From www.richelbilderbeek.nl/Cpp<a href="CppGetDistance.htm">GetDistance</a>.htm<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_y);<br/>
<br/>
<a href="CppComment.htm">///</a>Obtain the Pythagorian distance from two coordinats<br/>
<a href="CppComment.htm">//</a>From www.richelbilderbeek.nl/Cpp<a href="CppGetDistance.htm">GetDistance</a>.htm<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x2, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y2);<br/>
<br/>
<a href="CppComment.htm">///</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppGetRegexMatches.htm">GetRegexMatches</a>.htm<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppGetRegexMatches.htm">GetRegexMatches</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppQRegExp.htm">QRegExp</a>&amp; r);<br/>
<br/>
<a href="CppComment.htm">///</a>Safe<a href="CppFileToVector.htm">FileToVector</a> calls <a href="CppFileToVector.htm">FileToVector</a> and<br/>
<a href="CppComment.htm">///</a>removes an empty trailing line that can be created under<br/>
<a href="CppComment.htm">///</a>the <a href="CppWindows.htm">Windows</a> operating system, due to different line endings<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; Safe<a href="CppFileToVector.htm">FileToVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; filename);<br/>
<br/>
<a href="CppComment.htm">///</a>Split an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a> into its parts<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppSplitXml.htm">SplitXml</a>.htm<br/>
<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppSplitXml.htm">SplitXml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppComment.htm">///</a>Test the helper <a href="CppFunction.htm">function</a>s<br/>
<b><a href="CppVoid.htm">void</a></b> TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">///</a>Undo a Wordwrap<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> Unwordwrap(<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt;&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Wordwrap the text to obtain lines of max_len <a href="CppChar.htm">character</a>s<br/>
<a href="CppComment.htm">///</a>If the string _must_ be seperable by spaces; a word can have a maximum length of max_len<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; Wordwrap(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s, <b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> max_len) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Pretty-print an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a> by indenting its elements<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppXmlToPretty.htm">XmlToPretty</a>.htm<br/>
<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppXmlToPretty.htm">XmlToPretty</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPHELPER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaphelper.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaphelper.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFstreamH.htm">fstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppAlgorithm.htm">algorithm</a>/string.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQFile.htm">QFile</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppFileIo.htm">fileio</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppSqrt.htm">std::sqrt</a>( (delta_x * delta_x) <a href="CppOperatorPlus.htm">+</a> (delta_y * delta_y) );<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x2, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y2)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppGetDistance.htm">GetDistance</a>(x1-x2,y1-y2);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppQRegExp.htm">QRegExp</a>&amp; r_original)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppQRegExp.htm">QRegExp</a> r(r_original);<br/>
&nbsp;&nbsp;r.setMinimal(<b><a href="CppTrue.htm">true</a></b>); <a href="CppComment.htm">//</a><a href="CppQRegExp.htm">QRegExp</a> must be non-greedy<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> pos <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((pos <a href="CppOperatorAssign.htm">=</a> r.indexIn(s.c_str(), pos)) <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppOperatorMinus.htm">-</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppQString.htm">QString</a> q <a href="CppOperatorAssign.htm">=</a> r.cap(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (q.isEmpty()) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(q.toStdString());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pos <a href="CppOperatorPlusAssign.htm">+=</a> r.matchedLength();<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Safe<a href="CppFileToVector.htm">FileToVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileToVector.htm">FileToVector</a>(filename);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!v.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> v.back().empty()) v.pop_back();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppSplitXml.htm">SplitXml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v;<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a>::const_iterator i <a href="CppOperatorAssign.htm">=</a> s.begin();<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a>::const_iterator j <a href="CppOperatorAssign.htm">=</a> s.begin();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>::const_iterator end <a href="CppOperatorAssign.htm">=</a> s.end();<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (j<a href="CppOperatorNotEqual.htm">!=</a>end)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((*j<a href="CppOperatorEqual.htm">==</a>'&gt;' <a href="CppOperatorLogicalOr.htm">||</a> *j <a href="CppOperatorEqual.htm">==</a> '&lt;') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> <a href="CppDistance.htm">std::distance</a>(i,j) &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppString.htm">std::string</a> t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*i<a href="CppOperatorEqual.htm">==</a>'&lt;' ? i&nbsp;&nbsp; : i+1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*j<a href="CppOperatorEqual.htm">==</a>'&gt;' ? j+1 : j,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBack_inserter.htm">std::back_inserter</a>(t));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i <a href="CppOperatorAssign.htm">=</a> j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::TestHelper<a href="CppFunction.htm">Function</a>s()<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started TestHelper<a href="CppFunction.htm">Function</a>s");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppGetRegexMatches.htm">GetRegexMatches</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> "In the Netherlands, 1234 AB and 2345 BC are valid zip codes";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; expected;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("1234 AB");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("2345 BC");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> "(\\d{4} [A-Z]{2})";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>(r.c_str())) <a href="CppOperatorEqual.htm">==</a> expected);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> "&lt;concept&gt;&lt;name&gt;Concept with examples&lt;/name&gt;&lt;example&gt;Example 1&lt;/example&gt;&lt;example&gt;Example 2&lt;/example&gt;&lt;example&gt;Example 3&lt;/example&gt;&lt;/concept&gt;";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(s.begin(),s.end(),'\b') <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; expected;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("&lt;example&gt;Example 1&lt;/example&gt;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("&lt;example&gt;Example 2&lt;/example&gt;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("&lt;example&gt;Example 3&lt;/example&gt;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> "(&lt;example&gt;.*&lt;/example&gt;)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>(r.c_str())) <a href="CppOperatorEqual.htm">==</a> expected);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppGetCombinations.htm">GetCombinations</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume the number of elements is correct<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2,3&nbsp;&nbsp;&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;8);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2,3,4&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a> 16);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2,3,4,5} ) ).size() <a href="CppOperatorEqual.htm">==</a> 32);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume the elements are correct<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1,2 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_2 <a href="CppOperatorAssign.htm">=</a> {2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_3 <a href="CppOperatorAssign.htm">=</a> {1,2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_3));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1,2,3 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_2 <a href="CppOperatorAssign.htm">=</a> {2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_3 <a href="CppOperatorAssign.htm">=</a> {3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_4 <a href="CppOperatorAssign.htm">=</a> {1,2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_5 <a href="CppOperatorAssign.htm">=</a> {1,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_6 <a href="CppOperatorAssign.htm">=</a> {2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_7 <a href="CppOperatorAssign.htm">=</a> {1,2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_3));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_7));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1,2,3,4 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_2 <a href="CppOperatorAssign.htm">=</a> {2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_3 <a href="CppOperatorAssign.htm">=</a> {3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_4 <a href="CppOperatorAssign.htm">=</a> {4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_5 <a href="CppOperatorAssign.htm">=</a> {1,2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_6 <a href="CppOperatorAssign.htm">=</a> {1,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_7 <a href="CppOperatorAssign.htm">=</a> {1,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_8 <a href="CppOperatorAssign.htm">=</a> {2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_9 <a href="CppOperatorAssign.htm">=</a> {2,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_10 <a href="CppOperatorAssign.htm">=</a> {3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_11 <a href="CppOperatorAssign.htm">=</a> {1,2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_12 <a href="CppOperatorAssign.htm">=</a> {1,2,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_13 <a href="CppOperatorAssign.htm">=</a> {1,3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_14 <a href="CppOperatorAssign.htm">=</a> {2,3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_15 <a href="CppOperatorAssign.htm">=</a> {1,2,3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_3));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_8));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_9));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_10));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_11));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_12));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_13));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_14));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCount.htm">std::count</a>(v.begin(),v.end(),expected_15));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Wordwrap<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789012",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789012345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789012345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1 1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12 12",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123 123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234 1234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345 12345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456 123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567 1234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678 8",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789 9",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 0",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" 1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1 2 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1 23 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;12 34&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;12&nbsp;&nbsp;34&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 6",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 6",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 6&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> len=1; len<a href="CppOperatorNotEqual.htm">!=</a>1000; <a href="CppOperatorIncrement.htm">++</a>len)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Wordwrap calls Unwordwrap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wordwrap(s,len);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("TestHelper<a href="CppFunction.htm">Function</a>s finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Unwordwrap(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt;&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Simply concatenate<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a> t;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s: v) { t <a href="CppOperatorPlusAssign.htm">+=</a> s; }<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> t;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Wordwrap(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s_original, <b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> max_len) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (max_len <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppLogic_error.htm">std::logic_error</a>("Cannot wordwrap <b><a href="CppFor.htm">for</a></b> a max_len of zero");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Wordwrap \'" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s_original <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\'' <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppEndl.htm">std::endl</a>;<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a> s{s_original};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorEqual.htm">==</a> s_original.size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace multiple spaces with '\b ', where x is a <b><a href="CppChar.htm">char</a></b> not in the string<br/>
&nbsp;&nbsp;<a href="CppString.htm">std::string</a>::value_type x <a href="CppOperatorAssign.htm">=</a> '\b'; <a href="CppComment.htm">//</a>Bell<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> s.size();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace spaces at beginning<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[i] <a href="CppOperatorEqual.htm">==</a> ' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Replace spaces at end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (sz &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>i<a href="CppOperatorNotEqual.htm">!=</a>0, because <b><a href="CppIf.htm">if</a></b> s[0] is a space, it is already <a href="CppConvert.htm">convert</a>ed to bell<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=sz-1; i<a href="CppOperatorNotEqual.htm">!=</a>0; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[i] <a href="CppOperatorEqual.htm">==</a> ' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace "&nbsp;&nbsp;" by "\b "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz-1; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[i] <a href="CppOperatorEqual.htm">==</a> ' ' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[i+1] <a href="CppOperatorEqual.htm">==</a> ' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start the actual wordwrapping<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (!s.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the word <b><a href="CppShort.htm">short</a></b> enough?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() &lt; max_len)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copy entire word<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>No spaces, or space beyond max_len: cut word<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.find(' ') <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>::npos <a href="CppOperatorLogicalOr.htm">||</a> s.find(' ') &gt; max_len)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s.substr(0,max_len));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> s.substr(max_len,s.size() <a href="CppOperatorMinus.htm">-</a> max_len);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find last space before max_len<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSize_t.htm">std::size_t</a> len <a href="CppOperatorAssign.htm">=</a> s.find(' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppString.htm">std::string</a>::npos);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> new_len <a href="CppOperatorAssign.htm">=</a> s.find(' ',len <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (new_len &gt; max_len <a href="CppOperatorLogicalOr.htm">||</a> new_len <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>::npos) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len <a href="CppOperatorAssign.htm">=</a> new_len;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len <a href="CppOperatorPlus.htm">+</a> 0 &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len <a href="CppOperatorPlus.htm">+</a> 1 &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cut s, put cut part in vector<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> line <a href="CppOperatorAssign.htm">=</a> s.substr(0,len+1); <a href="CppComment.htm">//</a>Keep space<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!line.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(line);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> new_index <a href="CppOperatorAssign.htm">=</a> len+1; <a href="CppComment.htm">//</a>After the space found<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_index &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> new_s <a href="CppOperatorAssign.htm">=</a> s.substr(new_index,s.size() <a href="CppOperatorMinus.htm">-</a> new_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorNotEqual.htm">!=</a> new_s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> new_s;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace bell <a href="CppChar.htm">character</a>s by spaces again<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorNotEqual.htm">!=</a> ' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSize_t.htm">std::size_t</a> pos <a href="CppOperatorAssign.htm">=</a> s.find(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (pos <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppString.htm">std::string</a>::npos)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppString.htm">std::string</a>::npos);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorEqual.htm">==</a> s.find(x)); <a href="CppComment.htm">//</a>To prevent infinite <b><a href="CppWhile.htm">while</a></b> loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[pos] <a href="CppOperatorAssign.htm">=</a> ' ';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s[pos] <a href="CppOperatorEqual.htm">==</a> ' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorNotEqual.htm">!=</a> s.find(x)); <a href="CppComment.htm">//</a>To prevent infinite <b><a href="CppWhile.htm">while</a></b> loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos <a href="CppOperatorAssign.htm">=</a> s.find(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.find(x) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>::npos);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> Unwordwrap the result produces the original input<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Unwordwrap(v) <a href="CppOperatorNotEqual.htm">!=</a> s_original)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> v.size() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCopy.htm">std::copy</a>(v.begin(),v.end(),<a href="CppOstream_iterator.htm">std::ostream_iterator</a>&lt;<a href="CppString.htm">std::string</a>&gt;(<a href="CppCerr.htm">std::cerr</a>,"\n"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Unwordwrap(v) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s_original <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppEndl.htm">std::endl</a>;<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Unwordwrap(v) <a href="CppOperatorEqual.htm">==</a> s_original);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppXmlToPretty.htm">XmlToPretty</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppSplitXml.htm">SplitXml</a>(s);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2;<br/>
&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[&amp;n](<a href="CppString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> '&lt;' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[1] <a href="CppOperatorNotEqual.htm">!=</a> '/')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<a href="CppOperatorPlusAssign.htm">+=</a>2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> <a href="CppString.htm">std::string</a>(n,' ') <a href="CppOperatorPlus.htm">+</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[n+0] <a href="CppOperatorEqual.htm">==</a> '&lt;' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[n+1] <a href="CppOperatorEqual.htm">==</a> '/')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<a href="CppOperatorMinusAssign.htm">-=</a>2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnode.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapelement.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> NodeFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A Node is the GUI independent part as used in <a href="CppQt.htm">Qt</a>ConceptMapItem<br/>
<b><a href="CppStruct.htm">struct</a></b> Node : <b><a href="CppPublic.htm">public</a></b> Element<br/>
{<br/>
&nbsp;&nbsp;Node(<b><a href="CppConst.htm">const</a></b> Node&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Node&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Node&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain a Node from an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the Concept<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&nbsp;&nbsp;GetConcept() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_concept; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt;&amp; GetConcept()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_concept; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>::use_count<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetConceptUseCount() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_concept.use_count(); }<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get some test nodes<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; GetTests();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the x coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetX() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_x; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the y coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetY() <b><a href="CppConst.htm">const</a></b> { <b><a href="CppReturn.htm">return</a></b> m_y; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Similar to <b><a href="CppOperatorEqual.htm">operator==</a></b>, except that GUI elements are not tested <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> HasSameContent(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the concept<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetConcept(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the position<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetPos(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) { SetX(x); SetY(y); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the x coordinat<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the y coordinat<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a Node from an <a href="CppXml.htm">XML</a> <a href="CppString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; c);<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Node *)&gt; m_signal_node_changed;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppProtected.htm">protected</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">construct</a>ion, except <b><a href="CppFor.htm">for</a></b> NodeFactory and derived <b><a href="CppClass.htm">classes</a></b><br/>
&nbsp;&nbsp;Node() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> NodeFactory;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppExplicit.htm">explicit</a></b> Node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Node() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Node* x);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; m_concept;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The x-coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_x;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The y-coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_y;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnode.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Node::Node(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
&nbsp;&nbsp;: m_signal_node_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_concept(concept),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x(x),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y(y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_concept);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::Node::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,6) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;node&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/node&gt;"));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;concept&gt;.*&lt;/concept&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept <a href="CppOperatorAssign.htm">=</a> Concept::From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;x&gt;.*&lt;/x&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppQRegExp.htm">QRegExp</a>("(&lt;y&gt;.*&lt;/y&gt;)"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node(<b><a href="CppNew.htm">new</a></b> Node(concept,x,y));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::Node::GetTests()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> test_concepts <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests();<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; result;<br/>
&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(test_concepts.begin(),test_concepts.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[&amp;result](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> (<a href="CppRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> 256) <a href="CppOperatorMinus.htm">-</a> 128;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> (<a href="CppRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> 256) <a href="CppOperatorMinus.htm">-</a> 128;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node(<b><a href="CppNew.htm">new</a></b> Node(concept,x,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::HasSameContent(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs-&gt;GetConcept() <a href="CppOperatorEqual.htm">==</a> *rhs-&gt;GetConcept();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::SetConcept(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; concept)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_concept <a href="CppOperatorNotEqual.htm">!=</a> concept)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_concept <a href="CppOperatorAssign.htm">=</a> concept;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_node_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_x <a href="CppOperatorNotEqual.htm">!=</a> x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_node_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_y <a href="CppOperatorNotEqual.htm">!=</a> y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_node_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Node::Test");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> Node::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; c <a href="CppOperatorAssign.htm">=</a> NodeFactory::DeepCopy(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> To<a href="CppXml.htm">Xml</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; d <a href="CppOperatorAssign.htm">=</a> From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test HasSameContent<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d(cmap::ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( c <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot shuffle Concept its examples. No need to as well: the order is important<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( c <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot shuffle Concept its examples. No need to as well: the order is important<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(a,b) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Order in examples is important and cannot be shuffled");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot shuffle Concept its examples. No need to as well: the order is important<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test ConceptFactory reproductions<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test ConceptFactory reproductions<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorNotEqual.htm">!=</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(<b><a href="CppNew.htm">new</a></b> Node(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(<b><a href="CppNew.htm">new</a></b> Node(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Node::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Node::To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;node&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Concept::To<a href="CppXml.htm">Xml</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;x&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> node-&gt;GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/x&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;y&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> node-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/y&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/node&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,6) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;node&gt;"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> <a href="CppString.htm">std::string</a>("&lt;/node&gt;"));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Node&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs.GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *lhs.GetConcept() <a href="CppOperatorEqual.htm">==</a> *rhs.GetConcept()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetX() <a href="CppOperatorEqual.htm">==</a> rhs.GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetY() <a href="CppOperatorEqual.htm">==</a> rhs.GetY();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Node&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnodefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnodefactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPNODEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPNODEFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Node;<br/>
<br/>
<a href="CppComment.htm">///</a>Factory <b><a href="CppFor.htm">for</a></b> creating Node <a href="CppInstance.htm">instances</a><br/>
<b><a href="CppStruct.htm">struct</a></b> NodeFactory<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; examples <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; node);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain testing nodes<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; GetTests();<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPNODEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnodefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnodefactory.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> cmap::Node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept,x,y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*concept <a href="CppOperatorEqual.htm">==</a> *node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppPair.htm">std::pair</a>&lt;<a href="CppString.htm">std::string</a>,Competency&gt; &gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory::Create(name,examples),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; new_concept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptFactory::DeepCopy(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_concept);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*node-&gt;GetConcept(),*new_concept));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; new_node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(new_concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetX(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*node,*new_node));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> new_node;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::GetTests()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; nodes;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests();<br/>
&nbsp;&nbsp;<a href="CppTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppBack_inserter.htm">std::back_inserter</a>(nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; p(<b><a href="CppNew.htm">new</a></b> Node(c,x,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> nodes;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaptestconcept.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaptestconcept.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppThreadH.htm">thread</a>&gt;<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
&nbsp;&nbsp;<a href="CppThread.htm">std::thread</a> t(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Concept::Test");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorEqual.htm">operator==</a></b> and <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sz &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tmp_a <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tmp_b <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> tmp_a.at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> tmp_b.at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b); <a href="CppComment.htm">//</a>FAILS AT CROSSCOMPILER<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a<a href="CppOperatorNotEqual.htm">!=</a>b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorLess.htm">operator&lt;</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering by name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("2");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("2");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering by examples' size, sizes 0 versus 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering by examples' size, sizes 1 versus 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering <b><a href="CppFor.htm">for</a></b> equal examples' size, lexicographically in the 2nd text<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc},{"4",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory::Create("1", { {"2",Competency::misc},{"4",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppXml.htm">XML</a> con<a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptFactory::GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; original)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a> and <b><a href="CppOperatorEqual.htm">operator==</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory::DeepCopy(original);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*original));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c-&gt;m_name <a href="CppOperatorAssign.htm">=</a> c-&gt;m_name <a href="CppOperatorPlus.htm">+</a> " (modified)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<b><a href="CppOperatorEqual.htm">operator==</a></b>(*c,*original));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test To<a href="CppXml.htm">Xml</a> and From<a href="CppXml.htm">Xml</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> To<a href="CppXml.htm">Xml</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Concept::Test finished successfully");<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;t.detach();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaptestconceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaptestconceptmap.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSetH.htm">set</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIteratorH.htm">iterator</a>&gt;<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppThreadH.htm">thread</a>&gt;<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
&nbsp;&nbsp;<a href="CppThread.htm">std::thread</a> t(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Test");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppTrace.htm">trace</a>_verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; Nodes;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("<b><a href="CppOperatorEqual.htm">operator==</a></b>, DeepCopy"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetAllTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; c(ConceptMapFactory::DeepCopy(m));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppXml.htm">XML</a> con<a href="CppVersion.htm">version</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> To<a href="CppXml.htm">Xml</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Can<a href="CppConstructor.htm">Construct</a>"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(ConceptFactory::Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory::Create(concept,123,234);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Can<a href="CppConstructor.htm">Construct</a>( { node }, {} ) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume focal <a href="CppQuestion.htm">question</a> without examples can be <a href="CppConstructor.htm">construct</a>ed");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(ConceptFactory::Create("FOCAL QUESTION", { {"No",Competency::misc},{"examples",Competency::misc},{"allowed",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory::Create(concept,123,234);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Can<a href="CppConstructor.htm">Construct</a>( { node }, {} )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume focal <a href="CppQuestion.htm">question</a> with examples can be <a href="CppConstructor.htm">construct</a>ed"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "<b><a href="CppFor.htm">for</a></b> example, when creating a sub-concept map");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 1"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(NodeFactory::GetTests().size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; node_a(CenterNodeFactory::Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node_a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory::GetTests().at(1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory::GetTests().at(2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(2),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 2"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_b(ConceptFactory::Create("1", { {"2",Competency::misc},{"3",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_f(ConceptFactory::Create("1", { {"2",Competency::misc},{"3",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory::Create(concept_b,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::Create("4", { {"5",Competency::misc},{"6",Competency::misc} },345,456)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::Create("4", { {"5",Competency::misc},{"6",Competency::misc} },901,012)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_g <a href="CppOperatorAssign.htm">=</a> NodeFactory::Create(concept_f,901,012);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory::Create("FOCAL QUESTION"), node_b, node_g<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 3"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_a(ConceptFactory::Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_b(ConceptFactory::Create("1",{{"2",Competency::misc},{"3",Competency::misc}}));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_c(ConceptFactory::Create("4",{{"5",Competency::misc},{"6",Competency::misc}}));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_d(ConceptFactory::Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e(ConceptFactory::Create("4",{{"5",Competency::misc},{"6",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_f(ConceptFactory::Create("1",{{"2",Competency::misc},{"3",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_a(CenterNodeFactory::Create(concept_a,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory::Create(concept_b,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory::Create(concept_c,345,456));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(CenterNodeFactory::Create(concept_d,567,678));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory::Create(concept_e,789,890));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_f(NodeFactory::Create(concept_f,901,012));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(ConceptMapFactory::Create( { node_a, node_b, node_c } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(ConceptMapFactory::Create( { node_d, node_f, node_e } )); <a href="CppComment.htm">//</a>Swap e and f<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(ConceptMapFactory::Create( { node_d, node_c, node_e } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 4"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n11(ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n12(ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n13(ConceptFactory::Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n21(ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n22(ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n23(ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_11(CenterNodeFactory::Create(concept_n11,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_12(NodeFactory::Create(concept_n12,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_13(NodeFactory::Create(concept_n13,345,456));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_21(CenterNodeFactory::Create(concept_n21,567,678));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_22(NodeFactory::Create(concept_n22,789,890));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_23(NodeFactory::Create(concept_n23,901,012));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e11(ConceptFactory::Create("9"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e12(ConceptFactory::Create("8"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e13(ConceptFactory::Create("7"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e21(ConceptFactory::Create("9"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e22(ConceptFactory::Create("8"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e23(ConceptFactory::Create("7"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_1 <a href="CppOperatorAssign.htm">=</a> { node_11, node_12, node_13 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_2 <a href="CppOperatorAssign.htm">=</a> { node_21, node_22, node_23 };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_11(EdgeFactory::Create(concept_e11,1.2,3.4,nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_12(EdgeFactory::Create(concept_e12,2.3,4.5,nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_13(EdgeFactory::Create(concept_e13,3.4,5.6,nodes_1.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_21(EdgeFactory::Create(concept_e21,4.5,6.7,nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_22(EdgeFactory::Create(concept_e22,5.6,7.8,nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_23(EdgeFactory::Create(concept_e23,6.7,8.9,nodes_2.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_11, node_12, node_13 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_11, edge_12, edge_13 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_21, node_22, node_23 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_21, edge_22, edge_23 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_21, node_22, node_23 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_21, edge_22 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 5"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n11(ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n12(ConceptFactory::Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n13(ConceptFactory::Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_11(CenterNodeFactory::Create(concept_n11,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_12(NodeFactory::Create(concept_n12,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_13(NodeFactory::Create(concept_n13,345,456));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e11(ConceptFactory::Create("1-&gt;2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e12(ConceptFactory::Create("1-&gt;3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e13(ConceptFactory::Create("2-&gt;3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n21(ConceptFactory::Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n22(ConceptFactory::Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n23(ConceptFactory::Create("2"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_21(CenterNodeFactory::Create(concept_n21,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_22(NodeFactory::Create(concept_n22,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_23(NodeFactory::Create(concept_n23,345,456));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e21(ConceptFactory::Create("2-&gt;3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e22(ConceptFactory::Create("1-&gt;2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e23(ConceptFactory::Create("1-&gt;3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_1 <a href="CppOperatorAssign.htm">=</a> { node_11, node_12, node_13 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_2 <a href="CppOperatorAssign.htm">=</a> { node_21, node_22, node_23 };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_21(EdgeFactory::Create(concept_e21,1.2,3.4,nodes_2.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_22(EdgeFactory::Create(concept_e22,2.3,4.5,nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_23(EdgeFactory::Create(concept_e23,3.4,4.5,nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_11(EdgeFactory::Create(concept_e11,1.2,3.4,nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_12(EdgeFactory::Create(concept_e12,2.3,4.5,nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_13(EdgeFactory::Create(concept_e13,3.4,5.6,nodes_1.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_11, node_12, node_13 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_11, edge_12, edge_13 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_21, node_22, node_23 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_21, edge_22, edge_23 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 6"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; a(ConceptMapFactory::DeepCopy(v[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *v[i]); <a href="CppAssert.htm">assert</a>(*v[i] <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; b(ConceptMapFactory::DeepCopy(v[j]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (ConceptMap::HasSameContent(*a,*b))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Testing concept maps #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must not be the same";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test: heteromorphous testing concept maps are successfully identified as being different");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Test simple homomorphous maps"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; a(ConceptMapFactory::DeepCopy(v[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; b(ConceptMapFactory::DeepCopy(v[j]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!ConceptMap::HasSameContent(*a,*b))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Testing simple concept maps #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must be homomorphous";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test: simple homomorphous testing concept maps are successfully identified as being different, yet homomorphous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Test complex homomorphous maps"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; a(ConceptMapFactory::DeepCopy(v[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; b(ConceptMapFactory::DeepCopy(v[j]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorNotEqual.htm">!=</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!ConceptMap::HasSameContent(*a,*b))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Testing complex concept maps #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must be homomorphous";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test: complex homomorphous testing concept maps are successfully identified as being different, yet homomorphous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>OLD NOTE: There is no perfect check <b><a href="CppFor.htm">for</a></b> shuffled, yet homomorphous concept maps<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>LATER NOTE: Yet, I cannot think of an example that wouldn't get caught<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;so perhaps the check _is_ perfect?<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> TO_ADD_TO_PROJECTBRAINWEAVER<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> from Cluster<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Cluster&gt; &gt; clusters <a href="CppOperatorAssign.htm">=</a> ClusterFactory::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppFor_each.htm">std::for_each</a>(clusters.begin(),clusters.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Cluster&gt; &amp; cluster)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cluster)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m(ConceptMapFactory::CreateFromCluster("Focal <a href="CppQuestion.htm">question</a>",cluster));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> ConceptMap::To<a href="CppXml.htm">Xml</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; n <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsEqual(*m,*n));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("CreateSubs"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of expected sub concept maps<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; maps<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_heteromorphous_concept_maps <a href="CppOperatorAssign.htm">=</a> 20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_heteromorphous_concept_maps <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(maps.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "To warn you <b><a href="CppIf.htm">if</a></b> you change the number of testing concept maps");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; n_subs_expected <a href="CppOperatorAssign.htm">=</a> { 1,2,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5 } ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_heteromorphous_concept_maps <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(n_subs_expected.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 0] <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 1] <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 2] <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 6] <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 7] <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[14] <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[15] <a href="CppOperatorEqual.htm">==</a> 5);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(n_subs_expected[16] <a href="CppOperatorEqual.htm">==</a> 5);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(maps.size() <a href="CppOperatorEqual.htm">==</a> n_subs_expected.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(n_subs_expected.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!maps[i]) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt;&amp; map <a href="CppOperatorAssign.htm">=</a> maps[i];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; subs <a href="CppOperatorAssign.htm">=</a> map-&gt;CreateSubs();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(subs.size()) <a href="CppOperatorNotEqual.htm">!=</a> n_subs_expected[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(subs.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(n_subs_expected[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(subs.size()) <a href="CppOperatorEqual.htm">==</a> n_subs_expected[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("CountCenterNodes"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of CenterNode objects<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; map: ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CountCenterNodes(map) <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Every test concept map must have one CenterNode");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the edges connected to CenterNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_connected_to_center { CountCenterNodeEdges(map) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes_expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> n_edges_connected_to_center <a href="CppOperatorPlus.htm">+</a> 1; <a href="CppComment.htm">//</a>+1, because with no edges, you expect the center node only<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of sub concept maps with a center node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; subs <a href="CppOperatorAssign.htm">=</a> map-&gt;CreateSubs();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes_here {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCount_if.htm">std::count_if</a>(subs.begin(),subs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; sub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CountCenterNodes(sub) &gt; 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes_found <a href="CppOperatorAssign.htm">=</a> n_center_nodes_here;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_center_nodes_expected <a href="CppOperatorNotEqual.htm">!=</a> n_center_nodes_found)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Original map next:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> s: xml::<a href="CppXmlToPretty.htm">XmlToPretty</a>(To<a href="CppXml.htm">Xml</a>(map))) { <a href="CppTRACE.htm">TRACE</a>(s); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(n_center_nodes_expected);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(n_center_nodes_found);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(subs.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_center_nodes_expected <a href="CppOperatorEqual.htm">==</a> n_center_nodes_found);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("IsValid"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_a <a href="CppOperatorAssign.htm">=</a> CenterNodeFactory::Create("...");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_a } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory::Create("...");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Node(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("<a href="CppAdd.htm">Add</a> nodes and edges"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: concept_maps)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes_before <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_before <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_a <a href="CppOperatorAssign.htm">=</a> NodeFactory::GetTests().at(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_b <a href="CppOperatorAssign.htm">=</a> NodeFactory::GetTests().at(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory::GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory::GetTests().at(index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge <a href="CppOperatorAssign.htm">=</a> EdgeFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept,123.456,456.789,node_a,<b><a href="CppTrue.htm">true</a></b>,node_b,<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Node(node_a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Node(node_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Edge(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes_after <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_after <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_nodes_after <a href="CppOperatorEqual.htm">==</a> n_nodes_before <a href="CppOperatorPlus.htm">+</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_edges_after <a href="CppOperatorEqual.htm">==</a> n_edges_before <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Deletion of nodes"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>n_concept_maps; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_nodes <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> n_nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; concept_map-&gt;GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetNodes()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;DeleteNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> n_nodes <a href="CppOperatorMinus.htm">-</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Node must really be gone");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Deletion of edges"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s().size();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>n_concept_maps; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_edges <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetEdges().size() <a href="CppOperatorEqual.htm">==</a> n_edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; concept_map-&gt;GetEdges().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetEdges()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;DeleteEdge(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetEdges().size() <a href="CppOperatorEqual.htm">==</a> n_edges <a href="CppOperatorMinus.htm">-</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Edge must really be gone");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Is GetNode()[0] a CenterNode?"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetAllTests().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>n_concept_maps; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!concept_map-&gt;GetNodes().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;FindCenterNode() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume a CenterNode at the center of ConceptMap");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test finished successfully");<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;t.detach();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidget.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidget.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPWIDGET_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPWIDGET_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppWidget.htm">Widget</a> does the Command-driven communication with ConceptMap<br/>
<a href="CppComment.htm">///</a>Note that a <a href="CppWidget.htm">Widget</a> does not know the type of ConceptMap (Display/Edit/Rate)<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppWidget.htm">Widget</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt;());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; other); <a href="CppComment.htm">//</a>Only to be used in <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<a href="CppPreElse.htm">#else</a><br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; other) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; command) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; command) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; GetConceptMap() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_conceptmap; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMap&gt; GetConceptMap()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_conceptmap; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain all commands possible<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetAllCommands() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the ConceptMap is modified as a whole: deleted, created or overwritten<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>()&gt; m_signal_concept_map_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when a Node receives focus<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Node*)&gt; m_signal_set_focus_node;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m_conceptmap;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The element in focus, <b><a href="CppIf.htm">if</a></b> <a href="CppAny.htm">any</a>. This might be:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> a <b><a href="CppTrue.htm">true</a></b> Node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> the label in the middle of an edge<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> the CenterNode<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<b><a href="CppNullptr.htm">nullptr</a></b> denotes no Node has focus<br/>
&nbsp;&nbsp;Node * m_focus;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_font_height;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_font_width;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The undo stack (use <a href="CppVector.htm">std::vector</a> because it is a <b><a href="CppTrue.htm">true</a></b> <a href="CppStl.htm">STL</a> <a href="CppContainer.htm">container</a>)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Commands aren't <b><a href="CppConst.htm">const</a></b>, because Command::Undo changes their state<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_undo;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Creates a <b><a href="CppNew.htm">new</a></b> Node in the concept map. The <b><a href="CppReturn.htm">return</a></b> value is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that node. This is used by CommandCreateNode::Undo<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; CreateNewNode() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete a Node in the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Find a Node at a coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Returns <b><a href="CppNullptr.htm">nullptr</a></b> <b><a href="CppIf.htm">if</a></b> none is present<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Node * GetFocus() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_focus; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Used by CommandSetFocusRandom<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; GetRandomNode() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Start, reset or <b><a href="CppDelete.htm">delete</a></b> a/the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetFocus(Node * <b><a href="CppConst.htm">const</a></b> node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> Command;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandCreateNewConceptMap;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandCreateNewNode;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandDeleteConceptMap;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandDeleteNode;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandLoseFocus;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandSetFocusRandom;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandSetFocusWithCoordinat;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs);<br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; w);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPWIDGET_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidget.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidget.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeleteconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>factory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap)<br/>
&nbsp;&nbsp;: m_signal_concept_map_changed{}, <a href="CppComment.htm">//</a><a href="CppSignal.htm">Signal</a>s first, as these are <b><a href="CppPublic.htm">public</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_set_focus_node{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_conceptmap(conceptmap),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_focus{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_height(12),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_width(6),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_undo{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_conceptmap <a href="CppOperatorLogicalOr.htm">||</a> !m_conceptmap )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Allow a <a href="CppWidget.htm">widget</a> with and without an actual concept map");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_font_height &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_font_width &gt; 0);<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; other)<br/>
&nbsp;&nbsp;: m_signal_concept_map_changed{}, <a href="CppComment.htm">//</a><a href="CppSignal.htm">Signal</a>s first, as these are <b><a href="CppPublic.htm">public</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_set_focus_node{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_conceptmap(ConceptMapFactory::DeepCopy(other.m_conceptmap)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_focus{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_height(other.m_font_height),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_width(other.m_font_width),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_undo{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(m_conceptmap) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(other.m_conceptmap));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (!m_conceptmap <a href="CppOperatorLogicalOr.htm">||</a> *m_conceptmap <a href="CppOperatorEqual.htm">==</a> *other.m_conceptmap) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (!m_conceptmap <a href="CppOperatorLogicalOr.htm">||</a> m_conceptmap <a href="CppOperatorNotEqual.htm">!=</a> other.m_conceptmap) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a deep copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_focus <a href="CppOperatorEqual.htm">==</a> other.m_focus <a href="CppOperatorLogicalOr.htm">||</a> m_focus <a href="CppOperatorNotEqual.htm">!=</a> other.m_focus)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot copy focus");<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_undo <a href="CppOperatorEqual.htm">==</a> other.m_undo <a href="CppOperatorLogicalOr.htm">||</a> m_undo <a href="CppOperatorNotEqual.htm">!=</a> other.m_undo)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot copy undo");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; command) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> command-&gt;CanDoCommand(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::CreateNewNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory::Create("...")<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;m_conceptmap-&gt;<a href="CppAdd.htm">Add</a>Node(node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_conceptmap-&gt;DeleteNode(node);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::DoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; command) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(command));<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(command-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Undo<br/>
&nbsp;&nbsp;m_undo.push_back(command);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Actually <b><a href="CppDo.htm">do</a></b> the move<br/>
&nbsp;&nbsp;command-&gt;DoCommand(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()) { <b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;(); }<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node: <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetNodes())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> left <a href="CppOperatorAssign.htm">=</a> node-&gt;GetX();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> top&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> node-&gt;GetY();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> right <a href="CppOperatorAssign.htm">=</a> left <a href="CppOperatorPlus.htm">+</a> (m_font_width * node-&gt;GetConcept()-&gt;GetName().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bottom&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> node-&gt;GetY() <a href="CppOperatorPlus.htm">+</a> m_font_height;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorGreaterEqual.htm">&gt;=</a> left <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> x <a href="CppOperatorLessEqual.htm">&lt;=</a> right <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorGreaterEqual.htm">&gt;=</a> top <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorLessEqual.htm">&lt;=</a> bottom) <b><a href="CppReturn.htm">return</a></b> node;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;();<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst_cast.htm">const_cast</a></b>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>*&gt;(<b><a href="CppThis.htm">this</a></b>)-&gt;FindNodeAt(x,y)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoost.htm">boost</a>::const_<a href="CppPointer.htm">pointer</a>_cast&lt;Node&gt;(node);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetRandomNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!GetConceptMap()-&gt;GetNodes().empty());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes <a href="CppOperatorAssign.htm">=</a> GetConceptMap()-&gt;GetNodes();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> (<a href="CppRand.htm">std::rand</a>() <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 4) <a href="CppOperatorModulus.htm">%</a> nodes.size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(nodes[i]);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> nodes[i];<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.1";<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-12-xx: <a href="CppVersion.htm">Version</a> 1.0: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-12-23: <a href="CppVersion.htm">Version</a> 1.1: started <a href="CppVersion.htm">version</a>ing"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::SetConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_conceptmap <a href="CppOperatorAssign.htm">=</a> conceptmap;<br/>
&nbsp;&nbsp;m_signal_concept_map_changed();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::SetFocus(Node * <b><a href="CppConst.htm">const</a></b> node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_focus <a href="CppOperatorAssign.htm">=</a> node;<br/>
&nbsp;&nbsp;m_signal_set_focus_node(node);<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Starting <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Test()");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> *<a href="CppWidget.htm">widget</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppEndl.htm">std::endl</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> individual commands have the intended effect<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_no <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_yes <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandDeleteConceptMap c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Can <b><a href="CppDelete.htm">delete</a></b> a concept map when present");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be present before deletion");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.DoCommand(<a href="CppWidget.htm">widget</a>.get());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be deleted");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be restored by undo");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_yes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot <b><a href="CppDelete.htm">delete</a></b> a concept map when absent");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_no &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_yes &gt; 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_no <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_yes <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandCreateNewConceptMap c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Can start a concept map when none is present");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.DoCommand(<a href="CppWidget.htm">widget</a>.get());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be created");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetEdges().size() <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be deleted by undo");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_yes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot start when a concept map already exists");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_no &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_yes &gt; 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start a concept map, add some nodes<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>(<b><a href="CppNew.htm">new</a></b> <a href="CppWidget.htm">Widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot add node without a concept map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandCreateNewNode c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandCreateNewConceptMap c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.DoCommand(<a href="CppWidget.htm">widget</a>.get());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map without nodes is not yet supported");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>5; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size()) <a href="CppOperatorEqual.htm">==</a> i <a href="CppOperatorPlus.htm">+</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map starts with one node, now another one must be added");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandCreateNewNode c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.DoCommand(<a href="CppWidget.htm">widget</a>.get());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size()) <a href="CppOperatorEqual.htm">==</a> i <a href="CppOperatorPlus.htm">+</a> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map starts with one node, now another one must be added");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test all commands <b><a href="CppDo.htm">do</a></b> and undo<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>: <a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; command: CommandFactory::CreateTestCommands())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(command);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(command))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a> prev_<a href="CppWidget.htm">widget</a>(*<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(prev_<a href="CppWidget.htm">widget</a> <a href="CppOperatorEqual.htm">==</a> *<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(command);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(prev_<a href="CppWidget.htm">widget</a> <a href="CppOperatorNotEqual.htm">!=</a> *<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(prev_<a href="CppWidget.htm">widget</a> <a href="CppOperatorEqual.htm">==</a> *<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Finished <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Test()");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Undo()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_undo.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_undo.back());<br/>
&nbsp;&nbsp;m_undo.back()-&gt;Undo();<br/>
&nbsp;&nbsp;m_undo.pop_back();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(lhs.m_conceptmap.get()) <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(rhs.m_conceptmap.get()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<b><a href="CppNullptr.htm">nullptr</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_conceptmap <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *lhs.m_conceptmap <a href="CppOperatorNotEqual.htm">!=</a> *rhs.m_conceptmap) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_focus <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_focus) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_undo.size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_undo.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppEqual.htm">std::equal</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBegin.htm">std::begin</a>(lhs.m_undo),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEnd.htm">std::end</a>(lhs.m_undo),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBegin.htm">std::begin</a>(rhs.m_undo),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; p,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; q)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> q-&gt;ToStr();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; w)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; concept_map { w.GetConceptMap() };<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; &gt; edges { concept_map-&gt;GetEdges() };<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt; nodes { concept_map-&gt;GetEdges() };<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>In reverse order of importance<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Draw edge lines<br/>
<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidgetfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidgetfactory.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPWIDGETFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPWIDGETFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-<b><a href="CppTypedef.htm">typedef</a></b>s"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppWidget.htm">Widget</a> does the Command-driven communication with ConceptMap<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppWidget.htm">Widget</a>Factory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get all the testing concept maps as a <a href="CppWidget.htm">widget</a> in one vector<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; &gt; GetAllTests() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPWIDGETFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidgetfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidgetfactory.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>factory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a><a href="CppOperatorStreamIn.htm">&gt;&gt;</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>Factory::GetAllTests() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a><a href="CppOperatorStreamIn.htm">&gt;&gt;</a> v;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m: ConceptMapFactory::GetAllTests())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m <a href="CppOperatorLogicalOr.htm">||</a> !m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Allow a <a href="CppWidget.htm">widget</a> with and without an actual concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; w {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> <a href="CppWidget.htm">Widget</a>(m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (!m <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !w-&gt;GetConceptMap())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>both <b><a href="CppNullptr.htm">nullptr</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalOr.htm">||</a> (&nbsp;&nbsp; m <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;w-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *w-&gt;GetConceptMap() <a href="CppOperatorEqual.htm">==</a> *m) <a href="CppComment.htm">//</a>both <a href="CppPointer.htm">point</a> to same<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(w);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
