<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>ConceptMap</title>
  <meta name="description" content="C++ ConceptMap"/>
  <meta name="keywords" content="C++ ConceptMap "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppConceptMap.htm">ConceptMap</a></h1>
<p>&nbsp;</p>
<!-- This page is generated by CodeToHtml version 1.1.680 at Sun Jul  6 18:30:43 2014
 -->
<p><img src="PicStl.png" alt="STL"/><img src="PicQtCreator.png" alt="Qt Creator"/><img src="PicLubuntu.png" alt="Lubuntu"/><img src="PicWindows.png" alt="Windows"/></p>
<p>&nbsp;</p>
<p>
  <a href="CppConceptMap.htm">ConceptMap</a> is a <a href="CppClass.htm">class</a>
  for a concept map.
</p>
<p>&nbsp;</p>
<p>
  <a href="CppConceptMap.htm">ConceptMap</a> is used in, among others,
  the <a href="Tools.htm">tool</a> <a href="ToolTestConceptMap.htm">TestConceptMap</a>
  and the <a href="Projects.htm">project</a> <a href="ProjectBrainweaver.htm">Brainweaver</a>.
</p>
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/CppConceptMap.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/CppConceptMap.pri" border = "1"><tr><td><code>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a><br/>
<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/Licence.txt<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapfwd.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternodefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcompetency.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconcept.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconceptfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedgefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexample.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamples.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplesfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnodefactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaphelper.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedge.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommand.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapelement.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>factory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewconceptmap.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewnode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeleteconceptmap.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandlosefocus.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocuswithcoordinat.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocusrandom.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeletenode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeletefocusnode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewedge.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandaddfocusrandom.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandaddselectedrandom.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandunselectrandom.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcompetencies.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapregex.h<br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcenternodefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcompetency.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconcept.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapconceptfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedge.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapedgefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexample.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamples.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapexamplesfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapnodefactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaphelper.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaptestconceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmaptestconcept.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommand.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapelement.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmap<a href="CppWidget.htm">widget</a>factory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewconceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewnode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeleteconceptmap.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandlosefocus.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocuswithcoordinat.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandsetfocusrandom.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeletenode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommanddeletefocusnode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandcreatenewedge.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandaddfocusrandom.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandaddselectedrandom.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcommandunselectrandom.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapcompetencies.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="CppClass.htm">Classes</a>/<a href="CppConceptMap.htm">CppConceptMap</a>/conceptmapregex.cpp<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmap.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmap.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPTMAP_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPTMAP_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMapFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A concept map<br/>
<a href="CppComment.htm">///</a>Its <a href="CppInterface.htm">interface</a> is based on nodes and edges<br/>
<a href="CppComment.htm">///</a>Use ConceptMap<a href="CppWidget.htm">Widget</a> to work with commands<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMap<br/>
{<br/>
&nbsp;&nbsp;ConceptMap(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;ConceptMap&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> an Edge, assumes that the nodes it <a href="CppPointer.htm">point</a>s to are in the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>Edge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> a node, always works<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>Node(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> ConceptMap can be <a href="CppConstructor.htm">construct</a>ed successfully<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> Can<a href="CppConstructor.htm">Construct</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Prepend the <a href="CppQuestion.htm">question</a> as a first node, before adding the supplied nodes<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; CreateNodes(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create all sub-conceptmaps<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Note that CreateSubs()[0] is the concept map around the focal <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; CreateSubs() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete an edge<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteEdge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete a node and all the edges connected to it<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Check <b><a href="CppIf.htm">if</a></b> the ConceptMap is empty, that is: it has no nodes and (thus) no edges<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> Empty() <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Find the CenterNode, <b><a href="CppIf.htm">if</a></b> <a href="CppAny.htm">any</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; FindCenterNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNode&gt; FindCenterNode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; &gt;&nbsp;&nbsp;GetEdges() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&gt; &gt;&amp; GetEdges() { <b><a href="CppReturn.htm">return</a></b> m_edges; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the focal node (always at index zero)<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFocalNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetFocalNode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt;&nbsp;&nbsp;GetNodes() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; &gt;&amp; GetNodes() { <b><a href="CppReturn.htm">return</a></b> m_nodes; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use <b><a href="CppThis.htm">this</a></b> instead:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(FindCenterNode());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(FindCenterNode()-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> FindCenterNode()-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdString.htm">std::string</a> Get<a href="CppQuestion.htm">Question</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> HasNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; node) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; &gt;&amp; GetNodes() { <b><a href="CppReturn.htm">return</a></b> m_nodes; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Similar to <b><a href="CppOperatorEqual.htm">operator==</a></b>, except that the GUI member variables aren't checked <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> HasSameContent(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> ConceptMap&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Check <b><a href="CppIf.htm">if</a></b> there are no nulls in the edges and nodes<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> IsValid() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a ConceptMap from an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; c) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The edges<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt; m_edges;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The nodes<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; m_nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">constructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> ConceptMapFactory<br/>
&nbsp;&nbsp;ConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Nodes[0] must be the focal <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;ConceptMap(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges <a href="CppOperatorAssign.htm">=</a> {});<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create a concept map from a cluster<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> TO_ADD_TO_PROJECTBRAINWEAVER<br/>
&nbsp;&nbsp;ConceptMap(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Cluster&gt;&amp; cluster);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/To <a href="CppMake.htm">make</a> the <a href="CppCompiler.htm">compiler</a> use the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; FindCenterNodeConst() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> FindCenterNode(); }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/To <a href="CppMake.htm">make</a> the <a href="CppCompiler.htm">compiler</a> use the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFocalNodeConst() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> GetFocalNode(); }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> ConceptMapFactory;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;~ConceptMap() {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(ConceptMap* x);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(<b><a href="CppConst.htm">const</a></b> ConceptMap* x);<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>Count the number of CenterNodes<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> regular concept map: 1, the focus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> sub-concept map: 0 or 1, <b><a href="CppIf.htm">if</a></b> the focus is connected to the sub's focus node<br/>
<b><a href="CppInt.htm">int</a></b> CountCenterNodes(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Count the number of Edges connected to a CenterNodes<br/>
<b><a href="CppInt.htm">int</a></b> CountCenterNodeEdges(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> ConceptMap&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> ConceptMap&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPTMAP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmap.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSetH.htm">set</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFunctionalH.htm">functional</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "conceptmapcluster.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::ConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>)<br/>
&nbsp;&nbsp;: m_edges( {} ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes(CreateNodes(<a href="CppQuestion.htm">question</a>, {} ))<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(m_nodes,m_edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(FindCenterNode()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume a CenterNode at the center of ConceptMap");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsCenterNode(FindCenterNode())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The CenterNode found must really be a CenterNode");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(FindCenterNode()-&gt;GetConcept()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The CenterNode must have an <a href="CppInitialize.htm">initialize</a>d Concept to display the focus");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(FindCenterNode()-&gt;GetConcept()-&gt;GetName() <a href="CppOperatorEqual.htm">==</a> <a href="CppQuestion.htm">question</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The CenterNode must display the focus");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::ConceptMap(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt;&amp; edges)<br/>
&nbsp;&nbsp;: m_edges(edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes(nodes)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(nodes,edges))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_nodes <a href="CppOperatorAssign.htm">=</a> nodes.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ": " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> nodes[i]-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_edges <a href="CppOperatorAssign.htm">=</a> edges.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge <a href="CppOperatorAssign.htm">=</a> edges[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> const_nodes <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ": " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Edge::To<a href="CppXml.htm">Xml</a>(edge,const_nodes) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(nodes,edges));<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TO_ADD_TO_PROJECTBRAINWEAVER<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::ConceptMap(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Cluster&gt;&amp; cluster)<br/>
&nbsp;&nbsp;: m_edges{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes(CreateNodes(<a href="CppQuestion.htm">question</a>, {} ))<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; &gt;&amp; v <a href="CppOperatorAssign.htm">=</a> cluster-&gt;Get();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(v[i],x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.push_back(node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorEqual.htm">==</a> m_nodes.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume the ConceptMap has as much nodes as the cluster has concepts <a href="CppOperatorPlus.htm">+</a> one focal <a href="CppQuestion.htm">question</a>");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>TO_ADD_TO_PROJECTBRAINWEAVER<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::<a href="CppAdd.htm">Add</a>Edge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> TODO_RICHEL<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a>&nbsp;&nbsp;TODO_RICHEL<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasNode(edge-&gt;GetFrom()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasNode(edge-&gt;GetTo()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "First enter the node <b><a href="CppThis.htm">this</a></b> edge originates from"); <a href="CppComment.htm">//</a>TODO RJCB<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "First enter the node <b><a href="CppThis.htm">this</a></b> edge targets to");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;m_edges.push_back(edge);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::<a href="CppAdd.htm">Add</a>Node(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;m_nodes.push_back(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),node) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Every node must be unique");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do not let concept map <a href="CppSignal.htm">signal</a> that a <b><a href="CppNew.htm">new</a></b> node has been added:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>keep it as stupid as possible. Let ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>have <b><a href="CppThis.htm">this</a></b> behavior<br/>
}<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; <a href="CppComment.htm">/*</a> nodes <a href="CppComment.htm">*/</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt;&amp; edges)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppTrace.htm">trace</a>_verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> there are 'two-way' edges, that is, one edge going from A to B<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>and another edge going from B to A<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges <a href="CppOperatorAssign.htm">=</a> edges.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &amp; a <a href="CppOperatorAssign.htm">=</a> edges[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> a_from <a href="CppOperatorAssign.htm">=</a> a-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> a_to&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> a-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=i+1; j<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorNotEqual.htm">!=</a> j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; n_edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &amp; b <a href="CppOperatorAssign.htm">=</a> edges[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a.get() <a href="CppOperatorNotEqual.htm">!=</a> b.get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume different <a href="CppPointer.htm">pointer</a>s");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> b_from <a href="CppOperatorAssign.htm">=</a> b-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> b_to&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> b-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (a_from.get() <a href="CppOperatorEqual.htm">==</a> b_from.get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> a_to.get() <a href="CppOperatorEqual.htm">==</a> b_to.get())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Cannot have two edges from the same node to the same node");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (a_from.get() <a href="CppOperatorEqual.htm">==</a> b_to.get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> a_to.get() <a href="CppOperatorEqual.htm">==</a> b_from.get())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Cannot have two edges from the same node to the same node");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::CreateNodes(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExamplesFactory::Create(), <a href="CppComment.htm">//</a>No examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFalse.htm">false</a></b>, <a href="CppComment.htm">//</a>Is not complex<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>1, <a href="CppComment.htm">//</a>No rated complexity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>1, <a href="CppComment.htm">//</a>No rated concreteness<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>1&nbsp;&nbsp;<a href="CppComment.htm">//</a>No rated specificity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; center_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().Create(concept,0.0,0.0)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node);<br/>
&nbsp;&nbsp;v.push_back(center_node);<br/>
&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(nodes.begin(),nodes.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> nodes.size() <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::CreateSubs() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; focal_node: m_nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_node);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Collect all edges connected top the focal node (which is m_nodes[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; nodes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt; edges;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(focal_node);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; focal_edge: m_edges)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppIf.htm">if</a></b> (focal_edge-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> focal_node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(focal_edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_edge-&gt;GetTo() <a href="CppOperatorNotEqual.htm">!=</a> focal_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(focal_edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (focal_edge-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> focal_node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(focal_edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(focal_edge-&gt;GetFrom() <a href="CppOperatorNotEqual.htm">!=</a> focal_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(focal_edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!nodes.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Put CenterNode in front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind_if.htm">std::find_if</a>(nodes.begin(),nodes.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node) { <b><a href="CppReturn.htm">return</a></b> IsCenterNode(node); } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end()) { <a href="CppStdSwap.htm">std::swap</a>(*nodes.begin(),*iter); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::Can<a href="CppConstructor.htm">Construct</a>(nodes,edges) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Only <a href="CppConstructor.htm">construct</a> valid concept maps");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<b><a href="CppNew.htm">new</a></b> ConceptMap(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::DeleteEdge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>One cannot be sure <b><a href="CppIf.htm">if</a></b> the edges are already deleted or not<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(<a href="CppStdCount.htm">std::count</a>(m_edges.begin(),m_edges.end(),edge) <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_edges.begin(),m_edges.end(),edge) <a href="CppOperatorNotEqual.htm">!=</a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The edge must exist");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_edges.begin(),m_edges.end(),edge) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Every edge is unique");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_edges_before <a href="CppOperatorAssign.htm">=</a> m_edges.size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;m_edges.erase(<a href="CppStdRemove.htm">std::remove</a>(m_edges.begin(),m_edges.end(),edge),m_edges.end());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_edges_after <a href="CppOperatorAssign.htm">=</a> m_edges.size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_edges_before <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> n_edges_after);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),node) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There are multiple ways to <b><a href="CppDelete.htm">delete</a></b> a node:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppQt.htm">Qt</a>ConceptMap: <b><a href="CppDelete.htm">delete</a></b> the <a href="CppQt.htm">Qt</a>Node, which deletes the Node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> ConceptMap<a href="CppWidget.htm">Widget</a>: deletes the Node, which <b><a href="CppQtSignals.htm">signals</a></b> its observers of <b><a href="CppThis.htm">this</a></b> event<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Because the sequence<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),node) &gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Can only <b><a href="CppDelete.htm">delete</a></b> an existing node");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),node) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Every node is unique");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_nodes_before <a href="CppOperatorAssign.htm">=</a> m_nodes.size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete all edges going to <b><a href="CppThis.htm">this</a></b> node<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; to_be_deleted;<br/>
&nbsp;&nbsp;<a href="CppStdCopy_if.htm">std::copy_if</a>(m_edges.begin(),m_edges.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(to_be_deleted),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[node](<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> node <a href="CppOperatorLogicalOr.htm">||</a> edge-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge: to_be_deleted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;DeleteEdge(edge);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the node itself<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copied from http://www.richelbilderbeek.nl/CppVector.htm<br/>
&nbsp;&nbsp;m_nodes.erase(<a href="CppStdRemove.htm">std::remove</a>(m_nodes.begin(),m_nodes.end(),node),m_nodes.end());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_nodes_after <a href="CppOperatorAssign.htm">=</a> m_nodes.size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_nodes_before <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorEqual.htm">==</a> n_nodes_after);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Empty() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(m_nodes.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !m_edges.empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "If there are no nodes, there cannot be edges");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_nodes.empty(); <a href="CppComment.htm">//</a> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_edges.empty();<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::FindCenterNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind_if.htm">std::find_if</a>(m_nodes.begin(),m_nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsCenterNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; center_node;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (iter <a href="CppOperatorEqual.htm">==</a> m_nodes.end())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!center_node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;center_node <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(*iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> center_node;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::FindCenterNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calls the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a> of <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s [1]<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1] <a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C<a href="CppOperatorIncrement.htm">++</a> (3rd edition). ISBN: 0-321-33487-6.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;Item 3, paragraph 'Avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s'<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; center_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDynamic_cast.htm">dynamic_cast</a></b>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap*&gt;(<b><a href="CppThis.htm">this</a></b>)-&gt;FindCenterNodeConst() <a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppConst.htm">const</a></b> because <a href="CppCompiler.htm">compiler</a> cannt find the right <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoost.htm">boost</a>::const_<a href="CppPointer.htm">pointer</a>_cast&lt;CenterNode&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;center_node<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetEdges() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppAdd.htm">Add</a>Const(m_edges);<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetFocalNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_nodes.empty()) <b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_nodes[0];<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetFocalNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calls the <b><a href="CppConst.htm">const</a></b> <a href="CppVersion.htm">version</a> of <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s [1]<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1] <a href="CppScottMeyers.htm">Scott Meyers</a>. Effective C<a href="CppOperatorIncrement.htm">++</a> (3rd edition). ISBN: 0-321-33487-6.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;Item 3, paragraph 'Avoid duplication in <b><a href="CppConst.htm">const</a></b> and non-<a href="CppConstMemberFunction.htm">const member function</a>s'<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; focal_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDynamic_cast.htm">dynamic_cast</a></b>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap*&gt;(<b><a href="CppThis.htm">this</a></b>)-&gt;GetFocalNodeConst() <a href="CppComment.htm">//</a><a href="CppCompiler.htm">Compiler</a> cannot distinguish <a href="CppMemberFunction.htm">member functions</a> by type<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoost.htm">boost</a>::const_<a href="CppPointer.htm">pointer</a>_cast&lt;Node&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;focal_node<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::GetNodes() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppAdd.htm">Add</a>Const(m_nodes);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Get<a href="CppQuestion.htm">Question</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; center_node(FindCenterNode());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (center_node)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> center_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppReturn.htm">return</a></b> "";<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.2";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-xx-xx: <a href="CppVersion.htm">Version</a> 1.0: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-12-23: <a href="CppVersion.htm">Version</a> 1.1: started <a href="CppVersion.htm">version</a>ing",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2014-02-08: <a href="CppVersion.htm">Version</a> 1.2: support an empty concept map"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::HasNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; node) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdCount.htm">std::count</a>(m_nodes.begin(),m_nodes.end(),node);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::HasSameContent(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppTrace.htm">trace</a>_verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetEdges().size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetEdges().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Number of edges differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetNodes().size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetNodes().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Number of nodes differ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(lhs.GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(rhs.GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppFunction.htm">Function</a> to compare Node <a href="CppSmartPointer.htm">smart pointer</a>s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; ConstNodePtr;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdFunction.htm">std::function</a>&lt;<b><a href="CppBool.htm">bool</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs)&gt; node_cmp<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> [](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs &lt; *rhs;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppFunction.htm">Function</a> to compare Concept <a href="CppSmartPointer.htm">smart pointer</a>s<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; ConstConceptPtr;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdFunction.htm">std::function</a>&lt;<b><a href="CppBool.htm">bool</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)&gt; concept_cmp<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> [](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs &lt; *rhs;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Same Concepts<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_lhs <a href="CppOperatorAssign.htm">=</a> lhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_lhs(concept_cmp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(nodes_lhs.begin(),nodes_lhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_lhs,concepts_lhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConstConceptPtr concept <a href="CppOperatorAssign.htm">=</a> node-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_rhs <a href="CppOperatorAssign.htm">=</a> rhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_rhs(concept_cmp);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(nodes_rhs.begin(),nodes_rhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_rhs,concepts_rhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdMismatch.htm">std::mismatch</a>(concepts_lhs.begin(),concepts_lhs.end(),concepts_rhs.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; a,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *a <a href="CppOperatorEqual.htm">==</a> *b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> <a href="CppStdMake_pair.htm">std::make_pair</a>(concepts_lhs.end(),concepts_rhs.end()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Node concepts differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Same Edges<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> edges_lhs <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_lhs(concept_cmp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(edges_lhs.begin(),edges_lhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_lhs,concepts_lhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode()-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetNode()-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> edges_rhs <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdMultiset.htm">std::multiset</a>&lt;ConstConceptPtr,decltype(concept_cmp)&gt; concepts_rhs(concept_cmp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(edges_rhs.begin(),edges_rhs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::inserter(concepts_rhs,concepts_rhs.begin()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode()-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge-&gt;GetNode()-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdMismatch.htm">std::mismatch</a>(concepts_lhs.begin(),concepts_lhs.end(),concepts_rhs.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; a,<b><a href="CppConst.htm">const</a></b> ConstConceptPtr&amp; b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *a <a href="CppOperatorEqual.htm">==</a> *b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> <a href="CppStdMake_pair.htm">std::make_pair</a>(concepts_lhs.end(),concepts_rhs.end()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Edge concepts differ"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> <b><a href="CppFor.htm">for</a></b> each edge a same 'from' and 'to' concept can be found<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdTuple.htm">std::tuple</a>&lt;<a href="CppStdString.htm">std::string</a>,<a href="CppStdString.htm">std::string</a>,<a href="CppStdString.htm">std::string</a>&gt; FakeEdge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;FakeEdge&gt; FakeEdges;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetEdges().size() <a href="CppOperatorEqual.htm">==</a> rhs.GetEdges().size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FakeEdges v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_node <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges()[i]-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> str_from <a href="CppOperatorAssign.htm">=</a> from_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> str_mid <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges()[i]-&gt;GetNode()-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_node <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges()[i]-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> str_to <a href="CppOperatorAssign.htm">=</a> to_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only <b><a href="CppIf.htm">if</a></b> arrow is reversed, reverse the fake edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetEdges()[i]-&gt;HasHeadArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (lhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> lhs.GetEdges()[i]-&gt;HasHeadArrow())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two-way or zero-way arrow, add it in both directions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Normal arrow<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size()) <a href="CppOperatorGreaterEqual.htm">&gt;=</a> sz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FakeEdges w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_node <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges()[i]-&gt;GetFrom();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> str_from <a href="CppOperatorAssign.htm">=</a> from_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> str_mid <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges()[i]-&gt;GetNode()-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_node <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges()[i]-&gt;GetTo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> str_to <a href="CppOperatorAssign.htm">=</a> to_node-&gt;GetConcept()-&gt;GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only <b><a href="CppIf.htm">if</a></b> arrow is reversed, reverse the fake edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rhs.GetEdges()[i]-&gt;HasHeadArrow() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (rhs.GetEdges()[i]-&gt;HasTailArrow() <a href="CppOperatorEqual.htm">==</a> rhs.GetEdges()[i]-&gt;HasHeadArrow())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two-way or zero-way arrow, add it in both directions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_to,str_mid,str_from));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Normal arrow<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(<a href="CppStd.htm">std</a>::make_<a href="CppTuple.htm">tuple</a>(str_from,str_mid,str_to));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w.size()) <a href="CppOperatorGreaterEqual.htm">&gt;=</a> sz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorNotEqual.htm">!=</a> w.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSort.htm">std::sort</a>(v.begin(),v.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSort.htm">std::sort</a>(w.begin(),w.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v <a href="CppOperatorNotEqual.htm">!=</a> w)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> REALLY_SHOW_ME_THIS_7364894385876473475934758934753<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> REALLY_SHOW_ME_THIS_7364894385876473475934758934753<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "[" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (i+1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "/" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sz <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "]: ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;0&gt;(v[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;1&gt;(v[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;2&gt;(v[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") , ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;0&gt;(w[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;1&gt;(w[i]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "," <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdGet.htm">std::get</a>&lt;2&gt;(w[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ")";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::IsValid() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node: m_nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Node is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge: m_edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Edge is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!edge-&gt;GetTo())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetTo() is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!edge-&gt;GetFrom())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetFrom() is <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorNotEqual.htm">!=</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetTo() <a href="CppPointer.htm">point</a>s to node not in the concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorNotEqual.htm">!=</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("edge-&gt;GetFrom() <a href="CppPointer.htm">point</a>s to node not in the concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::To<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; map) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;concept_map&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;nodes&gt;";<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt;&amp; nodes <a href="CppOperatorAssign.htm">=</a> map-&gt;GetNodes();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node: nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> node-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/nodes&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;edges&gt;";<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt;&amp; edges <a href="CppOperatorAssign.htm">=</a> map-&gt;GetEdges();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge: edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Edge::To<a href="CppXml.htm">Xml</a>(edge,nodes);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/edges&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/concept_map&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 27);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,13) <a href="CppOperatorEqual.htm">==</a> "&lt;concept_map&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 14,14) <a href="CppOperatorEqual.htm">==</a> "&lt;/concept_map&gt;");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CountCenterNodes(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> conceptmap-&gt;GetNodes();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cnt <a href="CppOperatorAssign.htm">=</a> <a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsCenterNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt &lt; 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A concept map can have one or zero (a sub-conceptmap) center nodes");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> cnt;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CountCenterNodeEdges(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes <a href="CppOperatorAssign.htm">=</a> CountCenterNodes(conceptmap);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_center_nodes &lt; 2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "A concept map can have one or zero (a sub-conceptmap) center nodes");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_center_nodes <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppReturn.htm">return</a></b> 0;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> conceptmap-&gt;GetEdges();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cnt <a href="CppOperatorAssign.htm">=</a> <a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsConnectedToCenterNode(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> cnt;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Compare nodes<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt; lhs_nodes <a href="CppOperatorAssign.htm">=</a> lhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt; rhs_nodes <a href="CppOperatorAssign.htm">=</a> rhs.GetNodes();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs_nodes.size() <a href="CppOperatorNotEqual.htm">!=</a> rhs_nodes.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdEqual.htm">std::equal</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBegin.htm">std::begin</a>(lhs_nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdEnd.htm">std::end</a>(&nbsp;&nbsp;lhs_nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBegin.htm">std::begin</a>(rhs_nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; lhs_node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; rhs_node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs_node <a href="CppOperatorEqual.htm">==</a> *rhs_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Compare edges<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; lhs_edges <a href="CppOperatorAssign.htm">=</a> lhs.GetEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; &gt; rhs_edges <a href="CppOperatorAssign.htm">=</a> rhs.GetEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs_edges.size() <a href="CppOperatorNotEqual.htm">!=</a> rhs_edges.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdEqual.htm">std::equal</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBegin.htm">std::begin</a>(lhs_edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdEnd.htm">std::end</a>(&nbsp;&nbsp;lhs_edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBegin.htm">std::begin</a>(rhs_edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; lhs_edge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; rhs_edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs_edge <a href="CppOperatorEqual.htm">==</a> *rhs_edge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternode.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCENTERNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCENTERNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>The focal <a href="CppQuestion.htm">question</a> of a ConceptMap<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> Every ConceptMap usually has one CenterNode<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> Every sub concept-map has none or one CenterNode<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;(a sub concet-map has a focal node instead)<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNode : <b><a href="CppPublic.htm">public</a></b> Node<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;~CenterNode() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(CenterNode* x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">construct</a>ion, except <b><a href="CppFor.htm">for</a></b> NodeFactory<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppStruct.htm">struct</a></b> CenterNodeFactory;<br/>
&nbsp;&nbsp;CenterNode() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lock to enforce use of CenterNodeFactory<br/>
&nbsp;&nbsp;<b><a href="CppExplicit.htm">explicit</a></b> CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> CenterNodeFactory&amp; lock<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
<a href="CppComment.htm">///</a>Returns <b><a href="CppTrue.htm">true</a></b> <b><a href="CppIf.htm">if</a></b> Node is of derived <b><a href="CppClass.htm">class</a></b> type CenterNode<br/>
<a href="CppComment.htm">///</a>Returns <b><a href="CppTrue.htm">true</a></b> <b><a href="CppIf.htm">if</a></b> Node is Node<br/>
<b><a href="CppBool.htm">bool</a></b> IsCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCENTERNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternode.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::CenterNode::CenterNode(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> CenterNodeFactory&amp;<br/>
)<br/>
&nbsp;&nbsp;: Node(concept,x,y,NodeFactory())<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::IsCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(node).get();<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::CenterNode::To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;center_node&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetConcept()-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;x&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/x&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;y&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/y&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/center_node&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,13) <a href="CppOperatorEqual.htm">==</a> "&lt;center_node&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 14,14) <a href="CppOperatorEqual.htm">==</a> "&lt;/center_node&gt;");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternodefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternodefactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCENTERNODEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCENTERNODEFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b>&nbsp;&nbsp;CenterNodeFactory<br/>
{<br/>
&nbsp;&nbsp;CenterNodeFactory();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; CreateFromStrings(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; examples <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;&amp; node<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain a CenterNode from an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCENTERNODEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcenternodefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcenternodefactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::CenterNodeFactory()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> cmap::CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept,x,y,*<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*concept <a href="CppOperatorEqual.htm">==</a> *node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::CreateFromStrings(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CenterNode(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(name,examples),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::CenterNode&gt;&amp; node<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; new_concept {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().DeepCopy(node-&gt;GetConcept())<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_concept);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node-&gt;GetConcept() <a href="CppOperatorEqual.htm">==</a> *new_concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; new_node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(new_concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetX(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node <a href="CppOperatorEqual.htm">==</a> *new_node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> new_node;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::CenterNode&gt; <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::From<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() &lt; 27)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt;();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.substr(0,13) <a href="CppOperatorNotEqual.htm">!=</a> "&lt;center_node&gt;")<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt;();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 14,14) <a href="CppOperatorNotEqual.htm">!=</a> "&lt;/center_node&gt;")<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt;();<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Concept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory().From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>X());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Y());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; node(<b><a href="CppNew.htm">new</a></b> CenterNode(concept,x,y,*<b><a href="CppThis.htm">this</a></b>));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorEqual.htm">==</a> s);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::CenterNodeFactory::Test");<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("CenterNodeFactory::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommand.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommand.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMAND_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMAND_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Command can be used to <b><a href="CppDo.htm">do</a></b> and undo commands to a concept map <a href="CppWidget.htm">Widget</a><br/>
<a href="CppComment.htm">///</a>Command must use a <a href="CppWidget.htm">Widget</a>* because a <a href="CppWidget.htm">Widget</a> will call a Command with <b><a href="CppThis.htm">this</a></b>:<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;some_command-&gt;CanDo(<b><a href="CppThis.htm">this</a></b>);<br/>
<a href="CppComment.htm">///</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;Command() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Command() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> CanDoCommand(<a href="CppWidget.htm">widget</a>.get()); }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommand(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> { DoCommand(<a href="CppWidget.htm">widget</a>.get()); }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<b><a href="CppConst.htm">const</a></b> Command*)&gt; m_signal_undo;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Hook, should be <b><a href="CppPrivate.htm">private</a></b> in derived <b><a href="CppClass.htm">classes</a></b> as well, use the general form<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Hook, should be <b><a href="CppPrivate.htm">private</a></b> in derived <b><a href="CppClass.htm">classes</a></b> as well, use the general form<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Hook, should be <b><a href="CppPrivate.htm">private</a></b> in derived <b><a href="CppClass.htm">classes</a></b> as well, use the general form<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMAND_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommand.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommand.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">//</a>Don't include ConceptMap, use <a href="CppWidget.htm">Widget</a> its mostly-<b><a href="CppPrivate.htm">private</a></b>-except-<b><a href="CppFor.htm">for</a></b>-Command <a href="CppInterface.htm">interface</a> only<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Command::Command() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
&nbsp;&nbsp;: m_signal_undo{}<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command::CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CanDoCommandSpecific(<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command::DoCommand(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(<a href="CppWidget.htm">widget</a>));<br/>
&nbsp;&nbsp;DoCommandSpecific(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>2; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;DoCommandSpecific(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;UndoSpecific();<br/>
&nbsp;&nbsp;m_signal_undo(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandaddfocusrandom.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandaddfocusrandom.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDADDFOCUSRANDOM_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDADDFOCUSRANDOM_H<br/>
<br/>
#error Please <b><a href="CppDo.htm">do</a></b> not use a nonsense <b><a href="CppClass.htm">class</a></b><br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SUPPORT_NONSENSE<br/>
<a href="CppComment.htm">//</a>Do not forget: only one item can have focus<br/>
<a href="CppComment.htm">//</a>What you probably meant is to add a selected item<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a><a href="CppIfdef.htm">#ifdef</a> SUPPORT_NONSENSE<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDADDFOCUSRANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandaddfocusrandom.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandaddfocusrandom.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfdef.htm">#ifdef</a> SUPPORT_NONSENSE<br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a><a href="CppIfdef.htm">#ifdef</a> SUPPORT_NONSENSE<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandaddselectedrandom.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandaddselectedrandom.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDADDSELECTEDRANDOM_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDADDSELECTEDRANDOM_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppAdd.htm">Add</a> another item to the selected pool<br/>
<b><a href="CppStruct.htm">struct</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;Command<a href="CppAdd.htm">Add</a>SelectedRandom() : m_old_selected{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;Command<a href="CppAdd.htm">Add</a>SelectedRandom(<b><a href="CppConst.htm">const</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Command<a href="CppAdd.htm">Add</a>SelectedRandom&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~Command<a href="CppAdd.htm">Add</a>SelectedRandom() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "add selected random"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_old_selected;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDADDSELECTEDRANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandaddselectedrandom.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandaddselectedrandom.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandaddselectedrandom.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocusrandom.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command<a href="CppAdd.htm">Add</a>SelectedRandom::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalOr.htm">||</a> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("<a href="CppAdd.htm">Add</a>Selected needs a concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("<a href="CppAdd.htm">Add</a>Selected needs nodes to focus on");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppConst_cast.htm">const_cast</a></b>&lt;<a href="CppWidget.htm">Widget</a>*&gt;(<a href="CppWidget.htm">widget</a>)-&gt;GetRandomNodes(<a href="CppAdd.htm">Add</a>Const(<a href="CppWidget.htm">widget</a>-&gt;GetSelected())).empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("<a href="CppAdd.htm">Add</a>Selected needs non-focused nodes to focus on");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command<a href="CppAdd.htm">Add</a>SelectedRandom::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_old_selected <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetSelected();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_old_selected.begin(),m_old_selected.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> selected_to_add(<a href="CppWidget.htm">widget</a>-&gt;GetRandomNodes(<a href="CppAdd.htm">Add</a>Const(m_old_selected)));<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;<a href="CppAdd.htm">Add</a>Selected(selected_to_add);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_focus_node();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Command<a href="CppAdd.htm">Add</a>SelectedRandom::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Lose focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_old_selected.begin(),m_old_selected.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetSelected(m_old_selected);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_selected(m_<a href="CppWidget.htm">widget</a>-&gt;m_selected);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewconceptmap.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewconceptmap.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDCREATENEWCONCEPTMAP_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDCREATENEWCONCEPTMAP_H<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Start a <b><a href="CppNew.htm">new</a></b> concept map<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is no existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandCreateNewConceptMap : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandCreateNewConceptMap() : m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandCreateNewConceptMap(<b><a href="CppConst.htm">const</a></b> CommandCreateNewConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandCreateNewConceptMap&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandCreateNewConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandCreateNewConceptMap() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "create <b><a href="CppNew.htm">new</a></b> concept map"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDCREATENEWCONCEPTMAP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewconceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewconceptmap.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewconceptmap.h"<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewConceptMap::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewConceptMap::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; new_map {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create("...")<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_map);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(new_map);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewConceptMap::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; empty_map;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(empty_map);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewedge.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewedge.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDCREATENEWEDGE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDCREATENEWEDGE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Start a <b><a href="CppNew.htm">new</a></b> node<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is an existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandCreateNewEdge : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandCreateNewEdge() : m_edge{}, m_nodes{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandCreateNewEdge(<b><a href="CppConst.htm">const</a></b> CommandCreateNewEdge&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandCreateNewEdge&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandCreateNewEdge&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandCreateNewEdge() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "create <b><a href="CppNew.htm">new</a></b> edge"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; m_edge;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_nodes;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDCREATENEWEDGE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewedge.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewedge.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewedge.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewEdge::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get()<br/>
&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> <a href="CppWidget.htm">widget</a>-&gt;GetFocus()<br/>
&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> <a href="CppWidget.htm">widget</a>-&gt;GetSelected().size() <a href="CppOperatorEqual.htm">==</a> 2;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewEdge::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(!m_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(<a href="CppWidget.htm">widget</a>));<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_nodes.push_back(m_<a href="CppWidget.htm">widget</a>-&gt;GetFocus());<br/>
&nbsp;&nbsp;m_nodes.push_back(m_<a href="CppWidget.htm">widget</a>-&gt;GetSelected()[0]);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_nodes.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_nodes[0]);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_nodes[1]);<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> TODO_ISSUE_190<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_nodes[0] <a href="CppOperatorNotEqual.htm">!=</a> m_nodes[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "An edge must be created from two different nodes");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;HasNode(m_nodes[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "An edge must be created from two existing nodes");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;HasNode(m_nodes[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "An edge must be created from two existing nodes");<br/>
<br/>
&nbsp;&nbsp;m_edge <a href="CppOperatorAssign.htm">=</a> m_<a href="CppWidget.htm">widget</a>-&gt;CreateNewEdge();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_edge);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewEdge::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;DeleteEdge(m_edge);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_nodes.clear();<br/>
&nbsp;&nbsp;m_edge <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;();<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewnode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewnode.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDCREATENEWNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDCREATENEWNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Start a <b><a href="CppNew.htm">new</a></b> node<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is an existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandCreateNewNode : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandCreateNewNode() : m_node{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandCreateNewNode(<b><a href="CppConst.htm">const</a></b> CommandCreateNewNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandCreateNewNode&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandCreateNewNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandCreateNewNode() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "create <b><a href="CppNew.htm">new</a></b> node"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_node;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDCREATENEWNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandcreatenewnode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandcreatenewnode.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewnode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewNode::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewNode::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_node <a href="CppOperatorAssign.htm">=</a> m_<a href="CppWidget.htm">widget</a>-&gt;CreateNewNode();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_node);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandCreateNewNode::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;DeleteNode(m_node);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_node <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeleteconceptmap.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeleteconceptmap.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDDELETECONCEPTMAP_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDDELETECONCEPTMAP_H<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Delete a concept map<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is an existing concept map<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandDeleteConceptMap : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandDeleteConceptMap() : m_deleted_concept_map{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandDeleteConceptMap(<b><a href="CppConst.htm">const</a></b> CommandDeleteConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandDeleteConceptMap&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandDeleteConceptMap&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandDeleteConceptMap() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> "<b><a href="CppDelete.htm">delete</a></b> concept map"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m_deleted_concept_map;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDDELETECONCEPTMAP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeleteconceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeleteconceptmap.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeleteconceptmap.h"<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteConceptMap::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(m_<a href="CppWidget.htm">widget</a>) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(m_deleted_concept_map));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot <b><a href="CppDelete.htm">delete</a></b> a concept map, when<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> the command already has deleted one, so its internals are non-<b><a href="CppNullptr.htm">nullptr</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> the offered <a href="CppWidget.htm">widget</a> has no concept map<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteConceptMap::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommandSpecific(<a href="CppWidget.htm">widget</a>));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct pre state<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Before executing the command,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>CommandDeleteConceptMap its internals (m_<a href="CppWidget.htm">widget</a> and m_conceptmap)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>should both be <b><a href="CppNullptr.htm">nullptr</a></b><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Before deleting a <a href="CppWidget.htm">Widget</a> its ConceptMap,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"CommandDeleteConceptMap::m_<a href="CppWidget.htm">widget</a> must be <b><a href="CppNullptr.htm">nullptr</a></b>");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_deleted_concept_map);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_deleted_concept_map <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(m);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct post state<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_deleted_concept_map);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteConceptMap::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct pre state<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_deleted_concept_map);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetConceptMap(m_deleted_concept_map);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; empty_map;<br/>
&nbsp;&nbsp;m_deleted_concept_map <a href="CppOperatorAssign.htm">=</a> empty_map;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct post state<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_deleted_concept_map);<br/>
}<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeletefocusnode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeletefocusnode.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDDELETEFOCUSNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDDELETEFOCUSNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Delete a node the concept map has in focus<br/>
<a href="CppComment.htm">///</a>-Can be used only when there is an existing concept map<br/>
/<a href="CppComment.htm">//</a> and a Node in focus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandDeleteFocusNode : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandDeleteFocusNode() : m_old_focus{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandDeleteFocusNode(<b><a href="CppConst.htm">const</a></b> CommandDeleteFocusNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandDeleteFocusNode&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandDeleteFocusNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandDeleteFocusNode() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "<b><a href="CppDelete.htm">delete</a></b> node in focus"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_old_focus;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDDELETEFOCUSNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeletefocusnode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeletefocusnode.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeletefocusnode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteFocusNode::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> <a href="CppWidget.htm">widget</a>-&gt;GetFocus();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteFocusNode::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(<a href="CppWidget.htm">widget</a>));<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> m_<a href="CppWidget.htm">widget</a>-&gt;GetFocus();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_old_focus);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;DeleteNode(m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteFocusNode::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;<a href="CppAdd.htm">Add</a>Node(m_old_focus);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeletenode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeletenode.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDDELETENODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDDELETENODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Delete an existing node<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandDeleteNode : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandDeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node);<br/>
&nbsp;&nbsp;CommandDeleteNode(<b><a href="CppConst.htm">const</a></b> CommandDeleteNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandDeleteNode&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandDeleteNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandDeleteNode() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "<b><a href="CppDelete.htm">delete</a></b> node"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_node;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDDELETENODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommanddeletenode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommanddeletenode.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeletenode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteNode::CommandDeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node)<br/>
&nbsp;&nbsp;: m_node{node}, m_<a href="CppWidget.htm">widget</a>{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_node);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteNode::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteNode::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;DeleteNode(m_node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_node);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandDeleteNode::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap().get());<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;<a href="CppAdd.htm">Add</a>Node(m_node);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandfactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>CommandFactory creates Commands<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandFactory<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; &gt; CreateTestCommands() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandfactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandaddselectedrandom.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeleteconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandlosefocus.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeletefocusnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocusrandom.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocuswithcoordinat.h"<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Command&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::CommandFactory::CreateTestCommands() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; &gt; v;<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewConceptMap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewEdge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandDeleteConceptMap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandLoseFocus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandSetFocusRandom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandSetFocusWithCoordinat(0,0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandDeleteFocusNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandlosefocus.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandlosefocus.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDLOSEFOCUS_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDLOSEFOCUS_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Lose focus of top node<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> opposite of <a href="CppAdd.htm">Add</a>Focus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandLoseFocus : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandLoseFocus() : m_old_focus{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandLoseFocus(<b><a href="CppConst.htm">const</a></b> CommandLoseFocus&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandLoseFocus&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandLoseFocus&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandLoseFocus() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "lose focus"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_old_focus;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDLOSEFOCUS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandlosefocus.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandlosefocus.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandlosefocus.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandLoseFocus::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppWidget.htm">widget</a>-&gt;GetFocus().get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandLoseFocus::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(<a href="CppWidget.htm">widget</a>));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_old_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> command<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(m_old_focus,<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_lose_focus(m_old_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandLoseFocus::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> command<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(m_old_focus,m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_old_focus);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_old_focus);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocusrandom.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocusrandom.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSRANDOM_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSRANDOM_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Set focus with a coordinat<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> opposite of LoseFocus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> SetFocus does not care <b><a href="CppIf.htm">if</a></b> there currently is something in focus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandSetFocusRandom : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandSetFocusRandom() : m_old_focus{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandSetFocusRandom(<b><a href="CppConst.htm">const</a></b> CommandSetFocusRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandSetFocusRandom&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandSetFocusRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandSetFocusRandom() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "set focus random"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_old_focus;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSRANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocusrandom.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocusrandom.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocusrandom.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusRandom::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalOr.htm">||</a> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_to_exclude;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;GetFocus()) { nodes_to_exclude.push_back(<a href="CppWidget.htm">widget</a>-&gt;GetFocus()); }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The concept map must contain at least one node<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !<b><a href="CppConst_cast.htm">const_cast</a></b>&lt;<a href="CppWidget.htm">Widget</a>*&gt;(<a href="CppWidget.htm">widget</a>)-&gt;GetRandomNodes(nodes_to_exclude).empty()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusRandom::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( <a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer focus to <b><a href="CppThis.htm">this</a></b> Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetFocus();<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_to_exclude;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;GetFocus()) { nodes_to_exclude.push_back(<a href="CppWidget.htm">widget</a>-&gt;GetFocus()); }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> new_focus(<a href="CppWidget.htm">widget</a>-&gt;GetRandomNode(nodes_to_exclude));<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetFocus(new_focus);<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_focus(new_focus);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusRandom::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Put back the old focus, or lose the focus<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_old_focus)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetFocus(m_old_focus);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;LoseFocus();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_focus(m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSWITHCOORDINAT_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSWITHCOORDINAT_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Set focus with a coordinat<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> opposite of LoseFocus<br/>
<a href="CppComment.htm">///</a><a href="CppOperatorMinus.htm">-</a> SetFocus does not care <b><a href="CppIf.htm">if</a></b> there currently is something in focus<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandSetFocusWithCoordinat : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandSetFocusWithCoordinat(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: m_old_focus{}, m_<a href="CppWidget.htm">widget</a>{}, m_x(x), m_y(y) {}<br/>
&nbsp;&nbsp;CommandSetFocusWithCoordinat(<b><a href="CppConst.htm">const</a></b> CommandSetFocusWithCoordinat&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandSetFocusWithCoordinat&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandSetFocusWithCoordinat&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandSetFocusWithCoordinat() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "set focus with coordinat"; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_old_focus;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_x;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_y;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMA<a href="CppNds.htm">NDS</a>ETFOCUSWITHCOORDINAT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandsetfocuswithcoordinat.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocuswithcoordinat.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusWithCoordinat::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;FindNodeAt(m_x,m_y).get();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusWithCoordinat::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommandSpecific(<a href="CppWidget.htm">widget</a>));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetFocus();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;FindNodeAt(m_x,m_y)<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;m_focus <a href="CppOperatorAssign.htm">=</a> node;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_focus(node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandSetFocusWithCoordinat::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>-&gt;m_focus);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Give back previous focus, or lose it<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_old_focus)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetFocus(m_old_focus);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;LoseFocus();<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;m_old_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandunselectrandom.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandunselectrandom.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMMANDUNSELECTRANDOM_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMMANDUNSELECTRANDOM_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppAdd.htm">Add</a> another item to the selected pool<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandUnselectRandom : <b><a href="CppPublic.htm">public</a></b> Command<br/>
{<br/>
&nbsp;&nbsp;CommandUnselectRandom() : m_old_selected{}, m_<a href="CppWidget.htm">widget</a>{} {}<br/>
&nbsp;&nbsp;CommandUnselectRandom(<b><a href="CppConst.htm">const</a></b> CommandUnselectRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;CommandUnselectRandom&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> CommandUnselectRandom&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;~CommandUnselectRandom() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b> { <b><a href="CppReturn.htm">return</a></b> "unselect random"; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_old_selected;<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a> * m_<a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b> <b><a href="CppFinal.htm">final</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMMANDUNSELECTRANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcommandunselectrandom.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcommandunselectrandom.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmapcommandunselectrandom.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandsetfocusrandom.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandUnselectRandom::CanDoCommandSpecific(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalOr.htm">||</a> !<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("Unselect needs a concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;GetSelected().empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("Unselect needs nodes to unselect on");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandUnselectRandom::DoCommandSpecific(<a href="CppWidget.htm">Widget</a> * <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">widget</a>) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a> <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Get a random selected node<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> all_selected <a href="CppOperatorAssign.htm">=</a> <a href="CppWidget.htm">widget</a>-&gt;GetSelected();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(all_selected.begin(),all_selected.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(all_selected.size());<br/>
&nbsp;&nbsp;m_old_selected <a href="CppOperatorAssign.htm">=</a> all_selected[i];<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Unselect it<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(all_selected[i],all_selected[ all_selected.size() <a href="CppOperatorMinus.htm">-</a> 1]);<br/>
&nbsp;&nbsp;all_selected.pop_back();<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;SetSelected(all_selected);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_focus_node();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_concept_map_changed();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::CommandUnselectRandom::UndoSpecific() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Re-select the previously selected Node<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;<a href="CppAdd.htm">Add</a>Selected( { m_old_selected} );<br/>
<br/>
&nbsp;&nbsp;m_<a href="CppWidget.htm">widget</a>-&gt;m_signal_set_selected(m_<a href="CppWidget.htm">widget</a>-&gt;m_selected);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_<a href="CppWidget.htm">widget</a>);<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcompetencies.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcompetencies.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMPETENCIES_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMPETENCIES_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/bimap.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppFunction.htm">Function</a>s to work on with the Competency <b><a href="CppEnum.htm">enum</a></b>eration<br/>
<b><a href="CppStruct.htm">struct</a></b> Competencies<br/>
{<br/>
&nbsp;&nbsp;Competencies();<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Competency&gt; GetAllCompetencies() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> ToIndex(<b><a href="CppConst.htm">const</a></b> Competency competency) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStrDutch(<b><a href="CppConst.htm">const</a></b> Competency competency) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr(<b><a href="CppConst.htm">const</a></b> Competency competency) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;Competency ToTypeFromDutch(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; dutch_string) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;Competency ToType(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt; m_map_dutch;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt; m_map_english;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt; CreateMapDutch() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt; CreateMapEnglish() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMPETENCIES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcompetencies.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcompetencies.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetencies.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<br/>
<a href="CppBoostBimap.htm">boost::bimap</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Competency,<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Competencies::m_map_english;<br/>
<a href="CppBoostBimap.htm">boost::bimap</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Competency,<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Competencies::m_map_dutch;<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Competencies::Competencies()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppBoostBimap.htm">boost::bimap</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Competency,<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Competencies::CreateMapEnglish() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt; m;<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::un<a href="CppInitialize.htm">initialize</a>d,"un<a href="CppInitialize.htm">initialize</a>d"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::profession,"profession"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::organisations,"organisations"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::social_surroundings,"social_surroundings"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::target_audience,"target_audience"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::ti_knowledge,"ti_knowledge"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::prof_growth,"prof_growth"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::misc,"misc"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.left.size() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(Competency::n_competencies));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m;<br/>
}<br/>
<br/>
<a href="CppBoostBimap.htm">boost::bimap</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Competency,<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Competencies::CreateMapDutch() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt; m;<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::un<a href="CppInitialize.htm">initialize</a>d,"[Ongeinitialiseerd]"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::profession,"Kennis van het beroepsdomein"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::organisations,"Kennis van de organisatie"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::social_surroundings,"Kennis van de sociale omgeving"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::target_audience,"Kennis van de doelgroep"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::ti_knowledge,"Technisch instrumentele kennis"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::prof_growth,"Kennis van de eigen persoon"));<br/>
&nbsp;&nbsp;m.insert(<a href="CppBoostBimap.htm">boost::bimap</a>&lt;Competency,<a href="CppStdString.htm">std::string</a>&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Competency::misc,"Overige"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m.left.size() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(Competency::n_competencies));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Competency&gt; <a href="CppRibi.htm">ribi</a>::cmap::Competencies::GetAllCompetencies() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Competency&gt; v {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::profession,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::organisations,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::social_surroundings,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::target_audience,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::ti_knowledge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::prof_growth,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Competency::misc<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size()) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(Competency::n_competencies));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competencies::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(Competency::un<a href="CppInitialize.htm">initialize</a>d) <a href="CppOperatorEqual.htm">==</a> 0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"Start the un<a href="CppInitialize.htm">initialize</a>d value at zero, so that GetAllCompetencies can check against n_competencies"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;Competencies c;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Competency&gt; v <a href="CppOperatorAssign.htm">=</a> c.GetAllCompetencies();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency t <a href="CppOperatorAssign.htm">=</a> v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> c.ToStr(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency u <a href="CppOperatorAssign.htm">=</a> c.ToType(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(u <a href="CppOperatorEqual.htm">==</a> t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency t <a href="CppOperatorAssign.htm">=</a> v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> c.ToStrDutch(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency u <a href="CppOperatorAssign.htm">=</a> c.ToTypeFromDutch(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(u <a href="CppOperatorEqual.htm">==</a> t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ToIndex<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.ToIndex(Competency::un<a href="CppInitialize.htm">initialize</a>d) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Competencies::ToIndex(<b><a href="CppConst.htm">const</a></b> Competency competency) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(competency);<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Competencies::ToStr(<b><a href="CppConst.htm">const</a></b> Competency type) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_map_english.left.empty()) m_map_english <a href="CppOperatorAssign.htm">=</a> CreateMapEnglish();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_map_english.left.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_map_english.left.count(type) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> m_map_english.left.find(type)-&gt;second;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Competencies::ToStrDutch(<b><a href="CppConst.htm">const</a></b> Competency type) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_map_dutch.left.empty()) m_map_dutch <a href="CppOperatorAssign.htm">=</a> CreateMapDutch();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_map_dutch.left.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_map_dutch.left.count(type) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> m_map_dutch.left.find(type)-&gt;second;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Competency <a href="CppRibi.htm">ribi</a>::cmap::Competencies::ToType(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_map_english.right.empty()) m_map_english <a href="CppOperatorAssign.htm">=</a> CreateMapEnglish();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_map_english.right.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_map_english.right.count(s) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency t <a href="CppOperatorAssign.htm">=</a> m_map_english.right.find(s)-&gt;second;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> t;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Competency <a href="CppRibi.htm">ribi</a>::cmap::Competencies::ToTypeFromDutch(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_map_dutch.right.empty()) m_map_dutch <a href="CppOperatorAssign.htm">=</a> CreateMapDutch();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_map_dutch.right.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_map_dutch.right.count(s) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency t <a href="CppOperatorAssign.htm">=</a> m_map_dutch.right.find(s)-&gt;second;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> t;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcompetency.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcompetency.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCOMPETENCY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCOMPETENCY_H<br/>
<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> Competency<br/>
{<br/>
&nbsp;&nbsp;un<a href="CppInitialize.htm">initialize</a>d,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Not yet set, must equal zero<br/>
&nbsp;&nbsp;profession,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>NL: 'Beroepsdomein'<br/>
&nbsp;&nbsp;organisations,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>NL: 'Organisaties'<br/>
&nbsp;&nbsp;social_surroundings, <a href="CppComment.htm">//</a>NL: 'Sociale omgeving'<br/>
&nbsp;&nbsp;target_audience,&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>NL 'Doelgroep'<br/>
&nbsp;&nbsp;ti_knowledge,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>'Technical Instrumental', NL: 'Technische instrumentele kennis'<br/>
&nbsp;&nbsp;prof_growth,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Professionele groei<br/>
&nbsp;&nbsp;misc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>NL: 'Overig'<br/>
&nbsp;&nbsp;n_competencies&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a> only<br/>
};<br/>
<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCOMPETENCY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapcompetency.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapcompetency.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconcept.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconcept.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPT_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPT_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A Concept is a <b><a href="CppClass.htm">class</a></b> that has a name and examples<br/>
<a href="CppComment.htm">///</a>A Concept is a Node without coordinats<br/>
<a href="CppComment.htm">///</a>A Concept is an Edge without coordinats, source and target<br/>
<a href="CppComment.htm">///</a>A Concept is the GUI independent part of a concept. It is displayed as:<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppQt.htm">Qt</a>ConceptDialog (as a <a href="CppQDialog.htm">QDialog</a>, to be used in a <a href="CppQDialog.htm">QDialog</a>)<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> (as part of <a href="CppQt.htm">Qt</a>Node)<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> (as part of <a href="CppQt.htm">Qt</a>Edge)<br/>
<b><a href="CppStruct.htm">struct</a></b> Concept<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block copying, as <b><a href="CppQtSignals.htm">signals</a></b> cannot be copied<br/>
&nbsp;&nbsp;Concept(<b><a href="CppConst.htm">const</a></b> Concept&amp; other) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Concept&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Concept&amp; other) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the examples of the concept, e.g. 'Plato', 'Aristotle'<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; GetExamples() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; GetExamples() <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_examples; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated the name of <b><a href="CppThis.htm">this</a></b> concept as being an addition to the complexity?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is something different than m_rating_complexity:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_is_complex can be used to help the assessor determine a m_rating_complexity,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/but m_rating_complexity is the <b><a href="CppFinal.htm">final</a></b> and complete rating<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsComplex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_complex; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the name of the concept, e.g. 'Philosphy'<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; GetName() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_name; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> complexity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetRatingComplexity() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_rating_complexity; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> concreteness<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetRatingConcreteness() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_rating_concreteness; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> specificity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetRatingSpecificity() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_rating_specificity; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the examples<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetExamples(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; examples) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated the name of <b><a href="CppThis.htm">this</a></b> concept as being an addition to the complexity?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is something different than m_rating_complexity:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_is_complex can be used to help the assessor determine a m_rating_complexity,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/but m_rating_complexity is the <b><a href="CppFinal.htm">final</a></b> and complete rating<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsComplex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the name<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetName(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> complexity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRatingComplexity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> concreteness<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRatingConcreteness(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> specificity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetRatingSpecificity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> Concept to a <b><a href="CppShort.htm">short</a></b> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> Concept to a <a href="CppStdString.htm">std::string</a> to write to file<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the examples are changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Concept*)&gt; m_signal_examples_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when IsComplex<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Concept*)&gt; m_signal_is_complex_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the name is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Concept*)&gt; m_signal_name_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the rating of the complexity is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Concept*)&gt; m_signal_rating_complexity_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the rating of the complexity is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Concept*)&gt; m_signal_rating_concreteness_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the rating of the specificity is changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Concept*)&gt; m_signal_rating_specificity_changed;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Examples of the concept, e.g. 'Plato', 'Aristotle'<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; m_examples;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated the name of <b><a href="CppThis.htm">this</a></b> concept as being an addition to the complexity?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This is something different than m_rating_complexity:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/m_is_complex can be used to help the assessor determine a m_rating_complexity,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/but m_rating_complexity is the <b><a href="CppFinal.htm">final</a></b> and complete rating<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_complex;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The name of the concept, e.g. 'Philosphy'<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_name;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> complexity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_rating_complexity;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> concreteness<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_rating_concreteness;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The rating of <b><a href="CppThis.htm">this</a></b> Concept <b><a href="CppFor.htm">for</a></b> specificity<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/-1: not rated, 0: lowest, 2: highest<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_rating_specificity;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use checked_delete <b><a href="CppFor.htm">for</a></b> <a href="CppDestructor.htm">destructor</a><br/>
&nbsp;&nbsp;~Concept() {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Concept* x);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Let only ConceptFactory <a href="CppConstructor.htm">construct</a> Concepts<br/>
&nbsp;&nbsp;Concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> ConceptFactory;<br/>
};<br/>
<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> Concept&amp; concept) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> Concept&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> Concept&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">///</a>Two Concept <a href="CppInstance.htm">instances</a> are ordered as follows:<br/>
<a href="CppComment.htm">///</a>(1) Alphabetically on the name<br/>
<a href="CppComment.htm">///</a>(2) (<b><a href="CppIf.htm">if</a></b> the names are equal) On their Examples<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> Concept&amp; rhs);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconcept.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconcept.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Concept::Concept(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity)<br/>
&nbsp;&nbsp;: m_signal_examples_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_complex_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_name_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_complexity_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_concreteness_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_specificity_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_examples{examples},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_complex{is_complex},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_name{name},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_complexity{rating_complexity},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_concreteness{rating_concreteness},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_specificity{rating_specificity}<br/>
<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity&nbsp;&nbsp; <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity&nbsp;&nbsp; <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity&nbsp;&nbsp;<a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity&nbsp;&nbsp;<a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::Concept::GetExamples() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_examples);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; p(m_examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetExamples(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt;&amp; examples) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (examples <a href="CppOperatorNotEqual.htm">!=</a> m_examples)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_examples <a href="CppOperatorAssign.htm">=</a> examples;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_examples_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetIsComplex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_complex <a href="CppOperatorNotEqual.htm">!=</a> m_is_complex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_complex <a href="CppOperatorAssign.htm">=</a> is_complex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_complex_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetName(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppThis.htm">this</a></b>-&gt;GetExamples());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (name <a href="CppOperatorNotEqual.htm">!=</a> m_name)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_name <a href="CppOperatorAssign.htm">=</a> name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_name_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetRatingComplexity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_rating_complexity <a href="CppOperatorNotEqual.htm">!=</a> rating_complexity)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_complexity <a href="CppOperatorAssign.htm">=</a> rating_complexity;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_complexity_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetRatingConcreteness(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_rating_concreteness <a href="CppOperatorNotEqual.htm">!=</a> rating_concreteness)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_concreteness <a href="CppOperatorAssign.htm">=</a> rating_concreteness;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_concreteness <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_concreteness_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::SetRatingSpecificity(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_rating_specificity <a href="CppOperatorNotEqual.htm">!=</a> rating_specificity)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rating_specificity <a href="CppOperatorAssign.htm">=</a> rating_specificity;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_rating_specificity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_rating_specificity_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Concept::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetName() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetExamples()-&gt;ToStr() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetIsComplex() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetRatingComplexity() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetRatingConcreteness() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetRatingSpecificity()<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s.str();<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Concept::To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;concept&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;name&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/name&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; GetExamples()-&gt;To<a href="CppXml.htm">Xml</a>()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;concept_is_complex&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetIsComplex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/concept_is_complex&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;complexity&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetRatingComplexity()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/complexity&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;concreteness&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetRatingConcreteness()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/concreteness&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;specificity&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetRatingSpecificity()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/specificity&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/concept&gt;"<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 19);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,9) <a href="CppOperatorEqual.htm">==</a> "&lt;concept&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> "&lt;/concept&gt;");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> Concept&amp; concept) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;os <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> concept.ToStr();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> os;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetIsComplex() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetIsComplex())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::IsComplex differs"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetName() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetName())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::Name differs"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingComplexity() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetRatingComplexity())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::RatingComplexity differs"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingConcreteness() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetRatingConcreteness())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::RatingConcreteness differs"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingSpecificity() <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetRatingSpecificity())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::RatingSpecificity differs"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lhs_examples <a href="CppOperatorAssign.htm">=</a> lhs.GetExamples();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rhs_examples <a href="CppOperatorAssign.htm">=</a> rhs.GetExamples();<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs_examples <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rhs_examples <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::Examples differs: lhs is <b><a href="CppNullptr.htm">nullptr</a></b>"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rhs_examples <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::Examples differs: rhs is <b><a href="CppNullptr.htm">nullptr</a></b>"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs_examples);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs_examples <a href="CppOperatorEqual.htm">==</a> rhs_examples) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs_examples <a href="CppOperatorEqual.htm">==</a> *rhs_examples)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Concept::Examples differs: content is different"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetName() &lt; rhs.GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetName() &gt; rhs.GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetExamples() &lt; *rhs.GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetExamples() <a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*lhs.GetExamples() <a href="CppOperatorEqual.htm">==</a> *rhs.GetExamples());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingComplexity() &lt; rhs.GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingComplexity() &gt; rhs.GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingConcreteness() &lt; rhs.GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetRatingConcreteness() &gt; rhs.GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.GetRatingSpecificity() &lt; rhs.GetRatingSpecificity();<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetName() &lt; rhs-&gt;GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetName() &gt; rhs-&gt;GetName()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetExamples() &lt; rhs-&gt;GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetExamples() <a href="CppOperatorNotEqual.htm">!=</a> rhs-&gt;GetExamples()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs-&gt;GetExamples() <a href="CppOperatorEqual.htm">==</a> rhs-&gt;GetExamples());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingComplexity() &lt; rhs-&gt;GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingComplexity() &gt; rhs-&gt;GetRatingComplexity()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingConcreteness() &lt; rhs-&gt;GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetRatingConcreteness() &gt; rhs-&gt;GetRatingConcreteness()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs-&gt;GetRatingSpecificity() &lt; rhs-&gt;GetRatingSpecificity();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(lhs) &lt; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(lhs) &lt; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs); <a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(lhs) &lt; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;(rhs);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconceptfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconceptfactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPTFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPTFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppArrayH.htm">array</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppArray.htm">array</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Creates Concepts<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptFactory<br/>
{<br/>
&nbsp;&nbsp;ConceptFactory();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Default and complete Create <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name <a href="CppOperatorAssign.htm">=</a> "...",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; examples <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Like a Concept deep-<a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&amp; concept<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Read concept from a <a href="CppStdString.htm">std::string</a> read from file<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain some testing concepts<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; &gt; GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(GetTests().size()); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPTFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapconceptfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapconceptfactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::ConceptFactory()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Concept(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rating_specificity<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(concept-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*examples <a href="CppOperatorEqual.htm">==</a> *concept-&gt;GetExamples());<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetName(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetIsComplex(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetRatingComplexity(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetRatingConcreteness(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept-&gt;GetRatingSpecificity());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*concept <a href="CppOperatorEqual.htm">==</a> *q);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">//</a>Do not create <b><a href="CppThis.htm">this</a></b> <a href="CppVersion.htm">version</a>: it will lead to ambiguities<br/>
<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt;&amp; examples)<br/>
<a href="CppComment.htm">//</a>{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Create(name,ExamplesFactory::Create(examples));<br/>
<a href="CppComment.htm">//</a>}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; v,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_complexity,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_concreteness,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rating_specificity<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt;&amp; p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.first,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; examples<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(w);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;examples,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_complexity,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_concreteness,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_specificity);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 19);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,9) <a href="CppOperatorEqual.htm">==</a> "&lt;concept&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> "&lt;/concept&gt;");<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> name;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; examples;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rating_complexity&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2; <a href="CppComment.htm">//</a>Not even unrated (which has <a href="CppOperatorMinus.htm">-</a>1 as its value)<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rating_concreteness&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2; <a href="CppComment.htm">//</a>Not even unrated (which has <a href="CppOperatorMinus.htm">-</a>1 as its value)<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rating_specificity&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2; <a href="CppComment.htm">//</a>Not even unrated (which has <a href="CppOperatorMinus.htm">-</a>1 as its value)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_name<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Name());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorNotEqual.htm">!=</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Name());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> t: v) { <a href="CppTRACE.htm">TRACE</a>(t); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("BREAK");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;name <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_examples<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Examples());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Get<a href="CppRegex.htm">Regex</a>Examples must be present once in a Concept");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;examples <a href="CppOperatorAssign.htm">=</a> ExamplesFactory().From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_is_complex<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>ConceptIsComplex());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Get<a href="CppRegex.htm">Regex</a>IsComplex must be present once per Concept");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_complex <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_rating_complexity<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Complexity());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Get<a href="CppRegex.htm">Regex</a>Complexity must be present once per Concept");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_complexity <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rating_complexity <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_rating_concreteness<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Concreteness());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_concreteness <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_rating_specificity<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Specificity());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rating_specificity <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(name,examples,is_complex,rating_complexity,rating_concreteness,rating_specificity)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(concept-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorEqual.htm">==</a> s); <a href="CppComment.htm">//</a>TODO RJCB: Put back in<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::GetTest(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; GetNumberOfTests());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;GetTests()[i]<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; &gt; v;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; examples <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept without examples", examples, <b><a href="CppFalse.htm">false</a></b>, 0, 1, 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with one example", { { "Only example", cmap::Competency::profession } }, 1, 2, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with two examples", { { "First example", cmap::Competency::organisations }, { "Second example", cmap::Competency::social_surroundings } }, 2, 0, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with three examples", { { "Example 1 of 3", cmap::Competency::target_audience }, { "Example 2 of 3", cmap::Competency::ti_knowledge }, { "Example 3 of 3", cmap::Competency::prof_growth } }, 0, 1, 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create("Concept with four Roman examples", { { "Example I/IV", cmap::Competency::misc }, { "Example II/IV", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d }, { "Example III/IV", cmap::Competency::profession }, { "Example III/IV", cmap::Competency::social_surroundings } }, 1, 2, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; p <a href="CppOperatorAssign.htm">=</a> Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Very <b><a href="CppLong.htm">long</a></b> multi-line concept with four Roman examples that also each span multiple lines, that is, eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example I/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::misc", cmap::Competency::misc },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example II/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example III/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::profession", cmap::Competency::profession },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "Example III/IV, spanning multiple lines (that is, having at least eight <a href="CppChar.htm">character</a>s) and is rated as cmap::Competency::social_surroundings", cmap::Competency::social_surroundings }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 1, 2, 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <a href="CppOperatorMinus.htm">-</a>1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;GetRatingComplexity() <a href="CppOperatorLessEqual.htm">&lt;=</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> !p; } ) <a href="CppOperatorEqual.htm">==</a> 0); <a href="CppComment.htm">//</a>FIX 2012-01-02<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(<a href="CppStdAll_of.htm">std::all_of</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> p; } ));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v[0]-&gt;GetExamples());<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::ConceptFactory::Test");<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ConceptFactory::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedge.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedge.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEDGE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEDGE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapelement.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> EdgeFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>An Edge is the GUI-independent part of the edges used in <a href="CppQt.htm">Qt</a>ConceptMap.<br/>
<a href="CppComment.htm">///</a>An Edge goes from one Node to another, which must a different Node,<br/>
/<a href="CppComment.htm">//</a> at the center of the Edge is a Node<br/>
<b><a href="CppStruct.htm">struct</a></b> Edge : <b><a href="CppPublic.htm">public</a></b> Element<br/>
{<br/>
&nbsp;&nbsp;Edge(<b><a href="CppConst.htm">const</a></b> Edge&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Edge&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Edge&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_node; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetNode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_node; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the Node <b><a href="CppThis.htm">this</a></b> edge originates from<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFrom() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_from; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetFrom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_from; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the Node index <b><a href="CppThis.htm">this</a></b> edge goes to<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetTo() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_to; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetTo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_to; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the x coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A Node has an X coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> GetX() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_x; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the y coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A Node has a Y coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> GetY() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_y; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Does the edge have an arrow at the head?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> HasHeadArrow() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_head_arrow; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Similar to <b><a href="CppOperatorEqual.htm">operator==</a></b>, except that the coordinats are not checked<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> HasSameContent(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Does the edge have an arrow at the tail?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> HasTailArrow() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_tail_arrow; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the Node index <b><a href="CppThis.htm">this</a></b> edge originates from<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetFrom(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set <b><a href="CppIf.htm">if</a></b> the head has an arrow<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetHeadArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_head_arrow) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the center Node<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the coordinat of the concept at the center of the node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetPos(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b> { SetX(x); SetY(y); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set <b><a href="CppIf.htm">if</a></b> the tail has an arrow<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetTailArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_tail_arrow) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the Node index <b><a href="CppThis.htm">this</a></b> edge goes to<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetTo(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the x coordinat of the concept at the center of the node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A Node has an X coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the y coordinat of the concept at the center of the node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>A Node has a Y coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> an Edge from an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The <a href="CppContainer.htm">container</a> of nodes is needed to <a href="CppConvert.htm">convert</a> the 'to' and 'from'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/field to indices<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when an Edge attribute has changed<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_from_changed;<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_head_arrow_changed;<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_node_changed;<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_tail_arrow_changed;<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_to_changed;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_x_changed;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b> (Edge*)&gt; m_signal_y_changed;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Node <b><a href="CppThis.htm">this</a></b> edge originates from<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_from;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Is there an arrowhead at the 'to' node?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_head_arrow;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Node on the Edge<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_node;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Is there an arrowhead at the 'from' node?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_tail_arrow;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Node <b><a href="CppThis.htm">this</a></b> edge goes to<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_to;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The x-coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> m_x;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The y-coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> m_y;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged();<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;Edge() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;~Edge() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge*);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(<b><a href="CppConst.htm">const</a></b> Edge*);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">constructor</a>, except <b><a href="CppFor.htm">for</a></b> EdgeFactory<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> EdgeFactory;<br/>
&nbsp;&nbsp;Edge(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; &amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow<br/>
&nbsp;&nbsp;);<br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> IsConnectedToCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; lhs,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEDGE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedge.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedge.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Edge::Edge(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow)<br/>
&nbsp;&nbsp;: m_signal_from_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_head_arrow_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_node_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_tail_arrow_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_to_changed{},<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;m_signal_x_changed{},<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;m_signal_y_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_from(from),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_head_arrow(head_arrow),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_node(node),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_tail_arrow(tail_arrow),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_to(to)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;m_x(concept_x),<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;m_y(concept_y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_node);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Subscribe to all Concept <b><a href="CppQtSignals.htm">signals</a></b> to re-<b><a href="CppEmit.htm">emit</a></b> m_signal_edge_changed<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_name_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_examples_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_complexity_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_concreteness_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_specificity_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Edge::~Edge() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_name_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_examples_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_complexity_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_concreteness_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_concept-&gt;m_signal_rating_specificity_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged,<b><a href="CppThis.htm">this</a></b>));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::<a href="CppEmit.htm">Emit</a><a href="CppSignal.htm">Signal</a>EdgeChanged()<br/>
{<br/>
&nbsp;&nbsp;m_signal_edge_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Edge::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.1";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Edge::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-xx-xx: <a href="CppVersion.htm">Version</a> 1.0: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2014-06-01: <a href="CppVersion.htm">Version</a> 1.1: replaced Concept, X and Y by a Node"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_node <a href="CppOperatorNotEqual.htm">!=</a> node)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_node <a href="CppOperatorAssign.htm">=</a> node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_node_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetFrom(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_from <a href="CppOperatorNotEqual.htm">!=</a> from)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_from <a href="CppOperatorAssign.htm">=</a> from;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_from_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetHeadArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_head_arrow) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_head_arrow <a href="CppOperatorNotEqual.htm">!=</a> has_head_arrow)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_head_arrow <a href="CppOperatorAssign.htm">=</a> has_head_arrow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_head_arrow_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetTailArrow(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> has_tail_arrow) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_tail_arrow <a href="CppOperatorNotEqual.htm">!=</a> has_tail_arrow)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_tail_arrow <a href="CppOperatorAssign.htm">=</a> has_tail_arrow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_tail_arrow_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetTo(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_to <a href="CppOperatorNotEqual.htm">!=</a> to)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_to <a href="CppOperatorAssign.htm">=</a> to;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_to_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_x <a href="CppOperatorNotEqual.htm">!=</a> x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_x_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_y <a href="CppOperatorNotEqual.htm">!=</a> y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_y_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test member variables<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Edge::Test");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nodes <a href="CppOperatorAssign.htm">=</a> Node::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(nodes.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_from <a href="CppOperatorAssign.htm">=</a> nodes[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_to&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> nodes[1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge: EdgeFactory().GetTests(node_from,node_to))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; c <a href="CppOperatorAssign.htm">=</a> EdgeFactory().DeepCopy(edge,node_from,node_to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*edge <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> *node_from);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetFrom() <a href="CppOperatorEqual.htm">==</a> *nodes[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> *node_to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c-&gt;GetTo() <a href="CppOperatorEqual.htm">==</a> *nodes[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> To<a href="CppXml.htm">Xml</a>(c,<a href="CppAdd.htm">Add</a>Const(nodes));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; d <a href="CppOperatorAssign.htm">=</a> EdgeFactory().From<a href="CppXml.htm">Xml</a>(s,nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*c <a href="CppOperatorNotEqual.htm">!=</a> *d)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(To<a href="CppXml.htm">Xml</a>(c,<a href="CppAdd.htm">Add</a>Const(nodes)));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(To<a href="CppXml.htm">Xml</a>(d,<a href="CppAdd.htm">Add</a>Const(nodes)));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Edge::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Edge::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> HasHeadArrow() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetNode()-&gt;ToStr() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> HasTailArrow() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetFrom()-&gt;ToStr() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetTo()-&gt;ToStr()<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s.str();<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Edge::To<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt;&amp; edge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt; &gt;&amp; nodes<br/>
) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;edge&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;GetNode()-&gt;GetConcept()-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetTo());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> from_index <a href="CppOperatorAssign.htm">=</a> <a href="CppStdDistance.htm">std::distance</a>(nodes.begin(),from_iter);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> to_index <a href="CppOperatorAssign.htm">=</a> <a href="CppStdDistance.htm">std::distance</a>(nodes.begin(),to_iter);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_index &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index <a href="CppOperatorNotEqual.htm">!=</a> to_index);<br/>
<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;from&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> from_index <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/from&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;head_arrow&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;HasHeadArrow() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/head_arrow&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;tail_arrow&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;HasTailArrow() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/tail_arrow&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;to&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> to_index <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/to&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;x&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;GetNode()-&gt;GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/x&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;y&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edge-&gt;GetNode()-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/y&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/edge&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,6) <a href="CppOperatorEqual.htm">==</a> "&lt;edge&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> "&lt;/edge&gt;");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::IsConnectedToCenterNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(IsCenterNode(edge-&gt;GetFrom()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> IsCenterNode(edge-&gt;GetTo()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "An Edge cannot be connected to two CenterNodes");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> IsCenterNode(edge-&gt;GetFrom()) <a href="CppOperatorLogicalOr.htm">||</a> IsCenterNode(edge-&gt;GetTo());<br/>
<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Edge&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetNode()); <a href="CppAssert.htm">assert</a>(rhs.GetNode());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetNode()&nbsp;&nbsp; <a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetNode()) <a href="CppTRACE.htm">TRACE</a>("Node differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetFrom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetFrom()) <a href="CppTRACE.htm">TRACE</a>("From node differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.GetTo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorNotEqual.htm">!=</a> *rhs.GetTo()) <a href="CppTRACE.htm">TRACE</a>("To node differs");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> ( lhs.GetX()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetX()) <a href="CppTRACE.htm">TRACE</a>("X differs");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> ( lhs.GetY()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorNotEqual.htm">!=</a> rhs.GetY()) <a href="CppTRACE.htm">TRACE</a>("Y differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( lhs.HasHeadArrow() <a href="CppOperatorNotEqual.htm">!=</a> rhs.HasHeadArrow()) <a href="CppTRACE.htm">TRACE</a>("Has head arrow differs");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( lhs.HasTailArrow() <a href="CppOperatorNotEqual.htm">!=</a> rhs.HasTailArrow()) <a href="CppTRACE.htm">TRACE</a>("Has tail arrow differs");<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *lhs.GetNode()&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> *rhs.GetNode()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *lhs.GetFrom()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> *rhs.GetFrom()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *lhs.GetTo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> *rhs.GetTo()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.GetX()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.GetY()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.HasHeadArrow() <a href="CppOperatorEqual.htm">==</a> rhs.HasHeadArrow()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;lhs.HasTailArrow() <a href="CppOperatorEqual.htm">==</a> rhs.HasTailArrow()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Edge&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedgefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedgefactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEDGEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEDGEFACTORY_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> EdgeFactory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The nodes need to be the deepcopied ones<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain an Edge from an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/You need the real nodes to connect the edge to<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; From<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; GetTest(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to<br/>
 ) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get testing edges connecting the two supplied nodes<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetTests(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEDGEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapedgefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapedgefactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> (from-&gt;GetX() <a href="CppOperatorPlus.htm">+</a> to-&gt;GetX()) <a href="CppOperatorDivide.htm">/</a> 2;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> (from-&gt;GetY() <a href="CppOperatorPlus.htm">+</a> to-&gt;GetY()) <a href="CppOperatorDivide.htm">/</a> 2;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept-&gt;GetExamples());<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept,x,y);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Edge(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail_arrow,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head_arrow<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_x,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> concept_y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> tail_arrow,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> head_arrow<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept()-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; p(<b><a href="CppNew.htm">new</a></b> Edge(node,from,tail_arrow,to,head_arrow));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; p(<b><a href="CppNew.htm">new</a></b> Edge(concept,concept_x,concept_y,from,tail_arrow,to,head_arrow));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Edge&gt; edge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode()-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetNode()-&gt;GetConcept()-&gt;GetExamples());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory().DeepCopy(edge-&gt;GetNode());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node <a href="CppOperatorAssign.htm">=</a> NodeFactory().DeepCopy(edge-&gt;GetNode());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;HasTailArrow(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;HasHeadArrow()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*edge <a href="CppOperatorEqual.htm">==</a> *p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::From<a href="CppXml.htm">Xml</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt;&amp; nodes<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,6) <a href="CppOperatorEqual.htm">==</a> "&lt;edge&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> "&lt;/edge&gt;");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Concept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory().From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_from<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> from <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>From());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;from <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_head_arrow<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> head_arrow <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>HeadArrow());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;head_arrow <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_tail_arrow<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> tail_arrow <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>TailArrow());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tail_arrow <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_to<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> to <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>To());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;to <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>X());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_y<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Y());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to&nbsp;&nbsp; &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(nodes.size()));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept,x,y);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(node,nodes[from],tail_arrow,nodes[to],head_arrow));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ConceptFactory().GetNumberOfTests();<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::GetTest(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; GetNumberOfTests());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> GetTests(from,to)[index];<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::EdgeFactory::GetTests(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; from,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; to<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> test_concepts <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests();<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> result;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept: test_concepts)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept,1.2,3.4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(node,from,<b><a href="CppFalse.htm">false</a></b>,to,<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,0,2,<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,0,3,<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,1,2,<b><a href="CppFalse.htm">false</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,1,3,<b><a href="CppFalse.htm">false</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge(<b><a href="CppNew.htm">new</a></b> Edge(concept,2,3,<b><a href="CppFalse.htm">false</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (GetNumberOfTests() <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(result.size()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "GetNumberOfTests should <b><a href="CppReturn.htm">return</a></b> " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> result.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(GetNumberOfTests() <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(result.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapelement.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapelement.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPELEMENT_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPELEMENT_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>A focusable element of a concept map, which is either a Node or an Edge<br/>
<b><a href="CppStruct.htm">struct</a></b> Element<br/>
{<br/>
&nbsp;&nbsp;Element() {}<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Element() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPELEMENT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapelement.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapelement.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmapelement.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexample.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexample.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLE_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppMake_shared.htm">make_shared</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ExampleFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A concept (on a node or an edge) can have examples<br/>
<a href="CppComment.htm">///</a>Example is displayed by:<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppQt.htm">Qt</a>ExampleDialog<br/>
<b><a href="CppStruct.htm">struct</a></b> Example<br/>
{<br/>
&nbsp;&nbsp;Example(<b><a href="CppConst.htm">const</a></b> Example&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Example&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Example&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a cmap::Competency to a <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> CompetencyToStr(<b><a href="CppConst.htm">const</a></b> Competency competency) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the competency, as might be judged by an assessor<br/>
&nbsp;&nbsp;Competency GetCompetency() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_competency; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the complexity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsComplex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_complex; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the concreteness?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsConcrete() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_concrete; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the specificity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetIsSpecific() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_specific; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the text of the example<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; GetText() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_text; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the competency<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetCompetency(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the complexity?<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsComplex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the concreteness?<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsConcrete(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the specificity?<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetIsSpecific(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the text<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetText(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; text) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> a <a href="CppStdString.htm">std::string</a> to a cmap::Competency<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> Competency StrToCompetency(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> Example to a <b><a href="CppShort.htm">short</a></b> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Convert</a> Example to an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when SetCompetency changes the competency<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_competency_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when m_is_complex is changed<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_is_complex_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when m_is_concrete is changed<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_is_concrete_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when m_is_specific is changed<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_is_specific_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when SetText changes the text<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Example*)&gt; m_signal_text_changed;<br/>
<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The competency, as might be judged by an assessor<br/>
&nbsp;&nbsp;Competency m_competency;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the complexity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_complex;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the concreteness?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_concrete;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Has an assessor rated <b><a href="CppThis.htm">this</a></b> example as being an addition to the specificity?<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_specific;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The text of the example<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/For example: 'Plato', 'When I was a kid', 'As I did on holiday'<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_text;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the competency with a string<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetCompetencyAsStr(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use checked_delete only<br/>
&nbsp;&nbsp;~Example() {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Example* x);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(<b><a href="CppConst.htm">const</a></b> Example* x);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppBoost.htm">boost</a>::detail::sp_ms_deleter&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example&gt;;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> <a href="CppBoost.htm">boost</a>::detail::sp_ms_deleter&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Only let ExampleFactory create Example <a href="CppInstance.htm">instances</a><br/>
&nbsp;&nbsp;Example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> ExampleFactory&amp; example_factory, <a href="CppComment.htm">//</a>To enforce its use<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency competency <a href="CppOperatorAssign.htm">=</a> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> ExampleFactory;<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Example&amp; lhs,<b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> Example&amp; lhs,<b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; lhs,<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexample.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexample.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetencies.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Example::Example(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> ExampleFactory&amp;,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency competency,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_signal_competency_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_complex_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_concrete_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_specific_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_text_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_competency(competency),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_complex(is_complex),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_concrete(is_concrete),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_specific(is_specific),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_text(text)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::CompetencyToStr(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (competency)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d: <b><a href="CppReturn.htm">return</a></b> "un<a href="CppInitialize.htm">initialize</a>d";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::profession: <b><a href="CppReturn.htm">return</a></b> "profession";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::organisations: <b><a href="CppReturn.htm">return</a></b> "organisations";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::social_surroundings: <b><a href="CppReturn.htm">return</a></b> "social_surroundings";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::target_audience: <b><a href="CppReturn.htm">return</a></b> "target_audience";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::ti_knowledge: <b><a href="CppReturn.htm">return</a></b> "ti_knowledge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::prof_growth: <b><a href="CppReturn.htm">return</a></b> "prof_growth";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> cmap::Competency::misc: <b><a href="CppReturn.htm">return</a></b> "misc";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("<a href="CppRibi.htm">ribi</a>::cmap::Example::CompetencyToStr: unknown Competency");<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetCompetency(<b><a href="CppConst.htm">const</a></b> cmap::Competency competency) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency competency_before <a href="CppOperatorAssign.htm">=</a> m_competency;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency competency_after&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp; competency;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (competency_before <a href="CppOperatorNotEqual.htm">!=</a> competency_after)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_competency <a href="CppOperatorEqual.htm">==</a> competency_before);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Example will change Competency from " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Competencies().ToStr(competency_before)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " to " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Competencies().ToStr(competency_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_competency <a href="CppOperatorAssign.htm">=</a> competency;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_competency <a href="CppOperatorEqual.htm">==</a> competency_after);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_competency_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_competency <a href="CppOperatorEqual.htm">==</a> competency_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Competency changed to " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Competencies().ToStr(m_competency);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetIsComplex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_is_complex <a href="CppOperatorNotEqual.htm">!=</a> is_complex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_complex <a href="CppOperatorAssign.htm">=</a> is_complex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_complex_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetIsConcrete(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_is_concrete <a href="CppOperatorNotEqual.htm">!=</a> is_concrete)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_concrete <a href="CppOperatorAssign.htm">=</a> is_concrete;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_concrete_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetIsSpecific(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_is_specific <a href="CppOperatorNotEqual.htm">!=</a> is_specific)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_specific <a href="CppOperatorAssign.htm">=</a> is_specific;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_is_specific_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::SetText(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; text) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_text <a href="CppOperatorNotEqual.htm">!=</a> text)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_text <a href="CppOperatorAssign.htm">=</a> text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_text_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Competency <a href="CppRibi.htm">ribi</a>::cmap::Example::StrToCompetency(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "un<a href="CppInitialize.htm">initialize</a>d") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "profession") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::profession;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "organisations") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::organisations;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "social_surroundings") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::social_surroundings;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "target_audience") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::target_audience;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "ti_knowledge") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::ti_knowledge;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "prof_growth") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::prof_growth;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "misc") <b><a href="CppReturn.htm">return</a></b> cmap::Competency::misc;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("<a href="CppRibi.htm">ribi</a>::cmap::Example::StrToCompetency: unknown string");<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Starting <a href="CppRibi.htm">ribi</a>::cmap::Example::Test");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test basic set and get<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency competency_before <a href="CppOperatorAssign.htm">=</a> Competency::un<a href="CppInitialize.htm">initialize</a>d;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Competency competency_after <a href="CppOperatorAssign.htm">=</a> Competency::misc;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex_before&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex_after&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete_before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete_after&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific_before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific_after&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> text_before <a href="CppOperatorAssign.htm">=</a> "before";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> text_after&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> "after";<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> example&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_before,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;competency_before,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_complex_before,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_concrete_before,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_specific_before<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetCompetency() <a href="CppOperatorEqual.htm">==</a> competency_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetCompetency() <a href="CppOperatorNotEqual.htm">!=</a> competency_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsComplex() <a href="CppOperatorEqual.htm">==</a> is_complex_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsComplex() <a href="CppOperatorNotEqual.htm">!=</a> is_complex_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsConcrete() <a href="CppOperatorEqual.htm">==</a> is_concrete_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsConcrete() <a href="CppOperatorNotEqual.htm">!=</a> is_concrete_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsSpecific() <a href="CppOperatorEqual.htm">==</a> is_specific_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsSpecific() <a href="CppOperatorNotEqual.htm">!=</a> is_specific_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetText() <a href="CppOperatorEqual.htm">==</a> text_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetText() <a href="CppOperatorNotEqual.htm">!=</a> text_after);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;SetCompetency(competency_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;SetIsComplex(is_complex_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;SetIsConcrete(is_concrete_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;SetIsSpecific(is_specific_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;SetText(text_after);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetCompetency() <a href="CppOperatorNotEqual.htm">!=</a> competency_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetCompetency() <a href="CppOperatorEqual.htm">==</a> competency_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsComplex() <a href="CppOperatorNotEqual.htm">!=</a> is_complex_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsComplex() <a href="CppOperatorEqual.htm">==</a> is_complex_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsConcrete() <a href="CppOperatorNotEqual.htm">!=</a> is_concrete_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsConcrete() <a href="CppOperatorEqual.htm">==</a> is_concrete_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsSpecific() <a href="CppOperatorNotEqual.htm">!=</a> is_specific_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetIsSpecific() <a href="CppOperatorEqual.htm">==</a> is_specific_after);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetText() <a href="CppOperatorNotEqual.htm">!=</a> text_before);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;GetText() <a href="CppOperatorEqual.htm">==</a> text_after);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test of <b><a href="CppOperatorEqual.htm">operator==</a></b> and <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> ExampleFactory().GetNumberOfTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; a <a href="CppOperatorAssign.htm">=</a> ExampleFactory().GetTest(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example&gt; b <a href="CppOperatorAssign.htm">=</a> ExampleFactory().GetTest(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; c <a href="CppOperatorAssign.htm">=</a> ExampleFactory().GetTest(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example&gt; d <a href="CppOperatorAssign.htm">=</a> ExampleFactory().GetTest(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> unrated and rated examples are noticed as different<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; a <a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; b <a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; c <a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create("1",Competency::un<a href="CppInitialize.htm">initialize</a>d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> between <a href="CppStdString.htm">std::string</a> and competency<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Checked by Competencies<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Competency&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::profession,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::organisations,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::social_surroundings,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::target_audience,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::ti_knowledge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::prof_growth,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmap::Competency::misc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> cmap::Competency&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppRibi.htm">ribi</a>::Example::CompetencyToStr(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Competency&gt; x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(w.begin(),w.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(x),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Example::StrToCompetency(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> between <b><a href="CppClass.htm">class</a></b> and <a href="CppXml.htm">XML</a>, test <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ExampleFactory().GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s { e-&gt;To<a href="CppXml.htm">Xml</a>() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; f(ExampleFactory().From<a href="CppXml.htm">Xml</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ExampleFactory().GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; e <a href="CppOperatorAssign.htm">=</a> v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s { e-&gt;To<a href="CppXml.htm">Xml</a>() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; f <a href="CppOperatorAssign.htm">=</a> v[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> f-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorEqual.htm">==</a> t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( s <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Example::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetText() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Competencies().ToStr(GetCompetency()) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetIsComplex() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetIsConcrete() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetIsSpecific()<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s.str();<br/>
<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Example::To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;example&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;text&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetText();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/text&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;competency&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Competencies().ToStr(GetCompetency());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; CompetencyToStr(GetCompetency());<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/competency&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;is_complex&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetIsComplex();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/is_complex&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;is_concrete&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetIsConcrete();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/is_concrete&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;is_specific&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;&nbsp; GetIsSpecific();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a>&nbsp;&nbsp; "&lt;/is_specific&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/example&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 17);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,9) <a href="CppOperatorEqual.htm">==</a> "&lt;example&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> "&lt;/example&gt;");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetText() <a href="CppOperatorEqual.htm">==</a> rhs.GetText()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetCompetency() <a href="CppOperatorEqual.htm">==</a> rhs.GetCompetency();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs,<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetText() &lt; rhs.GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetText() &gt; rhs.GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.GetCompetency() &lt; rhs.GetCompetency();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; lhs,<b><a href="CppConst.htm">const</a></b> cmap::Example&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetText() &gt; rhs.GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetText() &lt; rhs.GetText()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs.GetCompetency() &gt; rhs.GetCompetency();<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplefactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLEFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ExampleFactory<br/>
{<br/>
&nbsp;&nbsp;ExampleFactory() {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an example from string and <b><a href="CppEnum.htm">enum</a></b><br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency&amp; competency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create examples <b><a href="CppFor.htm">for</a></b> strings<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Note that all cmap::Competency values are set to un<a href="CppInitialize.htm">initialize</a>d<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; CreateExamples(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an example from <a href="CppXml.htm">XML</a><br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(GetTests().size()); }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplefactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppMake_shared.htm">make_shared</a>.hpp&gt;<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; text,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> cmap::Competency&amp; competency,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_complex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_concrete,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_specific<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;competency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_complex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_concrete,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_specific<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> example;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 17);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,9) <a href="CppOperatorEqual.htm">==</a> "&lt;example&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 10,10) <a href="CppOperatorEqual.htm">==</a> "&lt;/example&gt;");<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> text;<br/>
&nbsp;&nbsp;cmap::Competency competency <a href="CppOperatorAssign.htm">=</a> cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_complex <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_concrete <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> is_specific <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>competency<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Competency());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;competency <a href="CppOperatorAssign.htm">=</a> Example::StrToCompetency(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>is_complex<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>IsComplex());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_complex <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>is_concrete<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>IsConcrete());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_concrete <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>is_specific<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>IsSpecific());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_specific <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>text<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Text());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Get<a href="CppRegex.htm">Regex</a>Text must be present once in an Example");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;text <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; example<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(text,competency,is_complex,is_concrete,is_specific)<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorEqual.htm">==</a> s);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> example;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; GetNumberOfTests());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> GetTests()[i];<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Example<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::ExampleFactory::GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 0",Competency::profession,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 1",Competency::organisations,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 2",Competency::social_surroundings,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 3",Competency::target_audience,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 4",Competency::ti_knowledge,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 5",Competency::prof_growth,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("Test example 6",Competency::misc,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create("",Competency::un<a href="CppInitialize.htm">initialize</a>d,<b><a href="CppTrue.htm">true</a></b>,<b><a href="CppFalse.htm">false</a></b>,<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;};<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamples.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamples.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLES_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLES_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppContainer.htm">Container</a> of Example <a href="CppInstance.htm">instances</a><br/>
<a href="CppComment.htm">///</a>Examples is displayed by<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> ?<a href="CppQt.htm">Qt</a>ExamplesItem: a <a href="CppQGraphicsItem.htm">QGraphicsItem</a>, to be used in a <a href="CppQGraphicsView.htm">QGraphicsView</a><br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppQt.htm">Qt</a>ExamplesDialog: a <a href="CppQDialog.htm">QDialog</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Examples<br/>
{<br/>
&nbsp;&nbsp;Examples(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v);<br/>
&nbsp;&nbsp;Examples(<b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Examples&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Example&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; Get() <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_v; }<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Get() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Something of one of the examples was changed<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Examples*)&gt; m_signal_examples_changed;<br/>
<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;~Examples() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_v;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; example);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/All <b><a href="CppQtSignals.htm">signals</a></b> <a href="CppEmit.htm">emitted</a> from the examples are connected to <b><a href="CppThis.htm">this</a></b> <a href="CppMemberFunction.htm">member function</a><br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> OnExampleChanged() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Correct <a href="CppFriend.htm">befriending</a>, from http://richelbilderbeek.nl/CppChecked_delete.htm<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Examples* x);<br/>
};<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> Examples&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> Examples&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">///</a>Two cmap::Examples <a href="CppInstance.htm">instances</a> are sorted as follows:<br/>
<a href="CppComment.htm">///</a>(1) By their number of examples<br/>
<a href="CppComment.htm">///</a>(2) (<b><a href="CppIf.htm">if</a></b> the sizes are equal) Alphabetically on the first different example<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> Examples&amp; rhs);<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b>&gt;(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperator.htm">operator</a></b><a href="CppOperatorGreaterEqual.htm">&gt;=</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;&amp; lhs, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamples.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamples.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/bind.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/lambda/lambda.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Examples::Examples(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v)<br/>
&nbsp;&nbsp;: m_signal_examples_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_v(v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> example: m_v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_competency_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_is_complex_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_is_concrete_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_is_specific_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_text_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount_if.htm">std::count_if</a>(m_v.begin(),m_v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt;&amp; e) { <b><a href="CppReturn.htm">return</a></b> !e; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;) <a href="CppOperatorEqual.htm">==</a> 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "All Example <a href="CppInstance.htm">instances</a> must be <a href="CppInitialize.htm">initialize</a>d");<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Examples::~Examples() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> example: m_v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_competency_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_is_complex_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_is_concrete_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_is_specific_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;example-&gt;m_signal_text_changed.disconnect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;Examples::OnExampleChanged,<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples::<a href="CppAdd.htm">Add</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt;&amp; example)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(example);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Connect the example<br/>
&nbsp;&nbsp;example-&gt;m_signal_competency_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;Examples::OnExampleChanged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;example-&gt;m_signal_text_changed.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;Examples::OnExampleChanged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> the example and notify <b><a href="CppThis.htm">this</a></b> change<br/>
&nbsp;&nbsp;m_v.push_back(example);<br/>
&nbsp;&nbsp;m_signal_examples_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Example&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::Examples::Get() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppAdd.htm">Add</a>Const(m_v);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples::OnExampleChanged() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_signal_examples_changed(<b><a href="CppThis.htm">this</a></b>); <br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Examples::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Examples::Test");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test of <b><a href="CppOperatorEqual.htm">operator==</a></b> and <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> ExamplesFactory().GetNumberOfTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; a <a href="CppOperatorAssign.htm">=</a> ExamplesFactory().GetTest(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples&gt; b <a href="CppOperatorAssign.htm">=</a> ExamplesFactory().GetTest(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; c <a href="CppOperatorAssign.htm">=</a> ExamplesFactory().GetTest(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples&gt; d <a href="CppOperatorAssign.htm">=</a> ExamplesFactory().GetTest(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> between <b><a href="CppClass.htm">class</a></b> and <a href="CppXml.htm">XML</a>, test <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ExamplesFactory().GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt;&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(e);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s { e-&gt;To<a href="CppXml.htm">Xml</a>() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; f(ExamplesFactory().From<a href="CppXml.htm">Xml</a>(s));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ExamplesFactory().GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt;&amp; e <a href="CppOperatorAssign.htm">=</a> v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s { e-&gt;To<a href="CppXml.htm">Xml</a>() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Examples&gt;&amp; f <a href="CppOperatorAssign.htm">=</a> v[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> t { f-&gt;To<a href="CppXml.htm">Xml</a>() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( s <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( s <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> unrated and rated examples are noticed as different<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; a <a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; b <a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create("1",Competency::misc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; c <a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create("1",Competency::un<a href="CppInitialize.htm">initialize</a>d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; v; v.push_back(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; w; w.push_back(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; x; x.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; d <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; e <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; f <a href="CppOperatorAssign.htm">=</a> ExamplesFactory::Create(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *e); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *d); <a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorEqual.htm">==</a> *e); <a href="CppAssert.htm">assert</a>(*e <a href="CppOperatorNotEqual.htm">!=</a> *f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*f <a href="CppOperatorNotEqual.htm">!=</a> *d); <a href="CppAssert.htm">assert</a>(*f <a href="CppOperatorNotEqual.htm">!=</a> *e); <a href="CppAssert.htm">assert</a>(*f <a href="CppOperatorEqual.htm">==</a> *f);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Examples::Test finished successfully");<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Examples::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "{ ";<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; examples <a href="CppOperatorAssign.htm">=</a> c-&gt;GetExamples();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> example: Get())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> example-&gt;ToStr() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " ";<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "}";<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s.str();<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Examples::To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;examples&gt;";<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; examples <a href="CppOperatorAssign.htm">=</a> c-&gt;GetExamples();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> example <a href="CppOperatorAssign.htm">=</a> Get();<br/>
&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(example.begin(),example.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[&amp;s](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; t)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> t-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/examples&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 20);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,10) <a href="CppOperatorEqual.htm">==</a> "&lt;examples&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 11,11) <a href="CppOperatorEqual.htm">==</a> "&lt;/examples&gt;");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.Get().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().empty()) { <a href="CppAssert.htm">assert</a>(rhs.Get().empty()); <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>; }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> lhs.Get();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt; &gt; w <a href="CppOperatorAssign.htm">=</a> rhs.Get();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdEqual.htm">std::equal</a>(v.begin(),v.end(),w.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; a, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Example&gt;&amp; b)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *a <a href="CppOperatorEqual.htm">==</a> *b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; lhs, <b><a href="CppConst.htm">const</a></b> cmap::Examples&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().size() &lt; rhs.Get().size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.Get().size() &gt; rhs.Get().size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.Get().size() <a href="CppOperatorEqual.htm">==</a> rhs.Get().size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> lhs.Get().size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.Get()[i] &lt; *rhs.Get()[i]) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*lhs.Get()[i] &gt; *rhs.Get()[i]) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplesfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplesfactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPEXAMPLESFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPEXAMPLESFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> ExamplesFactory<br/>
{<br/>
&nbsp;&nbsp;ExamplesFactory() {}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConstructor.htm">Constructor</a> like<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Copy-<a href="CppConstructor.htm">constructor</a> like<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; examples);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; v);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Create an Examples from <a href="CppXml.htm">XML</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(GetTests().size()); }<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPEXAMPLESFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapexamplesfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapexamplesfactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexample.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamples.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; examples(<b><a href="CppNew.htm">new</a></b> Examples( {} ));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> examples;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Examples&gt;&amp; examples)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; p <a href="CppOperatorAssign.htm">=</a> Create(examples-&gt;Get());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; p(<b><a href="CppNew.htm">new</a></b> Examples(v));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt; &gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Example&gt;&amp; p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create(p-&gt;GetText(),p-&gt;GetCompetency());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; examples(<b><a href="CppNew.htm">new</a></b> Examples(w));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(examples);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> examples;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt;&amp; p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory().Create(p.first,p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; q <a href="CppOperatorAssign.htm">=</a> Create(w);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() &lt; 20)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.substr(0,10) <a href="CppOperatorNotEqual.htm">!=</a> "&lt;examples&gt;")<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 11,11) <a href="CppOperatorNotEqual.htm">!=</a> "&lt;/examples&gt;")<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt;();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,"(&lt;examples&gt;)").size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,"(&lt;/examples&gt;)").size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Example&gt; &gt; examples;<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,"(&lt;example&gt;)").size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,"(&lt;/example&gt;)").size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Example());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(examples),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ExampleFactory().From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Examples&gt; result {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Create(examples)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(result);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(result-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorNotEqual.htm">!=</a> s)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(result-&gt;To<a href="CppXml.htm">Xml</a>());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("BREAK");<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(result-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorEqual.htm">==</a> s); <a href="CppComment.htm">//</a>TODO RJCB: put back in<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; GetNumberOfTests());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> GetTests()[i];<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; is <a href="CppOperatorAssign.htm">=</a> { {0}, {1}, {0,1,2,3}, {} };<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; &gt; v;<br/>
&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(is.begin(),is.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<b><a href="CppThis.htm">this</a></b>](<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp; js)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; &gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(js.begin(),js.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>&amp; j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;cmap::Example&gt; p<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ExampleFactory().GetTest(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Examples&gt; q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::cmap::ExamplesFactory::Create(w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapfactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPCONCEPTMAPFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPCONCEPTMAPFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppArrayH.htm">array</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Factory <b><a href="CppClass.htm">class</a></b> to create ConceptMaps<br/>
<a href="CppComment.htm">///</a>ConceptMapFactory is the only <b><a href="CppClass.htm">class</a></b> <b><a href="CppUsing.htm">using</a></b> the ConceptMap <a href="CppConstructor.htm">constructor</a><br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMapFactory<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges <a href="CppOperatorAssign.htm">=</a> {});<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; map);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain a ConceptMap from an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get all the other tests as one vector<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetAllTests();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the documented heteromorphous test concept maps<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the documented complex homomorphous test concept maps<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the documented simple homomorphous test concept maps<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPCONCEPTMAPFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapfactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "<a href="CppFileIo.htm">fileio</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; nodes,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; edges)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; p(<b><a href="CppNew.htm">new</a></b> ConceptMap(nodes,edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;IsValid());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; map)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!map) <b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt;();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map-&gt;IsValid() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a valid original");<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Deep-copy the center node <b><a href="CppIf.htm">if</a></b> present<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Deep-copy the non-center nodes<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes <a href="CppOperatorAssign.htm">=</a> map-&gt;GetNodes();<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> new_nodes;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node: nodes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; new_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt; center_node<br/>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostDynamic_pointer_cast.htm">boost::dynamic_pointer_cast</a>&lt;<b><a href="CppConst.htm">const</a></b> CenterNode&gt;(node))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(center_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_node <a href="CppOperatorAssign.htm">=</a> CenterNodeFactory().DeepCopy(center_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_node <a href="CppOperatorAssign.htm">=</a> NodeFactory().DeepCopy(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*new_node <a href="CppOperatorEqual.htm">==</a> *node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new_nodes.push_back(new_node);<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Deep-copy the edges<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; &gt; edges <a href="CppOperatorAssign.htm">=</a> map-&gt;GetEdges();<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> new_edges;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; edge: edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the <b><a href="CppNew.htm">new</a></b> from node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> from_index <a href="CppOperatorAssign.htm">=</a> <a href="CppStdDistance.htm">std::distance</a>(nodes.begin(),from_iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(new_nodes.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from <a href="CppOperatorAssign.htm">=</a> new_nodes[from_index];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the <b><a href="CppNew.htm">new</a></b> to node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_iter <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_iter <a href="CppOperatorNotEqual.htm">!=</a> nodes.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> to_index <a href="CppOperatorAssign.htm">=</a> <a href="CppStdDistance.htm">std::distance</a>(nodes.begin(),to_iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to_index &lt; <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(new_nodes.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to <a href="CppOperatorAssign.htm">=</a> new_nodes[to_index];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from_index <a href="CppOperatorNotEqual.htm">!=</a> to_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from <a href="CppOperatorNotEqual.htm">!=</a> to);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; new_edge {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().DeepCopy(edge,from,to)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*new_edge <a href="CppOperatorEqual.htm">==</a> *edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new_edges.push_back(new_edge);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; p <a href="CppOperatorAssign.htm">=</a> Create(new_nodes,new_edges);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*p <a href="CppOperatorEqual.htm">==</a> *map <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( p <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;map <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a deep copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p-&gt;IsValid() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a valid copy");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">///</a>TODO: let CenterNodes manage their own &lt;center_node&gt; tags<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> &amp;s)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 27);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(0,13) <a href="CppOperatorEqual.htm">==</a> "&lt;concept_map&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 14,14) <a href="CppOperatorEqual.htm">==</a> "&lt;/concept_map&gt;");<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;concept_map&gt; ... &lt;/concept_map&gt; string<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,("(&lt;concept_map&gt;.*&lt;/concept_map&gt;)"));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Strip the &lt;concept_map&gt; tags<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> concept_map_str <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;nodes&gt; ... &lt;/nodes&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(concept_map_str,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Nodes());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Strip the &lt;nodes&gt; tags<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> nodes_str <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(w[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>CenterNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(nodes_str,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>CenterNode());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x.empty() <a href="CppOperatorLogicalOr.htm">||</a> x.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(x.begin(),x.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&amp;nodes](<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().From<a href="CppXml.htm">Xml</a>(s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Regular nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(nodes_str,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Node());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(x.begin(),x.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&amp;nodes](<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().From<a href="CppXml.htm">Xml</a>(s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes.push_back(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Replace the first node by its CenterNode equivalent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!nodes.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !IsCenterNode(nodes[0]))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; old_node <a href="CppOperatorAssign.htm">=</a> nodes[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept <a href="CppOperatorAssign.htm">=</a> old_node-&gt;GetConcept();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> old_node-&gt;GetX();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> old_node-&gt;GetY();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; center_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().Create(concept,x,y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes[0] <a href="CppOperatorAssign.htm">=</a> center_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*old_node <a href="CppOperatorEqual.htm">==</a> *center_node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(nodes.empty() <a href="CppOperatorLogicalOr.htm">||</a> IsCenterNode(nodes[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> edges;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;edges&gt; ... &lt;/edges&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(concept_map_str,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Edges());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Strip the &lt;edges&gt; tags<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> nodes_str <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Obtain the &lt;edge&gt; ... &lt;/edge&gt; strings<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(nodes_str,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Edge());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s: x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().From<a href="CppXml.htm">Xml</a>(s,nodes)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<b><a href="CppNew.htm">new</a></b> ConceptMap(nodes,edges));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept_map;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetAllTests()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(w.begin(),w.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; w <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(w.begin(),w.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(w.begin(),w.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(v));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> empty concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v(20);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> p; } ) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[0]: empty concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[0]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[1]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[2]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[2]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[3]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("edge_a concept"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_d(NodeFactory().Create(concept_d,1.2,3.4));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cmap::EdgeFactory().Create(concept_d,1.2,3.4,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_d,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[3]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[4]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("edge_a concept"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_d(NodeFactory().Create(concept_d,1.2,3.4));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cmap::EdgeFactory().Create(concept_d,1.2,3.4,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_d,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[4]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[5]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_d(NodeFactory().Create(concept_d,1.2,3.4));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_d,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[5]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[6]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_d(NodeFactory().Create(concept_d,1.2,3.4));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_d,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[6]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[7]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[7]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[8]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge_a(EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[8]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[9]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_a(EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[9]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[10]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[10]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[11]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(nodes,edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[11]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[12]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[12]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[13]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("2"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[13]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[14]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[14]=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[15]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create("B", { {"B-1",cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} },0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("C", { {"C-1",cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"C-2",cmap::Competency::misc}},-1,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("D", { {"D-1",cmap::Competency::misc},{"D-2",cmap::Competency::misc},{"D-3",cmap::Competency::misc}},-1,-1,-1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory().Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_h(ConceptFactory().Create("2",{{"2-I",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3",{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_i(ConceptFactory().Create("4",{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_j(ConceptFactory().Create("5",{{"5-I",cmap::Competency::misc},{"5-II",cmap::Competency::misc},{"5-III",cmap::Competency::misc},{"5-IV",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_h(NodeFactory().Create(concept_h,3.4,5.6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_i(NodeFactory().Create(concept_i,4.5,6.7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_j(NodeFactory().Create(concept_j,5.6,7.8));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_h,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_i,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_j,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(15)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[16]: complex rated concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create("B", { {"B-1: profession",cmap::Competency::profession} },0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("C", { {"C-1: organisations",cmap::Competency::organisations},{"C-2: social_surroundings",cmap::Competency::social_surroundings}},2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("D", { {"D-1: target_audience",cmap::Competency::target_audience},{"D-2: ti_knowledge",cmap::Competency::ti_knowledge},{"D-3: prof_growth",cmap::Competency::prof_growth},{"D-4: misc",cmap::Competency::misc}},0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory().Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_h(ConceptFactory().Create("2",{{"2-I",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3",{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_i(ConceptFactory().Create("4",{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_j(ConceptFactory().Create("5",{{"5-I",cmap::Competency::misc},{"5-II",cmap::Competency::misc},{"5-III",cmap::Competency::misc},{"5-IV",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_h(NodeFactory().Create(concept_h,3.4,5.6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_i(NodeFactory().Create(concept_i,4.5,6.7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_j(NodeFactory().Create(concept_j,5.6,7.8));<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_h,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_i,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_j,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(16)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[17]: complex rated concept map with many examples<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create("B",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-P",cmap::Competency::profession},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-O",cmap::Competency::organisations},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-S",cmap::Competency::social_surroundings},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TA",cmap::Competency::target_audience},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TK",cmap::Competency::ti_knowledge},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-PG",cmap::Competency::prof_growth},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-M",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("C",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {"C-1: organisations",cmap::Competency::organisations},{"C-2: social_surroundings",cmap::Competency::social_surroundings}},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("D",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ {"D-1: target_audience",cmap::Competency::target_audience},{"D-2: ti_knowledge",cmap::Competency::ti_knowledge},{"D-3: prof_growth",cmap::Competency::prof_growth},{"D-4: misc",cmap::Competency::misc}},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory().Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"2-I",cmap::Competency::misc}}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_h(ConceptFactory().Create("2",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"2-I",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_i(ConceptFactory().Create("4",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_j(ConceptFactory().Create("5",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{"5-I",cmap::Competency::misc},{"5-II",cmap::Competency::misc},{"5-III",cmap::Competency::misc},{"5-IV",cmap::Competency::misc} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_h(NodeFactory().Create(concept_h,3.4,5.6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_i(NodeFactory().Create(concept_i,4.5,6.7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_j(NodeFactory().Create(concept_j,5.6,7.8));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_h,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_i,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_j,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(17)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[18]: complex rated concept map with many <b><a href="CppLong.htm">long</a></b> concept names and examples<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"B: This is a concept that has all types of competencies as its examples, each example name being multiple lines as well",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-P: <b><a href="CppThis.htm">this</a></b> is B its first example (out of seven) and it is categorized as a competency in the profession domain",cmap::Competency::profession},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-O: <b><a href="CppThis.htm">this</a></b> is B its second example (out of seven) and it is categorized as a competency in the organisation domain",cmap::Competency::organisations},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-S: <b><a href="CppThis.htm">this</a></b> is B its third example (out of seven) and it is categorized as a competency in the social surroundings domain",cmap::Competency::social_surroundings},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TA: <b><a href="CppThis.htm">this</a></b> is B its fourth example (out of seven) and it is categorized as a competency in the target audience domain",cmap::Competency::target_audience},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-TK: <b><a href="CppThis.htm">this</a></b> is B its fifth example (out of seven) and it is categorized as a competency in the technical instrumental knowledge domain",cmap::Competency::ti_knowledge},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-PG: <b><a href="CppThis.htm">this</a></b> is B its sixth example (out of seven) and it is categorized as a competency in the professional growth domain",cmap::Competency::prof_growth},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"B-M: <b><a href="CppThis.htm">this</a></b> is B its seventh example (out of seven) and it is categorized as a competency in the misc domain",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"C: This is a concept that has only two of the seven types of competencies as its examples, each example name being multiple lines as well",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"C-O: <b><a href="CppThis.htm">this</a></b> is C its first example (out of two) and it is categorized as a competency in the organisation domain",cmap::Competency::organisations},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"C-S: <b><a href="CppThis.htm">this</a></b> is C its second example (out of two) and it is categorized as a competency in the social surroundings domain",cmap::Competency::social_surroundings}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"D: This is a concept that has only four of the seven types of competencies as its examples, each example name being multiple lines as well",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-TA: <b><a href="CppThis.htm">this</a></b> is D its first example (out of four) and it is categorized as a competency in the target audience domain",cmap::Competency::target_audience},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-TK: <b><a href="CppThis.htm">this</a></b> is D its second example (out of four) and it is categorized as a competency in the technical instrumental knowledge domain",cmap::Competency::ti_knowledge},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-PG: <b><a href="CppThis.htm">this</a></b> is D its third example (out of four) and it is categorized as a competency in the professional growth domain",cmap::Competency::prof_growth},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"D-M: <b><a href="CppThis.htm">this</a></b> is D its fourth example (out of four) and it is categorized as a competency in the misc domain",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory().Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X: This is the center node concept that can have no examples, oterwise each of its example name would be multiple lines"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A: This is a concept that has none of all types of competencies as its examples, oterwise each of its example name would be multiple lines"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1: the first description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{"2-I: <b><a href="CppThis.htm">this</a></b> misc example ",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_h(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"2: the second description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"2-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3: the third description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"3-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"3-II: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_i(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"4: the fourth description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"4-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"4-II: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"4-III: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_j(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"5: the fifth description of a relation that has one example. This description spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-I: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-II: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-III: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{"5-IV: an example of a description of a relation. This example spans multiple lines as it is longer than eighty <a href="CppChar.htm">character</a>s",cmap::Competency::misc}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_h(NodeFactory().Create(concept_h,3.4,5.6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_i(NodeFactory().Create(concept_i,4.5,6.7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_j(NodeFactory().Create(concept_j,5.6,7.8));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_h,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_i,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_j,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(18)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[19]: complex rated concept map with all nodes connected<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create("B", { {"B-1: profession",cmap::Competency::profession} },0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("C", { {"C-1: organisations",cmap::Competency::organisations},{"C-2: social_surroundings",cmap::Competency::social_surroundings}},2,1,0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("D", { {"D-1: target_audience",cmap::Competency::target_audience},{"D-2: ti_knowledge",cmap::Competency::ti_knowledge},{"D-3: prof_growth",cmap::Competency::prof_growth},{"D-4: misc",cmap::Competency::misc}},0,1,2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory().Create(concept_e));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_c,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_d,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_e<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_h(ConceptFactory().Create("2",{{"2-I",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3",{{"3-I",cmap::Competency::misc},{"3-II",cmap::Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_i(ConceptFactory().Create("4",{{"4-I",cmap::Competency::misc},{"4-II",cmap::Competency::misc},{"4-III",cmap::Competency::misc} } ));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Concepts connected to the center should never be visible<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_j(ConceptFactory().Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_k(ConceptFactory().Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_l(ConceptFactory().Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_m(ConceptFactory().Create("..."));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_n(ConceptFactory().Create("..."));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_h(NodeFactory().Create(concept_h,3.4,5.6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_i(NodeFactory().Create(concept_i,4.5,6.7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_j(NodeFactory().Create(concept_j,5.6,7.8));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_k(NodeFactory().Create(concept_k,6.7,8.9));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_l(NodeFactory().Create(concept_l,7.8,9.0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_m(NodeFactory().Create(concept_m,8.9,0.1));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_h,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_i,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(4),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_j,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_k,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_l,nodes.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b> ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_m,nodes.at(0),<b><a href="CppTrue.htm">true</a></b> ,nodes.at(4),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.at(19)=concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v { GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s() };<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v[i];<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[0] (note: same as heteromorphous[11])<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,2.3,4.5));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[2]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[3]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[4]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[5]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[6] (note: same as heteromorphous[11], yet arrows reversed<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[7]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[8]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_a(ConceptFactory().Create("X"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_b(ConceptFactory().Create("B"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create("A"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("C"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_a(NodeFactory().Create(concept_a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory().Create(concept_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[9]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_a(ConceptFactory().Create("X"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_b(ConceptFactory().Create("B"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_c(ConceptFactory().Create("C"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_d(ConceptFactory().Create("A"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_a(NodeFactory().Create(concept_a));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory().Create(concept_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(NodeFactory().Create(concept_d));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[10]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[11]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_e(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_f(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_g(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_e(NodeFactory().Create(concept_e,1.2,3.4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_f(NodeFactory().Create(concept_f,2.3,4.5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_g(NodeFactory().Create(concept_g,3.4,5.6));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_e,nodes.at(2),<b><a href="CppTrue.htm">true</a></b>,nodes.at(3),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_f,nodes.at(1),<b><a href="CppTrue.htm">true</a></b>,nodes.at(2),<b><a href="CppFalse.htm">false</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(node_g,nodes.at(3),<b><a href="CppTrue.htm">true</a></b>,nodes.at(1),<b><a href="CppFalse.htm">false</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(concept_map);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 12);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::ConceptMapFactory::GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Nodes;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; v(6);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount_if.htm">std::count_if</a>(v.begin(),v.end(),[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt;&amp; p) { <b><a href="CppReturn.htm">return</a></b> p; } ) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[0]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[0] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[1]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[1] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[2]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[2] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[3]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[3] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[4]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[4] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>[5]<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("X"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("C"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("B"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("A")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges edges<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(nodes,edges));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[5] <a href="CppOperatorAssign.htm">=</a> concept_map;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node: concept_map-&gt;GetNodes())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge: concept_map-&gt;GetEdges())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetTo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge-&gt;GetFrom());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetTo()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;GetNodes().end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge-&gt;GetFrom()) <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapfwd.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapfwd.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPFWD_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPFWD_H<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> <a href="CppQRegExp.htm">QRegExp</a>;<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> <a href="CppQTimer.htm">QTimer</a>;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNode;<br/>
<b><a href="CppStruct.htm">struct</a></b> CenterNodeFactory;<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> Cluster; <a href="CppComment.htm">//</a>Remove <b><a href="CppFor.htm">for</a></b> now, must be added at <a href="ProjectBrainweaver.htm">ProjectBrainweaver</a> later<br/>
<b><a href="CppStruct.htm">struct</a></b> Command;<br/>
<b><a href="CppStruct.htm">struct</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom;<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandDeleteFocusNode;<br/>
<b><a href="CppStruct.htm">struct</a></b> CommandUnselectRandom;<br/>
<b><a href="CppStruct.htm">struct</a></b> Concept;<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptFactory;<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMap;<br/>
<b><a href="CppStruct.htm">struct</a></b> ConceptMapFactory;<br/>
<b><a href="CppStruct.htm">struct</a></b> Edge;<br/>
<b><a href="CppStruct.htm">struct</a></b> EdgeFactory;<br/>
<b><a href="CppStruct.htm">struct</a></b> Element;<br/>
<b><a href="CppStruct.htm">struct</a></b> Example;<br/>
<b><a href="CppStruct.htm">struct</a></b> Examples;<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> File;<br/>
<b><a href="CppStruct.htm">struct</a></b> Node;<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppWidget.htm">Widget</a>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPFWD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaphelper.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaphelper.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPHELPER_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPHELPER_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppArrayH.htm">array</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppArray.htm">array</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/numeric/conversion/cast.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<a href="CppComment.htm">///</a>Help adding constness a bit<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> T&gt; &gt; <a href="CppAdd.htm">Add</a>Const(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;T&gt; &gt; v) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> T&gt; &gt; w(v.begin(),v.end());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> w.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) { <a href="CppAssert.htm">assert</a>(v[i] <a href="CppOperatorEqual.htm">==</a> w[i]); }<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Help adding constness a bit<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppConst.htm">const</a></b> T *&gt; <a href="CppAdd.htm">Add</a>Const(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;T *&gt; v) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppConst.htm">const</a></b> T *&gt; w(v.begin(),v.end());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> w.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i) { <a href="CppAssert.htm">assert</a>(v[i] <a href="CppOperatorEqual.htm">==</a> w[i]); }<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> w;<br/>
}<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Obtain all possible selections of a <a href="CppStdVector.htm">std::vector</a>, preserving the ordering of its elements<br/>
<a href="CppComment.htm">///</a>Examples:<br/>
/<a href="CppComment.htm">//</a> {&nbsp;&nbsp;&nbsp;&nbsp; } <a href="CppOperatorMinus.htm">-</a>&gt; { {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
/<a href="CppComment.htm">//</a> {1&nbsp;&nbsp;&nbsp;&nbsp;} <a href="CppOperatorMinus.htm">-</a>&gt; { {}, {1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
/<a href="CppComment.htm">//</a> {1,2&nbsp;&nbsp;} <a href="CppOperatorMinus.htm">-</a>&gt; { {}, {1}, {2},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1,2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
/<a href="CppComment.htm">//</a> {1,2,3} <a href="CppOperatorMinus.htm">-</a>&gt; { {}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3} }<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppGetPermutations.htm">GetPermutations</a>.htm<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;T&gt; &gt; <a href="CppGetCombinations.htm">GetCombinations</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;T&gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;T&gt; &gt; result;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostNumeric_cast.htm">boost::numeric_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_combinations <a href="CppOperatorAssign.htm">=</a> (1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sz);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_combinations; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;T&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j) &amp; i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(w);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<a href="CppComment.htm">///</a>Obtain the Pythagorian distance from two delta's<br/>
<a href="CppComment.htm">//</a>From www.richelbilderbeek.nl/Cpp<a href="CppGetDistance.htm">GetDistance</a>.htm<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_y);<br/>
<br/>
<a href="CppComment.htm">///</a>Obtain the Pythagorian distance from two coordinats<br/>
<a href="CppComment.htm">//</a>From www.richelbilderbeek.nl/Cpp<a href="CppGetDistance.htm">GetDistance</a>.htm<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x2, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y2);<br/>
<br/>
<a href="CppComment.htm">///</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppGetRegexMatches.htm">GetRegexMatches</a>.htm<br/>
<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppGetRegexMatches.htm">GetRegexMatches</a>(<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppQRegExp.htm">QRegExp</a>&amp; r<br/>
<a href="CppComment.htm">//</a>) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Safe<a href="CppFileToVector.htm">FileToVector</a> calls <a href="CppFileToVector.htm">FileToVector</a> and<br/>
<a href="CppComment.htm">///</a>removes an empty trailing line that can be created under<br/>
<a href="CppComment.htm">///</a>the <a href="CppWindows.htm">Windows</a> operating system, due to different line endings<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Safe<a href="CppFileToVector.htm">FileToVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; filename) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppComment.htm">///</a>Test the helper <a href="CppFunction.htm">function</a>s<br/>
<b><a href="CppVoid.htm">void</a></b> TestHelper<a href="CppFunction.htm">Function</a>s() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">///</a>Undo a Wordwrap<br/>
<a href="CppStdString.htm">std::string</a> Unwordwrap(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">///</a>Wordwrap the text to obtain lines of max_len <a href="CppChar.htm">character</a>s<br/>
<a href="CppComment.htm">///</a>If the string _must_ be seperable by spaces; a word can have a maximum length of max_len<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Wordwrap(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, <b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> max_len) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPHELPER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaphelper.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaphelper.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFstreamH.htm">fstream</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppAlgorithm.htm">algorithm</a>/string.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQFile.htm">QFile</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppFileIo.htm">fileio</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> delta_y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdSqrt.htm">std::sqrt</a>( (delta_x * delta_x) <a href="CppOperatorPlus.htm">+</a> (delta_y * delta_y) );<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppGetDistance.htm">GetDistance</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x2, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y2)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppGetDistance.htm">GetDistance</a>(x1-x2,y1-y2);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppQRegExp.htm">QRegExp</a>&amp; r_original<br/>
) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppQRegExp.htm">QRegExp</a> r(r_original);<br/>
&nbsp;&nbsp;r.setMinimal(<b><a href="CppTrue.htm">true</a></b>); <a href="CppComment.htm">//</a><a href="CppQRegExp.htm">QRegExp</a> must be non-greedy<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> pos <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((pos <a href="CppOperatorAssign.htm">=</a> r.indexIn(s.c_str(), pos)) <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppOperatorMinus.htm">-</a>1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppQString.htm">QString</a> q <a href="CppOperatorAssign.htm">=</a> r.cap(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (q.isEmpty()) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(q.toStdString());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pos <a href="CppOperatorPlusAssign.htm">+=</a> r.matchedLength();<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Safe<a href="CppFileToVector.htm">FileToVector</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; filename) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppFileToVector.htm">FileToVector</a>(filename);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!v.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> v.back().empty()) v.pop_back();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::TestHelper<a href="CppFunction.htm">Function</a>s() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started TestHelper<a href="CppFunction.htm">Function</a>s");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppGetRegexMatches.htm">GetRegexMatches</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> "In the Netherlands, 1234 AB and 2345 BC are valid zip codes";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; expected;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("1234 AB");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("2345 BC");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> "(\\d{4} [A-Z]{2})";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,(r.c_str())) <a href="CppOperatorEqual.htm">==</a> expected);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> "&lt;concept&gt;&lt;name&gt;Concept with examples&lt;/name&gt;&lt;example&gt;Example 1&lt;/example&gt;&lt;example&gt;Example 2&lt;/example&gt;&lt;example&gt;Example 3&lt;/example&gt;&lt;/concept&gt;";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(s.begin(),s.end(),'\b') <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; expected;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("&lt;example&gt;Example 1&lt;/example&gt;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("&lt;example&gt;Example 2&lt;/example&gt;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expected.push_back("&lt;example&gt;Example 3&lt;/example&gt;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> "(&lt;example&gt;.*?&lt;/example&gt;)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,(r.c_str())) <a href="CppOperatorEqual.htm">==</a> expected);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppGetCombinations.htm">GetCombinations</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume the number of elements is correct<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;1);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;4);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2,3&nbsp;&nbsp;&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a>&nbsp;&nbsp;8);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2,3,4&nbsp;&nbsp;} ) ).size() <a href="CppOperatorEqual.htm">==</a> 16);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( {1,2,3,4,5} ) ).size() <a href="CppOperatorEqual.htm">==</a> 32);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assume the elements are correct<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1,2 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_2 <a href="CppOperatorAssign.htm">=</a> {2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_3 <a href="CppOperatorAssign.htm">=</a> {1,2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_3));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1,2,3 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_2 <a href="CppOperatorAssign.htm">=</a> {2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_3 <a href="CppOperatorAssign.htm">=</a> {3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_4 <a href="CppOperatorAssign.htm">=</a> {1,2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_5 <a href="CppOperatorAssign.htm">=</a> {1,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_6 <a href="CppOperatorAssign.htm">=</a> {2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_7 <a href="CppOperatorAssign.htm">=</a> {1,2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_3));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_7));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppGetCombinations.htm">GetCombinations</a>(<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;( { 1,2,3,4 } ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_0 <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_1 <a href="CppOperatorAssign.htm">=</a> {1};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_2 <a href="CppOperatorAssign.htm">=</a> {2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_3 <a href="CppOperatorAssign.htm">=</a> {3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_4 <a href="CppOperatorAssign.htm">=</a> {4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_5 <a href="CppOperatorAssign.htm">=</a> {1,2};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_6 <a href="CppOperatorAssign.htm">=</a> {1,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_7 <a href="CppOperatorAssign.htm">=</a> {1,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_8 <a href="CppOperatorAssign.htm">=</a> {2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_9 <a href="CppOperatorAssign.htm">=</a> {2,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_10 <a href="CppOperatorAssign.htm">=</a> {3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_11 <a href="CppOperatorAssign.htm">=</a> {1,2,3};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_12 <a href="CppOperatorAssign.htm">=</a> {1,2,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_13 <a href="CppOperatorAssign.htm">=</a> {1,3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_14 <a href="CppOperatorAssign.htm">=</a> {2,3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; expected_15 <a href="CppOperatorAssign.htm">=</a> {1,2,3,4};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_3));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_4));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_5));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_6));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_7));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_8));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_9));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_10));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_11));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_12));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_13));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_14));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(v.begin(),v.end(),expected_15));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Wordwrap<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789012",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789012345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678901234567890123456789012345678",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789012345678901234567890123456789",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890123456789012345678901234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1 1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12 12",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123 123",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234 1234",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345 12345",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456 123456",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567 1234567",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"12345678 8",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"123456789 9",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 0",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" 1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1 2 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;1 23 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;12 34&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;12&nbsp;&nbsp;34&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 ",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 6",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 6",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0&nbsp;&nbsp; 12&nbsp;&nbsp; 34&nbsp;&nbsp; 5 6&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> len=1; len<a href="CppOperatorNotEqual.htm">!=</a>1000; <a href="CppOperatorIncrement.htm">++</a>len)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Wordwrap calls Unwordwrap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wordwrap(s,len);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("TestHelper<a href="CppFunction.htm">Function</a>s finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Unwordwrap(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; v) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Simply concatenate<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> t;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s: v) { t <a href="CppOperatorPlusAssign.htm">+=</a> s; }<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> t;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::Wordwrap(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s_original, <b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> max_len) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (max_len <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Cannot wordwrap <b><a href="CppFor.htm">for</a></b> a max_len of zero");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdClog.htm">std::clog</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Wordwrap \'" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s_original <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\'' <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdEndl.htm">std::endl</a>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> s{s_original};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.size() <a href="CppOperatorEqual.htm">==</a> s_original.size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace multiple spaces with '\b ', where x is a <b><a href="CppChar.htm">char</a></b> not in the string<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a>::value_type x <a href="CppOperatorAssign.htm">=</a> '\b'; <a href="CppComment.htm">//</a>Bell<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz <a href="CppOperatorAssign.htm">=</a> s.size();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace spaces at beginning<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[i] <a href="CppOperatorEqual.htm">==</a> ' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Replace spaces at end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (sz &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>i<a href="CppOperatorNotEqual.htm">!=</a>0, because <b><a href="CppIf.htm">if</a></b> s[0] is a space, it is already <a href="CppConvert.htm">convert</a>ed to bell<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=sz-1; i<a href="CppOperatorNotEqual.htm">!=</a>0; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[i] <a href="CppOperatorEqual.htm">==</a> ' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace "&nbsp;&nbsp;" by "\b "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz-1; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[i] <a href="CppOperatorEqual.htm">==</a> ' ' <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> s[i+1] <a href="CppOperatorEqual.htm">==</a> ' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start the actual wordwrapping<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (!s.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the word <b><a href="CppShort.htm">short</a></b> enough?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() &lt; max_len)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Copy entire word<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> {};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>No spaces, or space beyond max_len: cut word<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.find(' ') <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>::npos <a href="CppOperatorLogicalOr.htm">||</a> s.find(' ') &gt; max_len)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(s.substr(0,max_len));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> s.substr(max_len,s.size() <a href="CppOperatorMinus.htm">-</a> max_len);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find last space before max_len<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSize_t.htm">std::size_t</a> len <a href="CppOperatorAssign.htm">=</a> s.find(' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppStdString.htm">std::string</a>::npos);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> new_len <a href="CppOperatorAssign.htm">=</a> s.find(' ',len <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (new_len &gt; max_len <a href="CppOperatorLogicalOr.htm">||</a> new_len <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>::npos) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len <a href="CppOperatorAssign.htm">=</a> new_len;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len <a href="CppOperatorPlus.htm">+</a> 0 &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(len <a href="CppOperatorPlus.htm">+</a> 1 &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cut s, put cut part in vector<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> line <a href="CppOperatorAssign.htm">=</a> s.substr(0,len+1); <a href="CppComment.htm">//</a>Keep space<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!line.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(line);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> new_index <a href="CppOperatorAssign.htm">=</a> len+1; <a href="CppComment.htm">//</a>After the space found<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_index &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> new_s <a href="CppOperatorAssign.htm">=</a> s.substr(new_index,s.size() <a href="CppOperatorMinus.htm">-</a> new_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s <a href="CppOperatorNotEqual.htm">!=</a> new_s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorAssign.htm">=</a> new_s;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Replace bell <a href="CppChar.htm">character</a>s by spaces again<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdString.htm">std::string</a>&amp; s: v)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorNotEqual.htm">!=</a> ' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSize_t.htm">std::size_t</a> pos <a href="CppOperatorAssign.htm">=</a> s.find(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (pos <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppStdString.htm">std::string</a>::npos)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppStdString.htm">std::string</a>::npos);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos &lt; s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorEqual.htm">==</a> s.find(x)); <a href="CppComment.htm">//</a>To prevent infinite <b><a href="CppWhile.htm">while</a></b> loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[pos] <a href="CppOperatorAssign.htm">=</a> ' ';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s[pos] <a href="CppOperatorEqual.htm">==</a> ' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(pos <a href="CppOperatorNotEqual.htm">!=</a> s.find(x)); <a href="CppComment.htm">//</a>To prevent infinite <b><a href="CppWhile.htm">while</a></b> loop<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos <a href="CppOperatorAssign.htm">=</a> s.find(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(s.find(x) <a href="CppOperatorEqual.htm">==</a> <a href="CppStdString.htm">std::string</a>::npos);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> Unwordwrap the result produces the original input<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (Unwordwrap(v) <a href="CppOperatorNotEqual.htm">!=</a> s_original)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> v.size() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(v.begin(),v.end(),<a href="CppStdOstream_iterator.htm">std::ostream_iterator</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(<a href="CppStdCerr.htm">std::cerr</a>,"\n"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> Unwordwrap(v) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCerr.htm">std::cerr</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s_original <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdEndl.htm">std::endl</a>;<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Unwordwrap(v) <a href="CppOperatorEqual.htm">==</a> s_original);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnode.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPNODE_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPNODE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapelement.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> NodeFactory;<br/>
<br/>
<a href="CppComment.htm">///</a>A Node is a Concept with coordinats, that is used as an Element in a ConceptMap<br/>
<a href="CppComment.htm">///</a>A Node is the GUI independent part of a node. It is displayed as:<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppQt.htm">Qt</a>Node (as <a href="CppQt.htm">Qt</a>ConceptMapElement: a <a href="CppQGraphicsItem.htm">QGraphicsItem</a>, to be used in a <a href="CppQGraphicsView.htm">QGraphicsView</a>)<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppQt.htm">Qt</a>NodeDialog (as a <a href="CppQDialog.htm">QDialog</a>, to be used in a <a href="CppQDialog.htm">QDialog</a>)<br/>
<a href="CppComment.htm">///</a>Node is used as a <a href="CppBaseClass.htm">base class</a> by:<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> CenterNode<br/>
<b><a href="CppStruct.htm">struct</a></b> Node : <b><a href="CppPublic.htm">public</a></b> Element<br/>
{<br/>
&nbsp;&nbsp;Node(<b><a href="CppConst.htm">const</a></b> Node&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Node&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Node&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the Concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Concept&gt;&nbsp;&nbsp;GetConcept() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_concept; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concept&gt;&amp; GetConcept()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_concept; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get some test nodes<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetTests() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the x coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetX() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_x; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get the y coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetY() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_y; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Similar to <b><a href="CppOperatorEqual.htm">operator==</a></b>, except that GUI elements are not tested <b><a href="CppFor.htm">for</a></b> equality<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> HasSameContent(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the concept<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetConcept(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the position<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetPos(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b> { SetX(x); SetY(y); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the x coordinat<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the y coordinat<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> <a href="CppStdString.htm">std::string</a> To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Node *)&gt; m_signal_concept_changed;<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Node *)&gt; m_signal_x_changed;<br/>
&nbsp;&nbsp;<b><a href="CppMutable.htm">mutable</a></b> <a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(Node *)&gt; m_signal_y_changed;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppProtected.htm">protected</a></b>:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppConstructor.htm">construct</a>ion, except <b><a href="CppFor.htm">for</a></b> NodeFactory and derived <b><a href="CppClass.htm">classes</a></b><br/>
&nbsp;&nbsp;Node() <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> NodeFactory;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use NodeFactory as an unused argument to enforce <b><a href="CppUsing.htm">using</a></b> it<br/>
&nbsp;&nbsp;<b><a href="CppExplicit.htm">explicit</a></b> Node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> NodeFactory&amp; lock<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Block <a href="CppDestructor.htm">destructor</a>, except <b><a href="CppFor.htm">for</a></b> the <b><a href="CppFriend.htm">friend</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a><br/>
&nbsp;&nbsp;<b><a href="CppVirtual.htm">virtual</a></b> ~Node() <b><a href="CppNoexcept.htm">noexcept</a></b> {}<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppVoid.htm">void</a></b> <a href="CppBoostChecked_delete.htm">boost::checked_delete</a>&lt;&gt;(Node* x);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; m_concept;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The x-coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_x;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The y-coordinat<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_y;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Test <b><a href="CppThis.htm">this</a></b> <b><a href="CppClass.htm">class</a></b><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> Node&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnode.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::Node::Node(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> NodeFactory&amp;<br/>
) : m_signal_concept_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_x_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_y_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_concept(concept),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x(x),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y(y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_concept);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; <a href="CppRibi.htm">ribi</a>::cmap::Node::GetTests() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> test_concepts <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests();<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; result;<br/>
&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(test_concepts.begin(),test_concepts.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[&amp;result](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> 256) <a href="CppOperatorMinus.htm">-</a> 128;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> 256) <a href="CppOperatorMinus.htm">-</a> 128;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept,x,y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push_back(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::HasSameContent(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs-&gt;GetConcept() <a href="CppOperatorEqual.htm">==</a> *rhs-&gt;GetConcept();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::SetConcept(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_concept <a href="CppOperatorNotEqual.htm">!=</a> concept)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_concept <a href="CppOperatorAssign.htm">=</a> concept;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_concept_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::SetX(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_x <a href="CppOperatorNotEqual.htm">!=</a> x)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_x_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::SetY(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_y <a href="CppOperatorNotEqual.htm">!=</a> y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_y_changed(<b><a href="CppThis.htm">this</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Node::Test");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> Node::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; c { NodeFactory().DeepCopy(node) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> c-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; d <a href="CppOperatorAssign.htm">=</a> NodeFactory().From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test HasSameContent<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( c <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot shuffle Concept its examples. No need to as well: the order is important<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( c <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot shuffle Concept its examples. No need to as well: the order is important<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(a,b) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Order in examples is important and cannot be shuffled");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Cannot shuffle Concept its examples. No need to as well: the order is important<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d},{"3", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2", cmap::Competency::un<a href="CppInitialize.htm">initialize</a>d} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test ConceptFactory reproductions<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test ConceptFactory reproductions<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c <a href="CppOperatorNotEqual.htm">!=</a> d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorNotEqual.htm">!=</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; a(NodeFactory().Create(c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; b(NodeFactory().Create(d));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(a,b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Node::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Node::ToStr() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> *<b><a href="CppThis.htm">this</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> s.str();<br/>
}<br/>
<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::Node::To<a href="CppXml.htm">Xml</a>() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;node&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetConcept()-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;x&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/x&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;y&gt;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/y&gt;";<br/>
&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&lt;/node&gt;";<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> r <a href="CppOperatorAssign.htm">=</a> s.str();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 13);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(0,6) <a href="CppOperatorEqual.htm">==</a> "&lt;node&gt;");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.substr(r.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorEqual.htm">==</a> "&lt;/node&gt;");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> r;<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs.GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *lhs.GetConcept() <a href="CppOperatorEqual.htm">==</a> *rhs.GetConcept()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetX() <a href="CppOperatorEqual.htm">==</a> rhs.GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> lhs.GetY() <a href="CppOperatorEqual.htm">==</a> rhs.GetY();<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorLess.htm">operator&lt;</a></b>(<b><a href="CppConst.htm">const</a></b> Node&amp; lhs, <b><a href="CppConst.htm">const</a></b> Node&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(lhs.GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(rhs.GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetX() &lt; rhs.GetX()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetX() &gt; rhs.GetX()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetY() &lt; rhs.GetY()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.GetY() &gt; rhs.GetY()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> *lhs.GetConcept() &lt; *rhs.GetConcept();<br/>
}<br/>
<br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> Node&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (*node.GetConcept()) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> node.GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> node.GetY()<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnodefactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnodefactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPNODEFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPNODEFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Node;<br/>
<br/>
<a href="CppComment.htm">///</a>Factory <b><a href="CppFor.htm">for</a></b> creating Node <a href="CppInstance.htm">instances</a><br/>
<b><a href="CppStruct.htm">struct</a></b> NodeFactory<br/>
{<br/>
&nbsp;&nbsp;NodeFactory();<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; CreateFromStrings(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; examples <a href="CppOperatorAssign.htm">=</a> {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/DeepCopy is only used <b><a href="CppFor.htm">for</a></b> <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; node<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain a Node or CenterNode from an <a href="CppXml.htm">XML</a> <a href="CppStdString.htm">std::string</a><br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain testing nodes<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> test) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPNODEFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapnodefactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapnodefactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppContainer.htm">container</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::NodeFactory()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::Create(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; concept,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Node(concept,x,y,*<b><a href="CppThis.htm">this</a></b>)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b>(*concept <a href="CppOperatorNotEqual.htm">!=</a> *node-&gt;GetConcept())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(concept);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(*concept);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(*node-&gt;GetConcept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("BREAK");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*concept <a href="CppOperatorEqual.htm">==</a> *node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::CreateFromStrings(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; name,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdPair.htm">std::pair</a>&lt;<a href="CppStdString.htm">std::string</a>,Competency&gt; &gt;&amp; examples,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Node(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptFactory().Create(name,examples),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> x);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> y);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::DeepCopy(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> cmap::Node&gt;&amp; node) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; new_concept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptFactory().DeepCopy(node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_concept);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node-&gt;GetConcept() <a href="CppOperatorEqual.htm">==</a> *new_concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; new_node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> Create(new_concept,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetX(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(new_node-&gt;GetConcept());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*node <a href="CppOperatorEqual.htm">==</a> *new_node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> new_node;<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::From<a href="CppXml.htm">Xml</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; center_node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().From<a href="CppXml.htm">Xml</a>(s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (center_node) { <b><a href="CppReturn.htm">return</a></b> center_node; }<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.size() &lt; 13)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("string too <b><a href="CppShort.htm">short</a></b>");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.substr(0,6) <a href="CppOperatorNotEqual.htm">!=</a> "&lt;node&gt;")<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("incorrect starting tag");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s.substr(s.size() <a href="CppOperatorMinus.htm">-</a> 7,7) <a href="CppOperatorNotEqual.htm">!=</a> "&lt;/node&gt;")<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) <a href="CppTRACE.htm">TRACE</a>("incorrect ending tag");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;();<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_concept<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Concept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (v.size() <a href="CppOperatorNotEqual.htm">!=</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Concept());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> t:v) { <a href="CppTRACE.htm">TRACE</a>(t); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> t: xml::<a href="CppXmlToPretty.htm">XmlToPretty</a>(s)) { <a href="CppTRACE.htm">TRACE</a>(t); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("BREAK");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory().From<a href="CppXml.htm">Xml</a>(v[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>X());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_x<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">Regex</a>().Get<a href="CppRegex.htm">Regex</a>Y());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(v.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(<a href="CppRibi.htm">ribi</a>::xml::<a href="CppStripXmlTag.htm">StripXmlTag</a>(v[0]));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node(NodeFactory().Create(concept,x,y));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(node-&gt;To<a href="CppXml.htm">Xml</a>() <a href="CppOperatorEqual.htm">==</a> s); <a href="CppComment.htm">//</a>TODO RJCB: Put back in<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::GetNumberOfTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(GetTests().size());<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::GetTest(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tests <a href="CppOperatorAssign.htm">=</a> GetTests();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(tests.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> tests[i];<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::GetTests() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; &gt; nodes;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests();<br/>
&nbsp;&nbsp;<a href="CppStdTransform.htm">std::transform</a>(v.begin(),v.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(nodes),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> x <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> y <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; p(NodeFactory().Create(c,x,y));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> nodes;<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory::Test");<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Finished <a href="CppRibi.htm">ribi</a>::cmap::NodeFactory successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapregex.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapregex.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPREGEX_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPREGEX_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a>Factory <b><a href="CppFor.htm">for</a></b> creating Node <a href="CppInstance.htm">instances</a><br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppRegex.htm">Regex</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppRegex.htm">Regex</a>();<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>CenterNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Competency() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Complexity() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Concept() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>ConceptIsComplex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Concreteness() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Edge() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Edges() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Example() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Examples() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>From() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>HeadArrow() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>IsComplex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>IsConcrete() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>IsSpecific() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Name() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Node() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Nodes() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Specificity() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>TailArrow() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Text() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>To() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>X() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> Get<a href="CppRegex.htm">Regex</a>Y() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppRegex.htm">regex</a>_str<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPREGEX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapregex.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapregex.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppRegex.htm">regex</a>.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppRibi.htm">ribi</a>_<a href="CppRegex.htm">regex</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::<a href="CppRegex.htm">Regex</a>()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>CenterNode() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;center_node&gt;.*?&lt;/center_node&gt;)";<br/>
}<br/>
<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Competency() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;competency&gt;.*?&lt;/competency&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Complexity() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;complexity&gt;.*?&lt;/complexity&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Concept() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;concept&gt;.*?&lt;/concept&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>ConceptIsComplex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;concept_is_complex&gt;.*?&lt;/concept_is_complex&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Concreteness() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;concreteness&gt;.*?&lt;/concreteness&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Edge() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;edge&gt;.*?&lt;/edge&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Edges() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;edges&gt;.*?&lt;/edges&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Example() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;example&gt;.*?&lt;/example&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Examples() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;examples&gt;.*?&lt;/examples&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>From() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;from&gt;.*?&lt;/from&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>HeadArrow() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;head_arrow&gt;.*?&lt;/head_arrow&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>IsComplex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;is_complex&gt;.*?&lt;/is_complex&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>IsConcrete() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;is_concrete&gt;.*?&lt;/is_concrete&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>IsSpecific() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;is_specific&gt;.*?&lt;/is_specific&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Name() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;name&gt;.*?&lt;/name&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Node() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;node&gt;.*?&lt;/node&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Nodes() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;nodes&gt;.*?&lt;/nodes&gt;)";<br/>
}<br/>
<br/>
<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Specificity() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;specificity&gt;.*?&lt;/specificity&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>TailArrow() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;tail_arrow&gt;.*?&lt;/tail_arrow&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Text() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;text&gt;.*?&lt;/text&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>To() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;to&gt;.*?&lt;/to&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>X() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;x&gt;.*?&lt;/x&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Get<a href="CppRegex.htm">Regex</a>Y() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "(&lt;y&gt;.*?&lt;/y&gt;)";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; <a href="CppRegex.htm">regex</a>_str<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppRibi.htm">ribi</a>::<a href="CppRegex.htm">Regex</a>().IsValid(<a href="CppRegex.htm">regex</a>_str));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppRibi.htm">ribi</a>::<a href="CppRegex.htm">Regex</a>().<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">regex</a>_str);<br/>
}<br/>
<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a>::Test");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRegex.htm">Regex</a> r;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (verbose) { <a href="CppTRACE.htm">TRACE</a>("Get<a href="CppRegex.htm">Regex</a>Example"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> "&lt;concept&gt;&lt;name&gt;Concept with examples&lt;/name&gt;&lt;example&gt;Example 1&lt;/example&gt;&lt;example&gt;Example 2&lt;/example&gt;&lt;example&gt;Example 3&lt;/example&gt;&lt;/concept&gt;";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; expected {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&lt;example&gt;Example 1&lt;/example&gt;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&lt;example&gt;Example 2&lt;/example&gt;",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&lt;example&gt;Example 3&lt;/example&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> <a href="CppRegex.htm">regex</a>_str <a href="CppOperatorAssign.htm">=</a> r.Get<a href="CppRegex.htm">Regex</a>Example();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(r.<a href="CppGetRegexMatches.htm">GetRegexMatches</a>(s,<a href="CppRegex.htm">regex</a>_str) <a href="CppOperatorEqual.htm">==</a> expected);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Finished <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppRegex.htm">Regex</a> successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaptestconcept.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaptestconcept.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppThreadH.htm">thread</a>&gt;<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
&nbsp;&nbsp;<a href="CppThread.htm">std::thread</a> t(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;cmap::TestHelper<a href="CppFunction.htm">Function</a>s();<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::Concept::Test");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorEqual.htm">operator==</a></b> and <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sz &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tmp_a <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tmp_b <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> tmp_a.at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> tmp_b.at(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b); <a href="CppComment.htm">//</a>FAILS AT CROSSCOMPILER<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a<a href="CppOperatorNotEqual.htm">!=</a>b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests().at(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i<a href="CppOperatorEqual.htm">==</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *c); <a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorNotEqual.htm">!=</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *a); <a href="CppAssert.htm">assert</a>(*d <a href="CppOperatorNotEqual.htm">!=</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorLess.htm">operator&lt;</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering by name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("2");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("2");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering by examples' size, sizes 0 versus 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering by examples' size, sizes 1 versus 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check correct ordering <b><a href="CppFor.htm">for</a></b> equal examples' size, lexicographically in the 2nd text<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; a <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; b <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc},{"3",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc},{"4",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().Create("1", { {"2",Competency::misc},{"4",Competency::misc} } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a); <a href="CppAssert.htm">assert</a>(b); <a href="CppAssert.htm">assert</a>(c); <a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a &lt; *c); <a href="CppAssert.htm">assert</a>(*a &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b &lt; *c); <a href="CppAssert.htm">assert</a>(*b &lt; *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppXml.htm">XML</a> conversion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptFactory().GetTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Concept&gt;&amp; original)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a> and <b><a href="CppOperatorEqual.htm">operator==</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; c <a href="CppOperatorAssign.htm">=</a> ConceptFactory().DeepCopy(original);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *original);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppOperatorNotEqual.htm">operator!=</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c-&gt;m_name <a href="CppOperatorAssign.htm">=</a> c-&gt;m_name <a href="CppOperatorPlus.htm">+</a> " (modified)";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorNotEqual.htm">!=</a> *original);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test To<a href="CppXml.htm">Xml</a> and From<a href="CppXml.htm">Xml</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> c-&gt;To<a href="CppXml.htm">Xml</a>();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptFactory().From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Concept::Test finished successfully");<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> MXE_SUPPORTS_THREADS<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;t.detach();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmaptestconceptmap.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmaptestconceptmap.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSetH.htm">set</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIteratorH.htm">iterator</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppLexical_cast.htm">lexical_cast</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQRegExp.htm">QRegExp</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcenternodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcompetency.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconceptfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedge.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapexamplesfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "xml.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Started <a href="CppRibi.htm">ribi</a>::cmap::ConceptMap::Test");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> <a href="CppTrace.htm">trace</a>_verbose <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt; Nodes;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("<b><a href="CppOperatorEqual.htm">operator==</a></b>, DeepCopy"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetAllTests());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(v.begin(),v.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppCopyConstructor.htm">copy constructor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; c(ConceptMapFactory::DeepCopy(m));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <a href="CppXml.htm">XML</a> conversions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> To<a href="CppXml.htm">Xml</a>(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; d <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*c <a href="CppOperatorEqual.htm">==</a> *d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Can<a href="CppConstructor.htm">Construct</a>"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Can<a href="CppConstructor.htm">Construct</a>( {}, {} ) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume empty concept map can be <a href="CppConstructor.htm">construct</a>ed");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(ConceptFactory().Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept,123,234);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Can<a href="CppConstructor.htm">Construct</a>( { node }, {} ) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume focal <a href="CppQuestion.htm">question</a> without examples can be <a href="CppConstructor.htm">construct</a>ed");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept(ConceptFactory().Create("FOCAL QUESTION", { {"No",Competency::misc},{"examples",Competency::misc},{"allowed",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept,123,234);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(Can<a href="CppConstructor.htm">Construct</a>( { node }, {} )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume focal <a href="CppQuestion.htm">question</a> with examples can be <a href="CppConstructor.htm">construct</a>ed"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "<b><a href="CppFor.htm">for</a></b> example, when creating a sub-concept map");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 1"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(NodeFactory().GetTests().size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CenterNode&gt; node_a(CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node_a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory().GetTests().at(1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().GetTests().at(2));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(2),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 2"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_b(ConceptFactory().Create("1", { {"2",Competency::misc},{"3",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_f(ConceptFactory().Create("1", { {"2",Competency::misc},{"3",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory().Create(concept_b,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("4", { {"5",Competency::misc},{"6",Competency::misc} },345,456)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTests().at(1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("4", { {"5",Competency::misc},{"6",Competency::misc} },901,012)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_g <a href="CppOperatorAssign.htm">=</a> NodeFactory().Create(concept_f,901,012);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CenterNodeFactory().CreateFromStrings("FOCAL QUESTION"), node_b, node_g<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 3"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_a(ConceptFactory().Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_b(ConceptFactory().Create("1",{{"2",Competency::misc},{"3",Competency::misc}}));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_c(ConceptFactory().Create("4",{{"5",Competency::misc},{"6",Competency::misc}}));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_d(ConceptFactory().Create("FOCAL QUESTION"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e(ConceptFactory().Create("4",{{"5",Competency::misc},{"6",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_f(ConceptFactory().Create("1",{{"2",Competency::misc},{"3",Competency::misc} } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_a(CenterNodeFactory().Create(concept_a,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_b(NodeFactory().Create(concept_b,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_c(NodeFactory().Create(concept_c,345,456));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_d(CenterNodeFactory().Create(concept_d,567,678));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_e(NodeFactory().Create(concept_e,789,890));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_f(NodeFactory().Create(concept_f,901,012));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(ConceptMapFactory::Create( { node_a, node_b, node_c } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(ConceptMapFactory::Create( { node_d, node_f, node_e } )); <a href="CppComment.htm">//</a>Swap e and f<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(ConceptMapFactory::Create( { node_d, node_c, node_e } ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 4"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n11(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n12(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n13(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n21(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n22(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n23(ConceptFactory().Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_11(CenterNodeFactory().Create(concept_n11,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_12(NodeFactory().Create(concept_n12,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_13(NodeFactory().Create(concept_n13,345,456));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_21(CenterNodeFactory().Create(concept_n21,567,678));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_22(NodeFactory().Create(concept_n22,789,890));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_23(NodeFactory().Create(concept_n23,901,012));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e11(ConceptFactory().Create("9"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e12(ConceptFactory().Create("8"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e13(ConceptFactory().Create("7"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e21(ConceptFactory().Create("9"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e22(ConceptFactory().Create("8"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e23(ConceptFactory().Create("7"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_1 <a href="CppOperatorAssign.htm">=</a> { node_11, node_12, node_13 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_2 <a href="CppOperatorAssign.htm">=</a> { node_21, node_22, node_23 };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_11(EdgeFactory().Create(NodeFactory().Create(concept_e11,1.2,3.4),nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_12(EdgeFactory().Create(NodeFactory().Create(concept_e12,2.3,4.5),nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_13(EdgeFactory().Create(NodeFactory().Create(concept_e13,3.4,5.6),nodes_1.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_21(EdgeFactory().Create(NodeFactory().Create(concept_e21,4.5,6.7),nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_22(EdgeFactory().Create(NodeFactory().Create(concept_e22,5.6,7.8),nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_23(EdgeFactory().Create(NodeFactory().Create(concept_e23,6.7,8.9),nodes_2.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_11, node_12, node_13 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_11, edge_12, edge_13 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_21, node_22, node_23 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_21, edge_22, edge_23 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_c(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_21, node_22, node_23 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_21, edge_22 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_a,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!HasSameContent(*map_b,*map_c));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_b <a href="CppOperatorNotEqual.htm">!=</a> map_c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 5"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n11(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n12(ConceptFactory().Create("2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n13(ConceptFactory().Create("3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_11(CenterNodeFactory().Create(concept_n11,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_12(NodeFactory().Create(concept_n12,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_13(NodeFactory().Create(concept_n13,345,456));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e11(ConceptFactory().Create("1-&gt;2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e12(ConceptFactory().Create("1-&gt;3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e13(ConceptFactory().Create("2-&gt;3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n21(ConceptFactory().Create("1"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n22(ConceptFactory().Create("3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_n23(ConceptFactory().Create("2"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_21(CenterNodeFactory().Create(concept_n21,123,234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_22(NodeFactory().Create(concept_n22,321,432));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_23(NodeFactory().Create(concept_n23,345,456));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e21(ConceptFactory().Create("2-&gt;3"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e22(ConceptFactory().Create("1-&gt;2"));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Concept&gt; concept_e23(ConceptFactory().Create("1-&gt;3"));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_1 <a href="CppOperatorAssign.htm">=</a> { node_11, node_12, node_13 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Nodes nodes_2 <a href="CppOperatorAssign.htm">=</a> { node_21, node_22, node_23 };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_21(EdgeFactory().Create(NodeFactory().Create(concept_e21,1.2,3.4),nodes_2.at(2),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_22(EdgeFactory().Create(NodeFactory().Create(concept_e22,2.3,4.5),nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_23(EdgeFactory().Create(NodeFactory().Create(concept_e23,3.4,4.5),nodes_2.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_2.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_11(EdgeFactory().Create(NodeFactory().Create(concept_e11,1.2,3.4),nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(1),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_12(EdgeFactory().Create(NodeFactory().Create(concept_e12,2.3,4.5),nodes_1.at(0),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge_13(EdgeFactory().Create(NodeFactory().Create(concept_e13,3.4,5.6),nodes_1.at(1),<b><a href="CppFalse.htm">false</a></b>,nodes_1.at(2),<b><a href="CppTrue.htm">true</a></b>));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_a(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_11, node_12, node_13 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_11, edge_12, edge_13 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; map_b(ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_21, node_22, node_23 },<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ edge_21, edge_22, edge_23 }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(HasSameContent(*map_a,*map_b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(map_a <a href="CppOperatorNotEqual.htm">!=</a> map_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("HasSameContent 6"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; a(ConceptMapFactory::DeepCopy(v[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *v[i]); <a href="CppAssert.htm">assert</a>(*v[i] <a href="CppOperatorEqual.htm">==</a> *a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; b(ConceptMapFactory::DeepCopy(v[j]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (ConceptMap::HasSameContent(*a,*b))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Testing concept maps #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must not be the same";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test: heteromorphous testing concept maps are successfully identified as being different");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Test simple homomorphous maps"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetSimpleHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; a(ConceptMapFactory::DeepCopy(v[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( a <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; b(ConceptMapFactory::DeepCopy(v[j]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( b <a href="CppOperatorNotEqual.htm">!=</a>&nbsp;&nbsp;v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!ConceptMap::HasSameContent(*a,*b))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Testing simple concept maps #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must be homomorphous";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test: simple homomorphous testing concept maps are successfully identified as being different, yet homomorphous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Test complex homomorphous maps"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; &gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppAdd.htm">Add</a>Const(ConceptMapFactory::GetComplexHomomorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; a(ConceptMapFactory::DeepCopy(v[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*a <a href="CppOperatorEqual.htm">==</a> *v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; b(ConceptMapFactory::DeepCopy(v[j]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(a <a href="CppOperatorNotEqual.htm">!=</a> b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(*b <a href="CppOperatorEqual.htm">==</a> *v[j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorNotEqual.htm">!=</a> j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!ConceptMap::HasSameContent(*a,*b))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Testing complex concept maps #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and #" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> j <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must be homomorphous";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMap::HasSameContent(*a,*b));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test: complex homomorphous testing concept maps are successfully identified as being different, yet homomorphous");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>OLD NOTE: There is no perfect check <b><a href="CppFor.htm">for</a></b> shuffled, yet homomorphous concept maps<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>LATER NOTE: Yet, I cannot think of an example that wouldn't get caught<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;so perhaps the check _is_ perfect?<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> TO_ADD_TO_PROJECTBRAINWEAVER<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Con<a href="CppVersion.htm">version</a> from Cluster<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Cluster&gt; &gt; clusters <a href="CppOperatorAssign.htm">=</a> ClusterFactory::GetTests();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFor_each.htm">std::for_each</a>(clusters.begin(),clusters.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Cluster&gt; &amp; cluster)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cluster)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m(ConceptMapFactory::CreateFromCluster("Focal <a href="CppQuestion.htm">question</a>",cluster));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> ConceptMap::To<a href="CppXml.htm">Xml</a>(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; n <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::From<a href="CppXml.htm">Xml</a>(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsEqual(*m,*n));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("CreateSubs"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of expected sub concept maps<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; maps<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_heteromorphous_concept_maps <a href="CppOperatorAssign.htm">=</a> 20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_heteromorphous_concept_maps <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(maps.size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "To warn you <b><a href="CppIf.htm">if</a></b> you change the number of testing concept maps");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; n_subs_expected <a href="CppOperatorAssign.htm">=</a> { 0,2,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5 } ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_heteromorphous_concept_maps <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(n_subs_expected.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 0] <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 1] <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 2] <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 6] <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[ 7] <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[14] <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_subs_expected[15] <a href="CppOperatorEqual.htm">==</a> 5);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(n_subs_expected[16] <a href="CppOperatorEqual.htm">==</a> 5);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(maps.size() <a href="CppOperatorEqual.htm">==</a> n_subs_expected.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> sz <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(n_subs_expected.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>sz; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!maps[i]) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt;&amp; map <a href="CppOperatorAssign.htm">=</a> maps[i];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; subs <a href="CppOperatorAssign.htm">=</a> map-&gt;CreateSubs();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(subs.size()) <a href="CppOperatorNotEqual.htm">!=</a> n_subs_expected[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(subs.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(n_subs_expected[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(subs.size()) <a href="CppOperatorEqual.htm">==</a> n_subs_expected[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("CountCenterNodes"); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of CenterNode objects<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; map: ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (CountCenterNodes(map) <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppContinue.htm">continue</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the edges connected to CenterNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_connected_to_center { CountCenterNodeEdges(map) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes_expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> n_edges_connected_to_center <a href="CppOperatorPlus.htm">+</a> 1; <a href="CppComment.htm">//</a>+1, because with no edges, you expect the center node only<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the number of sub concept maps with a center node<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; &gt; subs <a href="CppOperatorAssign.htm">=</a> map-&gt;CreateSubs();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes_here {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCount_if.htm">std::count_if</a>(subs.begin(),subs.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; sub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> CountCenterNodes(sub) &gt; 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_center_nodes_found <a href="CppOperatorAssign.htm">=</a> n_center_nodes_here;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_center_nodes_expected <a href="CppOperatorNotEqual.htm">!=</a> n_center_nodes_found)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Original map next:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s: xml::<a href="CppXmlToPretty.htm">XmlToPretty</a>(To<a href="CppXml.htm">Xml</a>(map))) { <a href="CppTRACE.htm">TRACE</a>(s); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(n_center_nodes_expected);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(n_center_nodes_found);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(subs.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_center_nodes_expected <a href="CppOperatorEqual.htm">==</a> n_center_nodes_found);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("IsValid"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node_a <a href="CppOperatorAssign.htm">=</a> CenterNodeFactory().CreateFromStrings("...");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ node_a } );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> NodeFactory().CreateFromStrings("...");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Node(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;IsValid());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("<a href="CppAdd.htm">Add</a> nodes and edges"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept_map: concept_maps)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes_before <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_before <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_a <a href="CppOperatorAssign.htm">=</a> NodeFactory().GetTests().at(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> node_b <a href="CppOperatorAssign.htm">=</a> NodeFactory().GetTests().at(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(ConceptFactory().GetTests().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> concept <a href="CppOperatorAssign.htm">=</a> ConceptFactory().GetTests().at(index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge <a href="CppOperatorAssign.htm">=</a> EdgeFactory().Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().Create(concept,123.456,456.789),node_a,<b><a href="CppTrue.htm">true</a></b>,node_b,<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Node(node_a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Node(node_b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;<a href="CppAdd.htm">Add</a>Edge(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes_after <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_after <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_nodes_after <a href="CppOperatorEqual.htm">==</a> n_nodes_before <a href="CppOperatorPlus.htm">+</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_edges_after <a href="CppOperatorEqual.htm">==</a> n_edges_before <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Deletion of nodes"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>n_concept_maps; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_nodes <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> n_nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; concept_map-&gt;GetNodes().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetNodes()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;DeleteNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> n_nodes <a href="CppOperatorMinus.htm">-</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Node must really be gone");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Deletion of edges"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s().size();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>n_concept_maps; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_edges <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>n_edges; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetEdges().size() <a href="CppOperatorEqual.htm">==</a> n_edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(j &lt; concept_map-&gt;GetEdges().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge <a href="CppOperatorAssign.htm">=</a> concept_map-&gt;GetEdges()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concept_map-&gt;DeleteEdge(edge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;GetEdges().size() <a href="CppOperatorEqual.htm">==</a> n_edges <a href="CppOperatorMinus.htm">-</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Edge must really be gone");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppTrace.htm">trace</a>_verbose) { <a href="CppTRACE.htm">TRACE</a>("Is GetNode()[0] a CenterNode?"); }<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetAllTests().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> n_concept_maps <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<a href="CppStdSize_t.htm">std::size_t</a> i <a href="CppOperatorAssign.htm">=</a> 0; i<a href="CppOperatorNotEqual.htm">!=</a>n_concept_maps; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map <a href="CppOperatorAssign.htm">=</a> ConceptMapFactory::GetHeteromorphous<a href="ToolTestConceptMap.htm">TestConceptMap</a>s()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (concept_map-&gt;GetNodes().empty()) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map-&gt;FindCenterNode() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume a CenterNode at the center of ConceptMap");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ConceptMap::Test finished successfully");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidget.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidget.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPWIDGET_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPWIDGET_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppSignals2.htm">signals2</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppQPoint.htm">QPoint</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppWidget.htm">Widget</a> does the Command-driven communication with ConceptMap<br/>
<a href="CppComment.htm">///</a>Note that a <a href="CppWidget.htm">Widget</a> does not know the type of ConceptMap (Display/Edit/Rate)<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppWidget.htm">Widget</a><br/>
{<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap <a href="CppOperatorAssign.htm">=</a> CreateEmptyConceptMap());<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; other); <a href="CppComment.htm">//</a>Only to be used in <a href="CppDebug.htm">debugging</a><br/>
&nbsp;&nbsp;<a href="CppPreElse.htm">#else</a><br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; other) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; command) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> CanUndo() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> !m_undo.empty(); }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; command) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; GetConceptMap() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_conceptmap; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConceptMap&gt; GetConceptMap()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_conceptmap; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/There is one item in focus at most<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/There can be multiple items selected<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The node in focus is never in the collection of selected nodes<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use GetFocusAndSelected to get all<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; GetFocus() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; GetFocus()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/There can be multiple items selected<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/There is one item in focus at most<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The node in focus is never in the collection of selected nodes<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Use GetFocusAndSelected to get all<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetSelected() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetSelected()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the <a href="CppVersion.htm">version</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdString.htm">std::string</a> Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Obtain the <a href="CppVersion.htm">version</a> history<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> MouseMoveEvent(<b><a href="CppConst.htm">const</a></b> <a href="CppQPointF.htm">QPointF</a>&amp; mouse_pos) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Undo() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when an Edge is added<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;)&gt; m_signal_add_edge;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when a Node is added<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;)&gt; m_signal_add_node;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when the ConceptMap is modified as a whole: deleted, created or overwritten<br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>()&gt; m_signal_concept_map_changed;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when an Edge is deleted<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;)&gt; m_signal_delete_edge;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when a Node is deleted<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;)&gt; m_signal_delete_node;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when a Node loses focus<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;)&gt; m_signal_lose_focus;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when one or more Nodes lose to be selected<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>)&gt; m_signal_lose_selected;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when a Node receives focus<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;)&gt; m_signal_set_focus;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppEmit.htm">Emitted</a> when multiple Nodes are selected<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/This has to be handled by <a href="CppQt.htm">Qt</a>ConceptMap<a href="CppWidget.htm">Widget</a><br/>
&nbsp;&nbsp;<a href="CppBoostSignal.htm">boost::signals2::signal</a>&lt;<b><a href="CppVoid.htm">void</a></b>(<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>)&gt; m_signal_set_selected;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m_conceptmap;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The elements in focus, <b><a href="CppIf.htm">if</a></b> <a href="CppAny.htm">any</a>. These might be:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> a <b><a href="CppTrue.htm">true</a></b> Node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> the label in the middle of an edge<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> the CenterNode<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; m_focus;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_font_height;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_font_width;<br/>
<br/>
&nbsp;&nbsp;<a href="CppQPointF.htm">QPointF</a> m_mouse_pos;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The elements selected<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> a <b><a href="CppTrue.htm">true</a></b> Node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> the label in the middle of an edge<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppOperatorMinus.htm">-</a> the CenterNode<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_selected;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The undo stack (use <a href="CppStdVector.htm">std::vector</a> because it is a <b><a href="CppTrue.htm">true</a></b> <a href="CppStl.htm">STL</a> <a href="CppContainer.htm">container</a>)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/The Commands aren't <b><a href="CppConst.htm">const</a></b>, because Command::Undo changes their state<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_undo;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppAdd.htm">Add</a>s back a deleted Node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>This is used by CommandDeleteNode::Undo<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>Node(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppAdd.htm">Add</a> the nodes to the current (can be zero) selecetd nodes<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> <a href="CppAdd.htm">Add</a>Selected(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; nodes) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; CreateEmptyConceptMap() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Creates a <b><a href="CppNew.htm">new</a></b> Node in the concept map. The <b><a href="CppReturn.htm">return</a></b> value is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that node. This is used by CommandCreateNode::Undo<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; CreateNewEdge() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Creates a <b><a href="CppNew.htm">new</a></b> Node in the concept map. The <b><a href="CppReturn.htm">return</a></b> value is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/that node. This is used by CommandCreateNode::Undo<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; CreateNewNode() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete an Edge in the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteEdge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Delete a Node in the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Find a Node at a coordinat<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Returns <b><a href="CppNullptr.htm">nullptr</a></b> <b><a href="CppIf.htm">if</a></b> none is present<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&gt; FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Lose the current focus, assumes something has focus<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> LoseFocus() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Used by Command<a href="CppAdd.htm">Add</a>FocusRandom and CommandSetFocusRandom<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Of all the concept maps its nodes, except <b><a href="CppFor.htm">for</a></b> the uses supplied as the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/argument, <b><a href="CppReturn.htm">return</a></b> 1 to all the nodes, except when there is no node<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/left (as all are excluded) or the concept map does not have <a href="CppAny.htm">any</a> nodes<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> GetRandomNodes(<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_to_exclude <a href="CppOperatorAssign.htm">=</a> {}) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; GetRandomNode(<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_to_exclude <a href="CppOperatorAssign.htm">=</a> {}) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Called by m_undo its top command when it calles Undo itself,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/by which the Command indicates that it must be removed from that m_undo vector<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> OnUndo(<b><a href="CppConst.htm">const</a></b> Command * <b><a href="CppConst.htm">const</a></b> command_to_remove) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Start, reset or <b><a href="CppDelete.htm">delete</a></b> a/the concept map<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the node to the only node in focus<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetFocus(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Set the nodes to the only nodes selected<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetSelected(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; nodes) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppVoid.htm">void</a></b> Test() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Unselect the node, assumes it is selected<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Unselect(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> Command;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandCreateNewConceptMap;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandCreateNewEdge;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandCreateNewNode;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandDeleteConceptMap;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandDeleteFocusNode;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandDeleteNode;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandLoseFocus;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandSetFocusRandom;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandSetFocusWithCoordinat;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> CommandUnselectRandom;<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppStdOstream.htm">std::ostream</a>&amp; <b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; w);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPWIDGET_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidget.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidget.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/lambda/bind.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/lambda/lambda.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapconcept.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommand.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandaddselectedrandom.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandcreatenewnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommanddeleteconceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandfactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapcommandunselectrandom.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapedgefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmaphelper.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnode.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapnodefactory.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>factory.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap)<br/>
&nbsp;&nbsp;: <a href="CppComment.htm">//</a><a href="CppSignal.htm">Signal</a>s first, as these are <b><a href="CppPublic.htm">public</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_add_edge{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_add_node{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_concept_map_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_delete_edge{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_delete_node{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_lose_focus{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_lose_selected{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_set_focus{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_set_selected{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_conceptmap(conceptmap),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_focus{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_height(18),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_width(12),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_mouse_pos{0.0,0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_selected{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_undo{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_conceptmap <a href="CppOperatorLogicalOr.htm">||</a> !m_conceptmap )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Allow a <a href="CppWidget.htm">widget</a> with and without an actual concept map");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_font_height &gt; 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_font_width &gt; 0);<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::<a href="CppWidget.htm">Widget</a>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; other)<br/>
&nbsp;&nbsp;: <a href="CppComment.htm">//</a><a href="CppSignal.htm">Signal</a>s first, as these are <b><a href="CppPublic.htm">public</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_add_edge{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_add_node{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_concept_map_changed{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_delete_edge{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_delete_node{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_lose_focus{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_lose_selected{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_set_focus{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_signal_set_selected{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_conceptmap(ConceptMapFactory::DeepCopy(other.m_conceptmap)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_focus{other.m_focus},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_height(other.m_font_height),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_font_width(other.m_font_width),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_mouse_pos{0.0,0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_selected{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_undo{}<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(m_conceptmap) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(other.m_conceptmap));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (!m_conceptmap <a href="CppOperatorLogicalOr.htm">||</a> *m_conceptmap <a href="CppOperatorEqual.htm">==</a> *other.m_conceptmap) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a copy");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (!m_conceptmap <a href="CppOperatorLogicalOr.htm">||</a> m_conceptmap <a href="CppOperatorNotEqual.htm">!=</a> other.m_conceptmap) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Must be a deep copy");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>( (m_focus <a href="CppOperatorEqual.htm">==</a> other.m_focus <a href="CppOperatorLogicalOr.htm">||</a> m_focus <a href="CppOperatorNotEqual.htm">!=</a> other.m_focus)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot copy focus");<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m_undo <a href="CppOperatorEqual.htm">==</a> other.m_undo <a href="CppOperatorLogicalOr.htm">||</a> m_undo <a href="CppOperatorNotEqual.htm">!=</a> other.m_undo)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot copy undo");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::<a href="CppAdd.htm">Add</a>Node(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ConceptMap does not <a href="CppSignal.htm">signal</a> the newly added node...<br/>
&nbsp;&nbsp;m_conceptmap-&gt;<a href="CppAdd.htm">Add</a>Node(node);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>But ConceptMap<a href="CppWidget.htm">Widget</a> does<br/>
&nbsp;&nbsp;m_signal_add_node(node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> after <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(after <a href="CppOperatorEqual.htm">==</a> before <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::<a href="CppAdd.htm">Add</a>Selected(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; nodes) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(nodes.begin(),nodes.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppStdCopy.htm">std::copy</a>(nodes.begin(),nodes.end(),<a href="CppStdBack_inserter.htm">std::back_inserter</a>(m_selected));<br/>
&nbsp;&nbsp;m_signal_set_selected(nodes);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::CanDoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; command) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> command-&gt;CanDoCommand(<b><a href="CppThis.htm">this</a></b>);<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::ConceptMap&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::CreateEmptyConceptMap() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; concept_map {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ConceptMapFactory().Create()<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(concept_map);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> concept_map;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Edge&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::CreateNewEdge() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetEdges().size();<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(GetSelected().size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; from { GetSelected()[0] };<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; to&nbsp;&nbsp; { GetSelected()[1] };<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(from);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(to);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!m_conceptmap-&gt;HasNode(from))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_conceptmap-&gt;HasNode(from));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_conceptmap-&gt;HasNode(to));<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;EdgeFactory().Create(from,to)<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ConceptMap does not <a href="CppSignal.htm">signal</a> the newly added node...<br/>
&nbsp;&nbsp;m_conceptmap-&gt;<a href="CppAdd.htm">Add</a>Edge(edge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>But ConceptMap<a href="CppWidget.htm">Widget</a> does<br/>
&nbsp;&nbsp;m_signal_add_edge(edge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> after <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetEdges().size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(after <a href="CppOperatorEqual.htm">==</a> before <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edge;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::CreateNewNode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().CreateFromStrings("...")<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ConceptMap does not <a href="CppSignal.htm">signal</a> the newly added node...<br/>
&nbsp;&nbsp;m_conceptmap-&gt;<a href="CppAdd.htm">Add</a>Node(node);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>But ConceptMap<a href="CppWidget.htm">Widget</a> does<br/>
&nbsp;&nbsp;m_signal_add_node(node);<br/>
<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> after <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()-&gt;GetNodes().size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(after <a href="CppOperatorEqual.htm">==</a> before <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;<a href="CppAdd.htm">Add</a>Selected( { node } ); <a href="CppComment.htm">//</a>Must be after 'm_signal_add_node(node);'<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> node;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::DeleteEdge(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; edge) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(edge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Edge might already be deleted by something <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_conceptmap-&gt;GetEdges().empty()) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; &gt;&amp; edges { m_conceptmap-&gt;GetEdges() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdFind.htm">std::find</a>(edges.begin(),edges.end(),edge) <a href="CppOperatorEqual.htm">==</a> edges.end()) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_conceptmap-&gt;GetEdges().empty());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_conceptmap-&gt;GetEdges().size());<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;m_conceptmap-&gt;DeleteEdge(edge);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_edges_after <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_conceptmap-&gt;GetEdges().size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_edges_after <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorEqual.htm">==</a> n_edges_before);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;m_signal_delete_edge(edge);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::DeleteNode(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Node might already be deleted by something <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_conceptmap-&gt;GetNodes().empty()) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; &gt;&amp; nodes { m_conceptmap-&gt;GetNodes() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdFind.htm">std::find</a>(nodes.begin(),nodes.end(),node) <a href="CppOperatorEqual.htm">==</a> nodes.end()) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_conceptmap-&gt;GetNodes().empty());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes_before <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_conceptmap-&gt;GetNodes().size());<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;m_conceptmap-&gt;DeleteNode(node);<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes_after <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_conceptmap-&gt;GetNodes().size());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_nodes_after <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorEqual.htm">==</a> n_nodes_before);<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;m_signal_delete_node(node);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::DoCommand(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; command) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(command);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!CanDoCommand(command))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(command-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("BREAK");<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanDoCommand(command));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>(command-&gt;ToStr());<br/>
<br/>
&nbsp;&nbsp;command-&gt;m_signal_undo.connect(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostBind.htm">boost::bind</a>(&amp;<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::OnUndo,<b><a href="CppThis.htm">this</a></b>,<a href="CppBoostLambda.htm">boost::lambda</a>::_1)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Undo<br/>
&nbsp;&nbsp;m_undo.push_back(command);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Actually <b><a href="CppDo.htm">do</a></b> the move<br/>
&nbsp;&nbsp;command-&gt;DoCommand(<b><a href="CppThis.htm">this</a></b>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanUndo());<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::FindNodeAt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y<br/>
) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<b><a href="CppThis.htm">this</a></b>-&gt;GetConceptMap()) { <b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;(); }<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; node: GetConceptMap()-&gt;GetNodes())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> width&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (m_font_width * node-&gt;GetConcept()-&gt;GetName().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> height <a href="CppOperatorAssign.htm">=</a> m_font_height;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> left&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> node-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> (0.5 * width);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> top&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> node-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> (0.5 * height);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> right&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> node-&gt;GetX() <a href="CppOperatorPlus.htm">+</a> (0.5 * width);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bottom <a href="CppOperatorAssign.htm">=</a> node-&gt;GetY() <a href="CppOperatorPlus.htm">+</a> (0.5 * height);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x <a href="CppOperatorGreaterEqual.htm">&gt;=</a> left <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> x <a href="CppOperatorLessEqual.htm">&lt;=</a> right <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorGreaterEqual.htm">&gt;=</a> top <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> y <a href="CppOperatorLessEqual.htm">&lt;=</a> bottom) <b><a href="CppReturn.htm">return</a></b> node;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt;();<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::FindNodeAt(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst_cast.htm">const_cast</a></b>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>*&gt;(<b><a href="CppThis.htm">this</a></b>)-&gt;FindNodeAt(x,y)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoost.htm">boost</a>::const_<a href="CppPointer.htm">pointer</a>_cast&lt;Node&gt;(node);<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetFocus() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_focus;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetFocus() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_focus;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetSelected() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_selected.empty()) { <b><a href="CppReturn.htm">return</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>(); }<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_selected.begin(),m_selected.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> selected {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAdd.htm">Add</a>Const(m_selected)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(selected.begin(),selected.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> selected;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetSelected() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(m_selected.begin(),m_selected.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_selected;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetRandomNodes(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_to_exclude<br/>
) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!GetConceptMap()-&gt;GetNodes().empty());<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> nodes(GetConceptMap()-&gt;GetNodes());<br/>
&nbsp;&nbsp;<a href="CppStdSort.htm">std::sort</a>(nodes.begin(),nodes.end());<br/>
&nbsp;&nbsp;<a href="CppStdSort.htm">std::sort</a>(nodes_to_exclude.begin(),nodes_to_exclude.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the Nodes present in nodes, absent in nodes_to_exclude<br/>
&nbsp;&nbsp;decltype(nodes) focus_nodes;<br/>
&nbsp;&nbsp;<a href="CppStdSet_difference.htm">std::set_difference</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodes.begin(),nodes.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodes_to_exclude.begin(),nodes_to_exclude.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBack_inserter.htm">std::back_inserter</a>(focus_nodes)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (focus_nodes.empty()) <b><a href="CppReturn.htm">return</a></b> focus_nodes;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (focus_nodes.size() <a href="CppOperatorEqual.htm">==</a> 1) <b><a href="CppReturn.htm">return</a></b> focus_nodes;<br/>
&nbsp;&nbsp;<a href="CppStdRandom_shuffle.htm">std::random_shuffle</a>(focus_nodes.begin(),focus_nodes.end());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorPlus.htm">+</a> (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> (focus_nodes.size() <a href="CppOperatorMinus.htm">-</a> 1));<br/>
&nbsp;&nbsp;focus_nodes.resize(n);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> focus_nodes;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::Node&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::GetRandomNode(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> nodes_to_exclude) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v(GetRandomNodes(nodes_to_exclude));<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; p;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!v.empty()) p <a href="CppOperatorAssign.htm">=</a> v[0];<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
<br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Get<a href="CppVersion.htm">Version</a>() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "1.2";<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Get<a href="CppVersion.htm">Version</a>History() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-12-xx: <a href="CppVersion.htm">Version</a> 1.0: initial <a href="CppVersion.htm">version</a>",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-12-23: <a href="CppVersion.htm">Version</a> 1.1: started <a href="CppVersion.htm">version</a>ing",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2014-03-24: <a href="CppVersion.htm">Version</a> 1.2: distinguished correctly between focus and selected"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::LoseFocus() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_focus);<br/>
<br/>
&nbsp;&nbsp;m_focus <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;() ;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_focus);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::OnUndo(<b><a href="CppConst.htm">const</a></b> Command * <b><a href="CppConst.htm">const</a></b><br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;command_to_remove<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(command_to_remove);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_undo.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_undo.back().get() <a href="CppOperatorEqual.htm">==</a> command_to_remove<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Assume the last command <b><a href="CppQtSignals.htm">signals</a></b> to be removed from the undo stack");<br/>
&nbsp;&nbsp;m_undo.pop_back();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::SetConceptMap(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; conceptmap) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_conceptmap <a href="CppOperatorAssign.htm">=</a> conceptmap;<br/>
&nbsp;&nbsp;m_signal_concept_map_changed();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::SetFocus(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt;&amp; node) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!node)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;m_focus <a href="CppOperatorAssign.htm">=</a> node;<br/>
&nbsp;&nbsp;m_signal_set_focus(node);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::SetSelected(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; nodes) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppStdCount.htm">std::count</a>(nodes.begin(),nodes.end(),<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;m_selected <a href="CppOperatorAssign.htm">=</a> nodes;<br/>
&nbsp;&nbsp;m_signal_set_selected(nodes);<br/>
}<br/>
<br/>
<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Test() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (is_tested) <b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Starting <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Test()");<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_depth <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> *<a href="CppWidget.htm">widget</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdEndl.htm">std::endl</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> individual commands have the intended effect<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete concept map<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_no <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_yes <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandDeleteConceptMap c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Can <b><a href="CppDelete.htm">delete</a></b> a concept map when present");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be present before deletion");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.DoCommand(<a href="CppWidget.htm">widget</a>.get());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be deleted");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be restored by undo");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_yes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot <b><a href="CppDelete.htm">delete</a></b> a concept map when absent");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_no &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_yes &gt; 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start concept map<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_no <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> cnt_yes <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandCreateNewConceptMap c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Can start a concept map when none is present");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.DoCommand(<a href="CppWidget.htm">widget</a>.get());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be created");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetEdges().size() <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be deleted by undo");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_yes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!c.CanDoCommand(<a href="CppWidget.htm">widget</a>.get()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Cannot start when a concept map already exists");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>cnt_no;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_no &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cnt_yes &gt; 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start a concept map, add a node <b><a href="CppUsing.htm">using</a></b> the concept map<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>(<b><a href="CppNew.htm">new</a></b> <a href="CppWidget.htm">Widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map starts empty");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Node&gt; node {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeFactory().GetTest(0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;<a href="CppAdd.htm">Add</a>Node(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must have one node added now");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;DeleteNode(node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be empty again now");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start a concept map, create a node <b><a href="CppUsing.htm">using</a></b> a command<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>(<b><a href="CppNew.htm">new</a></b> <a href="CppWidget.htm">Widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map starts empty");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CommandCreateNewNode&gt; command {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(command));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(command);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size() <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must have one node added now");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;CanUndo());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;command-&gt;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().empty()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must be empty again now");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start a concept map, create two nodes, unselect both, then select both <b><a href="CppUsing.htm">using</a></b> <a href="CppAdd.htm">Add</a>Selected<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>(<b><a href="CppNew.htm">new</a></b> <a href="CppWidget.htm">Widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodes <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CommandCreateNewNode&gt; command {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandCreateNewNode<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(command));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(command);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetConceptMap()-&gt;GetNodes().size()) <a href="CppOperatorEqual.htm">==</a> n_nodes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Concept map must have two nodes");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Freshly created nodes are selected");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Unselect both<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorMinus.htm">-</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CommandUnselectRandom&gt; command {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandUnselectRandom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(command));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(command);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorMinus.htm">-</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Select both again<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command<a href="CppAdd.htm">Add</a>SelectedRandom&gt; command {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> Command<a href="CppAdd.htm">Add</a>SelectedRandom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(command));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(command);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> i <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Undo selection<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_nodes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 2 <a href="CppOperatorMinus.htm">-</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;CommandUnselectRandom&gt; command {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> CommandUnselectRandom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(command));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 1 <a href="CppOperatorMinus.htm">-</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<a href="CppWidget.htm">widget</a>-&gt;GetSelected().size()) <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do all <b><a href="CppDo.htm">do</a></b> and undo of a single command<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_commands { <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(CommandFactory::CreateTestCommands().size()) };<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_commands; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>: <a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppWidget.htm">widget</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; cmd(CommandFactory::CreateTestCommands()[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cmd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppTRACE.htm">TRACE</a>(cmd-&gt;ToStr());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(cmd))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(cmd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do all combinations of two commands<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_depth <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_commands; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j=0; j<a href="CppOperatorNotEqual.htm">!=</a>n_commands; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; <a href="CppWidget.htm">widget</a>: <a href="CppWidget.htm">Widget</a>Factory::GetAllTests())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Command&gt; cmd:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandFactory::CreateTestCommands()[i],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CommandFactory::CreateTestCommands()[j]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(cmd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppWidget.htm">widget</a>-&gt;CanDoCommand(cmd))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(cmd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;Undo();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppWidget.htm">widget</a>-&gt;DoCommand(cmd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Finished <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Test()");<br/>
}<br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>::Undo() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(CanUndo());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_undo.empty());<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_undo.back());<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz_before <a href="CppOperatorAssign.htm">=</a> m_undo.size();<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;m_undo.back()-&gt;Undo();<br/>
&nbsp;&nbsp;<a href="CppIfndef.htm">#ifndef</a> <a href="CppNDEBUG.htm">NDEBUG</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdSize_t.htm">std::size_t</a> sz_after <a href="CppOperatorAssign.htm">=</a> m_undo.size();<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(sz_after &lt; sz_before<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "The undo Command calls DoUndo itself;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DoUndo shortens the m_undo stack"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_undo.pop_back(); <a href="CppComment.htm">//</a>DON'T, DoUndo does <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(lhs.m_conceptmap.get()) <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(rhs.m_conceptmap.get()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppBool.htm">bool</a></b>&gt;(<b><a href="CppNullptr.htm">nullptr</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_conceptmap <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *lhs.m_conceptmap <a href="CppOperatorNotEqual.htm">!=</a> *rhs.m_conceptmap) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_focus <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_focus) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_selected <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_selected) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs.m_undo.size() <a href="CppOperatorNotEqual.htm">!=</a> rhs.m_undo.size()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdEqual.htm">std::equal</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBegin.htm">std::begin</a>(lhs.m_undo),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdEnd.htm">std::end</a>(lhs.m_undo),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBegin.htm">std::begin</a>(rhs.m_undo),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; p,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Command&gt; q)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p-&gt;ToStr() <a href="CppOperatorEqual.htm">==</a> q-&gt;ToStr();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; lhs, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> !(lhs <a href="CppOperatorEqual.htm">==</a> rhs);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppStdOstream.htm">std::ostream</a>&amp; <a href="CppRibi.htm">ribi</a>::cmap::<b><a href="CppOperatorStreamOut.htm">operator&lt;&lt;</a></b>(<a href="CppStdOstream.htm">std::ostream</a>&amp; os, <b><a href="CppConst.htm">const</a></b> <a href="CppWidget.htm">Widget</a>&amp; w)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> ConceptMap&gt; concept_map { w.GetConceptMap() };<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Edge&gt; &gt; edges { concept_map-&gt;GetEdges() };<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Node&gt; &gt; nodes { concept_map-&gt;GetEdges() };<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>In reverse order of importance<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Draw edge lines<br/>
<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidgetfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidgetfactory.h" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppIfndef.htm">#ifndef</a> CONCEPTMAPWIDGETFACTORY_H<br/>
<a href="CppDefine.htm">#define</a> CONCEPTMAPWIDGETFACTORY_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIosfwdH.htm">iosfwd</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfwd.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> cmap {<br/>
<br/>
<a href="CppComment.htm">///</a><a href="CppWidget.htm">Widget</a> does the Command-driven communication with ConceptMap<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppWidget.htm">Widget</a>Factory<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/Get all the testing concept maps as a <a href="CppWidget.htm">widget</a> in one vector<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; &gt; GetAllTests() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> cmap<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CONCEPTMAPWIDGETFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppConceptMap/conceptmapwidgetfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppConceptMap/conceptmapwidgetfactory.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">/*</a><br/>
ConceptMap, concept map <b><a href="CppClass.htm">classes</a></b><br/>
Copyright (C) 2013-2014 Richel Bilderbeek<br/>
<br/>
This program is free software: you can redistribute it and/or modify<br/>
it under the terms of the GNU General Public License as published by<br/>
the Free Software Foundation, either version 3 of the License, or<br/>
(at your option) any later version.<br/>
<br/>
This program is distributed in the hope that it will be useful,<br/>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
GNU General Public License for more details.<br/>
You should have received a copy of the GNU General Public License<br/>
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/<a href="CppConceptMap.htm">CppConceptMap</a>.htm<br/>
<a href="CppComment.htm">//</a>---------------------------------------------------------------------------<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>factory.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "conceptmap.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmap<a href="CppWidget.htm">widget</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "conceptmapfactory.h"<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a><a href="CppOperatorStreamIn.htm">&gt;&gt;</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::cmap::<a href="CppWidget.htm">Widget</a>Factory::GetAllTests() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a><a href="CppOperatorStreamIn.htm">&gt;&gt;</a> v;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;ConceptMap&gt; m: ConceptMapFactory::GetAllTests())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (m <a href="CppOperatorLogicalOr.htm">||</a> !m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Allow a <a href="CppWidget.htm">widget</a> with and without an actual concept map");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppWidget.htm">Widget</a>&gt; w {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppNew.htm">new</a></b> <a href="CppWidget.htm">Widget</a>(m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>( (!m <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !w-&gt;GetConceptMap())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>both <b><a href="CppNullptr.htm">nullptr</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalOr.htm">||</a> (&nbsp;&nbsp; m <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;w-&gt;GetConceptMap() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *w-&gt;GetConceptMap() <a href="CppOperatorEqual.htm">==</a> *m) <a href="CppComment.htm">//</a>both <a href="CppPointer.htm">point</a> to same<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(w);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
