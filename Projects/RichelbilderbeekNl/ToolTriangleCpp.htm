<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>TriangleCpp</title>
  <meta name="description" content="C++ TriangleCpp"/>
  <meta name="keywords" content="C++ TriangleCpp "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="ToolTriangleCpp.htm">TriangleCpp</a></h1>
<p>&nbsp;</p>
<!-- No CodeToHtmlInfo about this class with page name ToolTriangleCpp-->
<h2>Technical facts</h2>
<p>&nbsp;</p>
<p><a href="CppOs.htm">Operating system(s) or programming environment(s)</a></p>
<ul>
  <li><img src="PicLubuntu.png" alt="Lubuntu"/> <a href="CppLubuntu.htm">Lubuntu</a> 14.04 (trusty)</li>
</ul>
<p><a href="CppIde.htm">IDE(s)</a>:</p>
<ul>
  <li><img src="PicQtCreator.png" alt="Qt Creator"/> <a href="CppQtCreator.htm">Qt Creator</a> 3.0.1</li>
</ul>
<p><a href="CppQtProjectType.htm">Project type</a>:</p>
<ul>
  <li><img src="PicConsole.png" alt="console"/> <a href="CppConsoleApplication.htm">Console application</a></li>
</ul>
<p><a href="CppStandard.htm">C++ standard</a>:</p>
<ul>
  <li><img src="PicCpp98.png" alt="C++98"/> <a href="Cpp98.htm">C++98</a></li>
</ul>
<p><a href="CppCompiler.htm">Compiler(s)</a>:</p>
<ul>
  <li><a href="CppGpp.htm">G++</a> 4.8.2</li>
</ul>
<p><a href="CppLibrary.htm">Libraries</a> used:</p>
<ul>
  <li><img src="PicStl.png" alt="STL"/> <a href="CppStl.htm">STL</a>: GNU ISO C++ Library, version 4.8.2</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a href="CppQtProjectFile.htm">Qt project file</a>: ./ToolTriangleCpp/ToolTriangleCppConsole.pro</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/ToolTriangleCppConsole.pro" border = "1"><tr><td><code>
include(../../<a href="CppConsoleApplication.htm">ConsoleApplication</a>.pri)<br/>
include(../../<a href="CppLibrary.htm">Libraries</a>/Boost.pri)<br/>
include(../../<a href="CppLibrary.htm">Libraries</a>/GeneralConsole.pri)<br/>
<br/>
include(../../<a href="CppClass.htm">Classes</a>/CppContainer/CppContainer.pri)<br/>
include(../../<a href="CppClass.htm">Classes</a>/CppGeometry/CppGeometry.pri)<br/>
include(../../<a href="CppClass.htm">Classes</a>/CppMake_array/CppMake_array.pri)<br/>
include(../../<a href="CppClass.htm">Classes</a>/CppPlane/CppPlane.pri)<br/>
include(../../<a href="CppClass.htm">Classes</a>/CppPolyFile/CppPolyFile.pri)<br/>
include(../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/ToolTriangleCppConsole.pri)<br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += <a href="CppMain.htm">main</a>.cpp<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/ToolTriangleCppConsole.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/ToolTriangleCppConsole.pri" border = "1"><tr><td><code>
<a href="CppQmakeIncludepath.htm">INCLUDEPATH</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp<br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpp<a href="CppMain.htm">main</a>.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppmesh.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppmemorypool.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpparguments.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpptriangle.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppotri.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppedge.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppinfo.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpposub.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppvertex.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppbadsubseg.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppbadtriang.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppflipstacker.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppevent.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppsplaynode.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppsyntax.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpptriangulateio.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpptrimalloc.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpplocateresult.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppinsertvertexresult.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppfinddirectionresult.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppfile.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppstring.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppglobals.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppdefines.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../ToolTriangleCpp/trianglecppvertextype.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../ToolTriangleCpp/trianglecpphelper.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trianglecppmeshbuilder.cpp<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpp<a href="CppMain.htm">main</a>.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppmesh.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppmemorypool.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpparguments.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpptriangle.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppotri.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppedge.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppinfo.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpposub.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppvertex.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppbadsubseg.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppbadtriang.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppflipstacker.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppevent.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppsplaynode.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppsyntax.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpptriangulateio.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppglobals.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpptrimalloc.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppfwd.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppdefines.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecpplocateresult.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppinsertvertexresult.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppfinddirectionresult.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppfile.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/trianglecppstring.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../ToolTriangleCpp/trianglecppvertextype.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../ToolTriangleCpp/trianglecpphelper.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trianglecpptypedefs.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trianglecppmeshbuilder.h<br/>
<br/>
<a href="CppQmakeOther_files.htm">OTHER_FILES</a> += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../ToolTriangleCpp/ToolTriangleCpp.txt<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/ToolTriangleCppDesktop.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/ToolTriangleCppDesktop.pri" border = "1"><tr><td><code>
include(../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/ToolTriangleCppConsole.pri)<br/>
<br/>
<a href="CppQmakeHeaders.htm">HEADERS</a> +=<br/>
<br/>
<a href="CppQmakeSources.htm">SOURCES</a> +=<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/ToolTriangleCppWebsite.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/ToolTriangleCppWebsite.pri" border = "1"><tr><td><code>
include(../../<a href="Tools.htm">Tools</a>/ToolTriangleCpp/ToolTriangleCppConsole.pri)<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/main.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/main.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmain.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppMain.htm">main</a>(<b><a href="CppInt.htm">int</a></b> <a href="CppArgc.htm">argc</a>, <b><a href="CppChar.htm">char</a></b>* <a href="CppArgc.htm">argv</a>[])<br/>
{<br/>
&nbsp;&nbsp;triangle_main(<a href="CppArgc.htm">argc</a>,<a href="CppArgc.htm">argv</a>);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/showme_cpp.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/showme_cpp.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;,d88^^o 888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;8888&nbsp;&nbsp;&nbsp;&nbsp;888o^88,&nbsp;&nbsp;o88^^o Y88b&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d8b&nbsp;&nbsp;d8b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o88^^8o&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;"Y88b&nbsp;&nbsp; 888&nbsp;&nbsp;888 d888&nbsp;&nbsp; b Y88b&nbsp;&nbsp;d8b&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d888bdY88b&nbsp;&nbsp;&nbsp;&nbsp;d888&nbsp;&nbsp;88b&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp; "Y88b, 888&nbsp;&nbsp;888 8888&nbsp;&nbsp; 8&nbsp;&nbsp;Y888/Y88b<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a> Y88Y Y888b&nbsp;&nbsp; 8888oo888&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;8888 888&nbsp;&nbsp;888 q888&nbsp;&nbsp; p&nbsp;&nbsp; Y8<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;Y8<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; YY&nbsp;&nbsp; Y888b&nbsp;&nbsp;q888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;"oo88P" 888&nbsp;&nbsp;888&nbsp;&nbsp;"88oo"&nbsp;&nbsp;&nbsp;&nbsp; Y&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y888b&nbsp;&nbsp;"88oooo"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;A Display Program <b><a href="CppFor.htm">for</a></b> Meshes and More.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;(showme.c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;<a href="CppVersion.htm">Version</a> 1.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;July 28, 2005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Copyright 1996, 1998, 2005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Jonathan Ri<b><a href="CppChar.htm">char</a></b>d Shewchuk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;2360 Woolsey #H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Berkeley, California&nbsp;&nbsp;94705-1927&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;jrs@cs.berkeley.edu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;This program may be freely redistributed under the condition that the&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;copyright notices (including <b><a href="CppThis.htm">this</a></b> entire header and the copyright&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;notice printed when the `-h' <b><a href="CppSwitch.htm">switch</a></b> is selected) are not removed, and&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;no compensation is received.&nbsp;&nbsp;Private, research, and institutional&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;use is free.&nbsp;&nbsp;You may distribute modified <a href="CppVersion.htm">version</a>s of <b><a href="CppThis.htm">this</a></b> code UNDER&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT IN THE&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;SAME <a href="CppCfile.htm">FILE</a> REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH SOURCE&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND CLEAR&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;NOTICE IS GIVEN OF THE MODIFICATIONS.&nbsp;&nbsp;Distribution of <b><a href="CppThis.htm">this</a></b> code as&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;part of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;WITH THE AUTHOR.&nbsp;&nbsp;(If you are not directly supplying <b><a href="CppThis.htm">this</a></b> code to a&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;customer, and you are instead telling them how they can obtain it <b><a href="CppFor.htm">for</a></b>&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;free, then you are not required to <a href="CppMake.htm">make</a> <a href="CppAny.htm">any</a> arrangement with me.)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Hypertext instructions <b><a href="CppFor.htm">for</a></b> Triangle are available on the Web at&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.cs.cmu.edu/~quake/showme.html&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Show Me was created as part of the Archimedes project in the School of&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;Computer Science at Carnegie Mellon University.&nbsp;&nbsp;Archimedes is a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;system <b><a href="CppFor.htm">for</a></b> compiling parallel finite element solvers.&nbsp;&nbsp;For further&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;information, see Anja Feldmann, Omar Ghattas, John R. Gilbert, Gary L. <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;Miller, David R. O'Hallaron, Eric J. Schwabe, Jonathan R. Shewchuk,&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;and Shang-Hua Teng.&nbsp;&nbsp;"Automated Parallel Solution of Unstructured PDE&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;Problems."&nbsp;&nbsp;To appear in Communications of the ACM, we hope.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;If you <a href="CppMake.htm">make</a> <a href="CppAny.htm">any</a> improvements to <b><a href="CppThis.htm">this</a></b> code, please please please let me&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;know, so that I may obtain the improvements.&nbsp;&nbsp;Even <b><a href="CppIf.htm">if</a></b> you don't change <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;the code, I'd still love to hear what it's being used <b><a href="CppFor.htm">for</a></b>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Disclaimer:&nbsp;&nbsp;Neither I nor Carnegie Mellon warrant <b><a href="CppThis.htm">this</a></b> code in <a href="CppAny.htm">any</a> way&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;whatsoever.&nbsp;&nbsp;Use at your own risk.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> For single precision (which will save some <a href="CppMemory.htm">memory</a> and reduce paging),&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; write "<a href="CppDefine.htm">#define</a> SINGLE" below.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a> For <b><a href="CppDouble.htm">double</a></b> precision (which will allow you to display triangulations of&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; a finer resolution), leave SINGLE undefined.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> <a href="CppDefine.htm">#define</a> SINGLE <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SINGLE<br/>
<a href="CppDefine.htm">#define</a> REAL <b><a href="CppFloat.htm">float</a></b><br/>
<a href="CppPreElse.htm">#else</a><br/>
<a href="CppDefine.htm">#define</a> REAL <b><a href="CppDouble.htm">double</a></b><br/>
<a href="CppEndif.htm">#endif</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Maximum number of <a href="CppChar.htm">character</a>s in a file name (including the null).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppDefine.htm">#define</a> <a href="CppCfile.htm">FILE</a>NAMESIZE 2048<br/>
<br/>
<a href="CppComment.htm">/*</a> Maximum number of <a href="CppChar.htm">character</a>s in a line read from a file (including the&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; null).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppDefine.htm">#define</a> INPUTLINESIZE 1024<br/>
<br/>
<a href="CppDefine.htm">#define</a> STARTWIDTH 414<br/>
<a href="CppDefine.htm">#define</a> STARTHEIGHT 414<br/>
<a href="CppDefine.htm">#define</a> MINWIDTH 50<br/>
<a href="CppDefine.htm">#define</a> MINHEIGHT 50<br/>
<a href="CppDefine.htm">#define</a> BUTTONHEIGHT 21<br/>
<a href="CppDefine.htm">#define</a> BUTTONROWS 3<br/>
<a href="CppDefine.htm">#define</a> PANELHEIGHT (BUTTONHEIGHT * BUTTONROWS)<br/>
<a href="CppDefine.htm">#define</a> MAXCOLORS 64<br/>
<br/>
<a href="CppDefine.htm">#define</a> IMAGE_TYPES 7<br/>
<a href="CppDefine.htm">#define</a> NOTHING <a href="CppOperatorMinus.htm">-</a>1<br/>
<a href="CppDefine.htm">#define</a> NODE 0<br/>
<a href="CppDefine.htm">#define</a> POLY 1<br/>
<a href="CppDefine.htm">#define</a> ELE 2<br/>
<a href="CppDefine.htm">#define</a> EDGE 3<br/>
<a href="CppDefine.htm">#define</a> PART 4<br/>
<a href="CppDefine.htm">#define</a> ADJ 5<br/>
<a href="CppDefine.htm">#define</a> VORO 6<br/>
<br/>
<a href="CppDefine.htm">#define</a> STARTEXPLOSION 0.5<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdioH.htm">stdio.h</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStd.htm">std</a>lib.h&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;string.h&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;X11/Xlib.h&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;X11/Xutil.h&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;X11/Xatom.h&gt;<br/>
<br/>
<a href="CppComment.htm">/*</a> A necessary <a href="CppForwardDeclaration.htm">forward declaration</a>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_image();<br/>
<br/>
Display *display;<br/>
<b><a href="CppInt.htm">int</a></b> screen;<br/>
Window rootwindow;<br/>
Window mainwindow;<br/>
Window quitwin;<br/>
Window leftwin;<br/>
Window rightwin;<br/>
Window upwin;<br/>
Window downwin;<br/>
Window resetwin;<br/>
Window pswin;<br/>
Window epswin;<br/>
Window expwin;<br/>
Window exppluswin;<br/>
Window expminuswin;<br/>
Window widthpluswin;<br/>
Window widthminuswin;<br/>
Window <a href="CppVersion.htm">version</a>pluswin;<br/>
Window <a href="CppVersion.htm">version</a>minuswin;<br/>
Window fillwin;<br/>
Window nodewin[2];<br/>
Window polywin[2];<br/>
Window elewin[2];<br/>
Window edgewin[2];<br/>
Window partwin[2];<br/>
Window adjwin[2];<br/>
Window voronoiwin[2];<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> windowdepth;<br/>
XEvent event;<br/>
Colormap rootmap;<br/>
XFontStruct *font;<br/>
<b><a href="CppInt.htm">int</a></b> width, height;<br/>
<b><a href="CppInt.htm">int</a></b> black, white;<br/>
<b><a href="CppInt.htm">int</a></b> showme_foreground;<br/>
GC fontgc;<br/>
GC blackfontgc;<br/>
GC linegc;<br/>
GC trianglegc;<br/>
<b><a href="CppInt.htm">int</a></b> colors[MAXCOLORS];<br/>
XColor rgb[MAXCOLORS];<br/>
<b><a href="CppInt.htm">int</a></b> color;<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> start_image, current_image;<br/>
<b><a href="CppInt.htm">int</a></b> start_inc, current_inc;<br/>
<b><a href="CppInt.htm">int</a></b> loweriteration;<br/>
<b><a href="CppInt.htm">int</a></b> line_width;<br/>
<b><a href="CppInt.htm">int</a></b> loaded[2][IMAGE_TYPES];<br/>
REAL xlo[2][IMAGE_TYPES], ylo[2][IMAGE_TYPES];<br/>
REAL xhi[2][IMAGE_TYPES], yhi[2][IMAGE_TYPES];<br/>
REAL xscale, yscale;<br/>
REAL xoffset, yoffset;<br/>
<b><a href="CppInt.htm">int</a></b> zoom;<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> nodes[2], node_dim[2];<br/>
REAL *nodeptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> polynodes[2], poly_dim[2], polyedges[2], polyholes[2];<br/>
REAL *polynodeptr[2], *polyholeptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> *polyedgeptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> elems[2], ele_corners[2];<br/>
<b><a href="CppInt.htm">int</a></b> *eleptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> edges[2];<br/>
<b><a href="CppInt.htm">int</a></b> *edgeptr[2];<br/>
REAL *normptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> subdomains[2];<br/>
<b><a href="CppInt.htm">int</a></b> *partpart[2];<br/>
REAL *partcenter[2], *partshift[2];<br/>
<b><a href="CppInt.htm">int</a></b> adjsubdomains[2];<br/>
<b><a href="CppInt.htm">int</a></b> *adjptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> vnodes[2], vnode_dim[2];<br/>
REAL *vnodeptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> vedges[2];<br/>
<b><a href="CppInt.htm">int</a></b> *vedgeptr[2];<br/>
REAL *vnormptr[2];<br/>
<b><a href="CppInt.htm">int</a></b> firstnumber[2];<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> quiet, fillelem, bw_ps, explode;<br/>
REAL explosion;<br/>
<br/>
<b><a href="CppChar.htm">char</a></b> filename[<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> nodefilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> polyfilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> elefilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> edgefilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> partfilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> adjfilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> vnodefilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<b><a href="CppChar.htm">char</a></b> vedgefilename[2][<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
<br/>
<b><a href="CppChar.htm">char</a></b> *colorname[] <a href="CppOperatorAssign.htm">=</a> {"aquamarine", "red", "green yellow", "magenta",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "yellow", "green", "orange", "blue",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "white", "sandy brown", "cyan", "moccasin",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "cadet blue", "coral", "cornflower blue", "sky blue",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "firebrick", "forest green", "gold", "goldenrod",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "gray", "hot pink", "<b><a href="CppChar.htm">char</a></b>treuse", "pale violet red",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "indian red", "khaki", "lavender", "light blue",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "light gray", "light steel blue", "lime green", "azure",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "maroon", "medium aquamarine", "dodger blue", "honeydew",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "medium orchid", "medium sea green", "moccasin",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "medium slate blue", "medium spring green",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "medium turquoise", "medium violet red",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "orange red", "chocolate", "light goldenrod",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "orchid", "pale green", "pink", "plum",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "purple", "salmon", "sea green",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "sienna", "slate blue", "spring green",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "steel blue", "tan", "<b><a href="CppThis.htm">this</a></b>tle", "turquoise",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "violet", "violet red", "wheat",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "yellow green"};<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> syntax()<br/>
{<br/>
&nbsp;&nbsp;printf("showme [-bfw_Qh] input_file\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>b&nbsp;&nbsp;Black and white PostScript (<b><a href="CppDefault.htm">default</a></b> is color).\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>f&nbsp;&nbsp;Fill triangles of partitioned mesh with color.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>w&nbsp;&nbsp;Set line width to some specified number.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>Q&nbsp;&nbsp;Quiet:&nbsp;&nbsp;No terminal output except errors.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>h&nbsp;&nbsp;Help:&nbsp;&nbsp;Detailed instructions <b><a href="CppFor.htm">for</a></b> Show Me.\n");<br/>
&nbsp;&nbsp;exit(0);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> info()<br/>
{<br/>
&nbsp;&nbsp;printf("Show Me\n");<br/>
&nbsp;&nbsp;printf("A Display Program <b><a href="CppFor.htm">for</a></b> Meshes and More.\n");<br/>
&nbsp;&nbsp;printf("<a href="CppVersion.htm">Version</a> 1.6\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"Copyright 1996 Jonathan Ri<b><a href="CppChar.htm">char</a></b>d Shewchuk&nbsp;&nbsp;(<a href="CppBug.htm">bug</a>s/comments to jrs@cs.cmu.edu)\n"<br/>
);<br/>
&nbsp;&nbsp;printf("School of Computer Science <a href="CppOperatorDivide.htm">/</a> Carnegie Mellon University\n");<br/>
&nbsp;&nbsp;printf("5000 Forbes Avenue <a href="CppOperatorDivide.htm">/</a> Pittsburgh, Pennsylvania&nbsp;&nbsp;15213-3891\n");<br/>
&nbsp;&nbsp;printf(<br/>
"Created as part of the Archimedes project (<a href="Tools.htm">tools</a> <b><a href="CppFor.htm">for</a></b> parallel FEM).\n");<br/>
&nbsp;&nbsp;printf(<br/>
"Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\n");<br/>
&nbsp;&nbsp;printf("There is no warranty whatsoever.&nbsp;&nbsp;Use at your own risk.\n");<br/>
<a href="CppIfdef.htm">#ifdef</a> SINGLE<br/>
&nbsp;&nbsp;printf("This executable is <a href="CppCompile.htm">compile</a>d <b><a href="CppFor.htm">for</a></b> single precision arithmetic.\n\n\n");<br/>
<a href="CppPreElse.htm">#else</a><br/>
&nbsp;&nbsp;printf("This executable is <a href="CppCompile.htm">compile</a>d <b><a href="CppFor.htm">for</a></b> <b><a href="CppDouble.htm">double</a></b> precision arithmetic.\n\n\n");<br/>
<a href="CppEndif.htm">#endif</a><br/>
&nbsp;&nbsp;printf(<br/>
"Show Me graphically displays the contents of geometric files, especially\n");<br/>
&nbsp;&nbsp;printf(<br/>
"those generated by Triangle, my two-dimensional quality mesh generator and\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"Delaunay triangulator.&nbsp;&nbsp;Show Me can also write images in PostScript form.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"Show Me is also useful <b><a href="CppFor.htm">for</a></b> checking the consistency of the files you create\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"as input to Triangle; Show Me does these checks more thoroughly than\n");<br/>
&nbsp;&nbsp;printf("Triangle does.&nbsp;&nbsp;The command syntax is:\n\n");<br/>
&nbsp;&nbsp;printf("showme [-bfw_Qh] input_file\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"The underscore indicates that a number should follow the <a href="CppOperatorMinus.htm">-</a>w <b><a href="CppSwitch.htm">switch</a></b>.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"input_file may be one of several types of file.&nbsp;&nbsp;It must have extension\n");<br/>
&nbsp;&nbsp;printf(<br/>
".node, .poly, .ele, .edge, .part, or .adj.&nbsp;&nbsp;If no extension is provided,\n");<br/>
&nbsp;&nbsp;printf(<br/>
"Show Me will assume the extension .ele.&nbsp;&nbsp;A .node file represents a set of\n");<br/>
&nbsp;&nbsp;printf(<br/>
"<a href="CppPointer.htm">point</a>s; a .poly file represents a Planar Straight Line Graph; an .ele file\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"(coupled with a .node file) represents the elements of a mesh or the\n");<br/>
&nbsp;&nbsp;printf(<br/>
"triangles of a triangulation; an .edge file (coupled with a .node file)\n");<br/>
&nbsp;&nbsp;printf(<br/>
"represents a set of edges; a .part file specifies a partition of a mesh;\n");<br/>
&nbsp;&nbsp;printf(<br/>
"and a .adj file represents the adjacency graph defined by a partition.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("Command Line Switches:\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>b&nbsp;&nbsp;Makes all PostScript output black and white.&nbsp;&nbsp;If <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> is not\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selected, color PostScript is used <b><a href="CppFor.htm">for</a></b> partitioned meshes and\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjacency graphs (.part and .adj files).\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>f&nbsp;&nbsp;On color displays and in color PostScript, displays partitioned\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meshes by filling triangles with color, rather than by coloring the\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges.&nbsp;&nbsp;This <b><a href="CppSwitch.htm">switch</a></b> will result in a clearer picture <b><a href="CppIf.htm">if</a></b> all\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles are reasonably large, and a less clear picture <b><a href="CppIf.htm">if</a></b> small\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles are present.&nbsp;&nbsp;(There is also a button to toggle <b><a href="CppThis.htm">this</a></b>\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;behavior.)\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>w&nbsp;&nbsp;Followed by an <a href="CppInt.htm">integer</a>, specifies the line width used in all\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;images.&nbsp;&nbsp;(There are also buttons to change the line width.)\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>Q&nbsp;&nbsp;Quiet:&nbsp;&nbsp;Suppresses all explanation of what Show Me is doing, unless\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an error occurs.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>h&nbsp;&nbsp;Help:&nbsp;&nbsp;Displays these instructions.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("Controls:\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;To zoom in on an image, <a href="CppPointer.htm">point</a> at the location where you want a closer\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;look, and click the left mouse button.&nbsp;&nbsp;To zoom out, click the right\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;mouse button.&nbsp;&nbsp;In either <b><a href="CppCase.htm">case</a></b>, the <a href="CppPointer.htm">point</a> you click on will be centered in\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;the window.&nbsp;&nbsp;If you want to know the coordinates of a <a href="CppPointer.htm">point</a>, click the\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;middle mouse button; the coordinates will be printed on the terminal you\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;invoked Show Me from.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;If you resize the window, the image will grow or shrink to match.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;There is a panel of control buttons at the bottom of the Show Me window:\n"<br/>
);<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;Quit:&nbsp;&nbsp;Shuts down Show Me.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&lt;, &gt;, ^, v:&nbsp;&nbsp;Moves the image in the indicated direction.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Reset: Unzooms and centers the image in the window.&nbsp;&nbsp;When you <b><a href="CppSwitch.htm">switch</a></b> from\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;one image to another, the viewing region does not change, so you may\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;need to reset the <b><a href="CppNew.htm">new</a></b> image to <a href="CppMake.htm">make</a> it fully visible.&nbsp;&nbsp;This often is\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;the <b><a href="CppCase.htm">case</a></b> when <b><a href="CppSwitch.htm">switch</a></b>ing between Delaunay triangulations and their\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;corresponding Voronoi diagrams, as Voronoi vertices can be far from the\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;initial <a href="CppPointer.htm">point</a> set.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Width+, <a href="CppOperatorMinus.htm">-</a>:&nbsp;&nbsp;<a href="CppIncrease.htm">Increase</a>s or decreases the width of all lines and <a href="CppPointer.htm">point</a>s.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Exp, <a href="CppOperatorPlus.htm">+</a>, <a href="CppOperatorMinus.htm">-</a>:&nbsp;&nbsp;These buttons appear only when you are viewing a partitioned\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;mesh (.part file).&nbsp;&nbsp;`Exp' toggles between an exploded and non-exploded\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;image of the mesh.&nbsp;&nbsp;The non-exploded image will not show the partition\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;on a black and white monitor.&nbsp;&nbsp;`+' and `-' allow you to adjust the\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;spacing between pieces of the mesh to better distinguish them.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Fill:&nbsp;&nbsp;This button appears only when you are viewing a partitioned mesh\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;(.part file).&nbsp;&nbsp;It toggles between color-filled triangles and colored\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;edges (as the <a href="CppOperatorMinus.htm">-</a>f <b><a href="CppSwitch.htm">switch</a></b> does).&nbsp;&nbsp;Filled triangles look better when all\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;triangles are reasonably large; colored edges look better when there\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;are very small triangles present.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;PS:&nbsp;&nbsp;Creates a PostScript file containing the image you are viewing.&nbsp;&nbsp;If\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;the <a href="CppOperatorMinus.htm">-</a>b <b><a href="CppSwitch.htm">switch</a></b> is selected, all PostScript output will be black and\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;white; otherwise, .part.ps and .adj.ps files will be color, independent\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;of whether you are <b><a href="CppUsing.htm">using</a></b> a color monitor.&nbsp;&nbsp;Normally the output will\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;preserve the properties of the image you see on the screen, including\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;zoom and line width; however, <b><a href="CppIf.htm">if</a></b> black and white output is selected (-b\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b>), partitioned meshes will always be drawn exploded.&nbsp;&nbsp;The output\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;file name depends on the image being viewed.&nbsp;&nbsp;If you want several\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;different snapshots (zooming in on different parts) of the same object,\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;you'll have to rename each file after Show Me creates it so that it\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;isn't overwritten by the next snapshot.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;EPS:&nbsp;&nbsp;Creates an encapsulated PostScript file, suitable <b><a href="CppFor.htm">for</a></b> inclusion in\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;documents.&nbsp;&nbsp;Otherwise, <b><a href="CppThis.htm">this</a></b> button is just like the PS button.&nbsp;&nbsp;(The\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;only difference is that .eps files lack a `showpage' command at the\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;end.)\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;There are two nearly-identical rows of buttons that load different images\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;from disk.&nbsp;&nbsp;Each row contains the following buttons:\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;node:&nbsp;&nbsp;Loads a .node file.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;poly:&nbsp;&nbsp;Loads a .poly file (and possibly an associated .node file).\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;ele:&nbsp;&nbsp;Loads an .ele file (and associated .node file).\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;edge:&nbsp;&nbsp;Loads an .edge file (and associated .node file).\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;part:&nbsp;&nbsp;Loads a .part file (and associated .node and .ele files).\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;adj:&nbsp;&nbsp;Loads an .adj file (and associated .node, .ele, and .part files).\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;voro:&nbsp;&nbsp;Loads a .v.node and .v.edge file <b><a href="CppFor.htm">for</a></b> a Voronoi diagram.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Each row represents a different iteration number of the <a href="CppGeometry.htm">geometry</a> files.\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;For a full explanation of iteration numbers, read the instructions <b><a href="CppFor.htm">for</a></b>\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Triangle.&nbsp;&nbsp;Briefly, iteration numbers are used to allow a user to easily\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;represent a sequence of related triangulations.&nbsp;&nbsp;Iteration numbers are\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;used in the names of <a href="CppGeometry.htm">geometry</a> files; <b><a href="CppFor.htm">for</a></b> <a href="CppInstance.htm">instance</a>, mymesh.3.ele is a\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;triangle file with iteration number three, and mymesh.ele has an implicit\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;iteration number of zero.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;The control buttons at the right end of each row display the two\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;iterations currently under view.&nbsp;&nbsp;These buttons can be clicked to\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;increase or decrease the iteration numbers, and thus conveniently view\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;a sequence of meshes.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Show Me keeps each file in <a href="CppMemory.htm">memory</a> after loading it, but you can force\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Show Me to reread a set of files (<b><a href="CppFor.htm">for</a></b> one iteration number) by reclicking\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;the button that corresponds to the current image.&nbsp;&nbsp;This is convenient <b><a href="CppIf.htm">if</a></b>\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;you have changed a <a href="CppGeometry.htm">geometry</a> file.\n\n");<br/>
&nbsp;&nbsp;printf("File Formats:\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;All files may contain comments prefixed by the <a href="CppChar.htm">character</a> '#'.&nbsp;&nbsp;<a href="CppPoint.htm">Point</a>s,\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;segments, holes, triangles, edges, and subdomains must be numbered\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;consecutively, starting from either 1 or 0.&nbsp;&nbsp;Whichever you choose, all\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;input files must be consistent (<b><a href="CppFor.htm">for</a></b> <a href="CppAny.htm">any</a> single iteration number); <b><a href="CppIf.htm">if</a></b> the\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;nodes are numbered from 1, so must be all other objects.&nbsp;&nbsp;Show Me\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;automatically detects your choice <b><a href="CppWhile.htm">while</a></b> reading a .node (or .poly) file.\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;Examples of these file formats are given below.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;.node files:\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of <a href="CppPointer.htm">point</a>s&gt; &lt;dimension (must be 2)&gt; &lt;# of attributes&gt;\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;# of boundary markers (0 or 1)&gt;\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;Remaining lines:&nbsp;&nbsp;&lt;<a href="CppPointer.htm">point</a> #&gt; &lt;x&gt; &lt;y&gt; [attributes] [boundary marker]\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;The attributes, which are typically floating-<a href="CppPointer.htm">point</a> values of physical\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;quantities (such as mass or conductivity) associated with the nodes of\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;a finite element mesh, are ignored by Show Me.&nbsp;&nbsp;Show Me also ignores\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;boundary markers.&nbsp;&nbsp;See the instructions <b><a href="CppFor.htm">for</a></b> Triangle to find out what\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;attributes and boundary markers are.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;.poly files:\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of <a href="CppPointer.htm">point</a>s&gt; &lt;dimension (must be 2)&gt; &lt;# of attributes&gt;\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;# of boundary markers (0 or 1)&gt;\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;<a href="CppPointer.htm">point</a> #&gt; &lt;x&gt; &lt;y&gt; [attributes] [boundary marker]\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;One line:&nbsp;&nbsp;&lt;# of segments&gt; &lt;# of boundary markers (0 or 1)&gt;\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;segment #&gt; &lt;endpoint&gt; &lt;endpoint&gt; [boundary marker]\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;One line:&nbsp;&nbsp;&lt;# of holes&gt;\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;hole #&gt; &lt;x&gt; &lt;y&gt;\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;[Optional additional lines that are ignored]\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;A .poly file represents a Planar Straight Line Graph (PSLG), an idea\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;familiar to computational geometers.&nbsp;&nbsp;By <a href="CppDefinition.htm">definition</a>, a PSLG is just a\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;list of <a href="CppPointer.htm">point</a>s and edges.&nbsp;&nbsp;A .poly file also contains some additional\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;information.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;The first section lists all the <a href="CppPointer.htm">point</a>s, and is identical to the format\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;of .node files.&nbsp;&nbsp;&lt;# of <a href="CppPointer.htm">point</a>s&gt; may be set to zero to indicate that the\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>s are listed in a separate .node file; .poly files produced by\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;Triangle always have <b><a href="CppThis.htm">this</a></b> format.&nbsp;&nbsp;When Show Me reads such a file, it\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;also reads the corresponding .node file.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;The second section lists the segments.&nbsp;&nbsp;Segments are edges whose\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;presence in a triangulation produced from the PSLG is enforced.&nbsp;&nbsp;Each\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;segment is specified by listing the indices of its two endpoints.&nbsp;&nbsp;This\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;means that its endpoints must be included in the <a href="CppPointer.htm">point</a> list.&nbsp;&nbsp;Each\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;segment, like each <a href="CppPointer.htm">point</a>, may have a boundary marker, which is ignored\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;by Show Me.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;The third section lists holes and concavities that are desired in <a href="CppAny.htm">any</a>\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;triangulation generated from the PSLG.&nbsp;&nbsp;Holes are specified by\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;identifying a <a href="CppPointer.htm">point</a> inside each hole.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;.ele files:\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of triangles&gt; &lt;<a href="CppPointer.htm">point</a>s per triangle&gt; &lt;# of attributes&gt;\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;Remaining lines:&nbsp;&nbsp;&lt;triangle #&gt; &lt;<a href="CppPointer.htm">point</a>&gt; &lt;<a href="CppPointer.htm">point</a>&gt; &lt;<a href="CppPointer.htm">point</a>&gt; ... [attributes]\n"<br/>
);<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPoint.htm">Point</a>s are indices into the corresponding .node file.&nbsp;&nbsp;Show Me ignores\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;all but the first three <a href="CppPointer.htm">point</a>s of each triangle; these should be the\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;corners listed in <a href="CppCounter.htm">counter</a>clockwise order around the triangle.&nbsp;&nbsp;The\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;attributes are ignored by Show Me.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;.edge files:\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of edges&gt; &lt;# of boundary markers (0 or 1)&gt;\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;edge #&gt; &lt;endpoint&gt; &lt;endpoint&gt; [boundary marker]\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;End<a href="CppPointer.htm">point</a>s are indices into the corresponding .node file.&nbsp;&nbsp;The boundary\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;markers are ignored by Show Me.\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;In Voronoi diagrams, one also finds a special kind of edge that is an\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;infinite ray with only one endpoint.&nbsp;&nbsp;For these edges, a different\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;format is used:\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;edge #&gt; &lt;endpoint&gt; <a href="CppOperatorMinus.htm">-</a>1 &lt;direction x&gt; &lt;direction y&gt;\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;The `direction' is a floating-<a href="CppPointer.htm">point</a> vector that indicates the direction\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;of the infinite ray.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;.part files:\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of triangles&gt; &lt;# of subdomains&gt;\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;Remaining lines:&nbsp;&nbsp;&lt;triangle #&gt; &lt;subdomain #&gt;\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;The set of triangles is partitioned by a .part file; each triangle is\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;mapped to a subdomain.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;.adj files:\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of subdomains&gt;\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;Remaining lines:&nbsp;&nbsp;&lt;adjacency <a href="CppMatrix.htm">matrix</a> entry&gt;\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;An .adj file represents adjacencies between subdomains (presumably\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;computed by a partitioner).&nbsp;&nbsp;The first line is followed by\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;(subdomains X subdomains) lines, each containing one entry of the\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;adjacency <a href="CppMatrix.htm">matrix</a>.&nbsp;&nbsp;A nonzero entry indicates that two subdomains are\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;adjacent (share a <a href="CppPointer.htm">point</a>).\n\n");<br/>
&nbsp;&nbsp;printf("Example:\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Here is a sample file `box.poly' desc<a href="CppRibi.htm">ribi</a>ng a square with a square hole:\n"<br/>
);<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;&nbsp;&nbsp;# A box with eight <a href="CppPointer.htm">point</a>s in 2D, no attributes, no boundary marker.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;8 2 0 0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Outer box has these vertices:\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0 0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 0 3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 3 0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 3 3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Inner square has these vertices:\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 1 1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 1 2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp; 2 1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 2 2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Five segments without boundary markers.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;5 0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Left side of outer box.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Segments 2 through 5 enclose the hole.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 7 8\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 8 6\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 6 5\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# One hole in the middle of the inner square.\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1.5 1.5\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;After <b><a href="CppThis.htm">this</a></b> PSLG is triangulated by Triangle, the resulting triangulation\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;consists of a .node and .ele file.&nbsp;&nbsp;Here is the former, `box.1.node',\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;which duplicates the <a href="CppPointer.htm">point</a>s of the PSLG:\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;2&nbsp;&nbsp;0&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Generated by triangle <a href="CppOperatorMinus.htm">-</a>pcBev box\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;Here is the triangulation file, `box.1.ele'.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;3&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; 6\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 8\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; 5\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 7\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Generated by triangle <a href="CppOperatorMinus.htm">-</a>pcBev box\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;Here is the edge file <b><a href="CppFor.htm">for</a></b> the triangulation, `box.1.edge'.\n\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;5\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5&nbsp;&nbsp;6\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 6&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 1&nbsp;&nbsp;3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 3&nbsp;&nbsp;5\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 2&nbsp;&nbsp;6\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp; 6&nbsp;&nbsp;8\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 8&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 2&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp; 7&nbsp;&nbsp;3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp; 3&nbsp;&nbsp;4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp; 4&nbsp;&nbsp;7\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp; 7&nbsp;&nbsp;5\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp; 8&nbsp;&nbsp;4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp; 4&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp; 8&nbsp;&nbsp;7\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Generated by triangle <a href="CppOperatorMinus.htm">-</a>pcBev box\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Here's a file `box.1.part' that partitions the mesh into four subdomains.\n"<br/>
);<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;3\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;1\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;# Generated by slice <a href="CppOperatorMinus.htm">-</a>s4 box.1\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;Here's a file `box.1.adj' that represents the resulting adjacencies.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;4\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("Display Speed:\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;It is worth<b><a href="CppWhile.htm">while</a></b> to note that .edge files typically plot and print twice\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;as quickly as .ele files, because .ele files cause each internal edge to\n"<br/>
);<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;be drawn twice.&nbsp;&nbsp;For the same reason, PostScript files created from edge\n"<br/>
);<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;sets are smaller than those created from triangulations.\n\n");<br/>
&nbsp;&nbsp;printf("Show Me on the Web:\n\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;To see an illustrated, updated <a href="CppVersion.htm">version</a> of these instructions, check out\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;http://www.cs.cmu.edu/~quake/showme.html\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf("A Brief Plea:\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;If you use Show Me (or Triangle), and especially <b><a href="CppIf.htm">if</a></b> you use it to\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;accomplish real work, I would like very much to hear from you.&nbsp;&nbsp;A <b><a href="CppShort.htm">short</a></b>\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;letter or email (to jrs@cs.cmu.edu) desc<a href="CppRibi.htm">ribi</a>ng how you use Show Me (and\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;its sister programs) will mean a lot to me.&nbsp;&nbsp;The more people I know\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;are <b><a href="CppUsing.htm">using</a></b> my programs, the more easily I can justify spending <a href="CppTime.htm">time</a> on\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;improvements, which in turn will benefit you.&nbsp;&nbsp;Also, I can put you\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;on a list to receive email whenever <b><a href="CppNew.htm">new</a></b> <a href="CppVersion.htm">version</a>s are available.\n");<br/>
&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;printf(<br/>
"&nbsp;&nbsp;If you use a PostScript file generated by Show Me in a <b><a href="CppPublic.htm">public</a></b>ation,\n");<br/>
&nbsp;&nbsp;printf("&nbsp;&nbsp;please include an acknowledgment as well.\n\n");<br/>
&nbsp;&nbsp;exit(0);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> set_filenames(filename, lowermeshnumber)<br/>
<b><a href="CppChar.htm">char</a></b> *filename;<br/>
<b><a href="CppInt.htm">int</a></b> lowermeshnumber;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> numberstring[100];<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(nodefilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(polyfilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(elefilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(edgefilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(partfilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(adjfilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(vnodefilename[i], filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(vedgefilename[i], filename);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lowermeshnumber <a href="CppOperatorPlus.htm">+</a> i &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSprintf.htm">sprintf</a>(numberstring, ".%d", lowermeshnumber <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(nodefilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(polyfilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(elefilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(edgefilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(partfilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(adjfilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(vnodefilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(vedgefilename[i], numberstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(nodefilename[i], ".node");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(polyfilename[i], ".poly");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(elefilename[i], ".ele");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(edgefilename[i], ".edge");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(partfilename[i], ".part");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(adjfilename[i], ".adj");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(vnodefilename[i], ".v.node");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(vedgefilename[i], ".v.edge");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> parsecommandline(<a href="CppArgc.htm">argc</a>, <a href="CppArgc.htm">argv</a>)<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppArgc.htm">argc</a>;<br/>
<b><a href="CppChar.htm">char</a></b> **<a href="CppArgc.htm">argv</a>;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> increment;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> meshnumber;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
<br/>
&nbsp;&nbsp;quiet <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;fillelem <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;line_width <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;bw_ps <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> ELE;<br/>
&nbsp;&nbsp;filename[0] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i &lt; <a href="CppArgc.htm">argc</a>; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArgc.htm">argv</a>[i][0] <a href="CppOperatorEqual.htm">==</a> '-') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 1; <a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorNotEqual.htm">!=</a> '\0'; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> 'f') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fillelem <a href="CppOperatorAssign.htm">=</a> 1;<br/>
	}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> 'w') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppArgc.htm">argv</a>[i][j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '1') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (<a href="CppArgc.htm">argv</a>[i][j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_width <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((<a href="CppArgc.htm">argv</a>[i][j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (<a href="CppArgc.htm">argv</a>[i][j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_width <a href="CppOperatorAssign.htm">=</a> line_width * 10 <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppInt.htm">int</a></b>) (<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorMinus.htm">-</a> '0');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (line_width &gt; 100) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Line width cannot exceed 100.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_width <a href="CppOperatorAssign.htm">=</a> 1;<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
	&nbsp;&nbsp;}<br/>
	}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> 'b') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bw_ps <a href="CppOperatorAssign.htm">=</a> 1;<br/>
	}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> 'Q') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quiet <a href="CppOperatorAssign.htm">=</a> 1;<br/>
	}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> 'h') <a href="CppOperatorLogicalOr.htm">||</a> (<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> 'H') <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a href="CppArgc.htm">argv</a>[i][j] <a href="CppOperatorEqual.htm">==</a> '?')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info();<br/>
	}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(filename, <a href="CppArgc.htm">argv</a>[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (filename[0] <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;syntax();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!strcmp(&amp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5], ".node")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> NODE;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!strcmp(&amp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5], ".poly")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> POLY;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!strcmp(&amp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 4], ".ele")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 4] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> ELE;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!strcmp(&amp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5], ".edge")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> EDGE;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!strcmp(&amp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5], ".part")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> PART;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!strcmp(&amp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 4], ".adj")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[<a href="CppStrlen.htm">strlen</a>(filename) <a href="CppOperatorMinus.htm">-</a> 4] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_image <a href="CppOperatorAssign.htm">=</a> ADJ;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;increment <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;j <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (filename[j] <a href="CppOperatorNotEqual.htm">!=</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((filename[j] <a href="CppOperatorEqual.htm">==</a> '.') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (filename[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorNotEqual.htm">!=</a> '\0')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;meshnumber <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (increment &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;j <a href="CppOperatorAssign.htm">=</a> increment;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((filename[j] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (filename[j] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meshnumber <a href="CppOperatorAssign.htm">=</a> meshnumber * 10 <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppInt.htm">int</a></b>) (filename[j] <a href="CppOperatorMinus.htm">-</a> '0');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (filename[j] <a href="CppOperatorNotEqual.htm">!=</a> '\0');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (increment &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;filename[increment <a href="CppOperatorMinus.htm">-</a> 1] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (meshnumber <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loweriteration <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;start_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loweriteration <a href="CppOperatorAssign.htm">=</a> meshnumber <a href="CppOperatorMinus.htm">-</a> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;set_filenames(filename, loweriteration);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> free_inc(inc)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][NODE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(nodeptr[inc]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][POLY]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (polynodes[inc] &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(polynodeptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(polyedgeptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(polyholeptr[inc]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][ELE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(eleptr[inc]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][PART]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(partpart[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(partcenter[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(partshift[inc]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][EDGE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(edgeptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(normptr[inc]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][ADJ]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(adjptr[inc]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][VORO]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(vnodeptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(vedgeptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(vnormptr[inc]);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> move_inc(inc)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;free_inc(1 <a href="CppOperatorMinus.htm">-</a> inc);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; IMAGE_TYPES; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loaded[1 <a href="CppOperatorMinus.htm">-</a> inc][i] <a href="CppOperatorAssign.htm">=</a> loaded[inc][i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loaded[inc][i] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xlo[1 <a href="CppOperatorMinus.htm">-</a> inc][i] <a href="CppOperatorAssign.htm">=</a> xlo[inc][i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ylo[1 <a href="CppOperatorMinus.htm">-</a> inc][i] <a href="CppOperatorAssign.htm">=</a> ylo[inc][i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xhi[1 <a href="CppOperatorMinus.htm">-</a> inc][i] <a href="CppOperatorAssign.htm">=</a> xhi[inc][i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;yhi[1 <a href="CppOperatorMinus.htm">-</a> inc][i] <a href="CppOperatorAssign.htm">=</a> yhi[inc][i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;nodes[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> nodes[inc];<br/>
&nbsp;&nbsp;node_dim[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> node_dim[inc];<br/>
&nbsp;&nbsp;nodeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> nodeptr[inc];<br/>
&nbsp;&nbsp;polynodes[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> polynodes[inc];<br/>
&nbsp;&nbsp;poly_dim[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> poly_dim[inc];<br/>
&nbsp;&nbsp;polyedges[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> polyedges[inc];<br/>
&nbsp;&nbsp;polyholes[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> polyholes[inc];<br/>
&nbsp;&nbsp;polynodeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> polynodeptr[inc];<br/>
&nbsp;&nbsp;polyedgeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> polyedgeptr[inc];<br/>
&nbsp;&nbsp;polyholeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> polyholeptr[inc];<br/>
&nbsp;&nbsp;elems[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> elems[inc];<br/>
&nbsp;&nbsp;ele_corners[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> ele_corners[inc];<br/>
&nbsp;&nbsp;eleptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> eleptr[inc];<br/>
&nbsp;&nbsp;edges[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> edges[inc];<br/>
&nbsp;&nbsp;edgeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> edgeptr[inc];<br/>
&nbsp;&nbsp;normptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> normptr[inc];<br/>
&nbsp;&nbsp;subdomains[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> subdomains[inc];<br/>
&nbsp;&nbsp;partpart[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> partpart[inc];<br/>
&nbsp;&nbsp;partcenter[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> partcenter[inc];<br/>
&nbsp;&nbsp;partshift[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> partshift[inc];<br/>
&nbsp;&nbsp;adjsubdomains[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> adjsubdomains[inc];<br/>
&nbsp;&nbsp;adjptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> adjptr[inc];<br/>
&nbsp;&nbsp;vnodes[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> vnodes[inc];<br/>
&nbsp;&nbsp;vnode_dim[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> vnode_dim[inc];<br/>
&nbsp;&nbsp;vnodeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> vnodeptr[inc];<br/>
&nbsp;&nbsp;vedges[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> vedges[inc];<br/>
&nbsp;&nbsp;vedgeptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> vedgeptr[inc];<br/>
&nbsp;&nbsp;vnormptr[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> vnormptr[inc];<br/>
&nbsp;&nbsp;firstnumber[1 <a href="CppOperatorMinus.htm">-</a> inc] <a href="CppOperatorAssign.htm">=</a> firstnumber[inc];<br/>
&nbsp;&nbsp;firstnumber[inc] <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> unload_inc(inc)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;current_image <a href="CppOperatorAssign.htm">=</a> NOTHING;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; IMAGE_TYPES; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loaded[inc][i] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;firstnumber[inc] <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> showme_init()<br/>
{<br/>
&nbsp;&nbsp;current_image <a href="CppOperatorAssign.htm">=</a> NOTHING;<br/>
&nbsp;&nbsp;current_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;explosion <a href="CppOperatorAssign.htm">=</a> STARTEXPLOSION;<br/>
&nbsp;&nbsp;unload_inc(0);<br/>
&nbsp;&nbsp;unload_inc(1);<br/>
}<br/>
<br/>
<b><a href="CppChar.htm">char</a></b> *readline(string, infile, infilename)<br/>
<b><a href="CppChar.htm">char</a></b> *string;<br/>
<a href="CppCfile.htm">FILE</a> *infile;<br/>
<b><a href="CppChar.htm">char</a></b> *infilename;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *result;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result <a href="CppOperatorAssign.htm">=</a> fgets(string, INPUTLINESIZE, infile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (result <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppChar.htm">char</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Unexpected end of file in <a href="CppOperatorModulus.htm">%</a>s.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; infilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorNotEqual.htm">!=</a> '\0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '#')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '.') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '+') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '-')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((*result &lt; '0') <a href="CppOperatorLogicalOr.htm">||</a> (*result &gt; '9'))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorEqual.htm">==</a> '#') <a href="CppOperatorLogicalOr.htm">||</a> (*result <a href="CppOperatorEqual.htm">==</a> '\0'));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<b><a href="CppChar.htm">char</a></b> *findfield(string)<br/>
<b><a href="CppChar.htm">char</a></b> *string;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *result;<br/>
<br/>
&nbsp;&nbsp;result <a href="CppOperatorAssign.htm">=</a> string;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorNotEqual.htm">!=</a> '\0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '#')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> ' ') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '\t')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorNotEqual.htm">!=</a> '\0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '#')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '.') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '+') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '-')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((*result &lt; '0') <a href="CppOperatorLogicalOr.htm">||</a> (*result &gt; '9'))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*result <a href="CppOperatorEqual.htm">==</a> '#') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*result <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_node(fname, firstnumber, nodes, dim, ptr, xmin, ymin, xmax, ymax)<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<b><a href="CppInt.htm">int</a></b> *firstnumber;<br/>
<b><a href="CppInt.htm">int</a></b> *nodes;<br/>
<b><a href="CppInt.htm">int</a></b> *dim;<br/>
REAL **ptr;<br/>
REAL *xmin;<br/>
REAL *ymin;<br/>
REAL *xmax;<br/>
REAL *ymax;<br/>
{<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *infile;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[INPUTLINESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> extras;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> nodemarks;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> nod<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> smallerr;<br/>
&nbsp;&nbsp;REAL x, y;<br/>
<br/>
&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> *ymin <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;*xmax <a href="CppOperatorAssign.htm">=</a> *ymax <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Opening <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;infile <a href="CppOperatorAssign.htm">=</a> fopen(fname, "r");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (infile <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Cannot access file <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*nodes <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*nodes &lt; 3) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d <a href="CppPointer.htm">point</a>s.\n", fname, *nodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*dim <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*dim <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*dim &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has dimensionality <a href="CppOperatorModulus.htm">%</a>d.\n", fname, *dim);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*dim <a href="CppOperatorNotEqual.htm">!=</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;I only understand two-dimensional meshes.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;extras <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;extras <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (extras &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> number of attributes.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodemarks <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodemarks <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nodemarks &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> number of <a href="CppPointer.htm">point</a> markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nodemarks &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf(<br/>
&nbsp;&nbsp; "&nbsp;&nbsp;Warning:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has value greater than one <b><a href="CppFor.htm">for</a></b> number of <a href="CppPointer.htm">point</a> markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*ptr <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc((*nodes <a href="CppOperatorPlus.htm">+</a> 1) * *dim * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*ptr <a href="CppOperatorEqual.htm">==</a> (REAL *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> *dim;<br/>
&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; *nodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((i <a href="CppOperatorEqual.htm">==</a> 0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*firstnumber <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*firstnumber <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*firstnumber <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((nod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorNotEqual.htm">!=</a> *firstnumber <a href="CppOperatorPlus.htm">+</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;<a href="CppPoint.htm">Point</a>s in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with <a href="CppPointer.htm">point</a> <a href="CppOperatorModulus.htm">%</a>d).\n", *firstnumber <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; *dim; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;<a href="CppPoint.htm">Point</a> <a href="CppOperatorModulus.htm">%</a>d is missing a coordinate in <a href="CppOperatorModulus.htm">%</a>s.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *firstnumber <a href="CppOperatorPlus.htm">+</a> i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*ptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ptr)[index<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> (REAL) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fclose(infile);<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> *dim;<br/>
&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> *xmax <a href="CppOperatorAssign.htm">=</a> (*ptr)[index];<br/>
&nbsp;&nbsp;*ymin <a href="CppOperatorAssign.htm">=</a> *ymax <a href="CppOperatorAssign.htm">=</a> (*ptr)[index <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 2; i <a href="CppOperatorLessEqual.htm">&lt;=</a> *nodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> *dim;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (*ptr)[index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (*ptr)[index <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &lt; *xmin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y &lt; *ymin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ymin <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &gt; *xmax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xmax <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y &gt; *ymax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ymax <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*xmin <a href="CppOperatorEqual.htm">==</a> *xmax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*xmin <a href="CppOperatorMinusAssign.htm">-=</a> 0.5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*xmax <a href="CppOperatorPlusAssign.htm">+=</a> 0.5;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*ymin <a href="CppOperatorEqual.htm">==</a> *ymax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*ymin <a href="CppOperatorMinusAssign.htm">-=</a> 0.5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*ymax <a href="CppOperatorPlusAssign.htm">+=</a> 0.5;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_poly(inc, fname, firstnumber, pnodes, dim, edges, holes, nodeptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edgeptr, holeptr, xmin, ymin, xmax, ymax)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<b><a href="CppInt.htm">int</a></b> *firstnumber;<br/>
<b><a href="CppInt.htm">int</a></b> *pnodes;<br/>
<b><a href="CppInt.htm">int</a></b> *dim;<br/>
<b><a href="CppInt.htm">int</a></b> *edges;<br/>
<b><a href="CppInt.htm">int</a></b> *holes;<br/>
REAL **nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> **edgeptr;<br/>
REAL **holeptr;<br/>
REAL *xmin;<br/>
REAL *ymin;<br/>
REAL *xmax;<br/>
REAL *ymax;<br/>
{<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *infile;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[INPUTLINESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> extras;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> nodemarks;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> segmentmarks;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> nod<b><a href="CppEnum.htm">enum</a></b>ber, edg<b><a href="CppEnum.htm">enum</a></b>ber, hol<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> maxnode;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> smallerr;<br/>
&nbsp;&nbsp;REAL x, y;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Opening <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;infile <a href="CppOperatorAssign.htm">=</a> fopen(fname, "r");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (infile <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Cannot access file <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*pnodes <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*pnodes <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][NODE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (load_image(inc, NODE)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maxnode <a href="CppOperatorAssign.htm">=</a> nodes[inc];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> xlo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*ymin <a href="CppOperatorAssign.htm">=</a> ylo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*xmax <a href="CppOperatorAssign.htm">=</a> xhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*ymax <a href="CppOperatorAssign.htm">=</a> yhi[inc][NODE];<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*pnodes &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d <a href="CppPointer.htm">point</a>s.\n", fname, *pnodes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;maxnode <a href="CppOperatorAssign.htm">=</a> *pnodes;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*dim <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*dim <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*dim &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has dimensionality <a href="CppOperatorModulus.htm">%</a>d.\n", fname, *dim);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*dim <a href="CppOperatorNotEqual.htm">!=</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;I only understand two-dimensional .poly files.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;extras <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;extras <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (extras &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> number of attributes.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodemarks <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodemarks <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nodemarks &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> number of <a href="CppPointer.htm">point</a> markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nodemarks &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf(<br/>
&nbsp;&nbsp; "&nbsp;&nbsp;Warning:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has value greater than one <b><a href="CppFor.htm">for</a></b> number of <a href="CppPointer.htm">point</a> markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*pnodes &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*nodeptr <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc((*pnodes <a href="CppOperatorPlus.htm">+</a> 1) * *dim * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*nodeptr <a href="CppOperatorEqual.htm">==</a> (REAL *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> *dim;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; *pnodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((i <a href="CppOperatorEqual.htm">==</a> 0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*firstnumber <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*firstnumber <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*firstnumber <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((nod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorNotEqual.htm">!=</a> *firstnumber <a href="CppOperatorPlus.htm">+</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;<a href="CppPoint.htm">Point</a>s in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with <a href="CppPointer.htm">point</a> <a href="CppOperatorModulus.htm">%</a>d).\n", *firstnumber <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; *dim; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;<a href="CppPoint.htm">Point</a> <a href="CppOperatorModulus.htm">%</a>d is missing a coordinate in <a href="CppOperatorModulus.htm">%</a>s.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *firstnumber <a href="CppOperatorPlus.htm">+</a> i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*nodeptr)[index<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> (REAL) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*edges <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*edges &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d segments.\n", fname, *edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;segmentmarks <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;segmentmarks <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (segmentmarks &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> number of segment markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (segmentmarks &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf(<br/>
&nbsp;&nbsp; "&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has value greater than one <b><a href="CppFor.htm">for</a></b> number of segment markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*edgeptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc(((*edges <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*edgeptr <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> *firstnumber; i &lt; *firstnumber <a href="CppOperatorPlus.htm">+</a> *edges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((edg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorNotEqual.htm">!=</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;Segments in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with segment <a href="CppOperatorModulus.htm">%</a>d).\n", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Segment <a href="CppOperatorModulus.htm">%</a>d is missing its endpoints in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*edgeptr)[index] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0) <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((*edgeptr)[index] &lt; 1) <a href="CppOperatorLogicalOr.htm">||</a> ((*edgeptr)[index] &gt; maxnode)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Segment <a href="CppOperatorModulus.htm">%</a>d has invalid endpoint in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Segment <a href="CppOperatorModulus.htm">%</a>d is missing an endpoint in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0) <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] &lt; 1) <a href="CppOperatorLogicalOr.htm">||</a> ((*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] &gt; maxnode)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Segment <a href="CppOperatorModulus.htm">%</a>d has invalid endpoint in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> 2;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*holes <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*holes &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d holes.\n", fname, *holes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*holeptr <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc((*holes <a href="CppOperatorPlus.htm">+</a> 1) * *dim * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*holeptr <a href="CppOperatorEqual.htm">==</a> (REAL *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> *dim;<br/>
&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> *firstnumber; i &lt; *firstnumber <a href="CppOperatorPlus.htm">+</a> *holes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;hol<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((hol<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorNotEqual.htm">!=</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;Holes in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with hole <a href="CppOperatorModulus.htm">%</a>d).\n", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; *dim; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Hole <a href="CppOperatorModulus.htm">%</a>d is missing a coordinate in <a href="CppOperatorModulus.htm">%</a>s.\n", i,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*nodeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*holeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*holeptr)[index<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> (REAL) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fclose(infile);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*pnodes &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> *dim;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> *xmax <a href="CppOperatorAssign.htm">=</a> (*nodeptr)[index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*ymin <a href="CppOperatorAssign.htm">=</a> *ymax <a href="CppOperatorAssign.htm">=</a> (*nodeptr)[index <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 2; i <a href="CppOperatorLessEqual.htm">&lt;=</a> *pnodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> *dim;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (*nodeptr)[index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (*nodeptr)[index <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &lt; *xmin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y &lt; *ymin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ymin <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &gt; *xmax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xmax <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y &gt; *ymax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ymax <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> *dim;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> *holes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (*holeptr)[index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (*holeptr)[index <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &lt; *xmin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xmin <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y &lt; *ymin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ymin <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (x &gt; *xmax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xmax <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (y &gt; *ymax) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ymax <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> *dim;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_ele(fname, firstnumber, nodes, elems, corners, ptr)<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<b><a href="CppInt.htm">int</a></b> firstnumber;<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> *elems;<br/>
<b><a href="CppInt.htm">int</a></b> *corners;<br/>
<b><a href="CppInt.htm">int</a></b> **ptr;<br/>
{<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *infile;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[INPUTLINESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> extras;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> elemnumber;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> smallerr;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Opening <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;infile <a href="CppOperatorAssign.htm">=</a> fopen(fname, "r");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (infile <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Cannot access file <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*elems <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*elems &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d triangles.\n", fname, *elems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*corners <a href="CppOperatorAssign.htm">=</a> 3;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*corners <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*corners &lt; 3) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Triangles in <a href="CppOperatorModulus.htm">%</a>s have only <a href="CppOperatorModulus.htm">%</a>d corners.\n", fname,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *corners);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;extras <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;extras <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (extras &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> extra fields.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*ptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc((*elems <a href="CppOperatorPlus.htm">+</a> 1) * 3 * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*ptr <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 3;<br/>
&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> firstnumber; i &lt; firstnumber <a href="CppOperatorPlus.htm">+</a> *elems; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elemnumber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((elemnumber <a href="CppOperatorNotEqual.htm">!=</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;Triangles in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with triangle <a href="CppOperatorModulus.htm">%</a>d).\n", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Triangle <a href="CppOperatorModulus.htm">%</a>d is missing a corner in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*ptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ptr)[index] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0) <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((*ptr)[index] &lt; 1) <a href="CppOperatorLogicalOr.htm">||</a> ((*ptr)[index] &gt; nodes)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Triangle <a href="CppOperatorModulus.htm">%</a>d has invalid corner in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fclose(infile);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_edge(fname, firstnumber, nodes, edges, edgeptr, normptr)<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<b><a href="CppInt.htm">int</a></b> firstnumber;<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> *edges;<br/>
<b><a href="CppInt.htm">int</a></b> **edgeptr;<br/>
REAL **normptr;<br/>
{<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *infile;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[INPUTLINESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> edg<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> edgemarks;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> smallerr;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Opening <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;infile <a href="CppOperatorAssign.htm">=</a> fopen(fname, "r");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (infile <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Cannot access file <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*edges <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*edges &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d edges.\n", fname, *edges);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edgemarks <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edgemarks <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgemarks &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has negative value <b><a href="CppFor.htm">for</a></b> number of edge markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgemarks &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf(<br/>
&nbsp;&nbsp; "&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s has value greater than one <b><a href="CppFor.htm">for</a></b> number of edge markers.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*edgeptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc(((*edges <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*edgeptr <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*normptr <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc(((*edges <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*normptr <a href="CppOperatorEqual.htm">==</a> (REAL *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> firstnumber; i &lt; firstnumber <a href="CppOperatorPlus.htm">+</a> *edges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((edg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorNotEqual.htm">!=</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;Edges in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with edge <a href="CppOperatorModulus.htm">%</a>d).\n", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Edge <a href="CppOperatorModulus.htm">%</a>d is missing its endpoints in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*normptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*edgeptr)[index] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0) <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((*edgeptr)[index] &lt; 1) <a href="CppOperatorLogicalOr.htm">||</a> ((*edgeptr)[index] &gt; nodes)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Edge <a href="CppOperatorModulus.htm">%</a>d has invalid endpoint in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Edge <a href="CppOperatorModulus.htm">%</a>d is missing an endpoint in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*normptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Edge <a href="CppOperatorModulus.htm">%</a>d is missing its direction in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*normptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*normptr)[index] <a href="CppOperatorAssign.htm">=</a> (REAL) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Edge <a href="CppOperatorModulus.htm">%</a>d is missing a direction coordinate in <a href="CppOperatorModulus.htm">%</a>s.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*edgeptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*normptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*normptr)[index <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> (REAL) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorPlusAssign.htm">+=</a> 1 <a href="CppOperatorMinus.htm">-</a> firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] &lt; 1) <a href="CppOperatorLogicalOr.htm">||</a> ((*edgeptr)[index <a href="CppOperatorPlus.htm">+</a> 1] &gt; nodes)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Edge <a href="CppOperatorModulus.htm">%</a>d has invalid endpoint in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> 2;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fclose(infile);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_part(fname, dim, firstnumber, elems, nodeptr, eleptr, parts,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partition, partcenter, partshift)<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> firstnumber;<br/>
<b><a href="CppInt.htm">int</a></b> elems;<br/>
REAL *nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> *eleptr;<br/>
<b><a href="CppInt.htm">int</a></b> *parts;<br/>
<b><a href="CppInt.htm">int</a></b> **partition;<br/>
REAL **partcenter;<br/>
REAL **partshift;<br/>
{<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *infile;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[INPUTLINESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> partelems;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> elemnumber;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> smallerr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *partsize;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Opening <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;infile <a href="CppOperatorAssign.htm">=</a> fopen(fname, "r");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (infile <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Cannot access file <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;partelems <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (partelems <a href="CppOperatorNotEqual.htm">!=</a> elems) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Error:&nbsp;&nbsp;.ele and .part files <b><a href="CppDo.htm">do</a></b> not agree on number of triangles.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*parts <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*parts <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*parts &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s specifies <a href="CppOperatorModulus.htm">%</a>d subdomains.\n", fname, *parts);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*partition <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc((elems <a href="CppOperatorPlus.htm">+</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*partition <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> firstnumber; i &lt; firstnumber <a href="CppOperatorPlus.htm">+</a> partelems; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elemnumber <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((elemnumber <a href="CppOperatorNotEqual.htm">!=</a> i) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (smallerr)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Warning:&nbsp;&nbsp;Triangles in <a href="CppOperatorModulus.htm">%</a>s are not numbered correctly.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(starting with triangle <a href="CppOperatorModulus.htm">%</a>d).\n", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallerr <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> findfield(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Triangle <a href="CppOperatorModulus.htm">%</a>d has no subdomain in <a href="CppOperatorModulus.htm">%</a>s.\n", i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*partition);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;j <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorMinus.htm">-</a> firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partition)[j] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0) <a href="CppOperatorMinus.htm">-</a> firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((*partition)[j] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> *parts) <a href="CppOperatorLogicalOr.htm">||</a> ((*partition)[j] &lt; 0)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Triangle <a href="CppOperatorModulus.htm">%</a>d of <a href="CppOperatorModulus.htm">%</a>s has an invalid subdomain.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*partition);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fclose(infile);<br/>
&nbsp;&nbsp;*partcenter <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc(((*parts <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*partcenter <a href="CppOperatorEqual.htm">==</a> (REAL *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*partition);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*partshift <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc((*parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*partshift <a href="CppOperatorEqual.htm">==</a> (REAL *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*partition);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*partcenter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;partsize <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc((*parts <a href="CppOperatorPlus.htm">+</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (partsize <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*partition);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*partcenter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(*partshift);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorLessEqual.htm">&lt;=</a> *parts; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;partsize[i] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[(i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 3;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> elems; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;partsize[(*partition)[i]] <a href="CppOperatorPlusAssign.htm">+=</a> 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[(*partition)[i] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorPlusAssign.htm">+=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeptr[eleptr[index] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[((*partition)[i] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorPlusAssign.htm">+=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeptr[eleptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; *parts; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorDivideAssign.htm">/=</a> (REAL) partsize[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[(i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorDivideAssign.htm">/=</a> (REAL) partsize[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[*parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorPlusAssign.htm">+=</a> (*partcenter)[i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*partcenter)[(*parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorPlusAssign.htm">+=</a> (*partcenter)[(i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;(*partcenter)[*parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorDivideAssign.htm">/=</a> (REAL) *parts;<br/>
&nbsp;&nbsp;(*partcenter)[(*parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorDivideAssign.htm">/=</a> (REAL) *parts;<br/>
&nbsp;&nbsp;free(partsize);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_adj(fname, subdomains, ptr)<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<b><a href="CppInt.htm">int</a></b> *subdomains;<br/>
<b><a href="CppInt.htm">int</a></b> **ptr;<br/>
{<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *infile;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[INPUTLINESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Opening <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;infile <a href="CppOperatorAssign.htm">=</a> fopen(fname, "r");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (infile <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Cannot access file <a href="CppOperatorModulus.htm">%</a>s.\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;*subdomains <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*subdomains &lt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>s contains <a href="CppOperatorModulus.htm">%</a>d subdomains.\n", fname, *subdomains);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*ptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc(*subdomains * *subdomains * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*ptr <a href="CppOperatorEqual.htm">==</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; *subdomains; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; *subdomains; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, infile, fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ptr)[i * *subdomains <a href="CppOperatorPlus.htm">+</a> j] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol (stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> findpartshift(parts, explosion, partcenter, partshift)<br/>
<b><a href="CppInt.htm">int</a></b> parts;<br/>
REAL explosion;<br/>
REAL *partcenter;<br/>
REAL *partshift;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; parts; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;partshift[i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorAssign.htm">=</a> explosion *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(partcenter[i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1] <a href="CppOperatorMinus.htm">-</a> partcenter[parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;partshift[(i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> explosion *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(partcenter[(i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorMinus.htm">-</a> partcenter[(parts <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1]);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> load_image(inc, image)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
<b><a href="CppInt.htm">int</a></b> image;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> error;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (image) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> NODE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_node(nodefilename[inc], &amp;firstnumber[inc], &amp;nodes[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;node_dim[inc], &amp;nodeptr[inc], &amp;xlo[inc][NODE],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;ylo[inc][NODE], &amp;xhi[inc][NODE], &amp;yhi[inc][NODE]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> POLY:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_poly(inc, polyfilename[inc], &amp;firstnumber[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;polynodes[inc], &amp;poly_dim[inc], &amp;polyedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;polyholes[inc], &amp;polynodeptr[inc], &amp;polyedgeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;polyholeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;xlo[inc][POLY], &amp;ylo[inc][POLY],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;xhi[inc][POLY], &amp;yhi[inc][POLY]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ELE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_ele(elefilename[inc], firstnumber[inc], nodes[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;elems[inc], &amp;ele_corners[inc], &amp;eleptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xlo[inc][ELE] <a href="CppOperatorAssign.htm">=</a> xlo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ylo[inc][ELE] <a href="CppOperatorAssign.htm">=</a> ylo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhi[inc][ELE] <a href="CppOperatorAssign.htm">=</a> xhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yhi[inc][ELE] <a href="CppOperatorAssign.htm">=</a> yhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> EDGE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_edge(edgefilename[inc], firstnumber[inc], nodes[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;edges[inc], &amp;edgeptr[inc], &amp;normptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xlo[inc][EDGE] <a href="CppOperatorAssign.htm">=</a> xlo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ylo[inc][EDGE] <a href="CppOperatorAssign.htm">=</a> ylo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhi[inc][EDGE] <a href="CppOperatorAssign.htm">=</a> xhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yhi[inc][EDGE] <a href="CppOperatorAssign.htm">=</a> yhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> PART:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_part(partfilename[inc], node_dim[inc], firstnumber[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elems[inc], nodeptr[inc], eleptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;subdomains[inc], &amp;partpart[inc], &amp;partcenter[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;partshift[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!error) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findpartshift(subdomains[inc], explosion, partcenter[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partshift[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xlo[inc][PART] <a href="CppOperatorAssign.htm">=</a> xlo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ylo[inc][PART] <a href="CppOperatorAssign.htm">=</a> ylo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhi[inc][PART] <a href="CppOperatorAssign.htm">=</a> xhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yhi[inc][PART] <a href="CppOperatorAssign.htm">=</a> yhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ADJ:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_adj(adjfilename[inc], &amp;adjsubdomains[inc], &amp;adjptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xlo[inc][ADJ] <a href="CppOperatorAssign.htm">=</a> xlo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ylo[inc][ADJ] <a href="CppOperatorAssign.htm">=</a> ylo[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xhi[inc][ADJ] <a href="CppOperatorAssign.htm">=</a> xhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yhi[inc][ADJ] <a href="CppOperatorAssign.htm">=</a> yhi[inc][NODE];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> VORO:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_node(vnodefilename[inc], &amp;firstnumber[inc], &amp;vnodes[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;vnode_dim[inc], &amp;vnodeptr[inc], &amp;xlo[inc][VORO],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;ylo[inc][VORO], &amp;xhi[inc][VORO], &amp;yhi[inc][VORO]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!error) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> load_edge(vedgefilename[inc], firstnumber[inc], vnodes[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;vedges[inc], &amp;vedgeptr[inc], &amp;vnormptr[inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!error) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loaded[inc][image] <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> error;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> choose_image(inc, image)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
<b><a href="CppInt.htm">int</a></b> image;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][image]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((image <a href="CppOperatorEqual.htm">==</a> ELE) <a href="CppOperatorLogicalOr.htm">||</a> (image <a href="CppOperatorEqual.htm">==</a> EDGE) <a href="CppOperatorLogicalOr.htm">||</a> (image <a href="CppOperatorEqual.htm">==</a> PART)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> (image <a href="CppOperatorEqual.htm">==</a> ADJ)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][NODE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (load_image(inc, NODE)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalOr.htm">||</a> (image <a href="CppOperatorEqual.htm">==</a> ADJ)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][ELE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (load_image(inc, ELE)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (image <a href="CppOperatorEqual.htm">==</a> ADJ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][PART]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (load_image(inc, PART)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (load_image(inc, image)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;current_inc <a href="CppOperatorAssign.htm">=</a> inc;<br/>
&nbsp;&nbsp;current_image <a href="CppOperatorAssign.htm">=</a> image;<br/>
}<br/>
<br/>
Window make_button(name, x, y, width)<br/>
<b><a href="CppChar.htm">char</a></b> *name;<br/>
<b><a href="CppInt.htm">int</a></b> x;<br/>
<b><a href="CppInt.htm">int</a></b> y;<br/>
<b><a href="CppInt.htm">int</a></b> width;<br/>
{<br/>
&nbsp;&nbsp;XSetWindowAttributes attr;<br/>
&nbsp;&nbsp;XSizeHints hints;<br/>
&nbsp;&nbsp;Window button;<br/>
<br/>
&nbsp;&nbsp;attr.background_pixel <a href="CppOperatorAssign.htm">=</a> black;<br/>
&nbsp;&nbsp;attr.border_pixel <a href="CppOperatorAssign.htm">=</a> white;<br/>
&nbsp;&nbsp;attr.backing_store <a href="CppOperatorAssign.htm">=</a> NotUseful;<br/>
&nbsp;&nbsp;attr.event_mask <a href="CppOperatorAssign.htm">=</a> ExposureMask | ButtonReleaseMask | ButtonPressMask;<br/>
&nbsp;&nbsp;attr.bit_gravity <a href="CppOperatorAssign.htm">=</a> SouthWestGravity;<br/>
&nbsp;&nbsp;attr.win_gravity <a href="CppOperatorAssign.htm">=</a> SouthWestGravity;<br/>
&nbsp;&nbsp;attr.save_under <a href="CppOperatorAssign.htm">=</a> False;<br/>
&nbsp;&nbsp;button <a href="CppOperatorAssign.htm">=</a> XCreateWindow(display, mainwindow, x, y, width, BUTTONHEIGHT <a href="CppOperatorMinus.htm">-</a> 4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2, 0, InputOutput, CopyFromParent,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWBackPixel | CWBorderPixel | C<a href="CppWEvent.htm">WEvent</a>Mask |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWBitGravity | CWWinGravity | CWBackingStore |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWSaveUnder, &amp;attr);<br/>
&nbsp;&nbsp;hints.width <a href="CppOperatorAssign.htm">=</a> width;<br/>
&nbsp;&nbsp;hints.height <a href="CppOperatorAssign.htm">=</a> BUTTONHEIGHT <a href="CppOperatorMinus.htm">-</a> 4;<br/>
&nbsp;&nbsp;hints.min_width <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;hints.min_height <a href="CppOperatorAssign.htm">=</a> BUTTONHEIGHT <a href="CppOperatorMinus.htm">-</a> 4;<br/>
&nbsp;&nbsp;hints.max_width <a href="CppOperatorAssign.htm">=</a> width;<br/>
&nbsp;&nbsp;hints.max_height <a href="CppOperatorAssign.htm">=</a> BUTTONHEIGHT <a href="CppOperatorMinus.htm">-</a> 4;<br/>
&nbsp;&nbsp;hints.width_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;hints.height_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;hints.flags <a href="CppOperatorAssign.htm">=</a> PMinSize | PMaxSize | PSize | PResizeInc;<br/>
&nbsp;&nbsp;XSetStandardProperties(display, button, name, "showme", None, (<b><a href="CppChar.htm">char</a></b> **) <a href="CppNULL.htm">NULL</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, &amp;hints);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> button;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> make_buttons(y)<br/>
<b><a href="CppInt.htm">int</a></b> y;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0; i<a href="CppOperatorDecrement.htm">--</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nodewin[i] <a href="CppOperatorAssign.htm">=</a> make_button("node", 0, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 42);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, nodewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;polywin[i] <a href="CppOperatorAssign.htm">=</a> make_button("poly", 44, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 42);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, polywin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elewin[i] <a href="CppOperatorAssign.htm">=</a> make_button("ele", 88, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 33);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, elewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edgewin[i] <a href="CppOperatorAssign.htm">=</a> make_button("edge", 123, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 42);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, edgewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;partwin[i] <a href="CppOperatorAssign.htm">=</a> make_button("part", 167, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 42);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, partwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;adjwin[i] <a href="CppOperatorAssign.htm">=</a> make_button("adj", 211, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 33);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, adjwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;voronoiwin[i] <a href="CppOperatorAssign.htm">=</a> make_button("voro", 246, y <a href="CppOperatorPlus.htm">+</a> (1 <a href="CppOperatorMinus.htm">-</a> i) * BUTTONHEIGHT, 42);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XMapWindow(display, voronoiwin[i]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppVersion.htm">version</a>pluswin <a href="CppOperatorAssign.htm">=</a> make_button("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>", 290, y, 52);<br/>
&nbsp;&nbsp;XMapWindow(display, <a href="CppVersion.htm">version</a>pluswin);<br/>
&nbsp;&nbsp;<a href="CppVersion.htm">version</a>minuswin <a href="CppOperatorAssign.htm">=</a> make_button("&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>", 290, y <a href="CppOperatorPlus.htm">+</a> BUTTONHEIGHT, 52);<br/>
&nbsp;&nbsp;XMapWindow(display, <a href="CppVersion.htm">version</a>minuswin);<br/>
<br/>
&nbsp;&nbsp;quitwin <a href="CppOperatorAssign.htm">=</a> make_button("Quit", 0, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 42);<br/>
&nbsp;&nbsp;XMapWindow(display, quitwin);<br/>
&nbsp;&nbsp;leftwin <a href="CppOperatorAssign.htm">=</a> make_button("&lt;", 44, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, leftwin);<br/>
&nbsp;&nbsp;rightwin <a href="CppOperatorAssign.htm">=</a> make_button("&gt;", 60, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, rightwin);<br/>
&nbsp;&nbsp;upwin <a href="CppOperatorAssign.htm">=</a> make_button("^", 76, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, upwin);<br/>
&nbsp;&nbsp;downwin <a href="CppOperatorAssign.htm">=</a> make_button("v", 92, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, downwin);<br/>
&nbsp;&nbsp;resetwin <a href="CppOperatorAssign.htm">=</a> make_button("Reset", 108, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 52);<br/>
&nbsp;&nbsp;XMapWindow(display, resetwin);<br/>
&nbsp;&nbsp;widthpluswin <a href="CppOperatorAssign.htm">=</a> make_button("Width+", 162, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 61);<br/>
&nbsp;&nbsp;XMapWindow(display, widthpluswin);<br/>
&nbsp;&nbsp;widthminuswin <a href="CppOperatorAssign.htm">=</a> make_button("-", 225, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, widthminuswin);<br/>
&nbsp;&nbsp;expwin <a href="CppOperatorAssign.htm">=</a> make_button("Exp", 241, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 33);<br/>
&nbsp;&nbsp;XMapWindow(display, expwin);<br/>
&nbsp;&nbsp;exppluswin <a href="CppOperatorAssign.htm">=</a> make_button("+", 276, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, exppluswin);<br/>
&nbsp;&nbsp;expminuswin <a href="CppOperatorAssign.htm">=</a> make_button("-", 292, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 14);<br/>
&nbsp;&nbsp;XMapWindow(display, expminuswin);<br/>
&nbsp;&nbsp;fillwin <a href="CppOperatorAssign.htm">=</a> make_button("Fill", 308, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 41);<br/>
&nbsp;&nbsp;XMapWindow(display, fillwin);<br/>
&nbsp;&nbsp;pswin <a href="CppOperatorAssign.htm">=</a> make_button("PS", 351, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 24);<br/>
&nbsp;&nbsp;XMapWindow(display, pswin);<br/>
&nbsp;&nbsp;epswin <a href="CppOperatorAssign.htm">=</a> make_button("EPS", 377, y <a href="CppOperatorPlus.htm">+</a> 2 * BUTTONHEIGHT, 33);<br/>
&nbsp;&nbsp;XMapWindow(display, epswin);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> fill_button(button)<br/>
Window button;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> x, y;<br/>
&nbsp;&nbsp;<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppInt.htm">int</a></b> w, h, d, b;<br/>
&nbsp;&nbsp;Window rootw;<br/>
<br/>
&nbsp;&nbsp;XGetGeometry(display, button, &amp;rootw, &amp;x, &amp;y, &amp;w, &amp;h, &amp;d, &amp;b);<br/>
&nbsp;&nbsp;XFill<a href="CppRectangle.htm">Rectangle</a>(display, button, fontgc, 0, 0, w, h);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw_buttons()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> numberstring[32];<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> buttonstring[6];<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0; i<a href="CppOperatorDecrement.htm">--</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> NODE) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(nodewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, nodewin[i], blackfontgc, 2, 13, "node", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, nodewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, nodewin[i], fontgc, 2, 13, "node", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> POLY) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(polywin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, polywin[i], blackfontgc, 2, 13, "poly", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, polywin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, polywin[i], fontgc, 2, 13, "poly", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> ELE) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(elewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, elewin[i], blackfontgc, 2, 13, "ele", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, elewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, elewin[i], fontgc, 2, 13, "ele", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> EDGE) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(edgewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, edgewin[i], blackfontgc, 2, 13, "edge", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, edgewin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, edgewin[i], fontgc, 2, 13, "edge", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(partwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, partwin[i], blackfontgc, 2, 13, "part", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, partwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, partwin[i], fontgc, 2, 13, "part", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> ADJ) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(adjwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, adjwin[i], blackfontgc, 2, 13, "adj", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, adjwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, adjwin[i], fontgc, 2, 13, "adj", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> VORO) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_inc <a href="CppOperatorEqual.htm">==</a> i)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(voronoiwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, voronoiwin[i], blackfontgc, 2, 13, "voro", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, voronoiwin[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, voronoiwin[i], fontgc, 2, 13, "voro", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;XClearWindow(display, <a href="CppVersion.htm">version</a>pluswin);<br/>
&nbsp;&nbsp;<a href="CppSprintf.htm">sprintf</a>(numberstring, "%d", loweriteration <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<a href="CppSprintf.htm">sprintf</a>(buttonstring, "%-4.4s+", numberstring);<br/>
&nbsp;&nbsp;XDrawString(display, <a href="CppVersion.htm">version</a>pluswin, fontgc, 2, 13, buttonstring, 5);<br/>
&nbsp;&nbsp;XClearWindow(display, <a href="CppVersion.htm">version</a>minuswin);<br/>
&nbsp;&nbsp;<a href="CppSprintf.htm">sprintf</a>(numberstring, "%d", loweriteration);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loweriteration <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSprintf.htm">sprintf</a>(buttonstring, "%-4.4s", numberstring);<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppSprintf.htm">sprintf</a>(buttonstring, "%-4.4s-", numberstring);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XDrawString(display, <a href="CppVersion.htm">version</a>minuswin, fontgc, 2, 13, buttonstring, 5);<br/>
<br/>
&nbsp;&nbsp;XClearWindow(display, quitwin);<br/>
&nbsp;&nbsp;XDrawString(display, quitwin, fontgc, 2, 13, "Quit", 4);<br/>
&nbsp;&nbsp;XClearWindow(display, leftwin);<br/>
&nbsp;&nbsp;XDrawString(display, leftwin, fontgc, 2, 13, "&lt;", 1);<br/>
&nbsp;&nbsp;XClearWindow(display, rightwin);<br/>
&nbsp;&nbsp;XDrawString(display, rightwin, fontgc, 2, 13, "&gt;", 1);<br/>
&nbsp;&nbsp;XClearWindow(display, upwin);<br/>
&nbsp;&nbsp;XDrawString(display, upwin, fontgc, 2, 13, "^", 1);<br/>
&nbsp;&nbsp;XClearWindow(display, downwin);<br/>
&nbsp;&nbsp;XDrawString(display, downwin, fontgc, 2, 13, "v", 1);<br/>
&nbsp;&nbsp;XClearWindow(display, resetwin);<br/>
&nbsp;&nbsp;XDrawString(display, resetwin, fontgc, 2, 13, "Reset", 6);<br/>
&nbsp;&nbsp;XClearWindow(display, widthpluswin);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (line_width &lt; 100) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, widthpluswin, fontgc, 2, 13, "Width+", 6);<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, widthpluswin, fontgc, 2, 13, "Width ", 6);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XClearWindow(display, widthminuswin);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (line_width &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, widthminuswin, fontgc, 2, 13, "-", 1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XClearWindow(display, expwin);<br/>
&nbsp;&nbsp;XClearWindow(display, exppluswin);<br/>
&nbsp;&nbsp;XClearWindow(display, expminuswin);<br/>
&nbsp;&nbsp;XClearWindow(display, fillwin);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (current_image <a href="CppOperatorEqual.htm">==</a> PART) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(expwin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, expwin, blackfontgc, 2, 13, "Exp", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, expwin, fontgc, 2, 13, "Exp", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, exppluswin, fontgc, 2, 13, "+", 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, expminuswin, fontgc, 2, 13, "-", 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (fillelem) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(fillwin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, fillwin, blackfontgc, 2, 13, "Fill", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, fillwin, fontgc, 2, 13, "Fill", 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XClearWindow(display, pswin);<br/>
&nbsp;&nbsp;XDrawString(display, pswin, fontgc, 2, 13, "PS", 2);<br/>
&nbsp;&nbsp;XClearWindow(display, epswin);<br/>
&nbsp;&nbsp;XDrawString(display, epswin, fontgc, 2, 13, "EPS", 3);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> showme_window(<a href="CppArgc.htm">argc</a>, <a href="CppArgc.htm">argv</a>)<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppArgc.htm">argc</a>;<br/>
<b><a href="CppChar.htm">char</a></b> **<a href="CppArgc.htm">argv</a>;<br/>
{<br/>
&nbsp;&nbsp;XSetWindowAttributes attr;<br/>
&nbsp;&nbsp;XSizeHints hints;<br/>
&nbsp;&nbsp;XGCValues fontvalues, linevalues;<br/>
&nbsp;&nbsp;XColor alloc_color, exact_color;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
<br/>
&nbsp;&nbsp;display <a href="CppOperatorAssign.htm">=</a> XOpenDisplay((<b><a href="CppChar.htm">char</a></b> *) <a href="CppNULL.htm">NULL</a>);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!display) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Cannot open display.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;screen <a href="CppOperatorAssign.htm">=</a> DefaultScreen(display);<br/>
&nbsp;&nbsp;rootwindow <a href="CppOperatorAssign.htm">=</a> DefaultRootWindow(display);<br/>
&nbsp;&nbsp;black <a href="CppOperatorAssign.htm">=</a> BlackPixel(display, screen);<br/>
&nbsp;&nbsp;white <a href="CppOperatorAssign.htm">=</a> WhitePixel(display, screen);<br/>
&nbsp;&nbsp;windowdepth <a href="CppOperatorAssign.htm">=</a> DefaultDepth(display, screen);<br/>
&nbsp;&nbsp;rootmap <a href="CppOperatorAssign.htm">=</a> DefaultColormap(display, screen);<br/>
&nbsp;&nbsp;width <a href="CppOperatorAssign.htm">=</a> STARTWIDTH;<br/>
&nbsp;&nbsp;height <a href="CppOperatorAssign.htm">=</a> STARTHEIGHT;<br/>
&nbsp;&nbsp;attr.background_pixel <a href="CppOperatorAssign.htm">=</a> black;<br/>
&nbsp;&nbsp;attr.border_pixel <a href="CppOperatorAssign.htm">=</a> white;<br/>
&nbsp;&nbsp;attr.backing_store <a href="CppOperatorAssign.htm">=</a> NotUseful;<br/>
&nbsp;&nbsp;attr.event_mask <a href="CppOperatorAssign.htm">=</a> ExposureMask | ButtonReleaseMask | ButtonPressMask |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StructureNotifyMask;<br/>
&nbsp;&nbsp;attr.bit_gravity <a href="CppOperatorAssign.htm">=</a> NorthWestGravity;<br/>
&nbsp;&nbsp;attr.win_gravity <a href="CppOperatorAssign.htm">=</a> NorthWestGravity;<br/>
&nbsp;&nbsp;attr.save_under <a href="CppOperatorAssign.htm">=</a> False;<br/>
&nbsp;&nbsp;mainwindow <a href="CppOperatorAssign.htm">=</a> XCreateWindow(display, rootwindow, 0, 0, width,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height <a href="CppOperatorPlus.htm">+</a> PANELHEIGHT, 3, 0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputOutput, CopyFromParent,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWBackPixel | CWBorderPixel | C<a href="CppWEvent.htm">WEvent</a>Mask |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWBitGravity | CWWinGravity | CWBackingStore |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWSaveUnder, &amp;attr);<br/>
&nbsp;&nbsp;hints.width <a href="CppOperatorAssign.htm">=</a> width;<br/>
&nbsp;&nbsp;hints.height <a href="CppOperatorAssign.htm">=</a> height <a href="CppOperatorPlus.htm">+</a> PANELHEIGHT;<br/>
&nbsp;&nbsp;hints.min_width <a href="CppOperatorAssign.htm">=</a> MINWIDTH;<br/>
&nbsp;&nbsp;hints.min_height <a href="CppOperatorAssign.htm">=</a> MINHEIGHT <a href="CppOperatorPlus.htm">+</a> PANELHEIGHT;<br/>
&nbsp;&nbsp;hints.width_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;hints.height_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;hints.flags <a href="CppOperatorAssign.htm">=</a> PMinSize | PSize | PResizeInc;<br/>
&nbsp;&nbsp;XSetStandardProperties(display, mainwindow, "Show Me", "showme", None,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppArgc.htm">argv</a>, <a href="CppArgc.htm">argc</a>, &amp;hints);<br/>
&nbsp;&nbsp;XChangeProperty(display, mainwindow, XA_WM_CLASS, XA_STRING, 8,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PropModeReplace, "showme\0Archimedes", 18);<br/>
&nbsp;&nbsp;XClearWindow(display, mainwindow);<br/>
&nbsp;&nbsp;XMapWindow(display, mainwindow);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((windowdepth &gt; 1) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XAllocNamedColor(display, rootmap, "yellow", &amp;alloc_color,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;exact_color)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;color <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;explode <a href="CppOperatorAssign.htm">=</a> bw_ps;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fontvalues.foreground <a href="CppOperatorAssign.htm">=</a> alloc_color.pixel;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;linevalues.foreground <a href="CppOperatorAssign.htm">=</a> alloc_color.pixel;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;showme_foreground <a href="CppOperatorAssign.htm">=</a> alloc_color.pixel;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 64; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (XAllocNamedColor(display, rootmap, colorname[i], &amp;alloc_color,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;rgb[i])) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colors[i] <a href="CppOperatorAssign.htm">=</a> alloc_color.pixel;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colors[i] <a href="CppOperatorAssign.htm">=</a> white;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rgb[i].red <a href="CppOperatorAssign.htm">=</a> alloc_color.red;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rgb[i].green <a href="CppOperatorAssign.htm">=</a> alloc_color.green;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rgb[i].blue <a href="CppOperatorAssign.htm">=</a> alloc_color.blue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Warning:&nbsp;&nbsp;I could not allocate <a href="CppOperatorModulus.htm">%</a>s.\n", colorname[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;color <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fillelem <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;explode <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fontvalues.foreground <a href="CppOperatorAssign.htm">=</a> white;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;linevalues.foreground <a href="CppOperatorAssign.htm">=</a> white;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;showme_foreground <a href="CppOperatorAssign.htm">=</a> white;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;font <a href="CppOperatorAssign.htm">=</a> XLoadQueryFont(display, "9x15");<br/>
&nbsp;&nbsp;fontvalues.background <a href="CppOperatorAssign.htm">=</a> black;<br/>
&nbsp;&nbsp;fontvalues.font <a href="CppOperatorAssign.htm">=</a> font-&gt;fid;<br/>
&nbsp;&nbsp;fontvalues.fill_style <a href="CppOperatorAssign.htm">=</a> FillSolid;<br/>
&nbsp;&nbsp;fontvalues.line_width <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;fontgc <a href="CppOperatorAssign.htm">=</a> XCreateGC(display, rootwindow, GCForeground | GCBackground |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCFont | GCLineWidth | GCFillStyle, &amp;fontvalues);<br/>
&nbsp;&nbsp;fontvalues.foreground <a href="CppOperatorAssign.htm">=</a> black;<br/>
&nbsp;&nbsp;blackfontgc <a href="CppOperatorAssign.htm">=</a> XCreateGC(display, rootwindow, GCForeground | GCBackground |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GCFont | GCLineWidth | GCFillStyle, &amp;fontvalues);<br/>
&nbsp;&nbsp;linevalues.background <a href="CppOperatorAssign.htm">=</a> black;<br/>
&nbsp;&nbsp;linevalues.line_width <a href="CppOperatorAssign.htm">=</a> line_width;<br/>
&nbsp;&nbsp;linevalues.cap_style <a href="CppOperatorAssign.htm">=</a> CapRound;<br/>
&nbsp;&nbsp;linevalues.join_style <a href="CppOperatorAssign.htm">=</a> JoinRound;<br/>
&nbsp;&nbsp;linevalues.fill_style <a href="CppOperatorAssign.htm">=</a> FillSolid;<br/>
&nbsp;&nbsp;linegc <a href="CppOperatorAssign.htm">=</a> XCreateGC(display, rootwindow, GCForeground | GCBackground |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GCLineWidth | GCCapStyle | GCJoinStyle | GCFillStyle,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;linevalues);<br/>
&nbsp;&nbsp;trianglegc <a href="CppOperatorAssign.htm">=</a> XCreateGC(display, rootwindow, GCForeground | GCBackground |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GCLineWidth | GCCapStyle | GCJoinStyle | GCFillStyle,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;linevalues);<br/>
&nbsp;&nbsp;make_buttons(height);<br/>
&nbsp;&nbsp;XFlush(display);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw_node(nodes, dim, ptr, xscale, yscale, xoffset, yoffset)<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
REAL *ptr;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> dim;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> nodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XFill<a href="CppRectangle.htm">Rectangle</a>(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) (ptr[index] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset) <a href="CppOperatorMinus.htm">-</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) (ptr[index <a href="CppOperatorPlus.htm">+</a> 1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset) <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1), line_width, line_width);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> dim;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw_poly(nodes, dim, edges, holes, nodeptr, edgeptr, holeptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xscale, yscale, xoffset, yoffset)<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> edges;<br/>
<b><a href="CppInt.htm">int</a></b> holes;<br/>
REAL *nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> *edgeptr;<br/>
REAL *holeptr;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;REAL *<a href="CppPointer.htm">point</a>1, *<a href="CppPointer.htm">point</a>2;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> x1, y1, x2, y2;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> dim;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> nodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XFill<a href="CppRectangle.htm">Rectangle</a>(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) (nodeptr[index] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset) <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) (nodeptr[index <a href="CppOperatorPlus.htm">+</a> 1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset) <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1), line_width, line_width);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> dim;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> edges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>2 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> dim;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (color) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XSetForeground(display, linegc, colors[0]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> holes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) (holeptr[index] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset) <a href="CppOperatorMinus.htm">-</a> 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y1 <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) (holeptr[index <a href="CppOperatorPlus.htm">+</a> 1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset) <a href="CppOperatorMinus.htm">-</a> 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;x2 <a href="CppOperatorAssign.htm">=</a> x1 <a href="CppOperatorPlus.htm">+</a> 6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;y2 <a href="CppOperatorAssign.htm">=</a> y1 <a href="CppOperatorPlus.htm">+</a> 6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc, x1, y1, x2, y2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc, x1, y2, x2, y1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> dim;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XSetForeground(display, linegc, showme_foreground);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw_ele(inc, elems, corners, ptr, partition, shift,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
<b><a href="CppInt.htm">int</a></b> elems;<br/>
<b><a href="CppInt.htm">int</a></b> corners;<br/>
<b><a href="CppInt.htm">int</a></b> *ptr;<br/>
<b><a href="CppInt.htm">int</a></b> *partition;<br/>
REAL *shift;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;REAL shiftx, shifty;<br/>
&nbsp;&nbsp;REAL *prev<a href="CppPointer.htm">point</a>, *now<a href="CppPointer.htm">point</a>;<br/>
&nbsp;&nbsp;X<a href="CppPoint.htm">Point</a> *vertices;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (color <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> fillelem <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices <a href="CppOperatorAssign.htm">=</a> (X<a href="CppPoint.htm">Point</a> *) malloc(3 * <b><a href="CppSizeof.htm">sizeof</a></b>(X<a href="CppPoint.htm">Point</a>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertices <a href="CppOperatorEqual.htm">==</a> (X<a href="CppPoint.htm">Point</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 3;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> elems; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shiftx <a href="CppOperatorAssign.htm">=</a> shift[partition[i] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifty <a href="CppOperatorAssign.htm">=</a> shift[(partition[i] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (color <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (fillelem) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetForeground(display, trianglegc, colors[partition[i] &amp; 63]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetForeground(display, linegc, colors[partition[i] &amp; 63]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (color <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> fillelem <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[inc][ptr[index <a href="CppOperatorPlus.htm">+</a> j] * node_dim[inc]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[j].x <a href="CppOperatorAssign.htm">=</a> (now<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorPlus.htm">+</a> shiftx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[j].y <a href="CppOperatorAssign.htm">=</a> (now<a href="CppPointer.htm">point</a>[1] <a href="CppOperatorPlus.htm">+</a> shifty) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[inc][ptr[index <a href="CppOperatorPlus.htm">+</a> j] * node_dim[inc]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[j].x <a href="CppOperatorAssign.htm">=</a> now<a href="CppPointer.htm">point</a>[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[j].y <a href="CppOperatorAssign.htm">=</a> now<a href="CppPointer.htm">point</a>[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XFillPolygon(display, mainwindow, trianglegc, vertices, 3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Convex, CoordModeOrigin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;prev<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[inc][ptr[index <a href="CppOperatorPlus.htm">+</a> 2] * node_dim[inc]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[inc][ptr[index<a href="CppOperatorIncrement.htm">++</a>] * node_dim[inc]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((prev<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorPlus.htm">+</a> shiftx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((prev<a href="CppPointer.htm">point</a>[1] <a href="CppOperatorPlus.htm">+</a> shifty) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((now<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorPlus.htm">+</a> shiftx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((now<a href="CppPointer.htm">point</a>[1] <a href="CppOperatorPlus.htm">+</a> shifty) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> now<a href="CppPointer.htm">point</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[inc][ptr[index<a href="CppOperatorIncrement.htm">++</a>] * node_dim[inc]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (prev<a href="CppPointer.htm">point</a>[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (prev<a href="CppPointer.htm">point</a>[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (now<a href="CppPointer.htm">point</a>[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (now<a href="CppPointer.htm">point</a>[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> now<a href="CppPointer.htm">point</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (color <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> fillelem <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;free(vertices);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XSetForeground(display, linegc, showme_foreground);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw_edge(nodes, dim, edges, nodeptr, edgeptr, normptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xscale, yscale, xoffset, yoffset)<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> edges;<br/>
REAL *nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> *edgeptr;<br/>
REAL *normptr;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;REAL *<a href="CppPointer.htm">point</a>1, *<a href="CppPointer.htm">point</a>2;<br/>
&nbsp;&nbsp;REAL normx, normy;<br/>
&nbsp;&nbsp;REAL normmult, normmultx, normmulty;<br/>
&nbsp;&nbsp;REAL windowxmin, windowymin, windowxmax, windowymax;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> edges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgeptr[index] <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normx <a href="CppOperatorAssign.htm">=</a> normptr[index <a href="CppOperatorMinus.htm">-</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normy <a href="CppOperatorAssign.htm">=</a> normptr[index<a href="CppOperatorIncrement.htm">++</a>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmultx <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normx &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowxmax <a href="CppOperatorAssign.htm">=</a> (width <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorMinus.htm">-</a> xoffset) <a href="CppOperatorDivide.htm">/</a> xscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmultx <a href="CppOperatorAssign.htm">=</a> (windowxmax <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[0]) <a href="CppOperatorDivide.htm">/</a> normx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normx &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowxmin <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>xoffset <a href="CppOperatorDivide.htm">/</a> xscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmultx <a href="CppOperatorAssign.htm">=</a> (windowxmin <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[0]) <a href="CppOperatorDivide.htm">/</a> normx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmulty <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normy &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowymax <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>yoffset <a href="CppOperatorDivide.htm">/</a> yscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmulty <a href="CppOperatorAssign.htm">=</a> (windowymax <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[1]) <a href="CppOperatorDivide.htm">/</a> normy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normy &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowymin <a href="CppOperatorAssign.htm">=</a> (height <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorMinus.htm">-</a> yoffset) <a href="CppOperatorDivide.htm">/</a> yscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmulty <a href="CppOperatorAssign.htm">=</a> (windowymin <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[1]) <a href="CppOperatorDivide.htm">/</a> normy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normmultx <a href="CppOperatorEqual.htm">==</a> 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmulty;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normmulty <a href="CppOperatorEqual.htm">==</a> 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmultx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normmultx &lt; normmulty) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmultx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmulty;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normmult &gt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((<a href="CppPointer.htm">point</a>1[0] <a href="CppOperatorPlus.htm">+</a> normmult * normx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((<a href="CppPointer.htm">point</a>1[1] <a href="CppOperatorPlus.htm">+</a> normmult * normy) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>2 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw_adj(dim, subdomains, ptr, center, xscale, yscale,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xoffset, yoffset)<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> subdomains;<br/>
<b><a href="CppInt.htm">int</a></b> *ptr;<br/>
REAL *center;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;REAL *<a href="CppPointer.htm">point</a>1, *<a href="CppPointer.htm">point</a>2;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; subdomains; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 1; j &lt; subdomains; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (ptr[i * subdomains <a href="CppOperatorPlus.htm">+</a> j]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;center[i * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>2 <a href="CppOperatorAssign.htm">=</a> &amp;center[j * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawLine(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; subdomains; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;center[i * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (color) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetForeground(display, linegc, colors[i &amp; 63]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XFillArc(display, mainwindow, linegc,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset) <a href="CppOperatorMinus.htm">-</a> 5 <a href="CppOperatorMinus.htm">-</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset) <a href="CppOperatorMinus.htm">-</a> 5 <a href="CppOperatorMinus.htm">-</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line_width <a href="CppOperatorPlus.htm">+</a> 10, line_width <a href="CppOperatorPlus.htm">+</a> 10, 0, 23040);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;XSetForeground(display, linegc, showme_foreground);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> draw(inc, image, xmin, ymin, xmax, ymax)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
<b><a href="CppInt.htm">int</a></b> image;<br/>
REAL xmin;<br/>
REAL ymin;<br/>
REAL xmax;<br/>
REAL ymax;<br/>
{<br/>
&nbsp;&nbsp;draw_buttons();<br/>
&nbsp;&nbsp;XClearWindow(display, mainwindow);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (image <a href="CppOperatorEqual.htm">==</a> NOTHING) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][image]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorPlusAssign.htm">+=</a> (xmin <a href="CppOperatorMinus.htm">-</a> partcenter[inc][subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1]) * explosion;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorPlusAssign.htm">+=</a> (xmax <a href="CppOperatorMinus.htm">-</a> partcenter[inc][subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1]) * explosion;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorPlusAssign.htm">+=</a> (ymin <a href="CppOperatorMinus.htm">-</a> partcenter[inc][(subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1]) * explosion;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorPlusAssign.htm">+=</a> (ymax <a href="CppOperatorMinus.htm">-</a> partcenter[inc][(subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1]) * explosion;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;xscale <a href="CppOperatorAssign.htm">=</a> (REAL) (width <a href="CppOperatorMinus.htm">-</a> line_width <a href="CppOperatorMinus.htm">-</a> 4) <a href="CppOperatorDivide.htm">/</a> (xmax <a href="CppOperatorMinus.htm">-</a> xmin);<br/>
&nbsp;&nbsp;yscale <a href="CppOperatorAssign.htm">=</a> (REAL) (height <a href="CppOperatorMinus.htm">-</a> line_width <a href="CppOperatorMinus.htm">-</a> 4) <a href="CppOperatorDivide.htm">/</a> (ymax <a href="CppOperatorMinus.htm">-</a> ymin);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (xscale &gt; yscale) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xscale <a href="CppOperatorAssign.htm">=</a> yscale;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;yscale <a href="CppOperatorAssign.htm">=</a> xscale;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;xoffset <a href="CppOperatorAssign.htm">=</a> 0.5 * ((REAL) width <a href="CppOperatorMinus.htm">-</a> xscale * (xmax <a href="CppOperatorMinus.htm">-</a> xmin)) <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale * xmin;<br/>
&nbsp;&nbsp;yoffset <a href="CppOperatorAssign.htm">=</a> (REAL) height <a href="CppOperatorMinus.htm">-</a> 0.5 * ((REAL) height <a href="CppOperatorMinus.htm">-</a> yscale * (ymax <a href="CppOperatorMinus.htm">-</a> ymin)) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yscale * ymin;<br/>
&nbsp;&nbsp;yscale <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> yscale;<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b>(image) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> NODE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_node(nodes[inc], node_dim[inc], nodeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> POLY:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (polynodes[inc] &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_poly(polynodes[inc], poly_dim[inc], polyedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyholes[inc], polynodeptr[inc], polyedgeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyholeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_poly(nodes[inc], node_dim[inc], polyedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyholes[inc], nodeptr[inc], polyedgeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyholeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ELE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_ele(inc, elems[inc], ele_corners[inc], eleptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>, (REAL *) <a href="CppNULL.htm">NULL</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> EDGE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_edge(nodes[inc], node_dim[inc], edges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeptr[inc], edgeptr[inc], normptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> PART:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_ele(inc, elems[inc], ele_corners[inc], eleptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; partpart[inc], partshift[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ADJ:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_adj(node_dim[inc], adjsubdomains[inc], adjptr[inc], partcenter[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> VORO:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loaded[inc][NODE]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_node(nodes[inc], node_dim[inc], nodeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_edge(vnodes[inc], vnode_dim[inc], vedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vnodeptr[inc], vedgeptr[inc], vnormptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> addps(instring, outstring, eps)<br/>
<b><a href="CppChar.htm">char</a></b> *instring;<br/>
<b><a href="CppChar.htm">char</a></b> *outstring;<br/>
<b><a href="CppInt.htm">int</a></b> eps;<br/>
{<br/>
&nbsp;&nbsp;strcpy(outstring, instring);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (eps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(outstring, ".eps");<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;strcat(outstring, ".ps");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> print_head(fname, file, llcornerx, llcornery, eps)<br/>
<b><a href="CppChar.htm">char</a></b> *fname;<br/>
<a href="CppCfile.htm">FILE</a> **file;<br/>
<b><a href="CppInt.htm">int</a></b> llcornerx;<br/>
<b><a href="CppInt.htm">int</a></b> llcornery;<br/>
<b><a href="CppInt.htm">int</a></b> eps;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("Writing <a href="CppOperatorModulus.htm">%</a>s\n", fname);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*file <a href="CppOperatorAssign.htm">=</a> fopen(fname, "w");<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*file <a href="CppOperatorEqual.htm">==</a> (<a href="CppCfile.htm">FILE</a> *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;Error:&nbsp;&nbsp;Could not open <a href="CppOperatorModulus.htm">%</a>s\n", fname);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (eps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(*file, "%%!PS-Adobe-2.0 EPSF-2.0\n");<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(*file, "%%!PS-Adobe-2.0\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fprintf(*file, "%%%%BoundingBox: <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d\n", llcornerx, llcornery,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;612 <a href="CppOperatorMinus.htm">-</a> llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;fprintf(*file, "%%%%Creator: Show Me\n");<br/>
&nbsp;&nbsp;fprintf(*file, "%%%%EndComments\n\n");<br/>
&nbsp;&nbsp;fprintf(*file, "/m {moveto} bind def\n");<br/>
&nbsp;&nbsp;fprintf(*file, "/l {lineto} bind def\n");<br/>
&nbsp;&nbsp;fprintf(*file, "/s {setrgbcolor} bind def\n");<br/>
&nbsp;&nbsp;fprintf(*file, "/g {gsave fill grestore} bind def\n");<br/>
&nbsp;&nbsp;fprintf(*file, "/k {stroke} bind def\n\n");<br/>
&nbsp;&nbsp;fprintf(*file, "1 setlinecap\n");<br/>
&nbsp;&nbsp;fprintf(*file, "1 setlinejoin\n");<br/>
&nbsp;&nbsp;fprintf(*file, "%d setlinewidth\n", line_width);<br/>
&nbsp;&nbsp;fprintf(*file, "%d <a href="CppOperatorModulus.htm">%</a>d m\n", llcornerx, llcornery);<br/>
&nbsp;&nbsp;fprintf(*file, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", 612 <a href="CppOperatorMinus.htm">-</a> llcornerx, llcornery);<br/>
&nbsp;&nbsp;fprintf(*file, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", 612 <a href="CppOperatorMinus.htm">-</a> llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;fprintf(*file, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;fprintf(*file, "closepath\nclip\nnewpath\n");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> print_node(nodefile, nodes, dim, ptr, xscale, yscale,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xoffset, yoffset)<br/>
<a href="CppCfile.htm">FILE</a> *nodefile;<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
REAL *ptr;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> dim;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> nodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(nodefile, "%d <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d 0 360 arc\nfill\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (ptr[index] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (ptr[index <a href="CppOperatorPlus.htm">+</a> 1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <a href="CppOperatorPlus.htm">+</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> dim;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> print_poly(polyfile, nodes, dim, edges, holes, nodeptr, edgeptr, holeptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset)<br/>
<a href="CppCfile.htm">FILE</a> *polyfile;<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> edges;<br/>
<b><a href="CppInt.htm">int</a></b> holes;<br/>
REAL *nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> *edgeptr;<br/>
REAL *holeptr;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;REAL *<a href="CppPointer.htm">point</a>1, *<a href="CppPointer.htm">point</a>2;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> dim;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> nodes; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(polyfile, "%d <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d 0 360 arc\nfill\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (nodeptr[index] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (nodeptr[index <a href="CppOperatorPlus.htm">+</a> 1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <a href="CppOperatorPlus.htm">+</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorPlusAssign.htm">+=</a> dim;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> edges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>2 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(polyfile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(polyfile, "%d <a href="CppOperatorModulus.htm">%</a>d l\nk\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> print_ele(elefile, nodes, dim, elems, corners, nodeptr, eleptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; partition, shift,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xscale, yscale, xoffset, yoffset, llcornerx, llcornery)<br/>
<a href="CppCfile.htm">FILE</a> *elefile;<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> elems;<br/>
<b><a href="CppInt.htm">int</a></b> corners;<br/>
REAL *nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> *eleptr;<br/>
<b><a href="CppInt.htm">int</a></b> *partition;<br/>
REAL *shift;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
<b><a href="CppInt.htm">int</a></b> llcornerx;<br/>
<b><a href="CppInt.htm">int</a></b> llcornery;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index, colorindex;<br/>
&nbsp;&nbsp;REAL shiftx, shifty;<br/>
&nbsp;&nbsp;REAL *now<a href="CppPointer.htm">point</a>;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 3;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !bw_ps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "0 0 0 s\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n", llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", 612 <a href="CppOperatorMinus.htm">-</a> llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", 612 <a href="CppOperatorMinus.htm">-</a> llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "fill\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> elems; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !bw_ps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorindex <a href="CppOperatorAssign.htm">=</a> partition[i] &amp; 63;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%6.3f <a href="CppOperatorModulus.htm">%</a>6.3f <a href="CppOperatorModulus.htm">%</a>6.3f s\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(REAL) rgb[colorindex].red <a href="CppOperatorDivide.htm">/</a> 65535.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(REAL) rgb[colorindex].green <a href="CppOperatorDivide.htm">/</a> 65535.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(REAL) rgb[colorindex].blue <a href="CppOperatorDivide.htm">/</a> 65535.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[eleptr[index <a href="CppOperatorPlus.htm">+</a> 2] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (explode <a href="CppOperatorLogicalOr.htm">||</a> bw_ps)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shiftx <a href="CppOperatorAssign.htm">=</a> shift[partition[i] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shifty <a href="CppOperatorAssign.htm">=</a> shift[(partition[i] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((now<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorPlus.htm">+</a> shiftx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((now<a href="CppPointer.htm">point</a>[1] <a href="CppOperatorPlus.htm">+</a> shifty) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[eleptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((now<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorPlus.htm">+</a> shiftx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((now<a href="CppPointer.htm">point</a>[1] <a href="CppOperatorPlus.htm">+</a> shifty) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (now<a href="CppPointer.htm">point</a>[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (now<a href="CppPointer.htm">point</a>[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now<a href="CppPointer.htm">point</a> <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[eleptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (now<a href="CppPointer.htm">point</a>[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (now<a href="CppPointer.htm">point</a>[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (fillelem <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (partition <a href="CppOperatorNotEqual.htm">!=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !bw_ps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "g\n1 1 0 s\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(elefile, "k\n");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> print_edge(edgefile, nodes, dim, edges, nodeptr, edgeptr, normptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscale, yscale, xoffset, yoffset, llcornerx, llcornery)<br/>
<a href="CppCfile.htm">FILE</a> *edgefile;<br/>
<b><a href="CppInt.htm">int</a></b> nodes;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> edges;<br/>
REAL *nodeptr;<br/>
<b><a href="CppInt.htm">int</a></b> *edgeptr;<br/>
REAL *normptr;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
<b><a href="CppInt.htm">int</a></b> llcornerx;<br/>
<b><a href="CppInt.htm">int</a></b> llcornery;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;REAL *<a href="CppPointer.htm">point</a>1, *<a href="CppPointer.htm">point</a>2;<br/>
&nbsp;&nbsp;REAL normx, normy;<br/>
&nbsp;&nbsp;REAL normmult, normmultx, normmulty;<br/>
&nbsp;&nbsp;REAL windowxmin, windowymin, windowxmax, windowymax;<br/>
<br/>
&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorLessEqual.htm">&lt;=</a> edges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgeptr[index] <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normx <a href="CppOperatorAssign.htm">=</a> normptr[index <a href="CppOperatorMinus.htm">-</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normy <a href="CppOperatorAssign.htm">=</a> normptr[index<a href="CppOperatorIncrement.htm">++</a>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmultx <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normx &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowxmax <a href="CppOperatorAssign.htm">=</a> ((REAL) (612 <a href="CppOperatorMinus.htm">-</a> llcornerx) <a href="CppOperatorMinus.htm">-</a> xoffset) <a href="CppOperatorDivide.htm">/</a> xscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmultx <a href="CppOperatorAssign.htm">=</a> (windowxmax <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[0]) <a href="CppOperatorDivide.htm">/</a> normx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normx &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowxmin <a href="CppOperatorAssign.htm">=</a> ((REAL) llcornerx <a href="CppOperatorMinus.htm">-</a> xoffset) <a href="CppOperatorDivide.htm">/</a> xscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmultx <a href="CppOperatorAssign.htm">=</a> (windowxmin <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[0]) <a href="CppOperatorDivide.htm">/</a> normx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmulty <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normy &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowymax <a href="CppOperatorAssign.htm">=</a> ((REAL) (792 <a href="CppOperatorMinus.htm">-</a> llcornery) <a href="CppOperatorMinus.htm">-</a> yoffset) <a href="CppOperatorDivide.htm">/</a> yscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmulty <a href="CppOperatorAssign.htm">=</a> (windowymax <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[1]) <a href="CppOperatorDivide.htm">/</a> normy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normy &lt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowymin <a href="CppOperatorAssign.htm">=</a> ((REAL) llcornery <a href="CppOperatorMinus.htm">-</a> yoffset) <a href="CppOperatorDivide.htm">/</a> yscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmulty <a href="CppOperatorAssign.htm">=</a> (windowymin <a href="CppOperatorMinus.htm">-</a> <a href="CppPointer.htm">point</a>1[1]) <a href="CppOperatorDivide.htm">/</a> normy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normmultx <a href="CppOperatorEqual.htm">==</a> 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmulty;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normmulty <a href="CppOperatorEqual.htm">==</a> 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmultx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (normmultx &lt; normmulty) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmultx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normmult <a href="CppOperatorAssign.htm">=</a> normmulty;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (normmult &gt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(edgefile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(edgefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\nk\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((<a href="CppPointer.htm">point</a>1[0] <a href="CppOperatorPlus.htm">+</a> normmult * normx) * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) ((<a href="CppPointer.htm">point</a>1[1] <a href="CppOperatorPlus.htm">+</a> normmult * normy) * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>2 <a href="CppOperatorAssign.htm">=</a> &amp;nodeptr[edgeptr[index<a href="CppOperatorIncrement.htm">++</a>] * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(edgefile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(edgefile, "%d <a href="CppOperatorModulus.htm">%</a>d l\nk\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> print_adj(adjfile, dim, subdomains, ptr, center, xscale, yscale,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xoffset, yoffset, llcornerx, llcornery)<br/>
<a href="CppCfile.htm">FILE</a> *adjfile;<br/>
<b><a href="CppInt.htm">int</a></b> dim;<br/>
<b><a href="CppInt.htm">int</a></b> subdomains;<br/>
<b><a href="CppInt.htm">int</a></b> *ptr;<br/>
REAL *center;<br/>
REAL xscale;<br/>
REAL yscale;<br/>
REAL xoffset;<br/>
REAL yoffset;<br/>
<b><a href="CppInt.htm">int</a></b> llcornerx;<br/>
<b><a href="CppInt.htm">int</a></b> llcornery;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;REAL *<a href="CppPointer.htm">point</a>1, *<a href="CppPointer.htm">point</a>2;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> colorindex;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!bw_ps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "0 0 0 s\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n", llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", 612 <a href="CppOperatorMinus.htm">-</a> llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", 612 <a href="CppOperatorMinus.htm">-</a> llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d l\n", llcornerx, 792 <a href="CppOperatorMinus.htm">-</a> llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "fill\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "1 1 0 s\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; subdomains; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 1; j &lt; subdomains; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (ptr[i * subdomains <a href="CppOperatorPlus.htm">+</a> j]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;center[i * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>2 <a href="CppOperatorAssign.htm">=</a> &amp;center[j * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d m\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d l\nk\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>2[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; subdomains; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppPointer.htm">point</a>1 <a href="CppOperatorAssign.htm">=</a> &amp;center[i * dim];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!bw_ps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorindex <a href="CppOperatorAssign.htm">=</a> i &amp; 63;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%6.3f <a href="CppOperatorModulus.htm">%</a>6.3f <a href="CppOperatorModulus.htm">%</a>6.3f s\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(REAL) rgb[colorindex].red <a href="CppOperatorDivide.htm">/</a> 65535.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(REAL) rgb[colorindex].green <a href="CppOperatorDivide.htm">/</a> 65535.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(REAL) rgb[colorindex].blue <a href="CppOperatorDivide.htm">/</a> 65535.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d 0 360 arc\nfill\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 <a href="CppOperatorPlus.htm">+</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(adjfile, "%d <a href="CppOperatorModulus.htm">%</a>d <a href="CppOperatorModulus.htm">%</a>d 0 360 arc\nfill\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[0] * xscale <a href="CppOperatorPlus.htm">+</a> xoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b>) (<a href="CppPointer.htm">point</a>1[1] * yscale <a href="CppOperatorPlus.htm">+</a> yoffset),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 <a href="CppOperatorPlus.htm">+</a> (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> print(inc, image, xmin, ymin, xmax, ymax, eps)<br/>
<b><a href="CppInt.htm">int</a></b> inc;<br/>
<b><a href="CppInt.htm">int</a></b> image;<br/>
REAL xmin;<br/>
REAL ymin;<br/>
REAL xmax;<br/>
REAL ymax;<br/>
<b><a href="CppInt.htm">int</a></b> eps;<br/>
{<br/>
&nbsp;&nbsp;REAL xxscale, yyscale, xxoffset, yyoffset;<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> psfilename[<a href="CppCfile.htm">FILE</a>NAMESIZE];<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> llcornerx, llcornery;<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> *psfile;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (image <a href="CppOperatorEqual.htm">==</a> NOTHING) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!loaded[inc][image]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (explode <a href="CppOperatorLogicalOr.htm">||</a> bw_ps)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorPlusAssign.htm">+=</a> (xmin <a href="CppOperatorMinus.htm">-</a> partcenter[inc][subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1]) * explosion;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorPlusAssign.htm">+=</a> (xmax <a href="CppOperatorMinus.htm">-</a> partcenter[inc][subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1]) * explosion;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorPlusAssign.htm">+=</a> (ymin <a href="CppOperatorMinus.htm">-</a> partcenter[inc][(subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1]) * explosion;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorPlusAssign.htm">+=</a> (ymax <a href="CppOperatorMinus.htm">-</a> partcenter[inc][(subdomains[inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1]) * explosion;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;xxscale <a href="CppOperatorAssign.htm">=</a> (460.0 <a href="CppOperatorMinus.htm">-</a> (REAL) line_width) <a href="CppOperatorDivide.htm">/</a> (xmax <a href="CppOperatorMinus.htm">-</a> xmin);<br/>
&nbsp;&nbsp;yyscale <a href="CppOperatorAssign.htm">=</a> (640.0 <a href="CppOperatorMinus.htm">-</a> (REAL) line_width) <a href="CppOperatorDivide.htm">/</a> (ymax <a href="CppOperatorMinus.htm">-</a> ymin);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (xxscale &gt; yyscale) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xxscale <a href="CppOperatorAssign.htm">=</a> yyscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;llcornerx <a href="CppOperatorAssign.htm">=</a> (604 <a href="CppOperatorMinus.htm">-</a> (<b><a href="CppInt.htm">int</a></b>) (yyscale * (xmax <a href="CppOperatorMinus.htm">-</a> xmin)) <a href="CppOperatorMinus.htm">-</a> line_width) <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;llcornery <a href="CppOperatorAssign.htm">=</a> 72;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;yyscale <a href="CppOperatorAssign.htm">=</a> xxscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;llcornerx <a href="CppOperatorAssign.htm">=</a> 72;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;llcornery <a href="CppOperatorAssign.htm">=</a> (784 <a href="CppOperatorMinus.htm">-</a> (<b><a href="CppInt.htm">int</a></b>) (xxscale * (ymax <a href="CppOperatorMinus.htm">-</a> ymin)) <a href="CppOperatorMinus.htm">-</a> line_width) <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;xxoffset <a href="CppOperatorAssign.htm">=</a> 0.5 * (612.0 <a href="CppOperatorMinus.htm">-</a> xxscale * (xmax <a href="CppOperatorMinus.htm">-</a> xmin)) <a href="CppOperatorMinus.htm">-</a> xxscale * xmin <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1);<br/>
&nbsp;&nbsp;yyoffset <a href="CppOperatorAssign.htm">=</a> 0.5 * (792.0 <a href="CppOperatorMinus.htm">-</a> yyscale * (ymax <a href="CppOperatorMinus.htm">-</a> ymin)) <a href="CppOperatorMinus.htm">-</a> yyscale * ymin <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line_width <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b>(image) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> NODE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(nodefilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> POLY:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(polyfilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ELE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(elefilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> EDGE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(edgefilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> PART:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(partfilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ADJ:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(adjfilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> VORO:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addps(vedgefilename[inc], psfilename, eps);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (print_head(psfilename, &amp;psfile, llcornerx, llcornery, eps)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b>(image) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> NODE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_node(psfile, nodes[inc], node_dim[inc], nodeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxscale, yyscale, xxoffset, yyoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> POLY:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (polynodes[inc] &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_poly(psfile, polynodes[inc], poly_dim[inc], polyedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyholes[inc], polynodeptr[inc], polyedgeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyholeptr[inc], xxscale, yyscale, xxoffset, yyoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_poly(psfile, nodes[inc], node_dim[inc], polyedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyholes[inc], nodeptr[inc], polyedgeptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyholeptr[inc], xxscale, yyscale, xxoffset, yyoffset);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ELE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_ele(psfile, nodes[inc], node_dim[inc], elems[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ele_corners[inc], nodeptr[inc], eleptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>, (REAL *) <a href="CppNULL.htm">NULL</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> EDGE:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_edge(psfile, nodes[inc], node_dim[inc], edges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodeptr[inc], edgeptr[inc], normptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> PART:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_ele(psfile, nodes[inc], node_dim[inc], elems[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ele_corners[inc], nodeptr[inc], eleptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partpart[inc], partshift[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ADJ:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_adj(psfile, node_dim[inc], adjsubdomains[inc], adjptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partcenter[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> VORO:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_edge(psfile, vnodes[inc], vnode_dim[inc], vedges[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vnodeptr[inc], vedgeptr[inc], vnormptr[inc],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!eps) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(psfile, "showpage\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;fclose(psfile);<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppMain.htm">main</a>(<a href="CppArgc.htm">argc</a>, <a href="CppArgc.htm">argv</a>)<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppArgc.htm">argc</a>;<br/>
<b><a href="CppChar.htm">char</a></b> **<a href="CppArgc.htm">argv</a>;<br/>
{<br/>
&nbsp;&nbsp;REAL xmin, ymin, xmax, ymax;<br/>
&nbsp;&nbsp;REAL xptr, yptr, xspan, yspan;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> past_image;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> new_image;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> new_inc;<br/>
<br/>
&nbsp;&nbsp;parsecommandline(<a href="CppArgc.htm">argc</a>, <a href="CppArgc.htm">argv</a>);<br/>
&nbsp;&nbsp;showme_init();<br/>
&nbsp;&nbsp;choose_image(start_inc, start_image);<br/>
&nbsp;&nbsp;showme_window(<a href="CppArgc.htm">argc</a>, <a href="CppArgc.htm">argv</a>);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (current_image <a href="CppOperatorNotEqual.htm">!=</a> NOTHING) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorAssign.htm">=</a> xlo[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorAssign.htm">=</a> ylo[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorAssign.htm">=</a> xhi[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorAssign.htm">=</a> yhi[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;zoom <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;XMaskEvent(display, ExposureMask, &amp;event);<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> (event.type) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ButtonRelease:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> quitwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDestroyWindow(display, mainwindow);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCloseDisplay(display);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> leftwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xspan <a href="CppOperatorAssign.htm">=</a> 0.25 * (xmax <a href="CppOperatorMinus.htm">-</a> xmin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorPlusAssign.htm">+=</a> xspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorPlusAssign.htm">+=</a> xspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> rightwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xspan <a href="CppOperatorAssign.htm">=</a> 0.25 * (xmax <a href="CppOperatorMinus.htm">-</a> xmin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorMinusAssign.htm">-=</a> xspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorMinusAssign.htm">-=</a> xspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> upwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yspan <a href="CppOperatorAssign.htm">=</a> 0.25 * (ymax <a href="CppOperatorMinus.htm">-</a> ymin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorMinusAssign.htm">-=</a> yspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorMinusAssign.htm">-=</a> yspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> downwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yspan <a href="CppOperatorAssign.htm">=</a> 0.25 * (ymax <a href="CppOperatorMinus.htm">-</a> ymin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorPlusAssign.htm">+=</a> yspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorPlusAssign.htm">+=</a> yspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> resetwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorAssign.htm">=</a> xlo[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorAssign.htm">=</a> ylo[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorAssign.htm">=</a> xhi[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorAssign.htm">=</a> yhi[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> widthpluswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (line_width &lt; 100) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_width<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetLineAttributes(display, linegc, line_width, LineSolid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CapRound, JoinRound);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetLineAttributes(display, trianglegc, line_width, LineSolid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CapRound, JoinRound);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> widthminuswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (line_width &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_width<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetLineAttributes(display, linegc, line_width, LineSolid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CapRound, JoinRound);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSetLineAttributes(display, trianglegc, line_width, LineSolid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CapRound, JoinRound);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> expwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> loaded[current_inc][PART]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explode <a href="CppOperatorAssign.htm">=</a> !explode;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> exppluswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> loaded[PART] <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explosion <a href="CppOperatorPlusAssign.htm">+=</a> 0.125;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findpartshift(subdomains[current_inc], explosion,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partcenter[current_inc], partshift[current_inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> expminuswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> loaded[PART] <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(explosion <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.125)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explosion <a href="CppOperatorMinusAssign.htm">-=</a> 0.125;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findpartshift(subdomains[current_inc], explosion,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partcenter[current_inc], partshift[current_inc]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> fillwin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> loaded[PART]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fillelem <a href="CppOperatorAssign.htm">=</a> !fillelem;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> pswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(pswin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XFlush(display);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(current_inc, current_image, xmin, ymin, xmax, ymax, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, pswin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, pswin, fontgc, 2, 13, "PS", 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> epswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill_button(epswin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XFlush(display);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(current_inc, current_image, xmin, ymin, xmax, ymax, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, epswin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDrawString(display, epswin, fontgc, 2, 13, "EPS", 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> <a href="CppVersion.htm">version</a>pluswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move_inc(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loweriteration<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_filenames(filename, loweriteration);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (current_inc <a href="CppOperatorEqual.htm">==</a> 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_image <a href="CppOperatorAssign.htm">=</a> NOTHING;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, mainwindow);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_buttons();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> <a href="CppVersion.htm">version</a>minuswin) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (loweriteration &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move_inc(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loweriteration<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_filenames(filename, loweriteration);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (current_inc <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_image <a href="CppOperatorAssign.htm">=</a> NOTHING;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XClearWindow(display, mainwindow);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_buttons();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> ((event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> nodewin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> polywin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> elewin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> edgewin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> partwin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> adjwin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> voronoiwin[0]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> nodewin[1]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> polywin[1]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> elewin[1]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> edgewin[1]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> partwin[1]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> adjwin[1]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> voronoiwin[1])) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> nodewin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> NODE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> polywin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> POLY;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> elewin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> ELE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> edgewin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> EDGE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> partwin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> PART;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> adjwin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> ADJ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> voronoiwin[0]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> VORO;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> nodewin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> NODE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> polywin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> POLY;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> elewin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> ELE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> edgewin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> EDGE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> partwin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> PART;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> adjwin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> ADJ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.x<a href="CppAny.htm">any</a>.window <a href="CppOperatorEqual.htm">==</a> voronoiwin[1]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_inc <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_image <a href="CppOperatorAssign.htm">=</a> VORO;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;past_image <a href="CppOperatorAssign.htm">=</a> current_image;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_inc <a href="CppOperatorEqual.htm">==</a> new_inc) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_image <a href="CppOperatorEqual.htm">==</a> new_image)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free_inc(new_inc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unload_inc(new_inc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choose_image(new_inc, new_image);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((past_image <a href="CppOperatorEqual.htm">==</a> NOTHING) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (current_image <a href="CppOperatorNotEqual.htm">!=</a> NOTHING)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorAssign.htm">=</a> xlo[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorAssign.htm">=</a> ylo[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorAssign.htm">=</a> xhi[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorAssign.htm">=</a> yhi[current_inc][current_image];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xptr <a href="CppOperatorAssign.htm">=</a> ((REAL) event.xbutton.x <a href="CppOperatorMinus.htm">-</a> xoffset) <a href="CppOperatorDivide.htm">/</a> xscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yptr <a href="CppOperatorAssign.htm">=</a> ((REAL) event.xbutton.y <a href="CppOperatorMinus.htm">-</a> yoffset) <a href="CppOperatorDivide.htm">/</a> yscale;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((current_image <a href="CppOperatorEqual.htm">==</a> PART) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> loaded[PART] <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> explode) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xptr <a href="CppOperatorAssign.htm">=</a> (xptr <a href="CppOperatorPlus.htm">+</a> partcenter[current_inc]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [subdomains[current_inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* explosion) <a href="CppOperatorDivide.htm">/</a> (1.0 <a href="CppOperatorPlus.htm">+</a> explosion);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yptr <a href="CppOperatorAssign.htm">=</a> (yptr <a href="CppOperatorPlus.htm">+</a> partcenter[current_inc]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(subdomains[current_inc] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 1) <a href="CppOperatorPlus.htm">+</a> 1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* explosion) <a href="CppOperatorDivide.htm">/</a> (1.0 <a href="CppOperatorPlus.htm">+</a> explosion);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((event.xbutton.button <a href="CppOperatorEqual.htm">==</a> Button1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> (event.xbutton.button <a href="CppOperatorEqual.htm">==</a> Button3)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (event.xbutton.button <a href="CppOperatorEqual.htm">==</a> Button1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xspan <a href="CppOperatorAssign.htm">=</a> 0.25 * (xmax <a href="CppOperatorMinus.htm">-</a> xmin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yspan <a href="CppOperatorAssign.htm">=</a> 0.25 * (ymax <a href="CppOperatorMinus.htm">-</a> ymin);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xspan <a href="CppOperatorAssign.htm">=</a> xmax <a href="CppOperatorMinus.htm">-</a> xmin;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yspan <a href="CppOperatorAssign.htm">=</a> ymax <a href="CppOperatorMinus.htm">-</a> ymin;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmin <a href="CppOperatorAssign.htm">=</a> xptr <a href="CppOperatorMinus.htm">-</a> xspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymin <a href="CppOperatorAssign.htm">=</a> yptr <a href="CppOperatorMinus.htm">-</a> yspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmax <a href="CppOperatorAssign.htm">=</a> xptr <a href="CppOperatorPlus.htm">+</a> xspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ymax <a href="CppOperatorAssign.htm">=</a> yptr <a href="CppOperatorPlus.htm">+</a> yspan;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (event.xbutton.button <a href="CppOperatorEqual.htm">==</a> Button2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("x <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorModulus.htm">%</a>.4g, y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorModulus.htm">%</a>.4g\n", xptr, yptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> DestroyNotify:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDestroyWindow(display, mainwindow);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCloseDisplay(display);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> ConfigureNotify:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((width <a href="CppOperatorNotEqual.htm">!=</a> event.xconfigure.width) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(height <a href="CppOperatorNotEqual.htm">!=</a> event.xconfigure.height <a href="CppOperatorMinus.htm">-</a> PANELHEIGHT)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width <a href="CppOperatorAssign.htm">=</a> event.xconfigure.width;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height <a href="CppOperatorAssign.htm">=</a> event.xconfigure.height <a href="CppOperatorMinus.htm">-</a> PANELHEIGHT;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (XCheckMaskEvent(display, ExposureMask, &amp;event));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppCase.htm">case</a></b> Expose:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw(current_inc, current_image, xmin, ymin, xmax, ymax);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (XCheckMaskEvent(display, ExposureMask, &amp;event));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;XNextEvent(display, &amp;event);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpparguments.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpparguments.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPBEHAVIOR_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPBEHAVIOR_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/si/area.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/si/length.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/si/plane_angle.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/quantity.hpp&gt;<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> Data structure <b><a href="CppFor.htm">for</a></b> command line <b><a href="CppSwitch.htm">switch</a></b>es and file names.&nbsp;&nbsp;This structure<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; is used (instead of global variables) to allow reentrancy.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Switches <b><a href="CppFor.htm">for</a></b> the triangulator.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; poly: <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;refine: <a href="CppOperatorMinus.htm">-</a>r <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; quality: <a href="CppOperatorMinus.htm">-</a>q <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; minangle: minimum angle bound, specified after <a href="CppOperatorMinus.htm">-</a>q <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; goodangle: cosine squared of minangle.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; offconstant: constant used to place off-center Steiner <a href="CppPointer.htm">point</a>s.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; vararea: <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b> without number.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; fixedarea: <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b> with number.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; maxarea: maximum area bound, specified after <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; usertest: <a href="CppOperatorMinus.htm">-</a>u <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; regionattrib: <a href="CppOperatorMinus.htm">-</a>A <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;convex: <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; weighted: 1 <b><a href="CppFor.htm">for</a></b> <a href="CppOperatorMinus.htm">-</a>w <b><a href="CppSwitch.htm">switch</a></b>, 2 <b><a href="CppFor.htm">for</a></b> <a href="CppOperatorMinus.htm">-</a>W <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;jettison: <a href="CppOperatorMinus.htm">-</a>j <b><a href="CppSwitch.htm">switch</a></b><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; firstnumber: inverse of <a href="CppOperatorMinus.htm">-</a>z <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;All items are numbered starting<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; from `firstnumber'.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; edgesout: <a href="CppOperatorMinus.htm">-</a>e <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;voronoi: <a href="CppOperatorMinus.htm">-</a>v <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; neighbors: <a href="CppOperatorMinus.htm">-</a>n <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;geomview: <a href="CppOperatorMinus.htm">-</a>g <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; nobound: <a href="CppOperatorMinus.htm">-</a>B <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;nopolywritten: <a href="CppOperatorMinus.htm">-</a>P <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; nonodewritten: <a href="CppOperatorMinus.htm">-</a>N <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;noelewritten: <a href="CppOperatorMinus.htm">-</a>E <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; noiterationnum: <a href="CppOperatorMinus.htm">-</a>I <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;noholes: <a href="CppOperatorMinus.htm">-</a>O <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; noexact: <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; order: element order, specified after <a href="CppOperatorMinus.htm">-</a>o <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; nobisect: count of how often <a href="CppOperatorMinus.htm">-</a>Y <b><a href="CppSwitch.htm">switch</a></b> is selected.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; steiner: maximum number of Steiner <a href="CppPointer.htm">point</a>s, specified after <a href="CppOperatorMinus.htm">-</a>S <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; incremental: <a href="CppOperatorMinus.htm">-</a>i <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;sweepline: <a href="CppOperatorMinus.htm">-</a>F <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; dwyer: inverse of <a href="CppOperatorMinus.htm">-</a>l <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; splitseg: <a href="CppOperatorMinus.htm">-</a>s <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; conformdel: <a href="CppOperatorMinus.htm">-</a>D <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;docheck: <a href="CppOperatorMinus.htm">-</a>C <b><a href="CppSwitch.htm">switch</a></b>.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; quiet: <a href="CppOperatorMinus.htm">-</a>Q <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;verbose: count of how often <a href="CppOperatorMinus.htm">-</a>V <b><a href="CppSwitch.htm">switch</a></b> is selected.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; usesegments: <a href="CppOperatorMinus.htm">-</a>p, <a href="CppOperatorMinus.htm">-</a>r, <a href="CppOperatorMinus.htm">-</a>q, or <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>; determines whether segments are<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; used at all.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Read the instructions to find out the meaning of these <b><a href="CppSwitch.htm">switch</a></b>es.<br/>
<b><a href="CppStruct.htm">struct</a></b> Arguments<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostUnits.htm">boost::units</a>::quantity&lt;<a href="CppBoostUnits.htm">boost::units</a>::si::length&gt; Length;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostUnits.htm">boost::units</a>::quantity&lt;<a href="CppBoostUnits.htm">boost::units</a>::si::plane_angle&gt; Angle;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostUnits.htm">boost::units</a>::quantity&lt;<a href="CppBoostUnits.htm">boost::units</a>::si::area&gt; Area;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Maximum number of <a href="CppChar.htm">character</a>s in a file name (including the null).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> max_filename_size <a href="CppOperatorAssign.htm">=</a> 2048;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Read the command line, identify <b><a href="CppSwitch.htm">switch</a></b>es, and set<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> up options and file names.<br/>
&nbsp;&nbsp;Arguments(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_areafilename;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_conformdel;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_convex;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_do_check;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_do_refine;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_dwyer;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_edgefilename;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_edgesout;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_firstnumber <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a>Start counting from zero, as every programmer does<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_fixedarea;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_geomview;<br/>
&nbsp;&nbsp;Angle m_goodangle;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_incremental;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_inelefilename;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_innodefilename;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_inpolyfilename;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> m_do_jettison <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>; <a href="CppComment.htm">//</a>As I always use it<br/>
&nbsp;&nbsp;Area m_maxarea;<br/>
&nbsp;&nbsp;Angle m_minangle;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_neighborfilename;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_neighbors;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_nobisect;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_nobound;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_noelewritten;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_noexact;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_noholes;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_noiterationnum;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_nonodewritten;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_nopolywritten;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_offconstant;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_offfilename;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_order <a href="CppOperatorAssign.htm">=</a> 1; <a href="CppComment.htm">//</a>RJCB: I always use 1<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_outelefilename;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_outnodefilename;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_outpolyfilename;<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppBool.htm">bool</a></b> m_quality <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_quiet;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_regionattrib;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_splitseg;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_max_added_steiner_<a href="CppPointer.htm">point</a>s;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_sweepline;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_usertest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> m_usesegments <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_vararea;<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_vedgefilename;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_verbosity; <a href="CppComment.htm">//</a>/0: no verbosity, 1: verbose, <a href="CppOperatorPlus.htm">+</a>1: more verbose<br/>
&nbsp;&nbsp;<a href="CppStdString.htm">std::string</a> m_vnodefilename;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_voronoi;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_weighted <a href="CppOperatorAssign.htm">=</a> 0;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPBEHAVIOR_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpparguments.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpparguments.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpparguments.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">cstring</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCmathH.htm">cmath</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/limits.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/math/constants/constants.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/angle/degrees.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppFileIo.htm">fileio</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppinfo.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppsyntax.h"<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppTrace.htm">trace</a>.h"<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Arguments::Arguments(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
&nbsp;&nbsp;: m_areafilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_conformdel{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_convex{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_do_check{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_do_refine{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_dwyer{1},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edgefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edgesout{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_firstnumber{1},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_fixedarea{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_geomview{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_goodangle{0.0 * <a href="CppBoostUnits.htm">boost::units</a>::si::radian},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_incremental{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_inelefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innodefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_inpolyfilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_do_jettison{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_maxarea{0.0 * <a href="CppBoostUnits.htm">boost::units</a>::si::meter * <a href="CppBoostUnits.htm">boost::units</a>::si::meter},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_minangle{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* (<a href="CppBoost.htm">boost</a>::math::constants::two_pi&lt;<b><a href="CppDouble.htm">double</a></b>&gt;() <a href="CppOperatorDivide.htm">/</a> 360.0) <a href="CppComment.htm">//</a>degrees <a href="CppOperatorMinus.htm">-</a>&gt; radian<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <a href="CppBoostUnits.htm">boost::units</a>::si::radian<br/>
&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighborfilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighbors{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nobisect{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nobound{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_noelewritten{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_noexact{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_noholes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_noiterationnum{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nonodewritten{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nopolywritten{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offconstant{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offfilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_order{1},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outelefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outnodefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outpolyfilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_poly{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_quality{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_quiet{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_regionattrib{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_splitseg{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_max_added_steiner_<a href="CppPointer.htm">point</a>s{<a href="CppBoost.htm">boost</a>::numeric::bounds&lt;<b><a href="CppInt.htm">int</a></b>&gt;::highest()},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_sweepline{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_usertest{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_usesegments{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vararea{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vedgefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_verbosity{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vnodefilename{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_voronoi{0}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_weighted{0}<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArgc.htm">argc</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(args.size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> start_index <a href="CppOperatorAssign.htm">=</a> 1; <a href="CppComment.htm">//</a>Because args[0] contains the filename<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> increment;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> meshnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> max_filename_size <a href="CppOperatorAssign.htm">=</a> 2048;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdString.htm">std::string</a> workstring; <a href="CppComment.htm">//</a>[max_filename_size];<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 1; i <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppArgc.htm">argc</a>; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> line <a href="CppOperatorAssign.htm">=</a> args[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!line.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (line[0] <a href="CppOperatorEqual.htm">==</a> '-')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> line.substr(1,line.size() <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "p")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("p is a useless flag, always set to on");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s <a href="CppOperatorEqual.htm">==</a> "r")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_do_refine <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'q')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> line.substr(1,s.size() <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_minangle <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_quality <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> '.')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> k <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (((line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> '.')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workstring[k] <a href="CppOperatorAssign.htm">=</a> line[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workstring[k] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_minangle <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(workstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_minangle <a href="CppOperatorAssign.htm">=</a> 20.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'a')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> s.substr(1,s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (t.empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_vararea <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppUsing.htm">using</a></b> <a href="CppBoostUnits.htm">boost::units</a>::si::meter;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_maxarea <a href="CppOperatorAssign.htm">=</a> Area(<a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(t) * meter * meter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppThis.htm">this</a></b>-&gt;m_maxarea <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0&nbsp;&nbsp;* meter * meter)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Triangle:&nbsp;&nbsp;Maximum area must be greater than zero");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_quality <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> '.'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_fixedarea <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> k <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (((line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9')) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> '.')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workstring[k] <a href="CppOperatorAssign.htm">=</a> line[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workstring[k] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_maxarea <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(workstring);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppThis.htm">this</a></b>-&gt;m_maxarea <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Triangle:&nbsp;&nbsp;Maximum area must be greater than zero.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_vararea <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'u')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_quality <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_usertest <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'A')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_regionattrib <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'c')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_convex <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (line[j] <a href="CppOperatorEqual.htm">==</a> 'w') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_weighted <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (line[j] <a href="CppOperatorEqual.htm">==</a> 'W') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_weighted <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'j')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_do_jettison <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (line[j] <a href="CppOperatorEqual.htm">==</a> 'z') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_firstnumber <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'e')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_edgesout <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'v')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_voronoi <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'n')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_neighbors <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'g')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_geomview <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'B')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nobound <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'P')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nopolywritten <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'N')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nonodewritten <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'E')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_noelewritten <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'I')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_noiterationnum <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'O')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_noholes <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'X')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_noexact <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RJCB: I don't use it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'o')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> s.substr(1,s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!t.empty() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> t[0] <a href="CppOperatorEqual.htm">==</a> '2')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> '2')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_order <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'Y')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_nobisect<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'S')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> t <a href="CppOperatorAssign.htm">=</a> s.substr(1,s.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_max_added_steiner_<a href="CppPointer.htm">point</a>s <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_max_added_steiner_<a href="CppPointer.htm">point</a>s &lt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Max added Steiner <a href="CppPointer.htm">point</a>s cannot be " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m_max_added_steiner_<a href="CppPointer.htm">point</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", use a positive value instead";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdRuntime_error.htm">std::runtime_error</a>(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_steiner <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (line[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_steiner <a href="CppOperatorAssign.htm">=</a> m_steiner * 10 <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppInt.htm">int</a></b>) (s[0] <a href="CppOperatorMinus.htm">-</a> '0');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'i')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_incremental <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'F')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_sweepline <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'l')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_dwyer <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 's')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_splitseg <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((s[0] <a href="CppOperatorEqual.htm">==</a> 'D') <a href="CppOperatorLogicalOr.htm">||</a> (s[0] <a href="CppOperatorEqual.htm">==</a> 'L'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_quality <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_conformdel <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'C')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_do_check <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'Q')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_quiet <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'V')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_verbosity;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (s[0] <a href="CppOperatorEqual.htm">==</a> 'h' <a href="CppOperatorLogicalOr.htm">||</a> s[0] <a href="CppOperatorEqual.htm">==</a> 'H' <a href="CppOperatorLogicalOr.htm">||</a> s[0] <a href="CppOperatorEqual.htm">==</a> '?')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <a href="CppArgc.htm">argc</a>); <a href="CppComment.htm">//</a>RJCB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_innodefilename <a href="CppOperatorAssign.htm">=</a> line;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_innodefilename[max_filename_size <a href="CppOperatorMinus.htm">-</a> 1] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_innodefilename.empty())<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (m_innodefilename[0] <a href="CppOperatorEqual.htm">==</a> '\0')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Syntax();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetExtension.htm">GetExtension</a>NoDot(m_innodefilename) <a href="CppOperatorEqual.htm">==</a> "node"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>!strcmp(&amp;<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 5], ".node")<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innodefilename <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetFileBasename.htm">GetFileBasename</a>(m_innodefilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetExtension.htm">GetExtension</a>NoDot(m_innodefilename) <a href="CppOperatorEqual.htm">==</a> "poly"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>!strcmp(&amp;<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 5], ".poly")<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innodefilename <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetFileBasename.htm">GetFileBasename</a>(m_innodefilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetExtension.htm">GetExtension</a>NoDot(m_innodefilename) <a href="CppOperatorEqual.htm">==</a> "ele"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>!strcmp(&amp;<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 4], ".ele")<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innodefilename <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetFileBasename.htm">GetFileBasename</a>(m_innodefilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 4] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_do_refine <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetExtension.htm">GetExtension</a>NoDot(m_innodefilename) <a href="CppOperatorEqual.htm">==</a> "area"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>!strcmp(&amp;<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 5], ".area")<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innodefilename <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppGetFileBasename.htm">GetFileBasename</a>(m_innodefilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename[<a href="CppStrlen.htm">strlen</a>(<b><a href="CppThis.htm">this</a></b>-&gt;m_innodefilename) <a href="CppOperatorMinus.htm">-</a> 5] <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_do_refine <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_quality <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_vararea <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic_assert.htm">static_assert</a></b>(<b><a href="CppThis.htm">this</a></b>-&gt;m_usesegments,"");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_usesegments <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_poly <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_do_refine <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_quality <a href="CppOperatorLogicalOr.htm">||</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_convex;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Angle temp_angle <a href="CppOperatorAssign.htm">=</a> <a href="CppStdCos.htm">std::cos</a>(m_minangle.value()) * radians;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_goodangle <a href="CppOperatorAssign.htm">=</a> <a href="CppStdCos.htm">std::cos</a>(m_minangle.value()) * radians; <a href="CppComment.htm">//</a>Hmmm, why is <b><a href="CppThis.htm">this</a></b>?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_goodangle <a href="CppOperatorAssign.htm">=</a> cos(<b><a href="CppThis.htm">this</a></b>-&gt;m_minangle * <a href="CppBoost.htm">boost</a>::math::constants::pi&lt;<b><a href="CppDouble.htm">double</a></b>&gt;() <a href="CppOperatorDivide.htm">/</a> 180.0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (temp_angle <a href="CppOperatorEqual.htm">==</a> 1.0 * radians) <a href="CppComment.htm">//</a>?Why?<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offconstant <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offconstant <a href="CppOperatorAssign.htm">=</a> 0.475 * <a href="CppStdSqrt.htm">std::sqrt</a>((1.0 <a href="CppOperatorPlus.htm">+</a> temp_angle.value()) <a href="CppOperatorDivide.htm">/</a> (1.0 <a href="CppOperatorMinus.htm">-</a> temp_angle.value()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_offconstant <a href="CppOperatorAssign.htm">=</a> 0.475 * sqrt((1.0 <a href="CppOperatorPlus.htm">+</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_goodangle) <a href="CppOperatorDivide.htm">/</a> (1.0 <a href="CppOperatorMinus.htm">-</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_goodangle));<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;m_goodangle <a href="CppOperatorAssign.htm">=</a> Angle(<a href="CppStdCos.htm">std::cos</a>(m_minangle.value()) * <a href="CppStdCos.htm">std::cos</a>(m_minangle.value()) * radians);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_goodangle <a href="CppOperatorMultiplyAssign.htm">*=</a> <b><a href="CppThis.htm">this</a></b>-&gt;m_goodangle;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_do_refine <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_noiterationnum)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>("Triangle: You cannot use the <a href="CppOperatorMinus.htm">-</a>I <b><a href="CppSwitch.htm">switch</a></b> when refining a triangulation.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Be careful not to allocate space <b><a href="CppFor.htm">for</a></b> element area constraints that <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; will never be as<b><a href="CppSigned.htm">signed</a></b> <a href="CppAny.htm">any</a> value (other than the <b><a href="CppDefault.htm">default</a></b> <a href="CppOperatorMinus.htm">-</a>1.0).&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Be careful not to add an extra attribute to each element unless the <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; input supports it (PSLG in, but not refining a preexisting mesh). <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_do_refine)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>-&gt;m_regionattrib <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Regular/weighted triangulations are incompatible with PSLGs <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; and meshing.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (<b><a href="CppThis.htm">this</a></b>-&gt;m_weighted)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>-&gt;m_weighted <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!<b><a href="CppThis.htm">this</a></b>-&gt;m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;printf("Warning:&nbsp;&nbsp;weighted triangulations (-w, <a href="CppOperatorMinus.htm">-</a>W) are incompatible\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;printf("&nbsp;&nbsp;with PSLGs (-p) and meshing (-q, <a href="CppOperatorMinus.htm">-</a>a, <a href="CppOperatorMinus.htm">-</a>u).&nbsp;&nbsp;Weights ignored.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_do_jettison <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m_nonodewritten <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !m_quiet)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>j and <a href="CppOperatorMinus.htm">-</a>N <b><a href="CppSwitch.htm">switch</a></b>es are somewhat incompatible."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "If <a href="CppAny.htm">any</a> vertices are jettisoned, you will need the output"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " .node file to re<a href="CppConstructor.htm">construct</a> the <b><a href="CppNew.htm">new</a></b> node indices."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;m_inpolyfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename;<br/>
&nbsp;&nbsp;m_inelefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename;<br/>
&nbsp;&nbsp;m_areafilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;increment <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;workstring <a href="CppOperatorAssign.htm">=</a> m_innodefilename;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (workstring[j] <a href="CppOperatorNotEqual.htm">!=</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((workstring[j] <a href="CppOperatorEqual.htm">==</a> '.') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (workstring[j <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorNotEqual.htm">!=</a> '\0')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;meshnumber <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (increment &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;j <a href="CppOperatorAssign.htm">=</a> increment;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((workstring[j] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> '0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (workstring[j] <a href="CppOperatorLessEqual.htm">&lt;=</a> '9'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meshnumber <a href="CppOperatorAssign.htm">=</a> meshnumber * 10 <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppInt.htm">int</a></b>) (workstring[j] <a href="CppOperatorMinus.htm">-</a> '0');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (workstring[j] <a href="CppOperatorNotEqual.htm">!=</a> '\0');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<b><a href="CppThis.htm">this</a></b>-&gt;m_noiterationnum)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outnodefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".node";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outelefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".ele";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edgefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".edge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vnodefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".v.node";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vedgefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".v.edge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighborfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".neigh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".off";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (increment <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outnodefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.node";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outpolyfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.poly";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outelefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.ele";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edgefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.edge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vnodefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.v.node";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vedgefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.v.edge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighborfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.neigh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> ".1.off";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> s <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;(meshnumber <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outnodefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".node";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outpolyfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".poly";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_outelefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".ele";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edgefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".edge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vnodefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".v.node";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vedgefilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".v.edge";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighborfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".neigh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_offfilename <a href="CppOperatorAssign.htm">=</a> m_innodefilename <a href="CppOperatorPlus.htm">+</a> "." <a href="CppOperatorPlus.htm">+</a> s <a href="CppOperatorPlus.htm">+</a> ".off";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;m_innodefilename <a href="CppOperatorPlusAssign.htm">+=</a> ".node";<br/>
&nbsp;&nbsp;m_inpolyfilename <a href="CppOperatorPlusAssign.htm">+=</a> ".poly";<br/>
&nbsp;&nbsp;m_inelefilename <a href="CppOperatorPlusAssign.htm">+=</a> ".ele";<br/>
&nbsp;&nbsp;m_areafilename <a href="CppOperatorPlusAssign.htm">+=</a> ".area";<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_do_refine <a href="CppOperatorEqual.htm">==</a> <b><a href="CppTrue.htm">true</a></b>);&nbsp;&nbsp;<a href="CppComment.htm">//</a>Which one is it?<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_do_refine <a href="CppOperatorEqual.htm">==</a> <b><a href="CppFalse.htm">false</a></b>); <a href="CppComment.htm">//</a>Which one is it?<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppbadsubseg.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppbadsubseg.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPBADSUBSEG_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPBADSUBSEG_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_BADSUBSEG<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> A queue used to store encroached subsegments.&nbsp;&nbsp;Each subsegment's vertices<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; are stored so that we can check whether a subsegment is still the same.<br/>
<b><a href="CppStruct.htm">struct</a></b> BadSubSeg<br/>
{<br/>
&nbsp;&nbsp;BadSubSeg();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/An encroached subsegment<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; m_encsubseg;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_subsegdest;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_subsegorg;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_BADSUBSEG<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPBADSUBSEG_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppbadsubseg.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppbadsubseg.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppbadsubseg.h"<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> USE_BADSUBSEG<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::BadSubSeg::BadSubSeg()<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_encsubseg{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subsegdest{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subsegorg{}<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> USE_BADSUBSEG<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppbadtriang.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppbadtriang.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPBADTRIANG_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPBADTRIANG_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_BADTRIANG<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> A queue used to store bad triangles.&nbsp;&nbsp;The key is the square of the cosine <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; of the smallest angle of the triangle.&nbsp;&nbsp;Each triangle's vertices are&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; stored so that one can check whether a triangle is still the same.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> BadTriang<br/>
{<br/>
&nbsp;&nbsp;BadTriang();<br/>
&nbsp;&nbsp;BadTriang(<b><a href="CppConst.htm">const</a></b> BadTriang&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;BadTriang&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> BadTriang&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_key; <a href="CppComment.htm">//</a>/cos^2 of smallest (apical) angle<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt; m_nexttriang; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> <a href="CppPointer.htm">Pointer</a> to next bad triangle<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; m_poortri;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> A skinny or too-large triangle.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_triangorg;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_triangdest;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_triangapex; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Its three vertices<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_BADTRIANG<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPBADTRIANG_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppbadtriang.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppbadtriang.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppbadtriang.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::BadTriang::BadTriang()<br/>
&nbsp;&nbsp;: m_key{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nexttriang{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_poortri{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangorg{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangdest{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangapex{}<br/>
{<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppdefines.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppdefines.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPP<a href="CppQmakeDefines.htm">DEFINES</a>_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPP<a href="CppQmakeDefines.htm">DEFINES</a>_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_<a href="CppQmakeDefines.htm">DEFINES</a><br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppglobals.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>Fast_Two_Sum(a,b,x,y) : x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Fast_Two_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> a<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Fast_Two_Sum_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Fast_Two_Sum_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>ahi <a href="CppOperatorAssign.htm">=</a> a<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Split(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppDouble.htm">double</a></b>&amp; ahi, <b><a href="CppDouble.htm">double</a></b>&amp; alo);<br/>
<b><a href="CppVoid.htm">void</a></b> Split_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppDouble.htm">double</a></b>&amp; ahi, <b><a href="CppDouble.htm">double</a></b>&amp; alo);<br/>
<br/>
<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Square(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> (a * a);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Square_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Square_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_Diff(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_Diff_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_Diff_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_Diff_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_One_Diff(a1,a0,b,x2,x1,x0): x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_One_Diff(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_One_Diff_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_One_<a href="CppProduct.htm">Product</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_One_<a href="CppProduct.htm">Product</a>_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_One_Sum(a1,a0,b,x2,x1,x0): x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> n, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_One_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_<a href="CppProduct.htm">Product</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_<a href="CppProduct.htm">Product</a>_Presplit(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bhi, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> blo, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> Two_<a href="CppProduct.htm">Product</a>_Presplit_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bhi, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> blo, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_<a href="CppProduct.htm">Product</a>_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_<a href="CppProduct.htm">Product</a>_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_Sum_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> a;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_Sum_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<b><a href="CppVoid.htm">void</a></b> Two_Sum_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y);<br/>
<br/>
<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_Two_Diff(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b0, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<br/>
<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0;<br/>
<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorPlus.htm">+</a> zero <a href="CppOperatorPlus.htm">+</a> b1;<br/>
<a href="CppComment.htm">//</a>x2 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<a href="CppComment.htm">//</a>x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<a href="CppComment.htm">//</a>x0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Two_Two_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b0, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_<a href="CppQmakeDefines.htm">DEFINES</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP<a href="CppQmakeDefines.htm">DEFINES</a>_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppdefines.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppdefines.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppdefines.h"<br/>
<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmesh.h"<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Split(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppDouble.htm">double</a></b>&amp; ahi, <b><a href="CppDouble.htm">double</a></b>&amp; alo)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> splitter <a href="CppOperatorAssign.htm">=</a> Global().m_splitter;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> c <a href="CppOperatorAssign.htm">=</a> (splitter * a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> abig <a href="CppOperatorAssign.htm">=</a> c <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> abig <a href="CppOperatorAssign.htm">=</a> (splitter * a) <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ahi <a href="CppOperatorAssign.htm">=</a> c <a href="CppOperatorMinus.htm">-</a> ((splitter * a) <a href="CppOperatorMinus.htm">-</a> a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ahi <a href="CppOperatorAssign.htm">=</a> (splitter * a) <a href="CppOperatorMinus.htm">-</a> ((splitter * a) <a href="CppOperatorMinus.htm">-</a> a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ahi <a href="CppOperatorAssign.htm">=</a> (splitter * a) <a href="CppOperatorMinus.htm">-</a> (splitter * a) <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;ahi <a href="CppOperatorAssign.htm">=</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ahi <a href="CppOperatorAssign.htm">=</a> c <a href="CppOperatorMinus.htm">-</a> abig;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>alo <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> (c <a href="CppOperatorMinus.htm">-</a> ((splitter * a) <a href="CppOperatorMinus.htm">-</a> a));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>alo <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> ((splitter * a) <a href="CppOperatorMinus.htm">-</a> ((splitter * a) <a href="CppOperatorMinus.htm">-</a> a));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>alo <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> (splitter * a) <a href="CppOperatorPlus.htm">+</a> (splitter * a) <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;alo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>alo <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> ahi;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> temp_ahi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> temp_alo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Split_Smartass(a,temp_ahi,temp_alo);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(temp_ahi <a href="CppOperatorAssign.htm">=</a> ahi);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(temp_alo <a href="CppOperatorAssign.htm">=</a> alo);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Split_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppDouble.htm">double</a></b>&amp; ahi, <b><a href="CppDouble.htm">double</a></b>&amp; alo)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> splitter <a href="CppOperatorAssign.htm">=</a> Global().m_splitter;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> c <a href="CppOperatorAssign.htm">=</a> splitter * a;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> abig <a href="CppOperatorAssign.htm">=</a> c <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;ahi <a href="CppOperatorAssign.htm">=</a> c <a href="CppOperatorMinus.htm">-</a> abig;<br/>
&nbsp;&nbsp;alo <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> ahi;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Split(a, ahi, alo) \<br/>
&nbsp;&nbsp;c <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (Global().m_splitter * a); \<br/>
&nbsp;&nbsp;abig <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (c <a href="CppOperatorMinus.htm">-</a> a); \<br/>
&nbsp;&nbsp;ahi <a href="CppOperatorAssign.htm">=</a> c <a href="CppOperatorMinus.htm">-</a> abig; \<br/>
&nbsp;&nbsp;alo <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> ahi<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Diff(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>(a <a href="CppOperatorMinus.htm">-</a> b) <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>a <a href="CppOperatorPlus.htm">+</a> b <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a, b, x, y);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Diff_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;Two_Diff_Tail_Smartass(a, b, x, y);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_Diff(a, b, x, y) \<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a <a href="CppOperatorMinus.htm">-</a> b); \<br/>
&nbsp;&nbsp;Two_Diff_Tail(a, b, x, y)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Diff_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bvirt <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> x);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> avirt <a href="CppOperatorAssign.htm">=</a> (x <a href="CppOperatorPlus.htm">+</a> (a <a href="CppOperatorMinus.htm">-</a> x));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bround <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> x) <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> around <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorPlus.htm">+</a> (a <a href="CppOperatorMinus.htm">-</a> x)));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorPlus.htm">+</a> (a <a href="CppOperatorMinus.htm">-</a> x))) <a href="CppOperatorPlus.htm">+</a> (a <a href="CppOperatorMinus.htm">-</a> x) <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> x)) <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorMinus.htm">-</a> a <a href="CppOperatorPlus.htm">+</a> x) <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Diff_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bvirt <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> x;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> avirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorPlus.htm">+</a> bvirt;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bround <a href="CppOperatorAssign.htm">=</a> bvirt <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> around <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> avirt;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> around <a href="CppOperatorPlus.htm">+</a> bround;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppDefine.htm">#define</a> Two_Diff_Tail(a, b, x, y) \<br/>
&nbsp;&nbsp;bvirt <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a <a href="CppOperatorMinus.htm">-</a> x); \<br/>
&nbsp;&nbsp;avirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorPlus.htm">+</a> bvirt; \<br/>
&nbsp;&nbsp;bround <a href="CppOperatorAssign.htm">=</a> bvirt <a href="CppOperatorMinus.htm">-</a> b; \<br/>
&nbsp;&nbsp;around <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> avirt; \<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> around <a href="CppOperatorPlus.htm">+</a> bround<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Fast_Two_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorPlus.htm">+</a> b;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum_Tail(a, b, x, y);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Fast_Two_Sum(a, b, x, y) \<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a <a href="CppOperatorPlus.htm">+</a> b); \<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::tricpp::Fast_Two_Sum_Tail(a, b, x, y)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Fast_Two_Sum_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bvirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> a;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Fast_Two_Sum_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bvirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> bvirt;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Fast_Two_Sum_Tail(a, b, x, y) \<br/>
&nbsp;&nbsp;bvirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> a; \<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> bvirt<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Square(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x_temp <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y_temp <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> (a * a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> (a * a) <a href="CppOperatorPlus.htm">+</a> (a * a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> (a * a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square_Tail(a, x, y);<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Square() can be done more quickly than Two_<a href="CppProduct.htm">Product</a>()<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a * a;<br/>
<br/>
<br/>
&nbsp;&nbsp;Square_Tail_Smartass(a, x_temp, y_temp);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(x <a href="CppOperatorEqual.htm">==</a> x_temp);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y <a href="CppOperatorEqual.htm">==</a> y_temp);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Square(a, x, y) \<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a * a); \<br/>
&nbsp;&nbsp;Square_Tail(a, x, y)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Square_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ahi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> alo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split(a, ahi, alo);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(ahi <a href="CppOperatorEqual.htm">==</a> a); <a href="CppAssert.htm">assert</a>(alo <a href="CppOperatorEqual.htm">==</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (a * a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * ahi);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err3 <a href="CppOperatorAssign.htm">=</a> err1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err3 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> ((a <a href="CppOperatorPlus.htm">+</a> a) * 0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err3 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> ((ahi <a href="CppOperatorPlus.htm">+</a> ahi) * alo);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> (alo * alo) <a href="CppOperatorMinus.htm">-</a> err3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> err3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> err1;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> (a * a);<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> y_temp <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Square_Tail_Smartass(a,x,y_temp);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y <a href="CppOperatorEqual.htm">==</a> y_temp);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Square_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> ahi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> alo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Split_Smartass(a, ahi, alo);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * ahi);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err3 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> ((ahi <a href="CppOperatorPlus.htm">+</a> ahi) * alo);<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (alo * alo) <a href="CppOperatorMinus.htm">-</a> err3;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Square_Tail(a, x, y) \<br/>
&nbsp;&nbsp;Split(a, ahi, alo); \<br/>
&nbsp;&nbsp;err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * ahi); \<br/>
&nbsp;&nbsp;err3 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> ((ahi <a href="CppOperatorPlus.htm">+</a> ahi) * alo); \<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (alo * alo) <a href="CppOperatorMinus.htm">-</a> err3<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_One_Diff(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff(a0, b , i, x0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> a0 <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;x0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> i;<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum( a1, i, x2, x1);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_One_Diff_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Two_Diff_Smartass(a0, b , i, x0);<br/>
<br/>
&nbsp;&nbsp;x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> i;<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum( a1, i, x2, x1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_One_Diff(a1, a0, b, x2, x1, x0) \<br/>
&nbsp;&nbsp;Two_Diff(a0, b , _i, x0); \<br/>
&nbsp;&nbsp;Two_Sum( a1, _i, x2, x1)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_One_<a href="CppProduct.htm">Product</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> zero <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> j <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> k <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bhi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> blo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bhi <a href="CppOperatorAssign.htm">=</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>blo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split(b, bhi, blo);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> a0 * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a0, b, bhi, blo, i, x0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> j <a href="CppOperatorAssign.htm">=</a> a1 * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a1, b, bhi, blo, j, zero);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> k <a href="CppOperatorAssign.htm">=</a> a0 * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> k <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> zero;<br/>
<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(i, zero, k, x1);<br/>
<br/>
&nbsp;&nbsp;x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> (a1 * b) <a href="CppOperatorPlus.htm">+</a> (a0 * b);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorPlus.htm">+</a> k;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(a,b,x,y) : x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(j, k, x3, x2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_One_<a href="CppProduct.htm">Product</a>_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> zero <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> j <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> k <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> bhi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> blo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Split_Smartass(b, bhi, blo);<br/>
<br/>
&nbsp;&nbsp;i <a href="CppOperatorAssign.htm">=</a> a0 * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a0, b, bhi, blo, i, x0);<br/>
<br/>
&nbsp;&nbsp;j <a href="CppOperatorAssign.htm">=</a> a1 * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a1, b, bhi, blo, j, zero);<br/>
<br/>
&nbsp;&nbsp;k <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> zero;<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(i, zero, k, x1);<br/>
<br/>
&nbsp;&nbsp;Fast_Two_Sum_Smartass(j, k, x3, x2);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_One_<a href="CppProduct.htm">Product</a>(a1, a0, b, x3, x2, x1, x0) \<br/>
&nbsp;&nbsp;Split(b, bhi, blo); \<br/>
&nbsp;&nbsp;Two_<a href="CppProduct.htm">Product</a>_Presplit(a0, b, bhi, blo, _i, x0); \<br/>
&nbsp;&nbsp;Two_<a href="CppProduct.htm">Product</a>_Presplit(a1, b, bhi, blo, _j, _0); \<br/>
&nbsp;&nbsp;Two_Sum(_i, _0, _k, x1); \<br/>
&nbsp;&nbsp;Fast_Two_Sum(_j, _k, x3, x2)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_One_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> a0 <a href="CppOperatorPlus.htm">+</a> b;<br/>
&nbsp;&nbsp;x0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(a0, b , i, x0);<br/>
<br/>
&nbsp;&nbsp;x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> i;<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(a1, i, x2, x1);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_One_Sum_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> i <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Two_Sum_Smartass(a0, b , i, x0);<br/>
&nbsp;&nbsp;Two_Sum_Smartass(a1, i, x2, x1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppDefine.htm">#define</a> Two_One_Sum(a1, a0, b, x2, x1, x0) \<br/>
&nbsp;&nbsp;Two_Sum(a0, b , _i, x0); \<br/>
&nbsp;&nbsp;Two_Sum(a1, _i, x2, x1)<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_<a href="CppProduct.htm">Product</a>(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a * b;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Tail(a, b, x, y);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_<a href="CppProduct.htm">Product</a>(a, b, x, y) \<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a * b); \<br/>
&nbsp;&nbsp;Two_<a href="CppProduct.htm">Product</a>_Tail(a, b, x, y)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_<a href="CppProduct.htm">Product</a>_Presplit(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bhi, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> blo, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a * b;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_<a href="CppProduct.htm">Product</a>_Presplit_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bhi, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> blo, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Two_<a href="CppProduct.htm">Product</a>_Presplit() is Two_<a href="CppProduct.htm">Product</a>() where one of the inputs has<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; already been split.&nbsp;&nbsp;Avoids redundant splitting.<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a * b;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> ahi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> alo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Split_Smartass(a, ahi, alo);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * bhi);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err2 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> (alo * bhi);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err3 <a href="CppOperatorAssign.htm">=</a> err2 <a href="CppOperatorMinus.htm">-</a> (ahi * blo);<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (alo * blo) <a href="CppOperatorMinus.htm">-</a> err3;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_<a href="CppProduct.htm">Product</a>_Presplit(a, b, bhi, blo, x, y) \<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a * b); \<br/>
&nbsp;&nbsp;Split(a, ahi, alo); \<br/>
&nbsp;&nbsp;err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * bhi); \<br/>
&nbsp;&nbsp;err2 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> (alo * bhi); \<br/>
&nbsp;&nbsp;err3 <a href="CppOperatorAssign.htm">=</a> err2 <a href="CppOperatorMinus.htm">-</a> (ahi * blo); \<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (alo * blo) <a href="CppOperatorMinus.htm">-</a> err3<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_<a href="CppProduct.htm">Product</a>_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0 <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> (a * b);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_<a href="CppProduct.htm">Product</a>_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> ahi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> alo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> bhi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> blo <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Split_Smartass(a, ahi, alo);<br/>
&nbsp;&nbsp;Split_Smartass(b, bhi, blo);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * bhi);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err2 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> (alo * bhi);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> err3 <a href="CppOperatorAssign.htm">=</a> err2 <a href="CppOperatorMinus.htm">-</a> (ahi * blo);<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (alo * blo) <a href="CppOperatorMinus.htm">-</a> err3;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_<a href="CppProduct.htm">Product</a>_Tail(a, b, x, y) \<br/>
&nbsp;&nbsp;Split(a, ahi, alo); \<br/>
&nbsp;&nbsp;Split(b, bhi, blo); \<br/>
&nbsp;&nbsp;err1 <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> (ahi * bhi); \<br/>
&nbsp;&nbsp;err2 <a href="CppOperatorAssign.htm">=</a> err1 <a href="CppOperatorMinus.htm">-</a> (alo * bhi); \<br/>
&nbsp;&nbsp;err3 <a href="CppOperatorAssign.htm">=</a> err2 <a href="CppOperatorMinus.htm">-</a> (ahi * blo); \<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> (alo * blo) <a href="CppOperatorMinus.htm">-</a> err3<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>a <a href="CppOperatorMinus.htm">-</a> b <a href="CppOperatorPlus.htm">+</a> b <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> b <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum_Tail(a, b, x, y);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Sum_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppDouble.htm">double</a></b>&amp; x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b;<br/>
&nbsp;&nbsp;Two_Sum_Tail_Smartass(a, b, x, y);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_Sum(a, b, x, y) \<br/>
&nbsp;&nbsp;x <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (a <a href="CppOperatorPlus.htm">+</a> b); \<br/>
&nbsp;&nbsp;Two_Sum_Tail(a, b, x, y)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Sum_Tail(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a> (a <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a> a))) <a href="CppOperatorPlus.htm">+</a> (b <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a> a));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;a <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a> a))&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;b <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a> a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;a <a href="CppOperatorMinus.htm">-</a> (x <a href="CppOperatorMinus.htm">-</a>&nbsp;&nbsp;x <a href="CppOperatorPlus.htm">+</a> a )&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;b <a href="CppOperatorMinus.htm">-</a>&nbsp;&nbsp;x <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>y <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;a <a href="CppOperatorMinus.htm">-</a>&nbsp;&nbsp;x <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;x <a href="CppOperatorMinus.htm">-</a> a&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;b <a href="CppOperatorMinus.htm">-</a>&nbsp;&nbsp;x <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> x <a href="CppOperatorPlus.htm">+</a> a;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> tempy_y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Two_Sum_Tail_Smartass(a,b,x,tempy_y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(y <a href="CppOperatorEqual.htm">==</a> tempy_y);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Sum_Tail_Smartass(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppDouble.htm">double</a></b>&amp; y)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bvirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> a;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> avirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> bvirt;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bround <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> bvirt;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> around <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> avirt;<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> around <a href="CppOperatorPlus.htm">+</a> bround;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_Sum_Tail(a, b, x, y) \<br/>
&nbsp;&nbsp;bvirt <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) (x <a href="CppOperatorMinus.htm">-</a> a); \<br/>
&nbsp;&nbsp;avirt <a href="CppOperatorAssign.htm">=</a> x <a href="CppOperatorMinus.htm">-</a> bvirt; \<br/>
&nbsp;&nbsp;bround <a href="CppOperatorAssign.htm">=</a> b <a href="CppOperatorMinus.htm">-</a> bvirt; \<br/>
&nbsp;&nbsp;around <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorMinus.htm">-</a> avirt; \<br/>
&nbsp;&nbsp;y <a href="CppOperatorAssign.htm">=</a> around <a href="CppOperatorPlus.htm">+</a> bround<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Two_Diff(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b0, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> zero <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> j <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> j <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> zero <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;x0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Diff(a1,a0,b,x2,x1,x0): x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Diff(a1, a0, b0,&nbsp;&nbsp;j, zero, x0);<br/>
<br/>
&nbsp;&nbsp;x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorMinus.htm">-</a> b1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorPlus.htm">+</a> zero <a href="CppOperatorMinus.htm">-</a> b1;<br/>
&nbsp;&nbsp;x2 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Diff(a1,a0,b,x2,x1,x0): x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Diff( j, zero, b1, x3, x2, x1);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_Two_Diff(a1, a0, b1, b0, x3, x2, x1, x0) \<br/>
&nbsp;&nbsp;Two_One_Diff(a1, a0, b0, _j, _0, x0); \<br/>
&nbsp;&nbsp;Two_One_Diff(_j, _0, b1, x3, x2, x1)<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Two_Two_Sum(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> a0, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b1, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b0, <b><a href="CppDouble.htm">double</a></b>&amp; x3, <b><a href="CppDouble.htm">double</a></b>&amp; x2, <b><a href="CppDouble.htm">double</a></b>&amp; x1, <b><a href="CppDouble.htm">double</a></b>&amp; x0)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> zero <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> j <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>j <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b0; zero <a href="CppOperatorAssign.htm">=</a> 0.0; x0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Sum(a1,a0,b,x2,x1,x0): x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b0n, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Sum(a1, a0, b0,&nbsp;&nbsp;j, zero, x0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>x3 <a href="CppOperatorAssign.htm">=</a> j <a href="CppOperatorPlus.htm">+</a> zero <a href="CppOperatorPlus.htm">+</a> b1;<br/>
&nbsp;&nbsp;x2 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;x1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Sum(a1,a0,b,x2,x1,x0): x2 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_Sum( j, zero, b1, x3, x2, x1);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> Two_Two_Sum(a1, a0, b1, b0, x3, x2, x1, x0) \<br/>
&nbsp;&nbsp;Two_One_Sum(a1, a0, b0, _j, _0, x0); \<br/>
&nbsp;&nbsp;Two_One_Sum(_j, _0, b1, x3, x2, x1)<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppedge.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppedge.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPSUBSEG_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPSUBSEG_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">//</a> The subsegment data structure.&nbsp;&nbsp;Each subsegment contains<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;two <a href="CppPointer.htm">pointer</a>s to adjoining subsegments,<br/>
<a href="CppComment.htm">//</a>WHY ONLY TWO? BOTH THE HEAD AND TAIL OF THE EDGE CAN BE CONNECTED TO MULTIPLE EDGES<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;plus four <a href="CppPointer.htm">pointer</a>s to vertices,<br/>
<a href="CppComment.htm">//</a>WHY FOUR VERTICES? AN EDGE IS A CONNECTION BETWEEN TWO POINTS<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;plus two <a href="CppPointer.htm">pointer</a>s to adjoining triangles,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;plus one boundary marker,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;plus one segment number.<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppTypedef.htm">typedef</a></b> <b><a href="CppDouble.htm">double</a></b> **SubSeg; <a href="CppComment.htm">/*</a> Really:&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> subseg *subseg&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Edge<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; VertexPtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; EdgePtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;EdgePtr&gt; Edges;<br/>
<br/>
&nbsp;&nbsp;Edge(<b><a href="CppConst.htm">const</a></b> VertexPtr&amp; from_vertex, <b><a href="CppConst.htm">const</a></b> VertexPtr&amp; to_vertex);<br/>
<br/>
&nbsp;&nbsp;Edges GetFromEdges();<br/>
&nbsp;&nbsp;Edges GetToEdges();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> GetX() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> GetY() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsDead() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> KillMe() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetBoundaryMarker(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetSubSeg(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; subseg, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetTriangle(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; triangle, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_subsegs;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_triangles;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;Edges m_from_edges;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_from_vertex;<br/>
&nbsp;&nbsp;Edges m_to_edges;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_to_vertex;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_boundary_marker;<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> AreConnected(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">//</a>sdecode() <a href="CppConvert.htm">converts</a> a <a href="CppPointer.htm">pointer</a> to an oriented subsegment.&nbsp;&nbsp;The orientation<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;is extracted from the least significant bit of the <a href="CppPointer.htm">pointer</a>.&nbsp;&nbsp;The two<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;least significant bits (one <b><a href="CppFor.htm">for</a></b> orientation, one <b><a href="CppFor.htm">for</a></b> viral infection)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;are masked out to produce the real <a href="CppPointer.htm">pointer</a>.<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sdecode(sptr, osub) \<br/>
&nbsp;&nbsp;(osub).m_subseg_orient <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (sptr) &amp; (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 1l); \<br/>
&nbsp;&nbsp;(osub).m_subseg <a href="CppOperatorAssign.htm">=</a> (SubSeg *) \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (sptr) &amp; ~ (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 3l)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>sencode() compresses an oriented subsegment into a single <a href="CppPointer.htm">pointer</a>.&nbsp;&nbsp;It<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;relies on the assumption that all subsegments are aligned to two-byte<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;boundaries, so the least significant bit of (osub).m_subseg is zero.<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sencode(osub) \<br/>
&nbsp;&nbsp;(SubSeg) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (osub).m_subseg | (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (osub).m_subseg_orient)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppComment.htm">///</a>ssym() toggles the orientation of a subsegment.<br/>
<b><a href="CppVoid.htm">void</a></b> ssym(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub1, Osub&amp; osub2);<br/>
<b><a href="CppVoid.htm">void</a></b> ssymself(Osub&amp; osub1);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetsOrigin(Osub&amp; osub, <b><a href="CppConst.htm">const</a></b> SubSeg&amp; subsegptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetDest(Osub&amp; osub, <b><a href="CppConst.htm">const</a></b> SubSeg&amp; subsegptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetOrg(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetDest(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr);<br/>
<b><a href="CppVoid.htm">void</a></b> setsegorg(Osub&amp; osub, Edge * subsegptr);<br/>
<b><a href="CppVoid.htm">void</a></b> setsegdest(Osub&amp; osub, Edge * subsegptr);<br/>
<br/>
<a href="CppComment.htm">///</a>Dissolve a subsegment bond (from one side).&nbsp;&nbsp;Note that the other<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment will still think it's connected to <b><a href="CppThis.htm">this</a></b> subsegment.<br/>
<b><a href="CppVoid.htm">void</a></b> sdissolve(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Edge m_m_dummysub);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> subsegcopy(<b><a href="CppConst.htm">const</a></b> SubSeg&amp; osub1, SubSeg&amp; osub2) { osub2 <a href="CppOperatorAssign.htm">=</a> osub1; }<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> subsegequal(<b><a href="CppConst.htm">const</a></b> SubSeg&amp; osub1, <b><a href="CppConst.htm">const</a></b> SubSeg&amp; osub2);<br/>
<b><a href="CppBool.htm">bool</a></b> deadsubseg(<b><a href="CppConst.htm">const</a></b> Edge&amp; t);<br/>
<b><a href="CppVoid.htm">void</a></b> killsubseg(Edge&amp; t);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPSUBSEG_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppedge.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppedge.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Edge::Edge(<b><a href="CppConst.htm">const</a></b> VertexPtr&amp; from_vertex, <b><a href="CppConst.htm">const</a></b> VertexPtr&amp; to_vertex)<br/>
&nbsp;&nbsp;: m_from_vertex(from_vertex),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_to_vertex(to_vertex)<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Edge::Edge()<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subsegs{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangles{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_boundary_marker{8}<br/>
{<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Edge::IsDead() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> deadsubseg(<b><a href="CppConst.htm">const</a></b> SubSeg&amp; t) { <b><a href="CppReturn.htm">return</a></b> t[1] <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>; }<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_triangles.size() &gt; 1);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_triangles[1] <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Edge::KillMe() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> killsubseg(<b><a href="CppConst.htm">const</a></b> SubSeg&amp; t) { t[1] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; t[2] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; }<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_triangles.size() &gt; 2);<br/>
&nbsp;&nbsp;m_triangles[1] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;m_triangles[2] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsDead());<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Edge::SetBoundaryMarker(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>* (<b><a href="CppInt.htm">int</a></b> *) (m.m_dummysub <a href="CppOperatorPlus.htm">+</a> 8) <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;m_boundary_marker <a href="CppOperatorAssign.htm">=</a> value;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Edge::SetSubSeg(Edge * <b><a href="CppConst.htm">const</a></b> subseg, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index&nbsp;&nbsp;&lt; 6 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "But not sure yet...");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_subsegs.size()));<br/>
&nbsp;&nbsp;m_subsegs[index] <a href="CppOperatorAssign.htm">=</a> subseg;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Edge::SetTriangle(Triangle * <b><a href="CppConst.htm">const</a></b> triangle, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 6);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index&nbsp;&nbsp;&lt; 8 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "But not sure yet...");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_triangles.size()));<br/>
&nbsp;&nbsp;m_triangles[index] <a href="CppOperatorAssign.htm">=</a> triangle;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::ssym(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub1, Osub&amp; osub2)<br/>
{<br/>
&nbsp;&nbsp;osub2.Ssym(osub1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub2.m_subseg <a href="CppOperatorAssign.htm">=</a> osub1.m_subseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub2.m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> osub1.m_subseg_orient;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> ssym(osub1, osub2) \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(osub2).m_subseg <a href="CppOperatorAssign.htm">=</a> (osub1).m_subseg; \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(osub2).m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> (osub1).m_subseg_orient<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::ssymself(Osub&amp; osub1)<br/>
{<br/>
&nbsp;&nbsp;osub1.Ssymself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub.m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> ssymself(osub) \<br/>
&nbsp;&nbsp;(osub).m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetDest(Osub&amp; osub, Vertex * vertexptr)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does not <b><a href="CppDo.htm">do</a></b> <a href="CppAny.htm">any</a>thing yet<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> osub.m_subseg[3 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sdest(osub, vertexptr) \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (osub).m_subseg[3 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::SetsOrigin(Osub&amp; osub, <b><a href="CppConst.htm">const</a></b> SubSeg &amp; subsegptr)<br/>
{<br/>
&nbsp;&nbsp;osub.SetOrigin(subsegptr);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub.m_subseg[2 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> subsegptr;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setsorg(osub, vertexptr) \<br/>
&nbsp;&nbsp;(osub).m_subseg[2 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::SetDest(Osub&amp; osub, <b><a href="CppConst.htm">const</a></b> SubSeg &amp; subsegptr)<br/>
{<br/>
&nbsp;&nbsp;osub.SetDest(subsegptr);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub.m_subseg[3 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> subsegptr;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setsdest(osub, vertexptr) \<br/>
&nbsp;&nbsp;(osub).m_subseg[3 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetOrg(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> osub.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexptr <a href="CppOperatorAssign.htm">=</a> osub.m_subseg[4 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> segorg(osub, vertexptr) \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (osub).m_subseg[4 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetDest(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> osub.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexptr <a href="CppOperatorAssign.htm">=</a> osub.m_subseg[5 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> segdest(osub, vertexptr) \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (osub).m_subseg[5 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setsegorg(Osub&amp; osub, Edge * subsegptr)<br/>
{<br/>
&nbsp;&nbsp;osub.m_subseg[4 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> subsegptr;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setsegorg(osub, vertexptr) \<br/>
&nbsp;&nbsp;(osub).m_subseg[4 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setsegdest(Osub&amp; osub, Edge * subsegptr)<br/>
{<br/>
&nbsp;&nbsp;osub.m_subseg[5 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> vertexptr;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setsegdest(osub, vertexptr) \<br/>
&nbsp;&nbsp;(osub).m_subseg[5 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::sdissolve(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Edge m_m_dummysub)<br/>
{<br/>
&nbsp;&nbsp;osub.m_subseg[osub.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> m.m_dummysub;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sdissolve(osub) \<br/>
&nbsp;&nbsp;(osub).m_subseg[(osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) m.m_dummysub<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> subsegcopy(osub1, osub2) \<br/>
&nbsp;&nbsp;(osub2).m_subseg <a href="CppOperatorAssign.htm">=</a> (osub1).m_subseg; \<br/>
&nbsp;&nbsp;(osub2).m_subseg_orient <a href="CppOperatorAssign.htm">=</a> (osub1).m_subseg_orient<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::subsegcopy(<b><a href="CppConst.htm">const</a></b> SubSeg&amp; osub1, SubSeg&amp; osub2) { osub2 <a href="CppOperatorAssign.htm">=</a> osub1; }<br/>
<br/>
<a href="CppComment.htm">//</a>Test <b><a href="CppFor.htm">for</a></b> equality of subsegments.<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::subsegequal(<b><a href="CppConst.htm">const</a></b> SubSeg&amp; osub1, <b><a href="CppConst.htm">const</a></b> SubSeg&amp; osub2) { <b><a href="CppReturn.htm">return</a></b> osub1 <a href="CppOperatorEqual.htm">==</a> osub2; }<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> subsegequal(osub1, osub2) \<br/>
&nbsp;&nbsp;(((osub1).ss <a href="CppOperatorEqual.htm">==</a> (osub2).ss) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> \<br/>
&nbsp;&nbsp; ((osub1).m_subseg_orient <a href="CppOperatorEqual.htm">==</a> (osub2).m_subseg_orient))<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>Check or set a subsegment's deallocation.&nbsp;&nbsp;Its second <a href="CppPointer.htm">pointer</a> is set to<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppNULL.htm">NULL</a> to indicate that it is not allocated.&nbsp;&nbsp;(Its first <a href="CppPointer.htm">pointer</a> is used<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> the stack of dead items.)&nbsp;&nbsp;Its third <a href="CppPointer.htm">pointer</a> (its first vertex)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;is set to <a href="CppNULL.htm">NULL</a> in <b><a href="CppCase.htm">case</a></b> a `badsubseg' structure <a href="CppPointer.htm">point</a>s to it.<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::deadsubseg(<b><a href="CppConst.htm">const</a></b> Edge&amp; t) { <b><a href="CppReturn.htm">return</a></b> t.IsDead(); }<br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> deadsubseg(sub)&nbsp;&nbsp;((sub)[1] <a href="CppOperatorEqual.htm">==</a> (SubSeg) <a href="CppNULL.htm">NULL</a>)<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::killsubseg(Edge&amp; t) { t.KillMe(); }<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::AreConnected(<b><a href="CppConst.htm">const</a></b> Edge&amp; lhs, <b><a href="CppConst.htm">const</a></b> Edge&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetFromVertex() <a href="CppOperatorEqual.htm">==</a> rhs.GetFromVertex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> lhs.GetFromVertex() <a href="CppOperatorEqual.htm">==</a> rhs.GetToVertex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> lhs.GetToVertex()&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetFromVertex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> lhs.GetToVertex()&nbsp;&nbsp; <a href="CppOperatorEqual.htm">==</a> rhs.GetToVertex()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppevent.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppevent.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPEVENT_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPEVENT_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_EVENT<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> A node in a heap used to store events <b><a href="CppFor.htm">for</a></b> the sweepline Delaunay<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppAlgorithm.htm">algorithm</a>.&nbsp;&nbsp;Nodes <b><a href="CppDo.htm">do</a></b> not <a href="CppPointer.htm">point</a> directly to their parents or children in<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; the heap.&nbsp;&nbsp;Instead, each node knows its position in the heap, and can<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; look up its parent and children in a separate <a href="CppArray.htm">array</a>.&nbsp;&nbsp;The `eventptr'<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppPointer.htm">point</a>s either to a `vertex' or to a triangle (in encoded format, so<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; that an orientation is included).&nbsp;&nbsp;In the latter <b><a href="CppCase.htm">case</a></b>, the origin of<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; the oriented triangle is the apex of a "circle event" of the sweepline<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppAlgorithm.htm">algorithm</a>.&nbsp;&nbsp;To distinguish site events from circle events, all circle<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; events are given an invalid (smaller than `xmin') x-coordinate `xkey'.<br/>
<b><a href="CppStruct.htm">struct</a></b> Event<br/>
{<br/>
&nbsp;&nbsp;Event();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Can be a vertex or the location of a circle event<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> *m_eventptr;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Marks <b><a href="CppThis.htm">this</a></b> event's position in the heap.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_heapposition;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Coordinates of the event<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_xkey;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_ykey;<br/>
};<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> eventheapdelete(<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> heap,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> eventnum<br/>
);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> eventheapify(<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> heap,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> eventnum<br/>
);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> eventheapinsert(<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> heap,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize,<br/>
&nbsp;&nbsp;Event * <b><a href="CppConst.htm">const</a></b> newevent<br/>
);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_EVENT<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPEVENT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppevent.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppevent.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppevent.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Event::Event()<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_eventptr{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_heapposition{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_xkey{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_ykey{0.0}<br/>
{<br/>
<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::eventheapinsert(<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> heap,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize,<br/>
&nbsp;&nbsp;Event * <b><a href="CppConst.htm">const</a></b> newevent)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> eventx <a href="CppOperatorAssign.htm">=</a> newevent-&gt;m_xkey;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> eventy <a href="CppOperatorAssign.htm">=</a> newevent-&gt;m_ykey;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> eventnum <a href="CppOperatorAssign.htm">=</a> heapsize;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> notdone <a href="CppOperatorAssign.htm">=</a> eventnum &gt; 0;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (notdone)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> parent <a href="CppOperatorAssign.htm">=</a> (eventnum <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((heap[parent]-&gt;m_ykey &lt; eventy) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((heap[parent]-&gt;m_ykey <a href="CppOperatorEqual.htm">==</a> eventy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (heap[parent]-&gt;m_xkey <a href="CppOperatorLessEqual.htm">&lt;=</a> eventx)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notdone <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[eventnum] <a href="CppOperatorAssign.htm">=</a> heap[parent];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[eventnum]-&gt;m_heapposition <a href="CppOperatorAssign.htm">=</a> eventnum;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventnum <a href="CppOperatorAssign.htm">=</a> parent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notdone <a href="CppOperatorAssign.htm">=</a> eventnum &gt; 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;heap[eventnum] <a href="CppOperatorAssign.htm">=</a> newevent;<br/>
&nbsp;&nbsp;newevent-&gt;m_heapposition <a href="CppOperatorAssign.htm">=</a> eventnum;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::eventheapify(<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> heap,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> eventnum<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rightchild <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> smallest <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
<br/>
&nbsp;&nbsp;Event *<b><a href="CppThis.htm">this</a></b>event <a href="CppOperatorAssign.htm">=</a> heap[eventnum];<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> eventx <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>event-&gt;m_xkey;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> eventy <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>event-&gt;m_ykey;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> leftchild <a href="CppOperatorAssign.htm">=</a> 2 * eventnum <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> notdone <a href="CppOperatorAssign.htm">=</a> leftchild &lt; heapsize;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (notdone)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((heap[leftchild]-&gt;m_ykey &lt; eventy) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((heap[leftchild]-&gt;m_ykey <a href="CppOperatorEqual.htm">==</a> eventy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (heap[leftchild]-&gt;m_xkey &lt; eventx)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallest <a href="CppOperatorAssign.htm">=</a> leftchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallest <a href="CppOperatorAssign.htm">=</a> eventnum;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rightchild <a href="CppOperatorAssign.htm">=</a> leftchild <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightchild &lt; heapsize) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((heap[rightchild]-&gt;m_ykey &lt; heap[smallest]-&gt;m_ykey) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((heap[rightchild]-&gt;m_ykey <a href="CppOperatorEqual.htm">==</a> heap[smallest]-&gt;m_ykey)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (heap[rightchild]-&gt;m_xkey &lt; heap[smallest]-&gt;m_xkey))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallest <a href="CppOperatorAssign.htm">=</a> rightchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (smallest <a href="CppOperatorEqual.htm">==</a> eventnum) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notdone <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[eventnum] <a href="CppOperatorAssign.htm">=</a> heap[smallest];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[eventnum]-&gt;m_heapposition <a href="CppOperatorAssign.htm">=</a> eventnum;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[smallest] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>event;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b>event-&gt;m_heapposition <a href="CppOperatorAssign.htm">=</a> smallest;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventnum <a href="CppOperatorAssign.htm">=</a> smallest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftchild <a href="CppOperatorAssign.htm">=</a> 2 * eventnum <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notdone <a href="CppOperatorAssign.htm">=</a> leftchild &lt; heapsize;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::eventheapdelete(<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> heap,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> eventnum<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Event * <b><a href="CppConst.htm">const</a></b> moveevent <a href="CppOperatorAssign.htm">=</a> heap[heapsize <a href="CppOperatorMinus.htm">-</a> 1];<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (eventnum &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> notdone <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> eventx <a href="CppOperatorAssign.htm">=</a> moveevent-&gt;m_xkey;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> eventy <a href="CppOperatorAssign.htm">=</a> moveevent-&gt;m_ykey;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> parent <a href="CppOperatorAssign.htm">=</a> (eventnum <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((heap[parent]-&gt;m_ykey &lt; eventy) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((heap[parent]-&gt;m_ykey <a href="CppOperatorEqual.htm">==</a> eventy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (heap[parent]-&gt;m_xkey <a href="CppOperatorLessEqual.htm">&lt;=</a> eventx))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notdone <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[eventnum] <a href="CppOperatorAssign.htm">=</a> heap[parent];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap[eventnum]-&gt;m_heapposition <a href="CppOperatorAssign.htm">=</a> eventnum;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventnum <a href="CppOperatorAssign.htm">=</a> parent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notdone <a href="CppOperatorAssign.htm">=</a> eventnum &gt; 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (notdone);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;heap[eventnum] <a href="CppOperatorAssign.htm">=</a> moveevent;<br/>
&nbsp;&nbsp;moveevent-&gt;m_heapposition <a href="CppOperatorAssign.htm">=</a> eventnum;<br/>
&nbsp;&nbsp;eventheapify(heap, heapsize <a href="CppOperatorMinus.htm">-</a> 1, eventnum);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppfile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppfile.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPP<a href="CppCfile.htm">FILE</a>_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPP<a href="CppCfile.htm">FILE</a>_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_<a href="CppCfile.htm">FILE</a><br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppStruct.htm">struct</a></b> _iobuf;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;readline()&nbsp;&nbsp; Read a nonempty line from a file.<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;A line is considered "nonempty" <b><a href="CppIf.htm">if</a></b> it contains something that looks like<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;a number.&nbsp;&nbsp;Comments (prefaced by `#') are ignored.<br/>
<b><a href="CppChar.htm">char</a></b> * readline(<b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> string, _iobuf * <b><a href="CppConst.htm">const</a></b> infile);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_<a href="CppCfile.htm">FILE</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP<a href="CppCfile.htm">FILE</a>_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppfile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppfile.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppfile.h"<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">cstring</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCstdioH.htm">cstdio</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppglobals.h"<br/>
<br/>
<b><a href="CppChar.htm">char</a></b> * <a href="CppRibi.htm">ribi</a>::tricpp::readline(<b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> string, <a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> infile)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> *result <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Search <b><a href="CppFor.htm">for</a></b> something that looks like a number.<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result <a href="CppOperatorAssign.htm">=</a> <a href="CppStdFgets.htm">std::fgets</a>(string, g_max_inputline_size, infile);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!result) { <a href="CppComment.htm">//</a>RJCB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Skip <a href="CppAny.htm">any</a>thing that doesn't look like a number, a comment,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; or the end of a line.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorNotEqual.htm">!=</a> '\0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '#')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '.') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '+') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '-')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((*result &lt; '0') <a href="CppOperatorLogicalOr.htm">||</a> (*result &gt; '9'))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> If it's a comment or end of line, read another line and <b><a href="CppTry.htm">try</a></b> again.<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorEqual.htm">==</a> '#') <a href="CppOperatorLogicalOr.htm">||</a> (*result <a href="CppOperatorEqual.htm">==</a> '\0'));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppfinddirectionresult.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppfinddirectionresult.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPFINDDIRECTIONRESULT_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPFINDDIRECTIONRESULT_H<br/>
<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> Labels that signify the result of direction finding.&nbsp;&nbsp;The result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; indicates that a segment connecting the two query <a href="CppPointer.htm">point</a>s falls within&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; the direction triangle, along the left edge of the direction triangle,&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; or along the right edge of the direction triangle.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppEnum.htm">enum</a></b> FindDirectionResult {WITHIN, LEFTCOLLINEAR, RIGHTCOLLINEAR};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPFINDDIRECTIONRESULT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppfinddirectionresult.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppfinddirectionresult.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppfinddirectionresult.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppflipstacker.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppflipstacker.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPFLIPSTACKER_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPFLIPSTACKER_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_FLIPSTACKER<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> A stack of triangles flipped during the most recent vertex insertion.&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; The stack is used to undo the vertex insertion <b><a href="CppIf.htm">if</a></b> the vertex encroaches <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; upon a subsegment.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> FlipStacker<br/>
{<br/>
&nbsp;&nbsp;FlipStacker();<br/>
&nbsp;&nbsp;FlipStacker(<b><a href="CppConst.htm">const</a></b> FlipStacker&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;FlipStacker&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> FlipStacker&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;Triangle m_flippedtri;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> A recently flipped triangle. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;FlipStacker *m_prevflip;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Previous flip in the stack. <a href="CppComment.htm">*/</a><br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_FLIPSTACKER<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPFLIPSTACKER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppflipstacker.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppflipstacker.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppflipstacker.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::FlipStacker::FlipStacker()<br/>
&nbsp;&nbsp;: m_flippedtri{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_prevflip{<b><a href="CppNullptr.htm">nullptr</a></b>}<br/>
{<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppfwd.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppfwd.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPFWD_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPFWD_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> PolyFile;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> BadSubSeg;<br/>
<b><a href="CppStruct.htm">struct</a></b> BadTriang;<br/>
<b><a href="CppStruct.htm">struct</a></b> Arguments;<br/>
<b><a href="CppStruct.htm">struct</a></b> Edge;<br/>
<b><a href="CppStruct.htm">struct</a></b> Event;<br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppMemory.htm">Memory</a>Pool;<br/>
<b><a href="CppStruct.htm">struct</a></b> Mesh;<br/>
<b><a href="CppStruct.htm">struct</a></b> MeshBuilder;<br/>
<b><a href="CppStruct.htm">struct</a></b> Osub;<br/>
<b><a href="CppStruct.htm">struct</a></b> Otri;<br/>
<b><a href="CppStruct.htm">struct</a></b> SplayNode;<br/>
<b><a href="CppStruct.htm">struct</a></b> Triangle;<br/>
<b><a href="CppStruct.htm">struct</a></b> TriangulateIo;<br/>
<b><a href="CppStruct.htm">struct</a></b> Vertex;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPFWD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppglobals.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppglobals.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPGLOBALS_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPGLOBALS_H<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUtilityH.htm">utility</a>&gt;<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<a href="CppComment.htm">///</a>TODO: Remove these<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Global<br/>
{<br/>
&nbsp;&nbsp;Global() : Global(CreateEpsilonAndSplitter()) {}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_ccwerrboundA;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_ccwerrboundB;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_ccwerrboundC;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;`epsilon' is the largest power of two such that 1.0 <a href="CppOperatorPlus.htm">+</a> epsilon <a href="CppOperatorAssign.htm">=</a> 1.0 in<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;floating-<a href="CppPointer.htm">point</a> arithmetic.&nbsp;&nbsp;`epsilon' bounds the relative roundoff<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;error.&nbsp;&nbsp;It is used <b><a href="CppFor.htm">for</a></b> floating-<a href="CppPointer.htm">point</a> error analysis.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_epsilon;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_iccerrboundA;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_iccerrboundB;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_iccerrboundC;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_o3derrboundA;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_o3derrboundB;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_o3derrboundC;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_resulterrbound;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;`splitter' is used to split floating-<a href="CppPointer.htm">point</a> numbers into two half-<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;length significands <b><a href="CppFor.htm">for</a></b> exact multiplication.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> m_splitter; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Used to split <b><a href="CppDouble.htm">double</a></b> factors <b><a href="CppFor.htm">for</a></b> exact multiplication<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;Global(<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppDouble.htm">double</a></b>,<b><a href="CppDouble.htm">double</a></b>&gt;&amp; p);<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppDouble.htm">double</a></b>,<b><a href="CppDouble.htm">double</a></b>&gt; CreateEpsilonAndSplitter() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
};<br/>
<br/>
<br/>
<br/>
<a href="CppComment.htm">/*</a> Maximum number of <a href="CppChar.htm">character</a>s in a line read from a file (including the&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; null).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> g_max_inputline_size <a href="CppOperatorAssign.htm">=</a> 1024;<br/>
<br/>
<a href="CppComment.htm">/*</a> For efficiency, a variety of data structures are allocated in bulk.&nbsp;&nbsp;The&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; following constants determine how many of each structure is allocated&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; at once.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> g_triangles_per_block <a href="CppOperatorAssign.htm">=</a> 4092;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Number of triangles allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> SUBSEGPERBLOCK <a href="CppOperatorAssign.htm">=</a> 508;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Number of subsegments allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> VERTEXPERBLOCK <a href="CppOperatorAssign.htm">=</a> 4092;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Number of vertices allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> VIRUSPERBLOCK <a href="CppOperatorAssign.htm">=</a> 1020;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Number of virus triangles allocated at once. <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a> Number of encroached subsegments allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> BADSUBSEGPERBLOCK <a href="CppOperatorAssign.htm">=</a> 252;<br/>
<a href="CppComment.htm">/*</a> Number of skinny triangles allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> g_bad_triangles_per_block <a href="CppOperatorAssign.htm">=</a> 4092;<br/>
<a href="CppComment.htm">/*</a> Number of flipped triangles allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> FLIPSTACKERPERBLOCK <a href="CppOperatorAssign.htm">=</a> 252;<br/>
<a href="CppComment.htm">/*</a> Number of splay tree nodes allocated at once. <a href="CppComment.htm">*/</a><br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> SPLAYNODEPERBLOCK <a href="CppOperatorAssign.htm">=</a> 508;<br/>
<br/>
<a href="CppComment.htm">/*</a> Two constants <b><a href="CppFor.htm">for</a></b> <a href="CppAlgorithm.htm">algorithm</a>s based on random sampling.&nbsp;&nbsp;Both constants&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; have been chosen empirically to optimize their respective <a href="CppAlgorithm.htm">algorithm</a>s.&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Used <b><a href="CppFor.htm">for</a></b> the <a href="CppPointer.htm">point</a> location scheme of Mucke, Saias, and Zhu, to decide&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; how large a random sample of triangles to inspect.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppDefine.htm">#define</a> SAMPLEFACTOR 11<br/>
<br/>
<a href="CppComment.htm">/*</a> Used in Fortune's sweepline Delaunay <a href="CppAlgorithm.htm">algorithm</a> to determine what fraction <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; of boundary edges should be maintained in the splay tree <b><a href="CppFor.htm">for</a></b> <a href="CppPointer.htm">point</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; location on the front.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> SAMPLERATE <a href="CppOperatorAssign.htm">=</a> 10;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPGLOBALS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppglobals.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppglobals.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppglobals.h"<br/>
<br/>
<a href="CppComment.htm">//</a>p.first <a href="CppOperatorAssign.htm">=</a> epsilon<br/>
<a href="CppComment.htm">//</a>p.second <a href="CppOperatorAssign.htm">=</a> splitter<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Global::Global(<b><a href="CppConst.htm">const</a></b> <a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppDouble.htm">double</a></b>,<b><a href="CppDouble.htm">double</a></b>&gt;&amp; p)<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_ccwerrboundA{( 3.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;16.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_ccwerrboundB{( 2.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;12.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_ccwerrboundC{( 9.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;64.0 * p.first) * p.first * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_epsilon{p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_iccerrboundA{(10.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;96.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_iccerrboundB{( 4.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;48.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_iccerrboundC{(44.0 <a href="CppOperatorPlus.htm">+</a> 576.0 * p.first) * p.first * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_o3derrboundA{( 7.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;56.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_o3derrboundB{( 3.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;28.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_o3derrboundC{(26.0 <a href="CppOperatorPlus.htm">+</a> 288.0 * p.first) * p.first * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_resulterrbound{(3.0 <a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;8.0 * p.first) * p.first},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_splitter{p.second}<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppDouble.htm">double</a></b>,<b><a href="CppDouble.htm">double</a></b>&gt; <a href="CppRibi.htm">ribi</a>::tricpp::Global::CreateEpsilonAndSplitter() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> lastcheck <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> every_other <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> epsilon <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> splitter <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> check <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Repeatedly divide `epsilon' by two until it is too small to add to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; one without ca<b><a href="CppUsing.htm">using</a></b> roundoff.&nbsp;&nbsp;(Also check <b><a href="CppIf.htm">if</a></b> the sum is equal to&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; the previous sum, <b><a href="CppFor.htm">for</a></b> machines that round up instead of <b><a href="CppUsing.htm">using</a></b> exact&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; rounding.&nbsp;&nbsp;Not that these routines will work on such machines.)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;lastcheck <a href="CppOperatorAssign.htm">=</a> check;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;epsilon <a href="CppOperatorMultiplyAssign.htm">*=</a> 0.5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (every_other)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitter <a href="CppOperatorMultiplyAssign.htm">*=</a> 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;every_other <a href="CppOperatorAssign.htm">=</a> !every_other;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;check <a href="CppOperatorAssign.htm">=</a> 1.0 <a href="CppOperatorPlus.htm">+</a> epsilon;<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((check <a href="CppOperatorNotEqual.htm">!=</a> 1.0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (check <a href="CppOperatorNotEqual.htm">!=</a> lastcheck));<br/>
&nbsp;&nbsp;splitter <a href="CppOperatorPlusAssign.htm">+=</a> 1.0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdPair.htm">std::pair</a>&lt;<b><a href="CppDouble.htm">double</a></b>,<b><a href="CppDouble.htm">double</a></b>&gt; p <a href="CppOperatorAssign.htm">=</a> <a href="CppStdMake_pair.htm">std::make_pair</a>(epsilon,splitter);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> p;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpphelper.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpphelper.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPHELPER_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPHELPER_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> randomnation()&nbsp;&nbsp; Generate a <a href="CppRandomNumber.htm">random number</a> between 0 and `choices' <a href="CppOperatorMinus.htm">-</a> 1.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This is a simple linear congruential <a href="CppRandomNumber.htm">random number</a> generator.&nbsp;&nbsp;Hence, it<br/>
/<a href="CppComment.htm">//</a> is a bad <a href="CppRandomNumber.htm">random number</a> generator, but good enough <b><a href="CppFor.htm">for</a></b> most randomized<br/>
/<a href="CppComment.htm">//</a> geometric <a href="CppAlgorithm.htm">algorithm</a>s.<br/>
<b><a href="CppInt.htm">int</a></b> DumbRand(<b><a href="CppConst.htm">const</a></b> <b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppInt.htm">int</a></b> choices);<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppSeperateString.htm">SeperateString</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; input,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> seperator<br/>
);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPHELPER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpphelper.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpphelper.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecpphelper.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCstdioH.htm">cstdio</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppAlgorithm.htm">algorithm</a>/string/split.hpp&gt;<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::DumbRand(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> max)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> max;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppInt.htm">int</a></b> s_randomseed <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>s_randomseed <a href="CppOperatorAssign.htm">=</a> (s_randomseed * 1366l <a href="CppOperatorPlus.htm">+</a> 150889l) <a href="CppOperatorModulus.htm">%</a> 714025l;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> s_randomseed <a href="CppOperatorDivide.htm">/</a> (714025l <a href="CppOperatorDivide.htm">/</a> choices <a href="CppOperatorPlus.htm">+</a> 1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a>From http://www.richelbilderbeek.nl/Cpp<a href="CppSeperateString.htm">SeperateString</a>.htm<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppSeperateString.htm">SeperateString</a>(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; input,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> seperator)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v;<br/>
&nbsp;&nbsp;<a href="CppBoostSplit.htm">boost::algorithm::split</a>(v,input,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdBind2nd.htm">std::bind2nd</a>(<a href="CppStdEqual_to.htm">std::equal_to</a>&lt;<b><a href="CppChar.htm">char</a></b>&gt;(),seperator),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoost.htm">boost</a>::<a href="CppAlgorithm.htm">algorithm</a>::token_compress_on);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> v;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppinfo.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppinfo.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPINFO_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPINFO_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> info();<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPINFO_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppinfo.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppinfo.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppinfo.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::info()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppVersion.htm">Version</a> 1.6\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Copyright 1993, 1995, 1997, 1998, 2002, 2005 Jonathan Ri<b><a href="CppChar.htm">char</a></b>d Shewchuk\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "2360 Woolsey #H <a href="CppOperatorDivide.htm">/</a> Berkeley, California 94705-1927\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppBug.htm">Bug</a>s/comments to jrs@cs.berkeley.edu\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Created as part of the Quake project (<a href="Tools.htm">tools</a> <b><a href="CppFor.htm">for</a></b> earthquake simulation).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "There is no warranty whatsoever.&nbsp;&nbsp;Use at your own risk.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "This executable is <a href="CppCompile.htm">compile</a>d <b><a href="CppFor.htm">for</a></b> <b><a href="CppDouble.htm">double</a></b> precision arithmetic.\n\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle generates exact Delaunay triangulations, constrained Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "triangulations, conforming Delaunay triangulations, Voronoi diagrams, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "high-quality triangular meshes.&nbsp;&nbsp;The latter can be generated with no small\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "or large angles, and are thus suitable <b><a href="CppFor.htm">for</a></b> finite element analysis.&nbsp;&nbsp;If no\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "command line <b><a href="CppSwitch.htm">switch</a></b> is specified, your .node input file is read, and the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Delaunay triangulation is <b><a href="CppReturn.htm">return</a></b>ed in .node and .ele output files.&nbsp;&nbsp;The\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "command syntax is:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "triangle [-rq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Underscores indicate that numbers may optionally follow certain <b><a href="CppSwitch.htm">switch</a></b>es.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Do not leave <a href="CppAny.htm">any</a> space between a <b><a href="CppSwitch.htm">switch</a></b> and its numeric parameter.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "input_file must be a file with&nbsp;&nbsp;extension .poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "If <a href="CppOperatorMinus.htm">-</a>r is used, you must supply .node and .ele files,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "and possibly a .poly file and an .area file as well.&nbsp;&nbsp;The formats of these\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "files are described below.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Command Line Switches:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>r&nbsp;&nbsp;Refines a previously generated mesh.&nbsp;&nbsp;The mesh is read from a .node\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file and an .ele file.&nbsp;&nbsp;If <a href="CppOperatorMinus.htm">-</a>p is also used, a .poly file is read\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and used to constrain segments in the mesh.&nbsp;&nbsp;If <a href="CppOperatorMinus.htm">-</a>a is also used\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with no number following), an .area file is read and used to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;impose area constraints on the mesh.&nbsp;&nbsp;Further details on refinement\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appear below.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>q&nbsp;&nbsp;Quality mesh generation by Delaunay refinement (a hybrid of Paul\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chew's and Jim Ruppert's <a href="CppAlgorithm.htm">algorithm</a>s).&nbsp;&nbsp;<a href="CppAdd.htm">Add</a>s vertices to the mesh to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensure that all angles are between 20 and 140 degrees.&nbsp;&nbsp;An\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternative bound on the minimum angle, replacing 20 degrees, may\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be specified after the `q'.&nbsp;&nbsp;The specified angle may include a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimal <a href="CppPointer.htm">point</a>, but not exponential notation.&nbsp;&nbsp;Note that a bound of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theta degrees on the smallest angle also implies a bound of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(180 <a href="CppOperatorMinus.htm">-</a> 2 theta) on the largest angle.&nbsp;&nbsp;If the minimum angle is 28.6\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;degrees or smaller, Triangle is mathematically guaranteed to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate (assuming infinite precision arithmetic<a href="CppOperatorDecrement.htm">--</a>Triangle may\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail to terminate <b><a href="CppIf.htm">if</a></b> you run out of precision).&nbsp;&nbsp;In practice,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Triangle often succeeds <b><a href="CppFor.htm">for</a></b> minimum angles up to 34 degrees.&nbsp;&nbsp;For\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;some meshes, however, you might need to reduce the minimum angle to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avoid problems associated with insufficient floating-<a href="CppPointer.htm">point</a>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;precision.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>a&nbsp;&nbsp;Imposes a maximum triangle area.&nbsp;&nbsp;If a number follows the `a', no\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangle is generated whose area is larger than that number.&nbsp;&nbsp;If no\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number is specified, an .area file (<b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>r is used) or .poly file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>r is not used) specifies a set of maximum area constraints.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An .area file contains a separate area constraint <b><a href="CppFor.htm">for</a></b> each\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangle, and is useful <b><a href="CppFor.htm">for</a></b> refining a finite element mesh based on\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a posteriori error estimates.&nbsp;&nbsp;A .poly file can optionally contain\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an area constraint <b><a href="CppFor.htm">for</a></b> each segment-bounded region, thereby\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controlling triangle densities in a first triangulation of a PSLG.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can impose both a fixed area constraint and a varying area\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraint by invoking the <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b> twice, once with and once\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;without a number following.&nbsp;&nbsp;Each area specified may include a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimal <a href="CppPointer.htm">point</a>.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>u&nbsp;&nbsp;Imposes a user-defined constraint on triangle size.&nbsp;&nbsp;There are two\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ways to use <b><a href="CppThis.htm">this</a></b> feature.&nbsp;&nbsp;One is to edit the triunsuitable()\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure in triangle.c to encode <a href="CppAny.htm">any</a> constraint you like, then\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;re<a href="CppCompile.htm">compile</a> Triangle.&nbsp;&nbsp;The other is to <a href="CppCompile.htm">compile</a> triangle.c with the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXTERNAL_TEST symbol set (<a href="CppCompiler.htm">compiler</a> <b><a href="CppSwitch.htm">switch</a></b> <a href="CppOperatorMinus.htm">-</a>DEXTERNAL_TEST), then\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppLink.htm">link</a> Triangle with a separate object file that implements\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triunsuitable().&nbsp;&nbsp;In either <b><a href="CppCase.htm">case</a></b>, the <a href="CppOperatorMinus.htm">-</a>u <b><a href="CppSwitch.htm">switch</a></b> causes the user-\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defined test to be applied to every triangle.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>A&nbsp;&nbsp;Assigns an additional floating-<a href="CppPointer.htm">point</a> attribute to each triangle\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that identifies what segment-bounded region each triangle belongs\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to.&nbsp;&nbsp;Attributes are as<b><a href="CppSigned.htm">signed</a></b> to regions by the .poly file.&nbsp;&nbsp;If a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region is not <b><a href="CppExplicit.htm">explicit</a></b>ly marked by the .poly file, triangles in\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that region are as<b><a href="CppSigned.htm">signed</a></b> an attribute of zero.&nbsp;&nbsp;The <a href="CppOperatorMinus.htm">-</a>A <b><a href="CppSwitch.htm">switch</a></b> has\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an effect only when the <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b> is used and the <a href="CppOperatorMinus.htm">-</a>r <b><a href="CppSwitch.htm">switch</a></b> is not.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>c&nbsp;&nbsp;Creates segments on the convex hull of the triangulation.&nbsp;&nbsp;If you\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are triangulating a vertex set, <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> causes a .poly file to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be written, containing all edges of the convex hull.&nbsp;&nbsp;If you are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangulating a PSLG, <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> specifies that the whole convex\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hull of the PSLG should be triangulated, regardless of what\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segments the PSLG has.&nbsp;&nbsp;If you <b><a href="CppDo.htm">do</a></b> not use <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> when\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangulating a PSLG, Triangle assumes that you have identified the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region to be triangulated by surrounding it with segments of the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input PSLG.&nbsp;&nbsp;Beware:&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> you are not careful, <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> can cause\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the introduction of an extremely thin angle between a PSLG segment\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and a convex hull segment, which can cause overrefinement (and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibly failure <b><a href="CppIf.htm">if</a></b> Triangle runs out of precision).&nbsp;&nbsp;If you are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refining a mesh, the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b> works differently:&nbsp;&nbsp;it causes a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.poly file to be written containing the boundary edges of the mesh\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(useful <b><a href="CppIf.htm">if</a></b> no .poly file was read).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>D&nbsp;&nbsp;Conforming Delaunay triangulation:&nbsp;&nbsp;use <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> <b><a href="CppIf.htm">if</a></b> you want to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensure that all the triangles in the mesh are Delaunay, and not\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merely constrained Delaunay; or <b><a href="CppIf.htm">if</a></b> you want to ensure that all the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Voronoi vertices lie within the triangulation.&nbsp;&nbsp;(Some finite volume\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppMemberFunction.htm">member function</a>s have <b><a href="CppThis.htm">this</a></b> requirement.)&nbsp;&nbsp;This <b><a href="CppSwitch.htm">switch</a></b> invokes Ruppert's\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;original <a href="CppAlgorithm.htm">algorithm</a>, which splits every subsegment whose diametral\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;circle is encroached.&nbsp;&nbsp;It usually increases the number of vertices\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and triangles.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>j&nbsp;&nbsp;Jettisons vertices that are not part of the <b><a href="CppFinal.htm">final</a></b> triangulation\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from the output .node file.&nbsp;&nbsp;By <b><a href="CppDefault.htm">default</a></b>, Triangle copies all\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices in the input .node file to the output .node file, in the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same order, so their indices <b><a href="CppDo.htm">do</a></b> not change.&nbsp;&nbsp;The <a href="CppOperatorMinus.htm">-</a>j <b><a href="CppSwitch.htm">switch</a></b> prevents\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duplicated input vertices, or vertices `eaten' by holes, from\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appearing in the output .node file.&nbsp;&nbsp;Thus, <b><a href="CppIf.htm">if</a></b> two input vertices\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;have exactly the same coordinates, only the first appears in the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.&nbsp;&nbsp;If <a href="CppAny.htm">any</a> vertices are jettisoned, the vertex numbering in\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the output .node file differs from that of the input .node file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>e&nbsp;&nbsp;Outputs (to an .edge file) a list of edges of the triangulation.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>v&nbsp;&nbsp;Outputs the Voronoi diagram associated with the triangulation.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does not attempt to detect degeneracies, so some Voronoi vertices\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;may be duplicated.&nbsp;&nbsp;See the discussion of Voronoi diagrams below.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>n&nbsp;&nbsp;Outputs (to a .neigh file) a list of triangles neighboring each\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangle.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>g&nbsp;&nbsp;Outputs the mesh to an Object File Format (.off) file, suitable <b><a href="CppFor.htm">for</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewing with the Geometry Center's Geomview package.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>B&nbsp;&nbsp;No boundary markers in the output .node, .poly, and .edge output\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files.&nbsp;&nbsp;See the detailed discussion of boundary markers below.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>P&nbsp;&nbsp;No output .poly file.&nbsp;&nbsp;Saves disk space, but you lose the ability\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to maintain constraining segments on later refinements of the mesh.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>N&nbsp;&nbsp;No output .node file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>E&nbsp;&nbsp;No output .ele file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>I&nbsp;&nbsp;No iteration numbers.&nbsp;&nbsp;Suppresses the output of .node and .poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files, so your input files won't be overwritten.&nbsp;&nbsp;(If your input is\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a .poly file only, a .node file is written.)&nbsp;&nbsp;Cannot be used with\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the <a href="CppOperatorMinus.htm">-</a>r <b><a href="CppSwitch.htm">switch</a></b>, because that would overwrite your input .ele file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shouldn't be used with the <a href="CppOperatorMinus.htm">-</a>q, <a href="CppOperatorMinus.htm">-</a>a, <a href="CppOperatorMinus.htm">-</a>u, or <a href="CppOperatorMinus.htm">-</a>s <b><a href="CppSwitch.htm">switch</a></b> <b><a href="CppIf.htm">if</a></b> you are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppUsing.htm">using</a></b> a .node file <b><a href="CppFor.htm">for</a></b> input, because no .node file is written, so\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there is no record of <a href="CppAny.htm">any</a> added Steiner <a href="CppPointer.htm">point</a>s.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>O&nbsp;&nbsp;No holes.&nbsp;&nbsp;Ignores the holes in the .poly file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>X&nbsp;&nbsp;No exact arithmetic.&nbsp;&nbsp;Normally, Triangle uses exact floating-<a href="CppPointer.htm">point</a>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arithmetic <b><a href="CppFor.htm">for</a></b> certain tests <b><a href="CppIf.htm">if</a></b> it thinks the inexact tests are not\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accurate enough.&nbsp;&nbsp;Exact arithmetic ensures the robustness of the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangulation <a href="CppAlgorithm.htm">algorithm</a>s, despite floating-<a href="CppPointer.htm">point</a> roundoff error.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disabling exact arithmetic with the <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b> causes a small\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;improvement in speed and creates the possibility that Triangle will\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail to produce a valid mesh.&nbsp;&nbsp;Not recommended.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>z&nbsp;&nbsp;Numbers all items starting from zero (rather than one).&nbsp;&nbsp;Note that\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> is normally overridden by the value used to number the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first vertex of the input .node or .poly file.&nbsp;&nbsp;However, <b><a href="CppThis.htm">this</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> is useful when calling Triangle from another program.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>o2 Generates second-order subparametric elements with six nodes each.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>Y&nbsp;&nbsp;No <b><a href="CppNew.htm">new</a></b> vertices on the boundary.&nbsp;&nbsp;This <b><a href="CppSwitch.htm">switch</a></b> is useful when the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh boundary must be preserved so that it conforms to some\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjacent mesh.&nbsp;&nbsp;Be forewarned that you will probably sacrifice much\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of the quality of the mesh; Triangle will <b><a href="CppTry.htm">try</a></b>, but the resulting\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh may contain poorly <a href="CppShape.htm">shape</a>d triangles.&nbsp;&nbsp;Works well <b><a href="CppIf.htm">if</a></b> all the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary vertices are closely spaced.&nbsp;&nbsp;Specify <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> twice\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(`-YY') to prevent all segment splitting, including internal\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundaries.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>S&nbsp;&nbsp;Specifies the maximum number of Steiner <a href="CppPointer.htm">point</a>s (vertices that are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not in the input, but are added to meet the constraints on minimum\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle and maximum area).&nbsp;&nbsp;The <b><a href="CppDefault.htm">default</a></b> is to allow an unlimited\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number.&nbsp;&nbsp;If you specify <b><a href="CppThis.htm">this</a></b> <b><a href="CppSwitch.htm">switch</a></b> with no number after it,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the limit is set to zero.&nbsp;&nbsp;Triangle always adds vertices at segment\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersections, even <b><a href="CppIf.htm">if</a></b> it needs to use more vertices than the limit\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you set.&nbsp;&nbsp;When Triangle inserts segments by splitting (-s), it\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;always adds enough vertices to ensure that all the segments of the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PLSG are recovered, ignoring the limit <b><a href="CppIf.htm">if</a></b> necessary.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>i&nbsp;&nbsp;Uses an incremental rather than a divide-and-conquer <a href="CppAlgorithm.htm">algorithm</a> to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppConstructor.htm">construct</a> a Delaunay triangulation.&nbsp;&nbsp;Try it <b><a href="CppIf.htm">if</a></b> the divide-and-\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conquer <a href="CppAlgorithm.htm">algorithm</a> fails.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>F&nbsp;&nbsp;Uses Steven Fortune's sweepline <a href="CppAlgorithm.htm">algorithm</a> to <a href="CppConstructor.htm">construct</a> a Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangulation.&nbsp;&nbsp;Warning:&nbsp;&nbsp;does not use exact arithmetic <b><a href="CppFor.htm">for</a></b> all\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculations.&nbsp;&nbsp;An exact result is not guaranteed.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>l&nbsp;&nbsp;Uses only vertical cuts in the divide-and-conquer <a href="CppAlgorithm.htm">algorithm</a>.&nbsp;&nbsp;By\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDefault.htm">default</a></b>, Triangle alternates between vertical and horizontal cuts,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which usually improve the speed except with vertex sets that are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;small or <b><a href="CppShort.htm">short</a></b> and wide.&nbsp;&nbsp;This <b><a href="CppSwitch.htm">switch</a></b> is primarily of theoretical\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interest.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>s&nbsp;&nbsp;Specifies that segments should be forced into the triangulation by\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recursively splitting them at their mid<a href="CppPointer.htm">point</a>s, rather than by\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generating a constrained Delaunay triangulation.&nbsp;&nbsp;Segment splitting\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is <b><a href="CppTrue.htm">true</a></b> to Ruppert's original <a href="CppAlgorithm.htm">algorithm</a>, but can create needlessly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;small triangles.&nbsp;&nbsp;This <b><a href="CppSwitch.htm">switch</a></b> is primarily of theoretical interest.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>C&nbsp;&nbsp;Check the consistency of the <b><a href="CppFinal.htm">final</a></b> mesh.&nbsp;&nbsp;Uses exact arithmetic <b><a href="CppFor.htm">for</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checking, even <b><a href="CppIf.htm">if</a></b> the <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b> is used.&nbsp;&nbsp;Useful <b><a href="CppIf.htm">if</a></b> you suspect\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Triangle is <a href="CppBug.htm">bug</a>gy.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>Q&nbsp;&nbsp;Quiet:&nbsp;&nbsp;Suppresses all explanation of what Triangle is doing,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unless an error occurs.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>V&nbsp;&nbsp;Verbose:&nbsp;&nbsp;Gives detailed information <a href="CppAbout.htm">about</a> what Triangle is doing.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAdd.htm">Add</a> more `V's <b><a href="CppFor.htm">for</a></b> increasing amount of detail.&nbsp;&nbsp;`-V' is most\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useful; itgives information on <a href="CppAlgorithm.htm">algorithm</a>ic progress and much more\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detailed statistics.&nbsp;&nbsp;`-VV' gives vertex-by-vertex details, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prints so much that Triangle runs much more slowly.&nbsp;&nbsp;`-VVVV' gives\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;information only a <a href="CppDebug.htm">debug</a>ger could love.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>h&nbsp;&nbsp;Help:&nbsp;&nbsp;Displays these instructions.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppDefinition.htm">Definitions</a>:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;A Delaunay triangulation of a vertex set is a triangulation whose\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices are the vertex set, that covers the convex hull of the vertex\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;set.&nbsp;&nbsp;A Delaunay triangulation has the property that no vertex lies\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;inside the circumsc<a href="CppRibi.htm">ribi</a>ng circle (circle that passes through all three\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices) of <a href="CppAny.htm">any</a> triangle in the triangulation.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;A Voronoi diagram of a vertex set is a subdivision of the plane into\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;polygonal cells (some of which may be unbounded, meaning infinitely\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;large), where each cell is the set of <a href="CppPointer.htm">point</a>s in the plane that are closer\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;to some input vertex than to <a href="CppAny.htm">any</a> other input vertex.&nbsp;&nbsp;The Voronoi diagram\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;is a geometric dual of the Delaunay triangulation.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;A Planar Straight Line Graph (PSLG) is a set of vertices and segments.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Segments are simply edges, whose endpoints are all vertices in the PSLG.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Segments may intersect each other only at their endpoints.&nbsp;&nbsp;The file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;format <b><a href="CppFor.htm">for</a></b> PSLGs (.poly files) is described below.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;A constrained Delaunay triangulation (CDT) of a PSLG is similar to a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Delaunay triangulation, but each PSLG segment is present as a single edge\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;of the CDT.&nbsp;&nbsp;(A constrained Delaunay triangulation is not truly a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Delaunay triangulation, because some of its triangles might not be\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Delaunay.)&nbsp;&nbsp;By <a href="CppDefinition.htm">definition</a>, a CDT does not have <a href="CppAny.htm">any</a> vertices other than\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;those specified in the input PSLG.&nbsp;&nbsp;Depending on context, a CDT might\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;cover the convex hull of the PSLG, or it might cover only a segment-\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;bounded region (e.g. a polygon).\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;A conforming Delaunay triangulation of a PSLG is a triangulation in which\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;each triangle is truly Delaunay, and each PSLG segment is represented by\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;a linear contiguous sequence of edges of the triangulation.&nbsp;&nbsp;New vertices\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(not part of the PSLG) may appear, and each input segment may have been\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;subdivided into shorter edges (subsegments) by these additional vertices.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The <b><a href="CppNew.htm">new</a></b> vertices are frequently necessary to maintain the Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;property <b><a href="CppWhile.htm">while</a></b> ensuring that every segment is represented.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;A conforming constrained Delaunay triangulation (CCDT) of a PSLG is a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;triangulation of a PSLG whose triangles are constrained Delaunay.&nbsp;&nbsp;New\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices may appear, and input segments may be subdivided into\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;subsegments, but not to guarantee that segments are respected; rather, to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;improve the quality of the triangles.&nbsp;&nbsp;The high-quality meshes produced\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;by the <a href="CppOperatorMinus.htm">-</a>q <b><a href="CppSwitch.htm">switch</a></b> are usually CCDTs, but can be made conforming Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;with the <a href="CppOperatorMinus.htm">-</a>D <b><a href="CppSwitch.htm">switch</a></b>.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "File Formats:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;All files may contain comments prefixed by the <a href="CppChar.htm">character</a> '#'.&nbsp;&nbsp;Vertices,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;triangles, edges, holes, and maximum area constraints must be numbered\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;consecutively, starting from either 1 or 0.&nbsp;&nbsp;Whichever you choose, all\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;input files must be consistent; <b><a href="CppIf.htm">if</a></b> the vertices are numbered from 1, so\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;must be all other objects.&nbsp;&nbsp;Triangle automatically detects your choice\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> reading the .node (or .poly) file.&nbsp;&nbsp;(When calling Triangle from\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;another program, use the <a href="CppOperatorMinus.htm">-</a>z <b><a href="CppSwitch.htm">switch</a></b> <b><a href="CppIf.htm">if</a></b> you wish to number objects from\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;zero.)&nbsp;&nbsp;Examples of these file formats are given below.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.node files:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of vertices&gt; &lt;dimension (must be 2)&gt; &lt;# of attributes&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;# of boundary markers (0 or 1)&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Remaining lines:&nbsp;&nbsp;&lt;vertex #&gt; &lt;x&gt; &lt;y&gt; [attributes] [boundary marker]\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The attributes, which are typically floating-<a href="CppPointer.htm">point</a> values of physical\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;quantities (such as mass or conductivity) associated with the nodes of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;a finite element mesh, are copied unchanged to the output mesh.&nbsp;&nbsp;If <a href="CppOperatorMinus.htm">-</a>q,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>a, <a href="CppOperatorMinus.htm">-</a>u, <a href="CppOperatorMinus.htm">-</a>D, or <a href="CppOperatorMinus.htm">-</a>s is selected, each <b><a href="CppNew.htm">new</a></b> Steiner <a href="CppPointer.htm">point</a> added to the mesh\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;has attributes as<b><a href="CppSigned.htm">signed</a></b> to it by linear interpolation.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If the fourth entry of the first line is `1', the last column of the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;remainder of the file is assumed to contain boundary markers.&nbsp;&nbsp;Boundary\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;markers are used to identify boundary vertices and vertices resting on\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;PSLG segments; a complete description appears in a section below.&nbsp;&nbsp;The\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;.node file produced by Triangle contains boundary markers in the last\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;column unless they are suppressed by the <a href="CppOperatorMinus.htm">-</a>B <b><a href="CppSwitch.htm">switch</a></b>.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.ele files:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of triangles&gt; &lt;nodes per triangle&gt; &lt;# of attributes&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Remaining lines:&nbsp;&nbsp;&lt;triangle #&gt; &lt;node&gt; &lt;node&gt; &lt;node&gt; ... [attributes]\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Nodes are indices into the corresponding .node file.&nbsp;&nbsp;The first three\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;nodes are the corner vertices, and are listed in <a href="CppCounter.htm">counter</a>clockwise order\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;around each triangle.&nbsp;&nbsp;(The remaining nodes, <b><a href="CppIf.htm">if</a></b> <a href="CppAny.htm">any</a>, depend on the type\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;of finite element used.)\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The attributes are just like those of .node files.&nbsp;&nbsp;Because there is no\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;simple mapping from input to output triangles, Triangle attempts to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;interpolate attributes, and may cause a lot of diffusion of attributes\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;among nearby triangles as the triangulation is refined.&nbsp;&nbsp;Attributes <b><a href="CppDo.htm">do</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;not diffuse across segments, so attributes used to identify\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segment-bounded regions remain intact.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;In .ele files produced by Triangle, each triangular element has three\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;nodes (vertices) unless the <a href="CppOperatorMinus.htm">-</a>o2 <b><a href="CppSwitch.htm">switch</a></b> is used, in which <b><a href="CppCase.htm">case</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;subparametric quadratic elements with six nodes each are generated.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The first three nodes are the corners in <a href="CppCounter.htm">counter</a>clockwise order, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;the fourth, fifth, and sixth nodes lie on the mid<a href="CppPointer.htm">point</a>s of the edges\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;opposite the first, second, and third vertices, respectively.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.poly files:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of vertices&gt; &lt;dimension (must be 2)&gt; &lt;# of attributes&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;# of boundary markers (0 or 1)&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;vertex #&gt; &lt;x&gt; &lt;y&gt; [attributes] [boundary marker]\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;One line:&nbsp;&nbsp;&lt;# of segments&gt; &lt;# of boundary markers (0 or 1)&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;segment #&gt; &lt;endpoint&gt; &lt;endpoint&gt; [boundary marker]\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;One line:&nbsp;&nbsp;&lt;# of holes&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;hole #&gt; &lt;x&gt; &lt;y&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Optional line:&nbsp;&nbsp;&lt;# of regional attributes and/or area constraints&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Optional following lines:&nbsp;&nbsp;&lt;region #&gt; &lt;x&gt; &lt;y&gt; &lt;attribute&gt; &lt;max area&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;A .poly file represents a PSLG, as well as some additional information.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The first section lists all the vertices, and is identical to the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;format of .node files.&nbsp;&nbsp;&lt;# of vertices&gt; may be set to zero to indicate\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;that the vertices are listed in a separate .node file; .poly files\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;produced by Triangle always have <b><a href="CppThis.htm">this</a></b> format.&nbsp;&nbsp;A vertex set represented\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b> way has the advantage that it may easily be triangulated with or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;without segments (depending on whether the <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b> is invoked).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The second section lists the segments.&nbsp;&nbsp;Segments are edges whose\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;presence in the triangulation is enforced.&nbsp;&nbsp;(Depending on the choice of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b>es, segment might be subdivided into smaller edges).&nbsp;&nbsp;Each\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segment is specified by listing the indices of its two endpoints.&nbsp;&nbsp;This\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;means that you must include its endpoints in the vertex list.&nbsp;&nbsp;Each\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segment, like each <a href="CppPointer.htm">point</a>, may have a boundary marker.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If <a href="CppOperatorMinus.htm">-</a>q, <a href="CppOperatorMinus.htm">-</a>a, <a href="CppOperatorMinus.htm">-</a>u, and <a href="CppOperatorMinus.htm">-</a>s are not selected, Triangle produces a constrained\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Delaunay triangulation (CDT), in which each segment appears as a single\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;edge in the triangulation.&nbsp;&nbsp;If <a href="CppOperatorMinus.htm">-</a>q, <a href="CppOperatorMinus.htm">-</a>a, <a href="CppOperatorMinus.htm">-</a>u, or <a href="CppOperatorMinus.htm">-</a>s is selected, Triangle\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;produces a conforming constrained Delaunay triangulation (CCDT), in\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;which segments may be subdivided into smaller edges.&nbsp;&nbsp;If <a href="CppOperatorMinus.htm">-</a>D is\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;selected, Triangle produces a conforming Delaunay triangulation, so\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;that every triangle is Delaunay, and not just constrained Delaunay.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The third section lists holes (and concavities, <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>c is selected) in\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;the triangulation.&nbsp;&nbsp;Holes are specified by identifying a <a href="CppPointer.htm">point</a> inside\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;each hole.&nbsp;&nbsp;After the triangulation is formed, Triangle creates holes\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;by eating triangles, spreading out from each hole <a href="CppPointer.htm">point</a> until its\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;progress is blocked by segments in the PSLG.&nbsp;&nbsp;You must be careful to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;enclose each hole in segments, or your whole triangulation might be\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;eaten away.&nbsp;&nbsp;If the two triangles abutting a segment are eaten, the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segment itself is also eaten.&nbsp;&nbsp;Do not place a hole directly on a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segment; <b><a href="CppIf.htm">if</a></b> you <b><a href="CppDo.htm">do</a></b>, Triangle chooses one side of the segment\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;arbitrarily.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The optional fourth section lists regional attributes (to be as<b><a href="CppSigned.htm">signed</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;to all triangles in a region) and regional constraints on the maximum\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;triangle area.&nbsp;&nbsp;Triangle reads <b><a href="CppThis.htm">this</a></b> section only <b><a href="CppIf.htm">if</a></b> the <a href="CppOperatorMinus.htm">-</a>A <b><a href="CppSwitch.htm">switch</a></b> is\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;used or the <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b> is used without a number following it, and the <a href="CppOperatorMinus.htm">-</a>r\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> is not used.&nbsp;&nbsp;Regional attributes and area constraints are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;propagated in the same manner as holes:&nbsp;&nbsp;you specify a <a href="CppPointer.htm">point</a> <b><a href="CppFor.htm">for</a></b> each\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;attribute and/or constraint, and the attribute and/or constraint\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;affects the whole region (bounded by segments) containing the <a href="CppPointer.htm">point</a>.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If two values are written on a line after the x and y coordinate, the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;first such value is assumed to be a regional attribute (but is only\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;applied <b><a href="CppIf.htm">if</a></b> the <a href="CppOperatorMinus.htm">-</a>A <b><a href="CppSwitch.htm">switch</a></b> is selected), and the second value is assumed\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;to be a regional area constraint (but is only applied <b><a href="CppIf.htm">if</a></b> the <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;is selected).&nbsp;&nbsp;You may specify just one value after the coordinates,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;which can serve as both an attribute and an area constraint, depending\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;on the choice of <b><a href="CppSwitch.htm">switch</a></b>es.&nbsp;&nbsp;If you are <b><a href="CppUsing.htm">using</a></b> the <a href="CppOperatorMinus.htm">-</a>A and <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b>es\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;simultaneously and wish to assign an attribute to some region without\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;imposing an area constraint, use a negative maximum area.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;When a triangulation is created from a .poly file, you must either\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;enclose the entire region to be triangulated in PSLG segments, or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;use the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>, which automatically creates extra segments that\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;enclose the convex hull of the PSLG.&nbsp;&nbsp;If you <b><a href="CppDo.htm">do</a></b> not use the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Triangle eats all triangles that are not enclosed by segments; <b><a href="CppIf.htm">if</a></b> you\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;are not careful, your whole triangulation may be eaten away.&nbsp;&nbsp;If you <b><a href="CppDo.htm">do</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;use the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>, you can still produce concavities by the appropriate\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;placement of holes just inside the boundary of the convex hull.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;An ideal PSLG has no intersecting segments, nor <a href="CppAny.htm">any</a> vertices that lie\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;upon segments (except, of course, the endpoints of each segment).&nbsp;&nbsp;You\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;aren't required to <a href="CppMake.htm">make</a> your .poly files ideal, but you should be aware\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;of what can go wrong.&nbsp;&nbsp;Segment intersections are relatively safe<a href="CppOperatorDecrement.htm">--</a>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Triangle calculates the intersection <a href="CppPointer.htm">point</a>s <b><a href="CppFor.htm">for</a></b> you and adds them to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;the triangulation<a href="CppOperatorDecrement.htm">--</a>as <b><a href="CppLong.htm">long</a></b> as your machine's floating-<a href="CppPointer.htm">point</a> precision\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;doesn't become a problem.&nbsp;&nbsp;You are tempting the fates <b><a href="CppIf.htm">if</a></b> you have three\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segments that cross at the same location, and expect Triangle to figure\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;out where the intersection <a href="CppPointer.htm">point</a> is.&nbsp;&nbsp;Thanks to floating-<a href="CppPointer.htm">point</a> roundoff\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;error, Triangle will probably decide that the three segments intersect\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;at three different <a href="CppPointer.htm">point</a>s, and you will find a minuscule triangle in\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;your output<a href="CppOperatorDecrement.htm">--</a>unless Triangle tries to refine the tiny triangle, uses\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;up the last bit of machine precision, and fails to terminate at all.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;You're better off putting the intersection <a href="CppPointer.htm">point</a> in the input files,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;and manually <b><a href="CppBreak.htm">break</a></b>ing up each segment into two.&nbsp;&nbsp;Similarly, <b><a href="CppIf.htm">if</a></b> you\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;place a vertex at the middle of a segment, and hope that Triangle will\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBreak.htm">break</a></b> up the segment at that vertex, you might get lucky.&nbsp;&nbsp;On the other\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;hand, Triangle might decide that the vertex doesn't lie precisely on\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;the segment, and you'll have a needle-sharp triangle in your output<a href="CppOperatorDecrement.htm">--</a>or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;a lot of tiny triangles <b><a href="CppIf.htm">if</a></b> you're generating a quality mesh.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;When Triangle reads a .poly file, it also writes a .poly file, which\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;includes all the subsegments<a href="CppOperatorDecrement.htm">--</a>the edges that are parts of input\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segments.&nbsp;&nbsp;If the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b> is used, the output .poly file also\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;includes all of the edges on the convex hull.&nbsp;&nbsp;Hence, the output .poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;file is useful <b><a href="CppFor.htm">for</a></b> finding edges associated with input segments and <b><a href="CppFor.htm">for</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;setting boundary conditions in finite element simulations.&nbsp;&nbsp;Moreover,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;you will need the output .poly file <b><a href="CppIf.htm">if</a></b> you plan to refine the output\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;mesh, and don't want segments to be missing in later triangulations.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.area files:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of triangles&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;triangle #&gt; &lt;maximum area&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;An .area file associates with each triangle a maximum area that is used\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> mesh refinement.&nbsp;&nbsp;As with other file formats, every triangle must\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;be represented, and the triangles must be numbered consecutively.&nbsp;&nbsp;A\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;triangle may be left unconstrained by assigning it a negative maximum\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;area.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.edge files:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of edges&gt; &lt;# of boundary markers (0 or 1)&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;edge #&gt; &lt;endpoint&gt; &lt;endpoint&gt; [boundary marker]\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;End<a href="CppPointer.htm">point</a>s are indices into the corresponding .node file.&nbsp;&nbsp;Triangle can\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;produce .edge files (use the <a href="CppOperatorMinus.htm">-</a>e <b><a href="CppSwitch.htm">switch</a></b>), but cannot read them.&nbsp;&nbsp;The\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;optional column of boundary markers is suppressed by the <a href="CppOperatorMinus.htm">-</a>B <b><a href="CppSwitch.htm">switch</a></b>.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;In Voronoi diagrams, one also finds a special kind of edge that is an\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;infinite ray with only one endpoint.&nbsp;&nbsp;For these edges, a different\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;format is used:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;edge #&gt; &lt;endpoint&gt; <a href="CppOperatorMinus.htm">-</a>1 &lt;direction x&gt; &lt;direction y&gt;\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;The `direction' is a floating-<a href="CppPointer.htm">point</a> vector that indicates the direction\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;of the infinite ray.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.neigh files:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First line:&nbsp;&nbsp;&lt;# of triangles&gt; &lt;# of neighbors per triangle (always 3)&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Following lines:&nbsp;&nbsp;&lt;triangle #&gt; &lt;neighbor&gt; &lt;neighbor&gt; &lt;neighbor&gt;\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Neighbors are indices into the corresponding .ele file.&nbsp;&nbsp;An index of <a href="CppOperatorMinus.htm">-</a>1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;indicates no neighbor (because the triangle is on an exterior\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;boundary).&nbsp;&nbsp;The first neighbor of triangle i is opposite the first\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;corner of triangle i, and so on.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Triangle can produce .neigh files (use the <a href="CppOperatorMinus.htm">-</a>n <b><a href="CppSwitch.htm">switch</a></b>), but cannot read\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;them.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Boundary Markers:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Boundary markers are tags used mainly to identify which output vertices\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and edges are associated with which PSLG segment, and to identify which\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices and edges occur on a boundary of the triangulation.&nbsp;&nbsp;A common\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;use is to determine where boundary conditions should be applied to a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;finite element mesh.&nbsp;&nbsp;You can prevent boundary markers from being written\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;into files produced by Triangle by <b><a href="CppUsing.htm">using</a></b> the <a href="CppOperatorMinus.htm">-</a>B <b><a href="CppSwitch.htm">switch</a></b>.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The boundary marker associated with each segment in an output .poly file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and each edge in an output .edge file is chosen as follows:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> If an output edge is part or all of a PSLG segment with a nonzero\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary marker, then the edge is as<b><a href="CppSigned.htm">signed</a></b> the same marker.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> Otherwise, <b><a href="CppIf.htm">if</a></b> the edge lies on a boundary of the triangulation\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even the boundary of a hole), then the edge is as<b><a href="CppSigned.htm">signed</a></b> the marker\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one (1).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> Otherwise, the edge is as<b><a href="CppSigned.htm">signed</a></b> the marker zero (0).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The boundary marker associated with each vertex in an output .node file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;is chosen as follows:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> If a vertex is as<b><a href="CppSigned.htm">signed</a></b> a nonzero boundary marker in the input file,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then it is as<b><a href="CppSigned.htm">signed</a></b> the same marker in the output .node file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> Otherwise, <b><a href="CppIf.htm">if</a></b> the vertex lies on a PSLG segment (even <b><a href="CppIf.htm">if</a></b> it is an\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endpoint of the segment) with a nonzero boundary marker, then the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex is as<b><a href="CppSigned.htm">signed</a></b> the same marker.&nbsp;&nbsp;If the vertex lies on several\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;such segments, one of the markers is chosen arbitrarily.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> Otherwise, <b><a href="CppIf.htm">if</a></b> the vertex occurs on a boundary of the triangulation,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then the vertex is as<b><a href="CppSigned.htm">signed</a></b> the marker one (1).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> Otherwise, the vertex is as<b><a href="CppSigned.htm">signed</a></b> the marker zero (0).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you want Triangle to determine <b><a href="CppFor.htm">for</a></b> you which vertices and edges are on\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;the boundary, assign them the boundary marker zero (or use no markers at\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;all) in your input files.&nbsp;&nbsp;In the output files, all boundary vertices,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;edges, and segments will be as<b><a href="CppSigned.htm">signed</a></b> the value one.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangulation Iteration Numbers:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Because Triangle can read and refine its own triangulations, input\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and output files have iteration numbers.&nbsp;&nbsp;For <a href="CppInstance.htm">instance</a>, Triangle might\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;read the files mesh.3.node, mesh.3.ele, and mesh.3.poly, refine the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;triangulation, and output the files mesh.4.node, mesh.4.ele, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;mesh.4.poly.&nbsp;&nbsp;Files with no iteration number are treated as <b><a href="CppIf.htm">if</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;their iteration number is zero; hence, Triangle might read the file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppPointer.htm">point</a>s.node, triangulate it, and produce the files <a href="CppPointer.htm">point</a>s.1.node and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppPointer.htm">point</a>s.1.ele.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Iteration numbers allow you to create a sequence of successively finer\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;meshes suitable for multigrid <a href="CppMemberFunction.htm">member function</a>s.&nbsp;&nbsp;They also allow you to produce a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;sequence of meshes <b><a href="CppUsing.htm">using</a></b> error estimate-driven mesh refinement.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you're not <b><a href="CppUsing.htm">using</a></b> refinement or quality meshing, and you don't like\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;iteration numbers, use the <a href="CppOperatorMinus.htm">-</a>I <b><a href="CppSwitch.htm">switch</a></b> to disable them.&nbsp;&nbsp;This <b><a href="CppSwitch.htm">switch</a></b> also\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;disables output of .node and .poly files to prevent your input files from\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;being overwritten.&nbsp;&nbsp;(If the input is a .poly file that contains its own\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppPointer.htm">point</a>s, a .node file is written.&nbsp;&nbsp;This can be quite convenient <b><a href="CppFor.htm">for</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;computing CDTs or quality meshes.)\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Examples of How to Use Triangle:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`triangle dots' reads vertices from dots.node, and writes their Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;triangulation to dots.1.node and dots.1.ele.&nbsp;&nbsp;(dots.1.node is identical\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;to dots.node.)&nbsp;&nbsp;`triangle <a href="CppOperatorMinus.htm">-</a>I dots' writes the triangulation to dots.ele\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;instead.&nbsp;&nbsp;(No additional .node file is needed, so none is written.)\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`triangle <a href="CppOperatorMinus.htm">-</a>pe object.1' reads a PSLG from object.1.poly (and possibly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;object.1.node, <b><a href="CppIf.htm">if</a></b> the vertices are omitted from object.1.poly) and writes\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;its constrained Delaunay triangulation to object.2.node and object.2.ele.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The segments are copied to object.2.poly, and all edges are written to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;object.2.edge.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`triangle <a href="CppOperatorMinus.htm">-</a>pq31.5a.1 object' reads a PSLG from object.poly (and possibly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;object.node), generates a mesh whose angles are all between 31.5 and 117\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;degrees and whose triangles all have areas of 0.1 or less, and writes the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;mesh to object.1.node and object.1.ele.&nbsp;&nbsp;Each segment may be broken up\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;into multiple subsegments; these are written to object.1.poly.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Here is a sample file `box.poly' desc<a href="CppRibi.htm">ribi</a>ng a square with a square hole:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;# A box with eight vertices in 2D, no attributes, one boundary marker.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;8 2 0 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; # Outer box has these vertices:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 0 0&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 0 3&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 3 0&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 3 3&nbsp;&nbsp; 33&nbsp;&nbsp;&nbsp;&nbsp; # A special marker <b><a href="CppFor.htm">for</a></b> <b><a href="CppThis.htm">this</a></b> vertex.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; # Inner square has these vertices:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 1 1&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 1 2&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp; 2 1&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 2 2&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;# Five segments with boundary markers.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;5 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1 2&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Left side of outer box.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; # Square hole has these segments:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5 7&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 7 8&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 8 6&nbsp;&nbsp; 10\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 6 5&nbsp;&nbsp; 0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;# One hole in the middle of the inner square.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1.5 1.5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Note that some segments are missing from the outer square, so you must\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;use the `-c' <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;After `triangle <a href="CppOperatorMinus.htm">-</a>pqc box.poly', here is the output\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;file `box.1.node', with twelve vertices.&nbsp;&nbsp;The last four vertices were\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;added to meet the angle constraint.&nbsp;&nbsp;Vertices 1, 2, and 9 have markers\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;from segment 1.&nbsp;&nbsp;Vertices 6 and 8 have markers from segment 4.&nbsp;&nbsp;All the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;other vertices but 4 have been marked to indicate that they lie on a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;boundary.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;2&nbsp;&nbsp;0&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 33\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 10\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 10\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; 1.5&nbsp;&nbsp;&nbsp;&nbsp;5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;1.5&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp; 1.5&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;1.5&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;# Generated by triangle <a href="CppOperatorMinus.htm">-</a>pqc box.poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Here is the output file `box.1.ele', with twelve triangles.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;3&nbsp;&nbsp;0\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 6&nbsp;&nbsp; 9\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp; 3&nbsp;&nbsp; 7\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 8&nbsp;&nbsp;12\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 1&nbsp;&nbsp; 5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 2&nbsp;&nbsp; 9\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp; 3&nbsp;&nbsp;11\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp; 4&nbsp;&nbsp; 8\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp; 5&nbsp;&nbsp;10\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp; 2&nbsp;&nbsp; 6\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 7&nbsp;&nbsp;11\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 1&nbsp;&nbsp;10\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 4&nbsp;&nbsp;12\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;# Generated by triangle <a href="CppOperatorMinus.htm">-</a>pqc box.poly\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Here is the output file `box.1.poly'.&nbsp;&nbsp;Note that segments have been added\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;to represent the convex hull, and some segments have been subdivided by\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;newly added vertices.&nbsp;&nbsp;Note also that &lt;# of vertices&gt; is set to zero to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;indicate that the vertices should be read from the .node file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;2&nbsp;&nbsp;0&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp; 5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;10\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1.5 1.5\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;# Generated by triangle <a href="CppOperatorMinus.htm">-</a>pqc box.poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Refinement and Area Constraints:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The <a href="CppOperatorMinus.htm">-</a>r <b><a href="CppSwitch.htm">switch</a></b> causes a mesh (.node and .ele files) to be read and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;refined.&nbsp;&nbsp;If the <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b> is also used, a .poly file is read and used to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;specify edges that are constrained and cannot be eliminated (although\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;they can be subdivided into smaller edges) by the refinement process.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;When you refine a mesh, you generally want to impose tighter constraints.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;One way to accomplish <b><a href="CppThis.htm">this</a></b> is to use <a href="CppOperatorMinus.htm">-</a>q with a larger angle, or <a href="CppOperatorMinus.htm">-</a>a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;followed by a smaller area than you used to generate the mesh you are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;refining.&nbsp;&nbsp;Another way to <b><a href="CppDo.htm">do</a></b> <b><a href="CppThis.htm">this</a></b> is to create an .area file, which\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;specifies a maximum area <b><a href="CppFor.htm">for</a></b> each triangle, and use the <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(without a number following).&nbsp;&nbsp;Each triangle's area constraint is applied\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;to that triangle.&nbsp;&nbsp;Area constraints tend to diffuse as the mesh is\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;refined, so <b><a href="CppIf.htm">if</a></b> there are large variations in area constraint between\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;adjacent triangles, you may not get the results you want.&nbsp;&nbsp;In that <b><a href="CppCase.htm">case</a></b>,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;consider instead <b><a href="CppUsing.htm">using</a></b> the <a href="CppOperatorMinus.htm">-</a>u <b><a href="CppSwitch.htm">switch</a></b> and writing a C procedure that\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;determines which triangles are too large.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you are refining a mesh composed of linear (three-node) elements, the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;output mesh contains all the nodes present in the input mesh, in the same\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;order, with <b><a href="CppNew.htm">new</a></b> nodes added at the end of the .node file.&nbsp;&nbsp;However, the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;refinement is not hierarchical: there is no guarantee that each output\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;element is contained in a single input element.&nbsp;&nbsp;Often, an output element\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;can overlap two or three input elements, and some input edges are not\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;present in the output mesh.&nbsp;&nbsp;Hence, a sequence of refined meshes forms a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;hierarchy of nodes, but not a hierarchy of elements.&nbsp;&nbsp;If you refine a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;mesh of higher-order elements, the hierarchical property applies only to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;the nodes at the corners of an element; the mid<a href="CppPointer.htm">point</a> nodes on each edge\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;are discarded before the mesh is refined.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum area constraints in .poly files operate differently from those in\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.area files.&nbsp;&nbsp;A maximum area in a .poly file applies to the whole\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(segment-bounded) region in which a <a href="CppPointer.htm">point</a> falls, whereas a maximum area\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;in an .area file applies to only one triangle.&nbsp;&nbsp;Area constraints in .poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;files are used only when a mesh is first generated, whereas area\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;constraints in .area files are used only to refine an existing mesh, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;are typically based on a posteriori error estimates resulting from a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;finite element simulation on that mesh.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`triangle <a href="CppOperatorMinus.htm">-</a>rq25 object.1' reads object.1.node and object.1.ele, then\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;refines the triangulation to enforce a 25 degree minimum angle, and then\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;writes the refined triangulation to object.2.node and object.2.ele.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`triangle <a href="CppOperatorMinus.htm">-</a>rpaa6.2 z.3' reads z.3.node, z.3.ele, z.3.poly, and z.3.area.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;After re<a href="CppConstructor.htm">construct</a>ing the mesh and its subsegments, Triangle refines the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;mesh so that no triangle has area greater than 6.2, and furthermore the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;triangles satisfy the maximum area constraints in z.3.area.&nbsp;&nbsp;No angle\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;bound is imposed at all.&nbsp;&nbsp;The output is written to z.4.node, z.4.ele, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;z.4.poly.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The sequence `triangle <a href="CppOperatorMinus.htm">-</a>qa1 x', `triangle <a href="CppOperatorMinus.htm">-</a>rqa.3 x.1', `triangle <a href="CppOperatorMinus.htm">-</a>rqa.1\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;x.2' creates a sequence of successively finer meshes x.1, x.2, and x.3,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;suitable for multigrid.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Convex Hulls and Mesh Boundaries:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If the input is a vertex set (not a PSLG), Triangle produces its convex\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;hull as a by-product in the output .poly file <b><a href="CppIf.htm">if</a></b> you use the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;There are faster <a href="CppAlgorithm.htm">algorithm</a>s <b><a href="CppFor.htm">for</a></b> finding a two-dimensional convex hull\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;than triangulation, of course, but <b><a href="CppThis.htm">this</a></b> one comes <b><a href="CppFor.htm">for</a></b> free.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If the input is an unconstrained mesh (you are <b><a href="CppUsing.htm">using</a></b> the <a href="CppOperatorMinus.htm">-</a>r <b><a href="CppSwitch.htm">switch</a></b> but\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;not the <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b>), Triangle produces a list of its boundary edges\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(including hole boundaries) as a by-product when you use the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you also use the <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b>, the output .poly file contains all the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;segments from the input .poly file as well.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Voronoi Diagrams:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The <a href="CppOperatorMinus.htm">-</a>v <b><a href="CppSwitch.htm">switch</a></b> produces a Voronoi diagram, in files suffixed .v.node and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.v.edge.&nbsp;&nbsp;For example, `triangle <a href="CppOperatorMinus.htm">-</a>v <a href="CppPointer.htm">point</a>s' reads <a href="CppPointer.htm">point</a>s.node, produces\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;its Delaunay triangulation in <a href="CppPointer.htm">point</a>s.1.node and <a href="CppPointer.htm">point</a>s.1.ele, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;produces its Voronoi diagram in <a href="CppPointer.htm">point</a>s.1.v.node and <a href="CppPointer.htm">point</a>s.1.v.edge.&nbsp;&nbsp;The\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;.v.node file contains a list of all Voronoi vertices, and the .v.edge\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;file contains a list of all Voronoi edges, some of which may be infinite\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;rays.&nbsp;&nbsp;(The choice of filenames <a href="CppMake.htm">make</a>s it easy to run the set of Voronoi\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices through Triangle, <b><a href="CppIf.htm">if</a></b> so desired.)\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;This implementation does not use exact arithmetic to compute the Voronoi\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices, and does not check whether neighboring vertices are identical.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Be forewarned that <b><a href="CppIf.htm">if</a></b> the Delaunay triangulation is degenerate or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;near-degenerate, the Voronoi diagram may have duplicate vertices or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;crossing edges.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The result is a valid Voronoi diagram only <b><a href="CppIf.htm">if</a></b> Triangle's output is a <b><a href="CppTrue.htm">true</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Delaunay triangulation.&nbsp;&nbsp;The Voronoi output is usually meaningless (and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;may contain crossing edges and other pathology) <b><a href="CppIf.htm">if</a></b> the output is a CDT or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;CCDT, or <b><a href="CppIf.htm">if</a></b> it has holes or concavities.&nbsp;&nbsp;If the triangulated domain is\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;convex and has no holes, you can use <a href="CppOperatorMinus.htm">-</a>D <b><a href="CppSwitch.htm">switch</a></b> to force Triangle to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppConstructor.htm">construct</a> a conforming Delaunay triangulation instead of a CCDT, so the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Voronoi diagram will be valid.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Mesh Topology:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;You may wish to know which triangles are adjacent to a certain Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;edge in an .edge file, which Voronoi cells are adjacent to a certain\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Voronoi edge in a .v.edge file, or which Voronoi cells are adjacent to\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;each other.&nbsp;&nbsp;All of <b><a href="CppThis.htm">this</a></b> information can be found by cross-referencing\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;output files with the recollection that the Delaunay triangulation and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;the Voronoi diagram are planar duals.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Specifically, edge i of an .edge file is the dual of Voronoi edge i of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;the corresponding .v.edge file, and is rotated 90 degrees <a href="CppCounter.htm">counter</a>clock-\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;wise from the Voronoi edge.&nbsp;&nbsp;Triangle j of an .ele file is the dual of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertex j of the corresponding .v.node file.&nbsp;&nbsp;Voronoi cell k is the dual\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;of vertex k of the corresponding .node file.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Hence, to find the triangles adjacent to a Delaunay edge, look at the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices of the corresponding Voronoi edge.&nbsp;&nbsp;If the endpoints of a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Voronoi edge are Voronoi vertices 2 and 6 respectively, then triangles 2\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and 6 adjoin the left and right sides of the corresponding Delaunay edge,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;respectively.&nbsp;&nbsp;To find the Voronoi cells adjacent to a Voronoi edge, look\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;at the endpoints of the corresponding Delaunay edge.&nbsp;&nbsp;If the endpoints of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;a Delaunay edge are input vertices 7 and 12, then Voronoi cells 7 and 12\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;adjoin the right and left sides of the corresponding Voronoi edge,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;respectively.&nbsp;&nbsp;To find which Voronoi cells are adjacent to each other,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;just read the list of Delaunay edges.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangle does not write a list of the edges adjoining each Voronoi cell,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;but you can re<a href="CppConstructor.htm">construct</a>ed it straightforwardly.&nbsp;&nbsp;For <a href="CppInstance.htm">instance</a>, to find\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;all the edges of Voronoi cell 1, search the output .edge file <b><a href="CppFor.htm">for</a></b> every\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;edge that has input vertex 1 as an endpoint.&nbsp;&nbsp;The corresponding dual\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;edges in the output .v.edge file form the boundary of Voronoi cell 1.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;For each Voronoi vertex, the .neigh file gives a list of the three\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Voronoi vertices attached to it.&nbsp;&nbsp;You might find <b><a href="CppThis.htm">this</a></b> more convenient\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;than the .v.edge file.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Quadratic Elements:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangle generates meshes with subparametric quadratic elements <b><a href="CppIf.htm">if</a></b> the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>o2 <b><a href="CppSwitch.htm">switch</a></b> is specified.&nbsp;&nbsp;Quadratic elements have six nodes per element,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;rather than three.&nbsp;&nbsp;`Subparametric' means that the edges of the triangles\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;are always straight, so that subparametric quadratic elements are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;geometrically identical to linear elements, even though they can be used\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;with quadratic interpolating <a href="CppFunction.htm">function</a>s.&nbsp;&nbsp;The three extra nodes of an\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;element fall at the mid<a href="CppPointer.htm">point</a>s of the three edges, with the fourth, fifth,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and sixth nodes appearing opposite the first, second, and third corners\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;respectively.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Domains with Small Angles:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If two input segments adjoin each other at a small angle, clearly the <a href="CppOperatorMinus.htm">-</a>q\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> cannot remove the small angle.&nbsp;&nbsp;Moreover, Triangle may have no\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;choice but to generate additional triangles whose smallest angles are\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;smaller than the specified bound.&nbsp;&nbsp;However, these triangles only appear\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;between input segments separated by small angles.&nbsp;&nbsp;Moreover, <b><a href="CppIf.htm">if</a></b> you\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;request a minimum angle of theta degrees, Triangle will generally produce\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;no angle larger than 180 <a href="CppOperatorMinus.htm">-</a> 2 theta, even <b><a href="CppIf.htm">if</a></b> it is forced to compromise on\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;the minimum angle.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Statistics:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;After generating a mesh, Triangle prints a count of entities in the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;output mesh, including the number of vertices, triangles, edges, exterior\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;boundary edges (i.e. subsegments on the boundary of the triangulation,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;including hole boundaries), interior boundary edges (i.e. subsegments of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;input segments not on the boundary), and total subsegments.&nbsp;&nbsp;If you've\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;forgotten the statistics <b><a href="CppFor.htm">for</a></b> an existing mesh, run Triangle on that mesh\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;with the <a href="CppOperatorMinus.htm">-</a>rNEP <b><a href="CppSwitch.htm">switch</a></b>es to read the mesh and print the statistics without\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;writing <a href="CppAny.htm">any</a> files.&nbsp;&nbsp;Use <a href="CppOperatorMinus.htm">-</a>rpNEP <b><a href="CppIf.htm">if</a></b> you've got a .poly file <b><a href="CppFor.htm">for</a></b> the mesh.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The <a href="CppOperatorMinus.htm">-</a>V <b><a href="CppSwitch.htm">switch</a></b> produces extended statistics, including a rough estimate\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;of <a href="CppMemory.htm">memory</a> use, the number of calls to geometric <a href="CppPredicate.htm">predicate</a>s, and\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;histograms of the angles and the aspect ratios of the triangles in the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;mesh.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Exact Arithmetic:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangle uses adaptive exact arithmetic to perform what computational\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;geometers call the `orientation' and `incircle' tests.&nbsp;&nbsp;If the floating-\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppPointer.htm">point</a> arithmetic of your machine conforms to the IEEE 754 standard (as\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;most workstations <b><a href="CppDo.htm">do</a></b>), and does not use extended precision internal\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;floating-<a href="CppPointer.htm">point</a> <b><a href="CppRegister.htm">register</a></b>s, then your output is guaranteed to be an\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;absolutely <b><a href="CppTrue.htm">true</a></b> Delaunay or constrained Delaunay triangulation, roundoff\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;error notwithstanding.&nbsp;&nbsp;The word `adaptive' implies that these arithmetic\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;routines compute the result only to the precision necessary to guarantee\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;correctness, so they are usually nearly as fast as their approximate\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppCounter.htm">counter</a>parts.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;May CPUs, including Intel x86 processors, have extended precision\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;floating-<a href="CppPointer.htm">point</a> <b><a href="CppRegister.htm">register</a></b>s.&nbsp;&nbsp;These must be reconfigured so their precision\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;is reduced to <a href="CppMemory.htm">memory</a> precision.&nbsp;&nbsp;Triangle does <b><a href="CppThis.htm">this</a></b> <b><a href="CppIf.htm">if</a></b> it is <a href="CppCompile.htm">compile</a>d\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;correctly.&nbsp;&nbsp;See the <a href="CppMakefile.htm">makefile</a> <b><a href="CppFor.htm">for</a></b> details.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The exact tests can be disabled with the <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;On most inputs, <b><a href="CppThis.htm">this</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<b><a href="CppSwitch.htm">switch</a></b> reduces the computation <a href="CppTime.htm">time</a> by <a href="CppAbout.htm">about</a> eight percent<a href="CppOperatorDecrement.htm">--</a>it's not\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;worth the risk.&nbsp;&nbsp;There are rare difficult inputs (having many collinear\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and cocircular vertices), however, <b><a href="CppFor.htm">for</a></b> which the difference in speed\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;could be a factor of two.&nbsp;&nbsp;Be forewarned that these are precisely the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;inputs most likely to cause errors <b><a href="CppIf.htm">if</a></b> you use the <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;Hence, the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b> is not recommended.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Unfortunately, the exact tests don't solve every numerical problem.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Exact arithmetic is not used to compute the positions of <b><a href="CppNew.htm">new</a></b> vertices,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;because the bit complexity of vertex coordinates would grow without\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;bound.&nbsp;&nbsp;Hence, segment intersections aren't computed exactly; in very\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;unusual <b><a href="CppCase.htm">case</a></b>s, roundoff error in computing an intersection <a href="CppPointer.htm">point</a> might\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;actually lead to an inverted triangle and an invalid triangulation.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(This is one reason to specify your own intersection <a href="CppPointer.htm">point</a>s in your .poly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;files.)&nbsp;&nbsp;Similarly, exact arithmetic is not used to compute the vertices\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;of the Voronoi diagram.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Another pair of problems not solved by the exact arithmetic routines is\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;underflow and overflow.&nbsp;&nbsp;If Triangle is <a href="CppCompile.htm">compile</a>d <b><a href="CppFor.htm">for</a></b> <b><a href="CppDouble.htm">double</a></b> precision\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;arithmetic, I believe that Triangle's geometric <a href="CppPredicate.htm">predicate</a>s work correctly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> the exponent of every input coordinate falls in the range [-148, 201].\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Underflow can silently prevent the orientation and incircle tests from\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;being performed exactly, <b><a href="CppWhile.htm">while</a></b> overflow typically causes a floating\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppException.htm">exception</a>.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Calling Triangle from Another Program:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Read the file triangle.h <b><a href="CppFor.htm">for</a></b> details.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Troubleshooting:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Please read <b><a href="CppThis.htm">this</a></b> section before mailing me <a href="CppBug.htm">bug</a>s.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`My output mesh has no triangles!'\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If you're <b><a href="CppUsing.htm">using</a></b> a PSLG, you've probably failed to specify a proper set\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;of bounding segments, or forgotten to use the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;Or you may\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;have placed a hole badly, thereby eating all your triangles.&nbsp;&nbsp;To test\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;these possibilities, <b><a href="CppTry.htm">try</a></b> again with the <a href="CppOperatorMinus.htm">-</a>c and <a href="CppOperatorMinus.htm">-</a>O <b><a href="CppSwitch.htm">switch</a></b>es.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Alternatively, all your input vertices may be collinear, in which <b><a href="CppCase.htm">case</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;you can hardly expect to triangulate them.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`Triangle doesn't terminate, or just crashes.'\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Bad things can happen when triangles get so small that the distance\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;between their vertices isn't much larger than the precision of your\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;machine's arithmetic.&nbsp;&nbsp;If you've <a href="CppCompile.htm">compile</a>d Triangle <b><a href="CppFor.htm">for</a></b> single-precision\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;arithmetic, you might <b><a href="CppDo.htm">do</a></b> better by recompiling it <b><a href="CppFor.htm">for</a></b> <b><a href="CppDouble.htm">double</a></b>-precision.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Then again, you might just have to settle for more lenient constraints\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;on the minimum angle and the maximum area than you had planned.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;You can minimize precision problems by ensuring that the origin lies\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;inside your vertex set, or even inside the densest part of your\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;mesh.&nbsp;&nbsp;If you're triangulating an object whose x-coordinates all fall\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;between 6247133 and 6247134, you're not leaving much floating-<a href="CppPointer.htm">point</a>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;precision <b><a href="CppFor.htm">for</a></b> Triangle to work with.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Precision problems can occur covertly <b><a href="CppIf.htm">if</a></b> the input PSLG contains two\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;segments that meet (or intersect) at an extremely small angle, or <b><a href="CppIf.htm">if</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;such an angle is introduced by the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;If you don't realize\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;that a tiny angle is being formed, you might never discover why\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Triangle is crashing.&nbsp;&nbsp;To check <b><a href="CppFor.htm">for</a></b> <b><a href="CppThis.htm">this</a></b> possibility, use the <a href="CppOperatorMinus.htm">-</a>S <b><a href="CppSwitch.htm">switch</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;(with an appropriate limit on the number of Steiner <a href="CppPointer.htm">point</a>s, found by\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;trial-and-error) to stop Triangle early, and view the output .poly file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;with Show Me (described below).&nbsp;&nbsp;Look carefully <b><a href="CppFor.htm">for</a></b> regions where dense\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;clusters of vertices are forming and <b><a href="CppFor.htm">for</a></b> small angles between segments.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Zoom in closely, as such segments might look like a single segment from\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;a distance.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If some of the input values are too large, Triangle may suffer a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;floating <a href="CppException.htm">exception</a> due to overflow when attempting to perform an\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;orientation or incircle test.&nbsp;&nbsp;(Read the section on exact arithmetic\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;above.)&nbsp;&nbsp;Again, I recommend compiling Triangle <b><a href="CppFor.htm">for</a></b> <b><a href="CppDouble.htm">double</a></b> (rather\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;than single) precision arithmetic.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Unexpected problems can arise <b><a href="CppIf.htm">if</a></b> you use quality meshing (-q, <a href="CppOperatorMinus.htm">-</a>a, or\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>u) with an input that is not segment-bounded<a href="CppOperatorDecrement.htm">--</a>that is, <b><a href="CppIf.htm">if</a></b> your input\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;is a vertex set, or you're <b><a href="CppUsing.htm">using</a></b> the <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;If the convex hull of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;your input vertices has collinear vertices on its boundary, an input\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;vertex that you think lies on the convex hull might actually lie just\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;inside the convex hull.&nbsp;&nbsp;If so, the vertex and the nearby convex hull\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;edge form an extremely thin triangle.&nbsp;&nbsp;When Triangle tries to refine\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;the mesh to enforce angle and area constraints, Triangle might generate\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;extremely tiny triangles, or it might fail because of insufficient\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;floating-<a href="CppPointer.htm">point</a> precision.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`The numbering of the output vertices doesn't match the input vertices.'\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;You may have had duplicate input vertices, or you may have eaten some\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;of your input vertices with a hole, or by placing them outside the area\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;enclosed by segments.&nbsp;&nbsp;In <a href="CppAny.htm">any</a> <b><a href="CppCase.htm">case</a></b>, you can solve the problem by not\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppUsing.htm">using</a></b> the <a href="CppOperatorMinus.htm">-</a>j <b><a href="CppSwitch.htm">switch</a></b>.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`Triangle executes without incident, but when I look at the resulting\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;mesh, it has overlapping triangles or other geometric inconsistencies.'\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If you select the <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b>, Triangle occasionally <a href="CppMake.htm">make</a>s mistakes due\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;to floating-<a href="CppPointer.htm">point</a> roundoff error.&nbsp;&nbsp;Although these errors are rare,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;don't use the <a href="CppOperatorMinus.htm">-</a>X <b><a href="CppSwitch.htm">switch</a></b>.&nbsp;&nbsp;If you still have problems, please report the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBug.htm">bug</a>.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;`Triangle executes without incident, but when I look at the resulting\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Voronoi diagram, it has overlapping edges or other geometric\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;inconsistencies.'\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;If your input is a PSLG (-p), you can only expect a meaningful Voronoi\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;diagram <b><a href="CppIf.htm">if</a></b> the domain you are triangulating is convex and free of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;holes, and you use the <a href="CppOperatorMinus.htm">-</a>D <b><a href="CppSwitch.htm">switch</a></b> to <a href="CppConstructor.htm">construct</a> a conforming Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;triangulation (instead of a CDT or CCDT).\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Strange things can happen <b><a href="CppIf.htm">if</a></b> you've taken liberties with your PSLG.&nbsp;&nbsp;Do\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;you have a vertex lying in the middle of a segment?&nbsp;&nbsp;Triangle some<a href="CppTime.htm">time</a>s\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;copes poorly with that sort of thing.&nbsp;&nbsp;Do you want to lay out a collinear\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;row of evenly spaced, segment-connected vertices?&nbsp;&nbsp;Have you simply\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;defined one <b><a href="CppLong.htm">long</a></b> segment connecting the leftmost vertex to the rightmost\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertex, and a bunch of vertices lying along it?&nbsp;&nbsp;This <a href="CppMemberFunction.htm">member function</a> occasionally\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;works, especially with horizontal and vertical lines, but often it\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;doesn't, and you'll have to connect each adjacent pair of vertices with a\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;separate segment.&nbsp;&nbsp;If you don't like it, tough.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Furthermore, <b><a href="CppIf.htm">if</a></b> you have segments that intersect other than at their\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;endpoints, <b><a href="CppTry.htm">try</a></b> not to let the intersections fall extremely close to PSLG\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices or each other.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you have problems refining a triangulation not produced by Triangle:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Are you sure the triangulation is geometrically valid?&nbsp;&nbsp;Is it formatted\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;correctly <b><a href="CppFor.htm">for</a></b> Triangle?&nbsp;&nbsp;Are the triangles all listed so the first three\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;vertices are their corners in <a href="CppCounter.htm">counter</a>clockwise order?&nbsp;&nbsp;Are all of the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;triangles constrained Delaunay?&nbsp;&nbsp;Triangle's Delaunay refinement <a href="CppAlgorithm.htm">algorithm</a>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;assumes that it starts with a CDT.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Show Me:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangle comes with a separate program named `Show Me', whose primary\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;purpose is to draw meshes on your screen or in PostScript.&nbsp;&nbsp;Its secondary\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;purpose is to check the validity of your input files, and <b><a href="CppDo.htm">do</a></b> so more\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;thoroughly than Triangle does.&nbsp;&nbsp;Unlike Triangle, Show Me requires that\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;you have the X <a href="CppWindows.htm">Windows</a> system.&nbsp;&nbsp;Sorry, Microsoft <a href="CppWindows.htm">Windows</a> users.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle on the Web:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;To see an illustrated <a href="CppVersion.htm">version</a> of these instructions, check out\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;http://www.cs.cmu.edu/~quake/triangle.html\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "A Brief Plea:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you use Triangle, and especially <b><a href="CppIf.htm">if</a></b> you use it to accomplish real\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;work, I would like very much to hear from you.&nbsp;&nbsp;A <b><a href="CppShort.htm">short</a></b> letter or email\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(to jrs@cs.berkeley.edu) desc<a href="CppRibi.htm">ribi</a>ng how you use Triangle will mean a lot\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;to me.&nbsp;&nbsp;The more people I know are <b><a href="CppUsing.htm">using</a></b> <b><a href="CppThis.htm">this</a></b> program, the more easily I\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;can justify spending <a href="CppTime.htm">time</a> on improvements, which in turn will benefit\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;you.&nbsp;&nbsp;Also, I can put you on a list to receive email whenever a <b><a href="CppNew.htm">new</a></b>\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppVersion.htm">version</a> of Triangle is available.\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you use a mesh generated by Triangle in a <b><a href="CppPublic.htm">public</a></b>ation, please include\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;an acknowledgment as well.&nbsp;&nbsp;And please spell Triangle with a capital `T'!\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;If you want to include a citation, use `Jonathan Ri<b><a href="CppChar.htm">char</a></b>d Shewchuk,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;``Triangle: Engineering a 2D Quality Mesh Generator and Delaunay\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangulator,'' in Applied Computational Geometry:&nbsp;&nbsp;Towards Geometric\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Engineering (Ming C. Lin and Dinesh Manocha, editors), volume 1148 of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Lecture Notes in Computer Science, pages 203-222, Springer-Verlag,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Berlin, May 1996.&nbsp;&nbsp;(From the First ACM Workshop on Applied Computational\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Geometry.)'\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Research credit:\n\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Of course, I can take credit <b><a href="CppFor.htm">for</a></b> only a fraction of the ideas that made\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b> mesh generator possible.&nbsp;&nbsp;Triangle owes its existence to the efforts\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;of many fine computational geometers and other researchers, including\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Marshall Bern, L. Paul Chew, Kenneth L. Clarkson, Boris Delaunay, Rex A.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Dwyer, David Eppstein, Steven Fortune, Leonidas J. Guibas, Donald E.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Knuth, Charles L. Lawson, Der-Tsai Lee, Gary L. Miller, Ernst P. Mucke,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Steven E. Pav, Douglas M. Priest, Jim Ruppert, Isaac Saias, Bruce J.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Schachter, Micha Sharir, Peter W. Shor, Daniel D. Sleator, Jorge Stolfi,\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Robert E. Tarjan, Alper Ungor, Christopher J. Van Wyk, Noel J.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Walkington, and Binhai Zhu.&nbsp;&nbsp;See the comments at the beginning of the\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;source code <b><a href="CppFor.htm">for</a></b> references.\n\n";<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppinsertvertexresult.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppinsertvertexresult.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPINSERTVERTEXRESULT_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPINSERTVERTEXRESULT_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> Labels that signify the result of vertex insertion.&nbsp;&nbsp;The result indicates <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; that the vertex was inserted with complete success, was inserted but&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; encroaches upon a subsegment, was not inserted because it lies on a&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; segment, or was not inserted because another vertex occupies the same&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; location.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> InsertVertexResult<br/>
{<br/>
&nbsp;&nbsp;SUCCESSFULVERTEX,<br/>
&nbsp;&nbsp;ENCROACHINGVERTEX,<br/>
&nbsp;&nbsp;VIOLATINGVERTEX,<br/>
&nbsp;&nbsp;DUPLICATEVERTEX<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPINSERTVERTEXRESULT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppinsertvertexresult.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppinsertvertexresult.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppinsertvertexresult.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpplocateresult.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpplocateresult.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPLOCATERESULT_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPLOCATERESULT_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> Labels that signify the result of <a href="CppPointer.htm">point</a> location.&nbsp;&nbsp;The result of a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; search indicates that the <a href="CppPointer.htm">point</a> falls in the interior of a triangle, on <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; an edge, on a vertex, or outside the mesh.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> LocateResult<br/>
{<br/>
&nbsp;&nbsp;INTRIANGLE, ONEDGE, ONVERTEX, OUTSIDE<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPLOCATERESULT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpplocateresult.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpplocateresult.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecpplocateresult.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmain.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmain.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLE_CPP_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLE_CPP_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecpplocateresult.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfinddirectionresult.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpp<b><a href="CppTypedef.htm">typedef</a></b>s.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppinsertvertexresult.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> alternateaxes()&nbsp;&nbsp; Sorts the vertices as appropriate <b><a href="CppFor.htm">for</a></b> the divide-and-<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conquer <a href="CppAlgorithm.htm">algorithm</a> with alternating cuts.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Partitions by x-coordinate <b><a href="CppIf.htm">if</a></b> axis <a href="CppOperatorEqual.htm">==</a> 0; by y-coordinate <b><a href="CppIf.htm">if</a></b> axis <a href="CppOperatorEqual.htm">==</a> 1.<br/>
/<a href="CppComment.htm">//</a> For the base <b><a href="CppCase.htm">case</a></b>, subsets containing only two or three vertices are<br/>
/<a href="CppComment.htm">//</a> always sorted by x-coordinate.<br/>
<b><a href="CppVoid.htm">void</a></b> alternateaxes(<br/>
&nbsp;&nbsp;Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArray.htm">array</a>size,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> axis<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> Deallocate space <b><a href="CppFor.htm">for</a></b> a bad subsegment, marking it<br/>
/<a href="CppComment.htm">//</a> dead.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> badsubsegdealloc(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;BadSubSeg&gt;&amp; m_badsubsegs,<br/>
&nbsp;&nbsp;BadSubSeg&amp; dyingseg<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
/<a href="CppComment.htm">//</a> badsubsegtraverse()&nbsp;&nbsp; Traverse the bad subsegments, skipping dead ones.<br/>
<a href="CppComment.htm">//</a>BadSubSeg * badsubsegtraverse(Mesh&amp; m);<br/>
<br/>
/<a href="CppComment.htm">//</a> boundingbox()&nbsp;&nbsp; Form an "infinite" bounding triangle to insert vertices<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; into.<br/>
/<a href="CppComment.htm">//</a> The vertices at "infinity" are as<b><a href="CppSigned.htm">signed</a></b> finite coordinates, which are<br/>
/<a href="CppComment.htm">//</a> used by the <a href="CppPointer.htm">point</a> location routines, but (mostly) ignored by the<br/>
/<a href="CppComment.htm">//</a> Delaunay edge flip routines.<br/>
<b><a href="CppVoid.htm">void</a></b> boundingbox(Mesh&amp; m, <b><a href="CppConst.htm">const</a></b> Arguments&amp; b);<br/>
<br/>
/<a href="CppComment.htm">//</a> carveholes()&nbsp;&nbsp; Find the holes and infect them.&nbsp;&nbsp;Find the area<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraints and infect them.&nbsp;&nbsp;Infect the convex hull.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spread the infection and kill triangles.&nbsp;&nbsp;Spread the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area constraints.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This routine mainly calls other routines to carry out all these<br/>
/<a href="CppComment.htm">//</a> <a href="CppFunction.htm">function</a>s.<br/>
<b><a href="CppVoid.htm">void</a></b> carveholes(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; holelist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> holelist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> holes,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; regionlist<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> regionlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> regions<br/>
);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> check4deadevent(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> checktri,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> <b><a href="CppConst.htm">const</a></b> <a href="CppComment.htm">*/</a> Event ** <b><a href="CppConst.htm">const</a></b> freeevents,<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> eventheap,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> * <b><a href="CppConst.htm">const</a></b> heapsize<br/>
);<br/>
<br/>
<a href="CppComment.htm">///</a>Ensure that the mesh is (constrained) Delaunay.<br/>
<b><a href="CppVoid.htm">void</a></b> checkdelaunay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_incirclecount<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> m_m_noexact,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Arguments&amp; b<br/>
);<br/>
<br/>
<a href="CppComment.htm">///</a>Test the mesh <b><a href="CppFor.htm">for</a></b> topological consistency.<br/>
<b><a href="CppVoid.htm">void</a></b> checkmesh(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; m_m_triangles,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Arguments&amp; b<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> Check a subsegment to see <b><a href="CppIf.htm">if</a></b> it is encroached; add<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it to the list <b><a href="CppIf.htm">if</a></b> it is.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> A subsegment is encroached <b><a href="CppIf.htm">if</a></b> there is a vertex in its diametral lens.<br/>
/<a href="CppComment.htm">//</a> For Ruppert's <a href="CppAlgorithm.htm">algorithm</a> (-D <b><a href="CppSwitch.htm">switch</a></b>), the "diametral lens" is the<br/>
/<a href="CppComment.htm">//</a> diametral circle.&nbsp;&nbsp;For Chew's <a href="CppAlgorithm.htm">algorithm</a> (<b><a href="CppDefault.htm">default</a></b>), the diametral lens is<br/>
/<a href="CppComment.htm">//</a> just big enough to enclose two isosceles triangles whose bases are the<br/>
/<a href="CppComment.htm">//</a> subsegment.&nbsp;&nbsp;Each of the two isosceles triangles has two angles equal<br/>
/<a href="CppComment.htm">//</a> to `b-&gt;minangle'.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Chew's <a href="CppAlgorithm.htm">algorithm</a> does not require diametral lenses at all<a href="CppOperatorDecrement.htm">--</a>but they save<br/>
/<a href="CppComment.htm">//</a> <a href="CppTime.htm">time</a>.&nbsp;&nbsp;Any vertex inside a subsegment's diametral lens implies that the<br/>
/<a href="CppComment.htm">//</a> triangle adjoining the subsegment will be too skinny, so it's only a<br/>
/<a href="CppComment.htm">//</a> matter of <a href="CppTime.htm">time</a> before the encroaching vertex is deleted by Chew's<br/>
/<a href="CppComment.htm">//</a> <a href="CppAlgorithm.htm">algorithm</a>.&nbsp;&nbsp;It's faster to simply not insert the doomed vertex in the<br/>
/<a href="CppComment.htm">//</a> first place, which is why I use diametral lenses with Chew's <a href="CppAlgorithm.htm">algorithm</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns a nonzero value <b><a href="CppIf.htm">if</a></b> the subsegment is encroached.<br/>
<b><a href="CppInt.htm">int</a></b> checkseg4encroach(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; m_m_dummytri,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_conformdel,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b_m_goodangle,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_nobisect,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; testsubseg<br/>
);<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> circletop(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> ccwabc<br/>
);<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; circletopinsert(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splayroot,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; newkey,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> topy<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> conformingedge()&nbsp;&nbsp; Force a segment into a conforming Delaunay<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangulation by inserting a vertex at its mid<a href="CppPointer.htm">point</a>,<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and recursively forcing in the two half-segments <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;necessary.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Generates a sequence of subsegments connecting `endpoint1' to<br/>
/<a href="CppComment.htm">//</a> `endpoint2'.&nbsp;&nbsp;`newmark' is the boundary marker of the segment, as<b><a href="CppSigned.htm">signed</a></b><br/>
/<a href="CppComment.htm">//</a> to each <b><a href="CppNew.htm">new</a></b> splitting vertex and subsegment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Note that conformingedge() does not always maintain the conforming<br/>
/<a href="CppComment.htm">//</a> Delaunay property.&nbsp;&nbsp;Once inserted, segments are locked into place;<br/>
/<a href="CppComment.htm">//</a> vertices inserted later (to force other segments in) may render these<br/>
/<a href="CppComment.htm">//</a> fixed segments non-Delaunay.&nbsp;&nbsp;The conforming Delaunay property will be<br/>
/<a href="CppComment.htm">//</a> restored by enforcequality() by splitting encroached subsegments.<br/>
<b><a href="CppVoid.htm">void</a></b> conformingedge(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; endpoint1,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> constrainededge()&nbsp;&nbsp; Force a segment into a constrained Delaunay<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; triangulation by deleting the triangles it<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intersects, and triangulating the polygons that<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; form on each side of it.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Generates a single subsegment connecting `endpoint1' to `endpoint2'.<br/>
/<a href="CppComment.htm">//</a> The triangle `starttri' has `endpoint1' as its origin.&nbsp;&nbsp;`newmark' is the<br/>
/<a href="CppComment.htm">//</a> boundary marker of the segment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> To insert a segment, every triangle whose interior intersects the<br/>
/<a href="CppComment.htm">//</a> segment is deleted.&nbsp;&nbsp;The <b><a href="CppUnion.htm">union</a></b> of these deleted triangles is a polygon<br/>
/<a href="CppComment.htm">//</a> (which is not necessarily monotone, but is close enough), which is<br/>
/<a href="CppComment.htm">//</a> divided into two polygons by the <b><a href="CppNew.htm">new</a></b> segment.&nbsp;&nbsp;This routine's task is<br/>
/<a href="CppComment.htm">//</a> to generate the Delaunay triangulation of these two polygons.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> You might think of <b><a href="CppThis.htm">this</a></b> routine's behavior as a two-step process.&nbsp;&nbsp;The<br/>
/<a href="CppComment.htm">//</a> first step is to walk from endpoint1 to endpoint2, flipping each edge<br/>
/<a href="CppComment.htm">//</a> en<a href="CppCounter.htm">counter</a>ed.&nbsp;&nbsp;This step creates a fan of edges connected to endpoint1,<br/>
/<a href="CppComment.htm">//</a> including the desired edge to endpoint2.&nbsp;&nbsp;The second step enforces the<br/>
/<a href="CppComment.htm">//</a> Delaunay condition on each side of the segment in an incremental manner:<br/>
/<a href="CppComment.htm">//</a> proceeding along the polygon from endpoint1 to endpoint2 (<b><a href="CppThis.htm">this</a></b> is done<br/>
/<a href="CppComment.htm">//</a> independently on each side of the segment), each vertex is "enforced"<br/>
/<a href="CppComment.htm">//</a> as <b><a href="CppIf.htm">if</a></b> it had just been inserted, but affecting only the previous<br/>
/<a href="CppComment.htm">//</a> vertices.&nbsp;&nbsp;The result is the same as <b><a href="CppIf.htm">if</a></b> the vertices had been inserted<br/>
/<a href="CppComment.htm">//</a> in the order they appear on the polygon, so the result is Delaunay.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> In truth, constrainededge() interleaves these two steps.&nbsp;&nbsp;The procedure<br/>
/<a href="CppComment.htm">//</a> walks from endpoint1 to endpoint2, and each <a href="CppTime.htm">time</a> an edge is en<a href="CppCounter.htm">counter</a>ed<br/>
/<a href="CppComment.htm">//</a> and flipped, the newly exposed vertex (at the far end of the flipped<br/>
/<a href="CppComment.htm">//</a> edge) is "enforced" upon the previously flipped edges, usually affecting<br/>
/<a href="CppComment.htm">//</a> only one side of the polygon (depending upon which side of the segment<br/>
/<a href="CppComment.htm">//</a> the vertex falls on).<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The <a href="CppAlgorithm.htm">algorithm</a> is complicated by the need to handle polygons that are not<br/>
/<a href="CppComment.htm">//</a> convex.&nbsp;&nbsp;Although the polygon is not necessarily monotone, it can be<br/>
/<a href="CppComment.htm">//</a> triangulated in a manner similar to the stack-based <a href="CppAlgorithm.htm">algorithm</a>s <b><a href="CppFor.htm">for</a></b><br/>
/<a href="CppComment.htm">//</a> monotone polygons.&nbsp;&nbsp;For each reflex vertex (local concavity) of the<br/>
/<a href="CppComment.htm">//</a> polygon, there will be an inverted triangle formed by one of the edge<br/>
/<a href="CppComment.htm">//</a> flips.&nbsp;&nbsp;(An inverted triangle is one with negative area <a href="CppOperatorMinus.htm">-</a> that is, its<br/>
/<a href="CppComment.htm">//</a> vertices are arranged in clockwise order <a href="CppOperatorMinus.htm">-</a> and is best thought of as a<br/>
/<a href="CppComment.htm">//</a> wrinkle in the fabric of the mesh.)&nbsp;&nbsp;Each inverted triangle can be<br/>
/<a href="CppComment.htm">//</a> thought of as a reflex vertex pushed on the stack, waiting to be fixed<br/>
/<a href="CppComment.htm">//</a> later.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> A reflex vertex is popped from the stack when a vertex is inserted that<br/>
/<a href="CppComment.htm">//</a> is visible to the reflex vertex.&nbsp;&nbsp;(However, <b><a href="CppIf.htm">if</a></b> the vertex behind the<br/>
/<a href="CppComment.htm">//</a> reflex vertex is not visible to the reflex vertex, a <b><a href="CppNew.htm">new</a></b> inverted<br/>
/<a href="CppComment.htm">//</a> triangle will take its place on the stack.)&nbsp;&nbsp;These details are handled<br/>
/<a href="CppComment.htm">//</a> by the delaunayfixup() routine above.<br/>
<b><a href="CppVoid.htm">void</a></b> constrainededge(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> starttri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
);<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppCounter.htm">counter</a>clockwise(<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> <a href="CppCounter.htm">counter</a>clockwise()&nbsp;&nbsp; Return a positive value <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a>s pa, pb, and<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc occur in <a href="CppCounter.htm">counter</a>clockwise order; a negative<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value <b><a href="CppIf.htm">if</a></b> they occur in clockwise order; and zero<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> they are collinear.&nbsp;&nbsp;The result is also a rough<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;approximation of twice the <b><a href="CppSigned.htm">signed</a></b> area of the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangle defined by the three <a href="CppPointer.htm">point</a>s.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Uses exact arithmetic <b><a href="CppIf.htm">if</a></b> necessary to ensure a correct answer.&nbsp;&nbsp;The<br/>
/<a href="CppComment.htm">//</a> result <b><a href="CppReturn.htm">return</a></b>ed is the determinant of a <a href="CppMatrix.htm">matrix</a>.&nbsp;&nbsp;This determinant is<br/>
/<a href="CppComment.htm">//</a> computed adaptively, in the sense that exact arithmetic is used only to<br/>
/<a href="CppComment.htm">//</a> the degree it is needed to ensure that the <b><a href="CppReturn.htm">return</a></b>ed value has the<br/>
/<a href="CppComment.htm">//</a> correct sign.&nbsp;&nbsp;Hence, <b><a href="CppThis.htm">this</a></b> <a href="CppFunction.htm">function</a> is usually quite fast, but will run<br/>
/<a href="CppComment.htm">//</a> more slowly when the input <a href="CppPointer.htm">point</a>s are collinear or nearly so.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> See my Robust <a href="CppPredicate.htm">Predicate</a>s paper <b><a href="CppFor.htm">for</a></b> details.<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppCounter.htm">counter</a>clockwiseadapt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> detsum<br/>
);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> createeventheap(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;Event *** eventheap,<br/>
&nbsp;&nbsp;Event ** events,<br/>
&nbsp;&nbsp;Event ** freeevents<br/>
);<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> delaunay()&nbsp;&nbsp; Form a Delaunay triangulation.<br/>
<b><a href="CppLong.htm">long</a></b> delaunay(Mesh&amp; m, <b><a href="CppConst.htm">const</a></b> Arguments&amp; b);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> delaunayfixup()&nbsp;&nbsp; Enforce the Delaunay condition at an edge, fanning out<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recursively from an existing vertex.&nbsp;&nbsp;Pay special<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attention to stacking inverted triangles.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This is a support routine <b><a href="CppFor.htm">for</a></b> inserting segments into a constrained<br/>
/<a href="CppComment.htm">//</a> Delaunay triangulation.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The origin of fixuptri is treated as <b><a href="CppIf.htm">if</a></b> it has just been inserted, and<br/>
/<a href="CppComment.htm">//</a> the local Delaunay condition needs to be enforced.&nbsp;&nbsp;It is only enforced<br/>
/<a href="CppComment.htm">//</a> in one sector, however, that being the angular range defined by<br/>
/<a href="CppComment.htm">//</a> fixuptri.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This routine also needs to <a href="CppMake.htm">make</a> decisions regarding the "stacking" of<br/>
/<a href="CppComment.htm">//</a> triangles.&nbsp;&nbsp;(Read the description of constrainededge() below before<br/>
/<a href="CppComment.htm">//</a> reading on here, so you understand the <a href="CppAlgorithm.htm">algorithm</a>.)&nbsp;&nbsp;If the position of<br/>
/<a href="CppComment.htm">//</a> the <b><a href="CppNew.htm">new</a></b> vertex (the origin of fixuptri) indicates that the vertex before<br/>
/<a href="CppComment.htm">//</a> it on the polygon is a reflex vertex, then "stack" the triangle by<br/>
/<a href="CppComment.htm">//</a> doing nothing.&nbsp;&nbsp;(fixuptri is an inverted triangle, which is how stacked<br/>
/<a href="CppComment.htm">//</a> triangles are identified.)<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Otherwise, check whether the vertex before that was a reflex vertex.<br/>
/<a href="CppComment.htm">//</a> If so, perform an edge flip, thereby eliminating an inverted triangle<br/>
/<a href="CppComment.htm">//</a> (popping it off the stack).&nbsp;&nbsp;The edge flip may result in the creation<br/>
/<a href="CppComment.htm">//</a> of a <b><a href="CppNew.htm">new</a></b> inverted triangle, depending on whether or not the <b><a href="CppNew.htm">new</a></b> vertex<br/>
/<a href="CppComment.htm">//</a> is visible to the vertex three edges behind on the polygon.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If neither of the two vertices behind the <b><a href="CppNew.htm">new</a></b> vertex are reflex<br/>
/<a href="CppComment.htm">//</a> vertices, fixuptri and fartri, the triangle opposite it, are not<br/>
/<a href="CppComment.htm">//</a> inverted; hence, ensure that the edge between them is locally Delaunay.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> `leftside' indicates whether or not fixuptri is to the left of the<br/>
/<a href="CppComment.htm">//</a> segment being inserted.&nbsp;&nbsp;(Imagine that the segment is <a href="CppPointer.htm">point</a>ing up from<br/>
/<a href="CppComment.htm">//</a> endpoint1 to endpoint2.)<br/>
<b><a href="CppVoid.htm">void</a></b> delaunayfixup(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> fixuptri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> leftside<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> deletevertex()&nbsp;&nbsp; Delete a vertex from a Delaunay triangulation, ensuring<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that the triangulation remains Delaunay.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The origin of `deltri' is deleted.&nbsp;&nbsp;The <b><a href="CppUnion.htm">union</a></b> of the triangles adjacent<br/>
/<a href="CppComment.htm">//</a> to <b><a href="CppThis.htm">this</a></b> vertex is a polygon, <b><a href="CppFor.htm">for</a></b> which the Delaunay triangulation is<br/>
/<a href="CppComment.htm">//</a> found.&nbsp;&nbsp;Two triangles are removed from the mesh.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Only interior vertices that <b><a href="CppDo.htm">do</a></b> not lie on segments or boundaries may be<br/>
/<a href="CppComment.htm">//</a> deleted.<br/>
<b><a href="CppVoid.htm">void</a></b> deletevertex(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; deltri<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> dequeuebadtriang()&nbsp;&nbsp; Remove a triangle from the front of the queue.<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt; dequeuebadtriang(Mesh&amp; m);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> divconqdelaunay()&nbsp;&nbsp; Form a Delaunay triangulation by the divide-and-<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conquer <a href="CppMemberFunction.htm">member function</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Sorts the vertices, calls a recursive procedure to triangulate them, and<br/>
/<a href="CppComment.htm">//</a> removes the bounding box, setting boundary markers as appropriate.<br/>
<b><a href="CppLong.htm">long</a></b> divconqdelaunay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> divconqrecurse()&nbsp;&nbsp; Recursively form a Delaunay triangulation by the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;divide-and-conquer <a href="CppMemberFunction.htm">member function</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Recursively <b><a href="CppBreak.htm">break</a></b>s down the problem into smaller pieces, which are<br/>
/<a href="CppComment.htm">//</a> knitted together by mergehulls().&nbsp;&nbsp;The base <b><a href="CppCase.htm">case</a></b>s (problems of two or<br/>
/<a href="CppComment.htm">//</a> three vertices) are handled specially here.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> On completion, `farleft' and `farright' are bounding triangles such that<br/>
/<a href="CppComment.htm">//</a> the origin of `farleft' is the leftmost vertex (<b><a href="CppBreak.htm">break</a></b>ing ties by<br/>
/<a href="CppComment.htm">//</a> choosing the highest leftmost vertex), and the destination of<br/>
/<a href="CppComment.htm">//</a> `farright' is the rightmost vertex (<b><a href="CppBreak.htm">break</a></b>ing ties by choosing the<br/>
/<a href="CppComment.htm">//</a> lowest rightmost vertex).<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">//</a>Use vertex* instead of <a href="CppIterator.htm">iterator</a>s <b><a href="CppFor.htm">for</a></b> now<br/>
<b><a href="CppVoid.htm">void</a></b> divconqrecurse(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertices,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axis,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farleft,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farright<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> dummyinit()&nbsp;&nbsp; <a href="CppInitialize.htm">Initialize</a> the triangle that fills "outer space" and the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; omnipresent subsegment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The triangle that fills "outer space," called `dummytri', is <a href="CppPointer.htm">point</a>ed to<br/>
/<a href="CppComment.htm">//</a> by every triangle and subsegment on a boundary (be it outer or inner) of<br/>
/<a href="CppComment.htm">//</a> the triangulation.&nbsp;&nbsp;Also, `dummytri' <a href="CppPointer.htm">point</a>s to one of the triangles on<br/>
/<a href="CppComment.htm">//</a> the convex hull (until the holes and concavities are carved), making it<br/>
/<a href="CppComment.htm">//</a> possible to find a starting triangle <b><a href="CppFor.htm">for</a></b> <a href="CppPointer.htm">point</a> location.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The omnipresent subsegment, `dummysub', is <a href="CppPointer.htm">point</a>ed to by every triangle<br/>
/<a href="CppComment.htm">//</a> or subsegment that doesn't have a full complement of real subsegments<br/>
/<a href="CppComment.htm">//</a> to <a href="CppPointer.htm">point</a> to.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> `dummytri' and `dummysub' are generally required to fulfill only a few<br/>
/<a href="CppComment.htm">//</a> <a href="CppInvariant.htm">invariant</a>s:&nbsp;&nbsp;their vertices must remain <a href="CppNULL.htm">NULL</a> and `dummytri' must always<br/>
/<a href="CppComment.htm">//</a> be bonded (at offset zero) to some triangle on the convex hull of the<br/>
/<a href="CppComment.htm">//</a> mesh, via a boundary edge.&nbsp;&nbsp;Otherwise, the connections of `dummytri' and<br/>
/<a href="CppComment.htm">//</a> `dummysub' may change willy-nilly.&nbsp;&nbsp;This <a href="CppMake.htm">make</a>s it possible to avoid<br/>
/<a href="CppComment.htm">//</a> writing a good deal of special-<b><a href="CppCase.htm">case</a></b> code (in the edge flip, <b><a href="CppFor.htm">for</a></b> example)<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppFor.htm">for</a></b> dealing with the boundary of the mesh, places where no subsegment is<br/>
/<a href="CppComment.htm">//</a> present, and so forth.&nbsp;&nbsp;Other entities are frequently bonded to<br/>
/<a href="CppComment.htm">//</a> `dummytri' and `dummysub' as <b><a href="CppIf.htm">if</a></b> they were real mesh entities, with no<br/>
/<a href="CppComment.htm">//</a> harm done.<br/>
<b><a href="CppVoid.htm">void</a></b> dummyinit(<br/>
&nbsp;&nbsp;Mesh&amp; m<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> trianglebytes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subsegbytes<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> enforcequality()&nbsp;&nbsp; Remove all the encroached subsegments and bad<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles from the triangulation.<br/>
<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a>s Steiner <a href="CppPointer.htm">point</a>s, then splits bad (*) Triangles<br/>
<a href="CppComment.htm">//</a> (*) Triangles with angle &lt; min_angle <a href="CppOperatorLogicalOr.htm">||</a> area &gt; max_area)<br/>
<b><a href="CppVoid.htm">void</a></b> enforcequality(<br/>
&nbsp;&nbsp;Mesh&amp; m<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> fast_expansion_sum_zeroelim()&nbsp;&nbsp; Sum two expansions, eliminating zero<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComponent.htm">component</a>s from the output expansion.<br/>
/<a href="CppComment.htm">//</a> Sets h <a href="CppOperatorAssign.htm">=</a> e <a href="CppOperatorPlus.htm">+</a> f.&nbsp;&nbsp;See my Robust <a href="CppPredicate.htm">Predicate</a>s paper <b><a href="CppFor.htm">for</a></b> details.<br/>
/<a href="CppComment.htm">//</a> If round-to-even is used (as with IEEE 754), maintains the s<a href="GameTronCollection.htm">tron</a>gly<br/>
/<a href="CppComment.htm">//</a> nonoverlapping property.&nbsp;&nbsp;(That is, <b><a href="CppIf.htm">if</a></b> e is s<a href="GameTronCollection.htm">tron</a>gly nonoverlapping, h<br/>
/<a href="CppComment.htm">//</a> will be also.)&nbsp;&nbsp;Does NOT maintain the nonoverlapping or nonadjacent<br/>
/<a href="CppComment.htm">//</a> properties.<br/>
<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
<b><a href="CppDouble.htm">double</a></b> fast_expansion_sum_zeroelim(<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> fast_expansion_sum_zeroelim(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; e,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> e,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> flen,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; f<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> f,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; h<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> h<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> findcircumcenter()&nbsp;&nbsp; Find the circumcenter of a triangle.<br/>
<br/>
/<a href="CppComment.htm">//</a> The result is <b><a href="CppReturn.htm">return</a></b>ed both in terms of x-y coordinates and xi-eta<br/>
/<a href="CppComment.htm">//</a> (barycentric) coordinates.&nbsp;&nbsp;The xi-eta coordinate system is defined in<br/>
/<a href="CppComment.htm">//</a> terms of the triangle:&nbsp;&nbsp;the origin of the triangle is the origin of the<br/>
/<a href="CppComment.htm">//</a> coordinate system; the destination of the triangle is one unit along the<br/>
/<a href="CppComment.htm">//</a> xi axis; and the apex of the triangle is one unit along the eta axis.<br/>
/<a href="CppComment.htm">//</a> This procedure also <a href="CppReturn.htm">returns</a> the square of the length of the triangle's<br/>
/<a href="CppComment.htm">//</a> shortest edge.<br/>
<b><a href="CppVoid.htm">void</a></b> findcircumcenter(<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_circumcentercount,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b_m_offconstant,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; torg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; tdest,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; tapex,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; circumcenter,<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b>&amp; xi,<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b>&amp; eta,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> offcenter<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> finddirection()&nbsp;&nbsp; Find the first triangle on the path from one <a href="CppPointer.htm">point</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to another.<br/>
<br/>
/<a href="CppComment.htm">//</a> Finds the triangle that intersects a line segment drawn from the<br/>
/<a href="CppComment.htm">//</a> origin of `searchtri' to the <a href="CppPointer.htm">point</a> `search<a href="CppPointer.htm">point</a>', and <a href="CppReturn.htm">returns</a> the result<br/>
/<a href="CppComment.htm">//</a> in `searchtri'.&nbsp;&nbsp;The origin of `searchtri' does not change, even though<br/>
/<a href="CppComment.htm">//</a> the triangle <b><a href="CppReturn.htm">return</a></b>ed may differ from the one passed in.&nbsp;&nbsp;This routine<br/>
/<a href="CppComment.htm">//</a> is used to find the direction to move in to get from one <a href="CppPointer.htm">point</a> to<br/>
/<a href="CppComment.htm">//</a> another.<br/>
<br/>
/<a href="CppComment.htm">//</a> The <b><a href="CppReturn.htm">return</a></b> value notes whether the destination or apex of the found<br/>
/<a href="CppComment.htm">//</a> triangle is collinear with the two <a href="CppPointer.htm">point</a>s in <a href="CppQuestion.htm">question</a>.<br/>
<br/>
<br/>
FindDirectionResult finddirection(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a><br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> flip()&nbsp;&nbsp; Transform two triangles to two different triangles by flipping<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an edge <a href="CppCounter.htm">counter</a>clockwise within a quadrilateral.<br/>
<br/>
/<a href="CppComment.htm">//</a> Imagine the original triangles, abc and bad, oriented so that the<br/>
/<a href="CppComment.htm">//</a> shared edge ab lies in a horizontal plane, with the vertex b on the left<br/>
/<a href="CppComment.htm">//</a> and the vertex a on the right.&nbsp;&nbsp;The vertex c lies below the edge, and<br/>
/<a href="CppComment.htm">//</a> the vertex d lies above the edge.&nbsp;&nbsp;The `flipedge' handle holds the edge<br/>
/<a href="CppComment.htm">//</a> ab of triangle abc, and is directed left, from vertex a to vertex b.<br/>
<br/>
/<a href="CppComment.htm">//</a> The triangles abc and bad are deleted and replaced by the triangles cdb<br/>
/<a href="CppComment.htm">//</a> and dca.&nbsp;&nbsp;The triangles that represent abc and bad are NOT deallocated;<br/>
/<a href="CppComment.htm">//</a> they are reused <b><a href="CppFor.htm">for</a></b> dca and cdb, respectively.&nbsp;&nbsp;Hence, <a href="CppAny.htm">any</a> handles that<br/>
/<a href="CppComment.htm">//</a> may have held the original triangles are still valid, although not<br/>
/<a href="CppComment.htm">//</a> directed as they were before.<br/>
<br/>
/<a href="CppComment.htm">//</a> Upon completion of <b><a href="CppThis.htm">this</a></b> routine, the `flipedge' handle holds the edge<br/>
/<a href="CppComment.htm">//</a> dc of triangle dca, and is directed down, from vertex d to vertex c.<br/>
/<a href="CppComment.htm">//</a> (Hence, the two triangles have rotated <a href="CppCounter.htm">counter</a>clockwise.)<br/>
<br/>
/<a href="CppComment.htm">//</a> WARNING:&nbsp;&nbsp;This transformation is geometrically valid only <b><a href="CppIf.htm">if</a></b> the<br/>
/<a href="CppComment.htm">//</a> quadrilateral adbc is convex.&nbsp;&nbsp;Furthermore, <b><a href="CppThis.htm">this</a></b> transformation is<br/>
/<a href="CppComment.htm">//</a> valid only <b><a href="CppIf.htm">if</a></b> there is not a subsegment between the triangles abc and<br/>
/<a href="CppComment.htm">//</a> bad.&nbsp;&nbsp;This routine does not check either of these preconditions, and<br/>
/<a href="CppComment.htm">//</a> it is the responsibility of the calling routine to ensure that they are<br/>
/<a href="CppComment.htm">//</a> met.&nbsp;&nbsp;If they are not, the streets shall be filled with wailing and<br/>
/<a href="CppComment.htm">//</a> gnashing of teeth.<br/>
<b><a href="CppVoid.htm">void</a></b> flip(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; flipedge<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> formskeleton()&nbsp;&nbsp; Create the segments of a triangulation, including PSLG<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segments and edges on the convex hull.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The PSLG segments are read from a .poly file.&nbsp;&nbsp;The <b><a href="CppReturn.htm">return</a></b> value is the<br/>
/<a href="CppComment.htm">//</a> number of segments in the file.<br/>
<a href="CppComment.htm">//</a>RJCB: ?creates all Edges<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> formskeleton(<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;Mesh&amp; m,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> polyfile,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename<br/>
<a href="CppComment.htm">//</a>);<br/>
<br/>
SplayNode * frontlocate(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;SplayNode * splayroot,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> bottommost,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; searchvertex,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> * <b><a href="CppConst.htm">const</a></b> farright<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> getvertex()&nbsp;&nbsp; Get a specific vertex, by number, from the list.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The first vertex is number 'firstnumber'.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Note that <b><a href="CppThis.htm">this</a></b> takes O(n) <a href="CppTime.htm">time</a> (with a small constant, <b><a href="CppIf.htm">if</a></b> VERTEXPERBLOCK<br/>
/<a href="CppComment.htm">//</a> is large).&nbsp;&nbsp;I don't care to take the trouble to <a href="CppMake.htm">make</a> it work in constant<br/>
/<a href="CppComment.htm">//</a> <a href="CppTime.htm">time</a>.<br/>
<a href="CppComment.htm">/*</a><br/>
Vertex getvertex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices, <a href="CppComment.htm">//</a>m_vertices<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> number<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> highorder()&nbsp;&nbsp; Create extra nodes <b><a href="CppFor.htm">for</a></b> quadratic subparametric elements.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> highorder(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> incircle(<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_incirclecount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> incircle()&nbsp;&nbsp; Return a positive value <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> pd lies inside the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;circle passing through pa, pb, and pc; a negative value <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it lies outside; and zero <b><a href="CppIf.htm">if</a></b> the four <a href="CppPointer.htm">point</a>s are cocircular.<a href="CppComment.htm">*/</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <a href="CppPointer.htm">point</a>s pa, pb, and pc must be in <a href="CppCounter.htm">counter</a>clockwise<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order, or the sign of the result will be reversed.<br/>
<br/>
/<a href="CppComment.htm">//</a> Uses exact arithmetic <b><a href="CppIf.htm">if</a></b> necessary to ensure a correct answer.&nbsp;&nbsp;The<br/>
/<a href="CppComment.htm">//</a> result <b><a href="CppReturn.htm">return</a></b>ed is the determinant of a <a href="CppMatrix.htm">matrix</a>.&nbsp;&nbsp;This determinant is<br/>
/<a href="CppComment.htm">//</a> computed adaptively, in the sense that exact arithmetic is used only to<br/>
/<a href="CppComment.htm">//</a> the degree it is needed to ensure that the <b><a href="CppReturn.htm">return</a></b>ed value has the<br/>
/<a href="CppComment.htm">//</a> correct sign.&nbsp;&nbsp;Hence, <b><a href="CppThis.htm">this</a></b> <a href="CppFunction.htm">function</a> is usually quite fast, but will run<br/>
/<a href="CppComment.htm">//</a> more slowly when the input <a href="CppPointer.htm">point</a>s are cocircular or nearly so.<br/>
<br/>
/<a href="CppComment.htm">//</a> See my Robust <a href="CppPredicate.htm">Predicate</a>s paper <b><a href="CppFor.htm">for</a></b> details.<br/>
<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> incircleadapt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> permanent<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> Form a Delaunay triangulation by incrementally<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inserting vertices.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns the number of edges on the convex hull of the triangulation.<br/>
<b><a href="CppInt.htm">int</a></b> incrementaldelaunay(Mesh&amp; m,<b><a href="CppConst.htm">const</a></b> Arguments&amp; b);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> infecthull()&nbsp;&nbsp; Virally infect all of the triangles of the convex hull<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that are not <b><a href="CppProtected.htm">protected</a></b> by subsegments.&nbsp;&nbsp;Where there are<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subsegments, set boundary markers as appropriate.<br/>
<b><a href="CppVoid.htm">void</a></b> infecthull(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> <a href="CppInitialize.htm">initialize</a>trisubpools()&nbsp;&nbsp; Calculate the sizes of the triangle and<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subsegment data structures and <a href="CppInitialize.htm">initialize</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; their <a href="CppMemory.htm">memory</a> pools.<br/>
/<a href="CppComment.htm">//</a> This routine also computes the `highorderindex', `elematt<a href="CppRibi.htm">ribi</a>ndex', and<br/>
/<a href="CppComment.htm">//</a> `areaboundindex' indices used to find values within each triangle.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppInitialize.htm">initialize</a>trisubpools(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
/<a href="CppComment.htm">//</a> <a href="CppInitialize.htm">initialize</a>vertexpool()&nbsp;&nbsp; Calculate the size of the vertex data structure<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and <a href="CppInitialize.htm">initialize</a> its <a href="CppMemory.htm">memory</a> pool.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This routine also computes the `vertexmarkindex' and `vertex2triindex'<br/>
/<a href="CppComment.htm">//</a> indices used to find values within each vertex.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppInitialize.htm">initialize</a>vertexpool(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
/<a href="CppComment.htm">//</a> insertsegment()&nbsp;&nbsp; Insert a PSLG segment into a triangulation.<br/>
<b><a href="CppVoid.htm">void</a></b> insertsegment(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Vertex endpoint1,<br/>
&nbsp;&nbsp;Vertex endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> insertsubseg()&nbsp;&nbsp; Create a <b><a href="CppNew.htm">new</a></b> subsegment and insert it between two<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles.<br/>
/<a href="CppComment.htm">//</a> The <b><a href="CppNew.htm">new</a></b> subsegment is inserted at the edge described by the handle<br/>
/<a href="CppComment.htm">//</a> `tri'.&nbsp;&nbsp;Its vertices are properly <a href="CppInitialize.htm">initialize</a>d.&nbsp;&nbsp;The marker `subsegmark'<br/>
/<a href="CppComment.htm">//</a> is applied to the subsegment and, <b><a href="CppIf.htm">if</a></b> appropriate, its vertices.<br/>
<b><a href="CppVoid.htm">void</a></b> insertsubseg(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; tri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subsegmark<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> insertvertex()&nbsp;&nbsp; Insert a vertex into a Delaunay triangulation,<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performing flips as necessary to maintain the Delaunay<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.<br/>
/<a href="CppComment.htm">//</a> The <a href="CppPointer.htm">point</a> `insertvertex' is located.&nbsp;&nbsp;If `searchtri.tri' is not <a href="CppNULL.htm">NULL</a>,<br/>
/<a href="CppComment.htm">//</a> the search <b><a href="CppFor.htm">for</a></b> the containing triangle begins from `searchtri'.&nbsp;&nbsp;If<br/>
/<a href="CppComment.htm">//</a> `searchtri.tri' is <a href="CppNULL.htm">NULL</a>, a full <a href="CppPointer.htm">point</a> location procedure is called.<br/>
/<a href="CppComment.htm">//</a> If `insertvertex' is found inside a triangle, the triangle is split into<br/>
/<a href="CppComment.htm">//</a> three; <b><a href="CppIf.htm">if</a></b> `insertvertex' lies on an edge, the edge is split in two,<br/>
/<a href="CppComment.htm">//</a> thereby splitting the two adjacent triangles into four.&nbsp;&nbsp;Edge flips are<br/>
/<a href="CppComment.htm">//</a> used to restore the Delaunay property.&nbsp;&nbsp;If `insertvertex' lies on an<br/>
/<a href="CppComment.htm">//</a> existing vertex, no action is taken, and the value DUPLICATEVERTEX is<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppReturn.htm">return</a></b>ed.&nbsp;&nbsp;On <b><a href="CppReturn.htm">return</a></b>, `searchtri' is set to a handle whose origin is the<br/>
/<a href="CppComment.htm">//</a> existing vertex.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Normally, the parameter `splitseg' is set to <a href="CppNULL.htm">NULL</a>, implying that no<br/>
/<a href="CppComment.htm">//</a> subsegment should be split.&nbsp;&nbsp;In <b><a href="CppThis.htm">this</a></b> <b><a href="CppCase.htm">case</a></b>, <b><a href="CppIf.htm">if</a></b> `insertvertex' is found to<br/>
/<a href="CppComment.htm">//</a> lie on a segment, no action is taken, and the value VIOLATINGVERTEX is<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppReturn.htm">return</a></b>ed.&nbsp;&nbsp;On <b><a href="CppReturn.htm">return</a></b>, `searchtri' is set to a handle whose primary edge<br/>
/<a href="CppComment.htm">//</a> is the violated subsegment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If the calling routine wishes to split a subsegment by inserting a<br/>
/<a href="CppComment.htm">//</a> vertex in it, the parameter `splitseg' should be that subsegment.&nbsp;&nbsp;In<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppThis.htm">this</a></b> <b><a href="CppCase.htm">case</a></b>, `searchtri' MUST be the triangle handle reached by pivoting<br/>
/<a href="CppComment.htm">//</a> from that subsegment; no <a href="CppPointer.htm">point</a> location is done.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> `segmentflaws' and `triflaws' are flags that indicate whether or not<br/>
/<a href="CppComment.htm">//</a> there should be checks <b><a href="CppFor.htm">for</a></b> the creation of encroached subsegments or bad<br/>
/<a href="CppComment.htm">//</a> quality triangles.&nbsp;&nbsp;If a newly inserted vertex encroaches upon<br/>
/<a href="CppComment.htm">//</a> subsegments, these subsegments are added to the list of subsegments to<br/>
/<a href="CppComment.htm">//</a> be split <b><a href="CppIf.htm">if</a></b> `segmentflaws' is set.&nbsp;&nbsp;If bad triangles are created, these<br/>
/<a href="CppComment.htm">//</a> are added to the queue <b><a href="CppIf.htm">if</a></b> `triflaws' is set.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If a duplicate vertex or violated segment does not prevent the vertex<br/>
/<a href="CppComment.htm">//</a> from being inserted, the <b><a href="CppReturn.htm">return</a></b> value will be ENCROACHINGVERTEX <b><a href="CppIf.htm">if</a></b> the<br/>
/<a href="CppComment.htm">//</a> vertex encroaches upon a subsegment (and checking is enabled), or<br/>
/<a href="CppComment.htm">//</a> SUCCESSFULVERTEX otherwise.&nbsp;&nbsp;In either <b><a href="CppCase.htm">case</a></b>, `searchtri' is set to a<br/>
/<a href="CppComment.htm">//</a> handle whose origin is the newly inserted vertex.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> insertvertex() does not use flip() <b><a href="CppFor.htm">for</a></b> reasons of speed; some<br/>
/<a href="CppComment.htm">//</a> information can be reused from edge flip to edge flip, like the<br/>
/<a href="CppComment.htm">//</a> locations of subsegments.<br/>
InsertVertexResult insertvertex(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; newvertex,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt;&amp; splitseg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> segmentflaws,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> triflaws<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> locate()&nbsp;&nbsp; Find a triangle or edge containing a given <a href="CppPointer.htm">point</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Searching begins from one of:&nbsp;&nbsp;the input `searchtri', a recently<br/>
/<a href="CppComment.htm">//</a> en<a href="CppCounter.htm">counter</a>ed triangle `recenttri', or from a triangle chosen from a<br/>
/<a href="CppComment.htm">//</a> random sample.&nbsp;&nbsp;The choice is made by determining which triangle's<br/>
/<a href="CppComment.htm">//</a> origin is closest to the <a href="CppPointer.htm">point</a> we are searching <b><a href="CppFor.htm">for</a></b>.&nbsp;&nbsp;Normally,<br/>
/<a href="CppComment.htm">//</a> `searchtri' should be a handle on the convex hull of the triangulation.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Details on the random sampling <a href="CppMemberFunction.htm">member function</a> can be found in the Mucke, Saias,<br/>
/<a href="CppComment.htm">//</a> and Zhu paper cited in the header of <b><a href="CppThis.htm">this</a></b> code.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> On completion, `searchtri' is a triangle that contains `search<a href="CppPointer.htm">point</a>'.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns ONVERTEX <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies on an existing vertex.&nbsp;&nbsp;`searchtri'<br/>
/<a href="CppComment.htm">//</a> is a handle whose origin is the existing vertex.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns ONEDGE <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies on a mesh edge.&nbsp;&nbsp;`searchtri' is a<br/>
/<a href="CppComment.htm">//</a> handle whose primary edge is the edge on which the <a href="CppPointer.htm">point</a> lies.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns INTRIANGLE <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies strictly within a triangle.<br/>
/<a href="CppComment.htm">//</a> `searchtri' is a handle on the triangle that contains the <a href="CppPointer.htm">point</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns OUTSIDE <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies outside the mesh.&nbsp;&nbsp;`searchtri' is a<br/>
/<a href="CppComment.htm">//</a> handle whose primary edge the <a href="CppPointer.htm">point</a> is to the right of.&nbsp;&nbsp;This might<br/>
/<a href="CppComment.htm">//</a> occur when the circumcenter of a triangle falls just slightly outside<br/>
/<a href="CppComment.htm">//</a> the mesh due to floating-<a href="CppPointer.htm">point</a> roundoff error.&nbsp;&nbsp;It also occurs when<br/>
/<a href="CppComment.htm">//</a> seeking a hole or region <a href="CppPointer.htm">point</a> that a foolish user has placed outside<br/>
/<a href="CppComment.htm">//</a> the mesh.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> WARNING:&nbsp;&nbsp;This routine is de<b><a href="CppSigned.htm">signed</a></b> <b><a href="CppFor.htm">for</a></b> convex triangulations, and will<br/>
/<a href="CppComment.htm">//</a> not generally work after the holes and concavities have been carved.<br/>
<br/>
<br/>
LocateResult locate(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a>,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri<br/>
);<br/>
<br/>
<a href="CppComment.htm">///</a>Create a <b><a href="CppNew.htm">new</a></b> subsegment with orientation zero.<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; <a href="CppMake.htm">make</a>subseg(<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppMake.htm">make</a>subseg(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; m_m_dummytri,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; m_m_dummysub<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub&amp; newsubseg<br/>
);<br/>
<br/>
<a href="CppComment.htm">///</a>Create a <b><a href="CppNew.htm">new</a></b> triangle with orientation zero.<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Otri&gt; <a href="CppMake.htm">make</a>triangle(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; m_m_dummytri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; m_m_dummysub,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_m_eextras,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_vararea<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; newotri<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> <a href="CppMake.htm">make</a>vertexmap()&nbsp;&nbsp; <a href="CppConstructor.htm">Construct</a> a mapping from vertices to triangles to<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; improve the speed of <a href="CppPointer.htm">point</a> location <b><a href="CppFor.htm">for</a></b> segment<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insertion.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Traverses all the triangles, and provides each corner of each triangle<br/>
/<a href="CppComment.htm">//</a> with a <a href="CppPointer.htm">pointer</a> to that triangle.&nbsp;&nbsp;Of course, <a href="CppPointer.htm">pointer</a>s will be<br/>
/<a href="CppComment.htm">//</a> overwritten by other <a href="CppPointer.htm">pointer</a>s because (almost) each vertex is a corner<br/>
/<a href="CppComment.htm">//</a> of several triangles, but in the end every vertex will <a href="CppPointer.htm">point</a> to some<br/>
/<a href="CppComment.htm">//</a> triangle that contains it.<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppMake.htm">make</a>vertexmap(<br/>
&nbsp;&nbsp;Mesh&amp; m<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
<a href="CppComment.htm">///</a>Cover the convex hull of a triangulation with subsegments.<br/>
<b><a href="CppVoid.htm">void</a></b> markhull(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> Merge two adjacent Delaunay triangulations into a<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single Delaunay triangulation.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This is similar to the <a href="CppAlgorithm.htm">algorithm</a> given by Guibas and Stolfi, but uses<br/>
/<a href="CppComment.htm">//</a> a triangle-based, rather than edge-based, data structure.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The <a href="CppAlgorithm.htm">algorithm</a> walks up the gap between the two triangulations, knitting<br/>
/<a href="CppComment.htm">//</a> them together.&nbsp;&nbsp;As they are merged, some of their bounding triangles<br/>
/<a href="CppComment.htm">//</a> are <a href="CppConvert.htm">convert</a>ed into real triangles of the triangulation.&nbsp;&nbsp;The procedure<br/>
/<a href="CppComment.htm">//</a> pulls each hull's bounding triangles apart, then knits them together<br/>
/<a href="CppComment.htm">//</a> like the teeth of two gears.&nbsp;&nbsp;The Delaunay property determines, at each<br/>
/<a href="CppComment.htm">//</a> step, whether the next "tooth" is a bounding triangle of the left hull<br/>
/<a href="CppComment.htm">//</a> or the right.&nbsp;&nbsp;When a bounding triangle becomes real, its apex is<br/>
/<a href="CppComment.htm">//</a> changed from <a href="CppNULL.htm">NULL</a> to a real vertex.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Only two <b><a href="CppNew.htm">new</a></b> triangles need to be allocated.&nbsp;&nbsp;These become <b><a href="CppNew.htm">new</a></b> bounding<br/>
/<a href="CppComment.htm">//</a> triangles at the top and bottom of the seam.&nbsp;&nbsp;They are used to connect<br/>
/<a href="CppComment.htm">//</a> the remaining bounding triangles (those that have not been <a href="CppConvert.htm">convert</a>ed<br/>
/<a href="CppComment.htm">//</a> into real triangles) into a single fan.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> On entry, `farleft' and `innerleft' are bounding triangles of the left<br/>
/<a href="CppComment.htm">//</a> triangulation.&nbsp;&nbsp;The origin of `farleft' is the leftmost vertex, and<br/>
/<a href="CppComment.htm">//</a> the destination of `innerleft' is the rightmost vertex of the<br/>
/<a href="CppComment.htm">//</a> triangulation.&nbsp;&nbsp;Similarly, `innerright' and `farright' are bounding<br/>
/<a href="CppComment.htm">//</a> triangles of the right triangulation.&nbsp;&nbsp;The origin of `innerright' and<br/>
/<a href="CppComment.htm">//</a> destination of `farright' are the leftmost and rightmost vertices.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> On completion, the origin of `farleft' is the leftmost vertex of the<br/>
/<a href="CppComment.htm">//</a> merged triangulation, and the destination of `farright' is the rightmost<br/>
/<a href="CppComment.htm">//</a> vertex.<br/>
<b><a href="CppVoid.htm">void</a></b> mergehulls(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farleft,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; innerleft,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; innerright,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farright,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axis<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> Return a positive value <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> pd is incompatible<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with the circle or plane passing through pa, pb, and pc<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(meaning that pd is inside the circle or below the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plane); a negative value <b><a href="CppIf.htm">if</a></b> it is compatible; and zero <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the four <a href="CppPointer.htm">point</a>s are cocircular/coplanar.&nbsp;&nbsp;The <a href="CppPointer.htm">point</a>s pa,<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pb, and pc must be in <a href="CppCounter.htm">counter</a>clockwise order, or the sign<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of the result will be reversed.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If the <a href="CppOperatorMinus.htm">-</a>w <b><a href="CppSwitch.htm">switch</a></b> is used, the <a href="CppPointer.htm">point</a>s are lifted onto the parabolic<br/>
/<a href="CppComment.htm">//</a> lifting map, then they are dropped according to their weights, then the<br/>
/<a href="CppComment.htm">//</a> 3D orientation test is applied.&nbsp;&nbsp;If the <a href="CppOperatorMinus.htm">-</a>W <b><a href="CppSwitch.htm">switch</a></b> is used, the <a href="CppPointer.htm">point</a>s'<br/>
/<a href="CppComment.htm">//</a> heights are already provided, so the 3D orientation test is applied<br/>
/<a href="CppComment.htm">//</a> directly.&nbsp;&nbsp;If neither <b><a href="CppSwitch.htm">switch</a></b> is used, the incircle test is applied.<br/>
<b><a href="CppDouble.htm">double</a></b> nonregular(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_incirclecount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> Number the vertices.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Each vertex is as<b><a href="CppSigned.htm">signed</a></b> a marker equal to its number.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Used when writenodes() is not called because no .node file is written.<br/>
<b><a href="CppVoid.htm">void</a></b> numbernodes(Mesh&amp; m, <b><a href="CppConst.htm">const</a></b> Arguments&amp; b);<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> orient3d(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_orient3dcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> aheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dheight<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> Return a positive value <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> pd lies below the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plane passing through pa, pb, and pc; "below" is defined so<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that pa, pb, and pc appear in <a href="CppCounter.htm">counter</a>clockwise order when<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewed from above the plane.&nbsp;&nbsp;Returns a negative value <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pd lies above the plane.&nbsp;&nbsp;Returns zero <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a>s are<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coplanar.&nbsp;&nbsp;The result is also a rough approximation of six<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppTime.htm">time</a>s the <b><a href="CppSigned.htm">signed</a></b> volume of the tetrahedron defined by the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;four <a href="CppPointer.htm">point</a>s.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Uses exact arithmetic <b><a href="CppIf.htm">if</a></b> necessary to ensure a correct answer.&nbsp;&nbsp;The<br/>
/<a href="CppComment.htm">//</a> result <b><a href="CppReturn.htm">return</a></b>ed is the determinant of a <a href="CppMatrix.htm">matrix</a>.&nbsp;&nbsp;This determinant is<br/>
/<a href="CppComment.htm">//</a> computed adaptively, in the sense that exact arithmetic is used only to<br/>
/<a href="CppComment.htm">//</a> the degree it is needed to ensure that the <b><a href="CppReturn.htm">return</a></b>ed value has the<br/>
/<a href="CppComment.htm">//</a> correct sign.&nbsp;&nbsp;Hence, <b><a href="CppThis.htm">this</a></b> <a href="CppFunction.htm">function</a> is usually quite fast, but will run<br/>
/<a href="CppComment.htm">//</a> more slowly when the input <a href="CppPointer.htm">point</a>s are coplanar or nearly so.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> See my Robust <a href="CppPredicate.htm">Predicate</a>s paper <b><a href="CppFor.htm">for</a></b> details.<br/>
<b><a href="CppDouble.htm">double</a></b> orient3dadapt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> aheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> permanent<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> Spread the virus from all infected triangles to <a href="CppAny.htm">any</a> neighbors<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not <b><a href="CppProtected.htm">protected</a></b> by subsegments.&nbsp;&nbsp;Delete all infected triangles.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This is the procedure that actually creates holes and concavities.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This procedure operates in two phases.&nbsp;&nbsp;The first phase identifies all<br/>
/<a href="CppComment.htm">//</a> the triangles that will die, and marks them as infected.&nbsp;&nbsp;They are<br/>
/<a href="CppComment.htm">//</a> marked to ensure that each triangle is added to the virus pool only<br/>
/<a href="CppComment.htm">//</a> once, so the procedure will terminate.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The second phase actually eliminates the infected triangles.&nbsp;&nbsp;It also<br/>
/<a href="CppComment.htm">//</a> eliminates orphaned vertices.<br/>
<b><a href="CppVoid.htm">void</a></b> plague(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> Find a triangle or edge containing a given <a href="CppPointer.htm">point</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Begins its search from `searchtri'.&nbsp;&nbsp;It is important that `searchtri'<br/>
/<a href="CppComment.htm">//</a> be a handle with the property that `search<a href="CppPointer.htm">point</a>' is strictly to the left<br/>
/<a href="CppComment.htm">//</a> of the edge denoted by `searchtri', or is collinear with that edge and<br/>
/<a href="CppComment.htm">//</a> does not intersect that edge.&nbsp;&nbsp;(In particular, `search<a href="CppPointer.htm">point</a>' should not<br/>
/<a href="CppComment.htm">//</a> be the origin or destination of that edge.)<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> These conditions are imposed because preciselocate() is normally used in<br/>
/<a href="CppComment.htm">//</a> one of two situations:<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> (1)&nbsp;&nbsp;To <b><a href="CppTry.htm">try</a></b> to find the location to insert a <b><a href="CppNew.htm">new</a></b> <a href="CppPointer.htm">point</a>.&nbsp;&nbsp;Normally, we<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;know an edge that the <a href="CppPointer.htm">point</a> is strictly to the left of.&nbsp;&nbsp;In the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incremental Delaunay <a href="CppAlgorithm.htm">algorithm</a>, that edge is a bounding box edge.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In Ruppert's Delaunay refinement <a href="CppAlgorithm.htm">algorithm</a> <b><a href="CppFor.htm">for</a></b> quality meshing,<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that edge is the shortest edge of the triangle whose circumcenter<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is being inserted.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> (2)&nbsp;&nbsp;To <b><a href="CppTry.htm">try</a></b> to find an existing <a href="CppPointer.htm">point</a>.&nbsp;&nbsp;In <b><a href="CppThis.htm">this</a></b> <b><a href="CppCase.htm">case</a></b>, <a href="CppAny.htm">any</a> edge on the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convex hull is a good starting edge.&nbsp;&nbsp;You must screen out the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibility that the vertex sought is an endpoint of the starting<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge before you call preciselocate().<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> On completion, `searchtri' is a triangle that contains `search<a href="CppPointer.htm">point</a>'.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This implementation differs from that given by Guibas and Stolfi.&nbsp;&nbsp;It<br/>
/<a href="CppComment.htm">//</a> walks from triangle to triangle, crossing an edge only <b><a href="CppIf.htm">if</a></b> `search<a href="CppPointer.htm">point</a>'<br/>
/<a href="CppComment.htm">//</a> is on the other side of the line containing that edge.&nbsp;&nbsp;After entering<br/>
/<a href="CppComment.htm">//</a> a triangle, there are two edges by which one can leave that triangle.<br/>
/<a href="CppComment.htm">//</a> If both edges are valid (`search<a href="CppPointer.htm">point</a>' is on the other side of both<br/>
/<a href="CppComment.htm">//</a> edges), one of the two is chosen by drawing a line perpendicular to<br/>
/<a href="CppComment.htm">//</a> the entry edge (whose endpoints are `forg' and `fdest') passing through<br/>
/<a href="CppComment.htm">//</a> `fapex'.&nbsp;&nbsp;Depending on which side of <b><a href="CppThis.htm">this</a></b> perpendicular `search<a href="CppPointer.htm">point</a>'<br/>
/<a href="CppComment.htm">//</a> falls on, an exit edge is chosen.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This implementation is empirically faster than the Guibas and Stolfi<br/>
/<a href="CppComment.htm">//</a> <a href="CppPointer.htm">point</a> location routine (which I originally used), which tends to spiral<br/>
/<a href="CppComment.htm">//</a> in toward its target.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns ONVERTEX <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies on an existing vertex.&nbsp;&nbsp;`searchtri'<br/>
/<a href="CppComment.htm">//</a> is a handle whose origin is the existing vertex.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns ONEDGE <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies on a mesh edge.&nbsp;&nbsp;`searchtri' is a<br/>
/<a href="CppComment.htm">//</a> handle whose primary edge is the edge on which the <a href="CppPointer.htm">point</a> lies.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns INTRIANGLE <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies strictly within a triangle.<br/>
/<a href="CppComment.htm">//</a> `searchtri' is a handle on the triangle that contains the <a href="CppPointer.htm">point</a>.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns OUTSIDE <b><a href="CppIf.htm">if</a></b> the <a href="CppPointer.htm">point</a> lies outside the mesh.&nbsp;&nbsp;`searchtri' is a<br/>
/<a href="CppComment.htm">//</a> handle whose primary edge the <a href="CppPointer.htm">point</a> is to the right of.&nbsp;&nbsp;This might<br/>
/<a href="CppComment.htm">//</a> occur when the circumcenter of a triangle falls just slightly outside<br/>
/<a href="CppComment.htm">//</a> the mesh due to floating-<a href="CppPointer.htm">point</a> roundoff error.&nbsp;&nbsp;It also occurs when<br/>
/<a href="CppComment.htm">//</a> seeking a hole or region <a href="CppPointer.htm">point</a> that a foolish user has placed outside<br/>
/<a href="CppComment.htm">//</a> the mesh.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If `stopatsubsegment' is nonzero, the search will stop <b><a href="CppIf.htm">if</a></b> it tries to<br/>
/<a href="CppComment.htm">//</a> walk through a subsegment, and will <b><a href="CppReturn.htm">return</a></b> OUTSIDE.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> WARNING:&nbsp;&nbsp;This routine is de<b><a href="CppSigned.htm">signed</a></b> <b><a href="CppFor.htm">for</a></b> convex triangulations, and will<br/>
/<a href="CppComment.htm">//</a> not generally work after the holes and concavities have been carved.<br/>
/<a href="CppComment.htm">//</a> However, it can still be used to find the circumcenter of a triangle, as<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppLong.htm">long</a></b> as the search is begun from the triangle in <a href="CppQuestion.htm">question</a>.<br/>
LocateResult preciselocate(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> m_m_checksegments,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> stopatsubsegment<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> printsubseg()&nbsp;&nbsp; Print out the details of an oriented subsegment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> I originally wrote <b><a href="CppThis.htm">this</a></b> procedure to simplify <a href="CppDebug.htm">debugging</a>; it can be<br/>
/<a href="CppComment.htm">//</a> called directly from the <a href="CppDebug.htm">debug</a>ger, and presents information <a href="CppAbout.htm">about</a> an<br/>
/<a href="CppComment.htm">//</a> oriented subsegment in digestible form.&nbsp;&nbsp;It's also used when the highest<br/>
/<a href="CppComment.htm">//</a> level of verbosity (`-VVV') is specified.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> printsubseg(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> SubSeg * <b><a href="CppConst.htm">const</a></b> m_dummysub,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Triangle * <b><a href="CppConst.htm">const</a></b> m_dummytri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Osub&amp; s<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
/<a href="CppComment.htm">//</a> printtriangle()&nbsp;&nbsp; Print out the details of an oriented triangle.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> I originally wrote <b><a href="CppThis.htm">this</a></b> procedure to simplify <a href="CppDebug.htm">debugging</a>; it can be<br/>
/<a href="CppComment.htm">//</a> called directly from the <a href="CppDebug.htm">debug</a>ger, and presents information <a href="CppAbout.htm">about</a> an<br/>
/<a href="CppComment.htm">//</a> oriented triangle in digestible form.&nbsp;&nbsp;It's also used when the<br/>
/<a href="CppComment.htm">//</a> highest level of verbosity (`-VVV') is specified.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> printtriangle(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> t<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> quality_statistics(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> readholes()&nbsp;&nbsp; Read the holes, and possibly regional attributes and area<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constraints, from a .poly file.<br/>
<b><a href="CppVoid.htm">void</a></b> readholes(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Mesh * <b><a href="CppConst.htm">const</a></b> <a href="CppComment.htm">/*</a> m <a href="CppComment.htm">*/</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> polyfile,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> polyfilename,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b> &gt;&amp; hlist, <a href="CppComment.htm">//</a>hole list<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ** <b><a href="CppConst.htm">const</a></b> hlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> * <b><a href="CppConst.htm">const</a></b> holes,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; rlist <a href="CppComment.htm">//</a>region list<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ** <b><a href="CppConst.htm">const</a></b> rlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> *regions<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> readnodes()&nbsp;&nbsp; Read the vertices from a file, which may be a .node or<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .poly file.<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> ReadVertices(<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> ReadNodes(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> re<a href="CppConstructor.htm">construct</a>()&nbsp;&nbsp; Re<a href="CppConstructor.htm">construct</a> a triangulation from its .ele (and possibly<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .poly) file.&nbsp;&nbsp;Used when the <a href="CppOperatorMinus.htm">-</a>r <b><a href="CppSwitch.htm">switch</a></b> is used.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Reads an .ele file and re<a href="CppConstructor.htm">construct</a>s the original mesh.&nbsp;&nbsp;If the <a href="CppOperatorMinus.htm">-</a>p <b><a href="CppSwitch.htm">switch</a></b><br/>
/<a href="CppComment.htm">//</a> is used, <b><a href="CppThis.htm">this</a></b> procedure will also read a .poly file and re<a href="CppConstructor.htm">construct</a> the<br/>
/<a href="CppComment.htm">//</a> subsegments of the original mesh.&nbsp;&nbsp;If the <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b> is used, <b><a href="CppThis.htm">this</a></b><br/>
/<a href="CppComment.htm">//</a> procedure will also read an .area file and set a maximum area constraint<br/>
/<a href="CppComment.htm">//</a> on each triangle.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Vertices that are not corners of triangles, such as nodes on edges of<br/>
/<a href="CppComment.htm">//</a> subparametric elements, are discarded.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This routine finds the adjacencies between triangles (and subsegments)<br/>
/<a href="CppComment.htm">//</a> by forming one stack of triangles <b><a href="CppFor.htm">for</a></b> each vertex.&nbsp;&nbsp;Each triangle is on<br/>
/<a href="CppComment.htm">//</a> three different stacks simultaneously.&nbsp;&nbsp;Each triangle's subsegment<br/>
/<a href="CppComment.htm">//</a> <a href="CppPointer.htm">pointer</a>s are used to <a href="CppLink.htm">link</a> the items in each stack.&nbsp;&nbsp;This <a href="CppMemory.htm">memory</a>-saving<br/>
/<a href="CppComment.htm">//</a> feature <a href="CppMake.htm">make</a>s the code harder to read.&nbsp;&nbsp;The most important thing to keep<br/>
/<a href="CppComment.htm">//</a> in mind is that each triangle is removed from a stack precisely when<br/>
/<a href="CppComment.htm">//</a> the corresponding <a href="CppPointer.htm">pointer</a> is adjusted to refer to a subsegment rather<br/>
/<a href="CppComment.htm">//</a> than the next triangle of the stack.<br/>
<b><a href="CppLong.htm">long</a></b> ReadSubSegs(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; elefilename,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; areafilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> polyfile<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> regionplague()&nbsp;&nbsp; Spread regional attributes and/or area constraints<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(from a .poly file) throughout the mesh.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This procedure operates in two phases.&nbsp;&nbsp;The first phase spreads an<br/>
/<a href="CppComment.htm">//</a> attribute and/or an area constraint through a (segment-bounded) region.<br/>
/<a href="CppComment.htm">//</a> The triangles are marked to ensure that each triangle is added to the<br/>
/<a href="CppComment.htm">//</a> virus pool only once, so the procedure will terminate.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The second phase uninfects all infected triangles, <b><a href="CppReturn.htm">return</a></b>ing them to<br/>
/<a href="CppComment.htm">//</a> normal.<br/>
<b><a href="CppVoid.htm">void</a></b> regionplague(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> attribute,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> area<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> removebox()&nbsp;&nbsp; Remove the "infinite" bounding triangle, setting boundary<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; markers as appropriate.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The triangular bounding box has three boundary triangles (one <b><a href="CppFor.htm">for</a></b> each<br/>
/<a href="CppComment.htm">//</a> side of the bounding box), and a bunch of triangles fanning out from<br/>
/<a href="CppComment.htm">//</a> the three bounding box vertices (one triangle <b><a href="CppFor.htm">for</a></b> each edge of the<br/>
/<a href="CppComment.htm">//</a> convex hull of the inner mesh).&nbsp;&nbsp;This routine removes these triangles.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns the number of edges on the convex hull of the triangulation.<br/>
<b><a href="CppLong.htm">long</a></b> removebox(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> removeghosts(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; startghost<br/>
);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> rightofhyperbola(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_hyperbolacount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> fronttri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; newsite<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> scale_expansion_zeroelim()&nbsp;&nbsp; <a href="CppMultiply.htm">Multiply</a> an expansion by a scalar,<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eliminating zero <a href="CppComponent.htm">component</a>s from the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output expansion.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Sets h <a href="CppOperatorAssign.htm">=</a> be.&nbsp;&nbsp;See my Robust <a href="CppPredicate.htm">Predicate</a>s paper <b><a href="CppFor.htm">for</a></b> details.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Maintains the nonoverlapping property.&nbsp;&nbsp;If round-to-even is used (as<br/>
/<a href="CppComment.htm">//</a> with IEEE 754), maintains the s<a href="GameTronCollection.htm">tron</a>gly nonoverlapping and nonadjacent<br/>
/<a href="CppComment.htm">//</a> properties as well.&nbsp;&nbsp;(That is, <b><a href="CppIf.htm">if</a></b> e has one of these properties, so<br/>
/<a href="CppComment.htm">//</a> will h.)<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> scale_expansion_zeroelim(<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> scale_expansion_zeroelim(<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> scale_expansion_zeroelim(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> e,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; e,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b>&amp; h<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> h<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> scoutsegment()&nbsp;&nbsp; Scout the first triangle on the path from one endpoint<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to another, and check <b><a href="CppFor.htm">for</a></b> completion (reaching the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second endpoint), a collinear vertex, or the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersection of two segments.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Returns one <b><a href="CppIf.htm">if</a></b> the entire segment is successfully inserted, and zero <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a> the job must be finished by conformingedge() or constrainededge().<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If the first triangle on the path has the second endpoint as its<br/>
/<a href="CppComment.htm">//</a> destination or apex, a subsegment is inserted and the job is done.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If the first triangle on the path has a destination or apex that lies on<br/>
/<a href="CppComment.htm">//</a> the segment, a subsegment is inserted connecting the first endpoint to<br/>
/<a href="CppComment.htm">//</a> the collinear vertex, and the search is <b><a href="CppContinue.htm">continue</a></b>d from the collinear<br/>
/<a href="CppComment.htm">//</a> vertex.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> If the first triangle on the path has a subsegment opposite its origin,<br/>
/<a href="CppComment.htm">//</a> then there is a segment that intersects the segment being inserted.<br/>
/<a href="CppComment.htm">//</a> Their intersection vertex is inserted, splitting the subsegment.<br/>
<b><a href="CppInt.htm">int</a></b> scoutsegment(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> segmentintersection()&nbsp;&nbsp; Find the intersection of an existing segment<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and a segment that is being inserted.&nbsp;&nbsp;Insert<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a vertex at the intersection, splitting an<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; existing subsegment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The segment being inserted connects the apex of splittri to endpoint2.<br/>
/<a href="CppComment.htm">//</a> splitsubseg is the subsegment being split, and MUST adjoin splittri.<br/>
/<a href="CppComment.htm">//</a> Hence, endpoints of the subsegment being split are the origin and<br/>
/<a href="CppComment.htm">//</a> destination of splittri.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> On completion, splittri is a handle having the newly inserted<br/>
/<a href="CppComment.htm">//</a> intersection <a href="CppPointer.htm">point</a> as its origin, and endpoint1 as its destination.<br/>
<b><a href="CppVoid.htm">void</a></b> segmentintersection(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; splittri,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt;&amp; splitsubseg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; endpoint2<br/>
);<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt;&amp; splaytree,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a>,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri<br/>
);<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splayinsert(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splayroot,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; newkey,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a><br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> splitencsegs()&nbsp;&nbsp; Split all the encroached subsegments.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Each encroached subsegment is repaired by splitting it <a href="CppOperatorMinus.htm">-</a> inserting a<br/>
/<a href="CppComment.htm">//</a> vertex at or near its mid<a href="CppPointer.htm">point</a>.&nbsp;&nbsp;Newly inserted vertices may encroach<br/>
/<a href="CppComment.htm">//</a> upon other subsegments; these are also repaired.<br/>
<a href="CppComment.htm">//</a><br/>
/<a href="CppComment.htm">//</a> `triflaws' is a flag that specifies whether one should take note of <b><a href="CppNew.htm">new</a></b><br/>
/<a href="CppComment.htm">//</a> bad triangles that result from inserting vertices to repair encroached<br/>
/<a href="CppComment.htm">//</a> subsegments.<br/>
<b><a href="CppVoid.htm">void</a></b> splitencsegs(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> triflaws<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> splittriangle()&nbsp;&nbsp; Inserts a vertex at the circumcenter of a triangle.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Deletes the newly inserted vertex <b><a href="CppIf.htm">if</a></b> it encroaches<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upon a segment.<br/>
<b><a href="CppVoid.htm">void</a></b> splittriangle(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt;&amp; badtri<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> statistics()&nbsp;&nbsp; Print all sorts of cool facts.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> statistics(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
/<a href="CppComment.htm">//</a> subsegdealloc()&nbsp;&nbsp; Deallocate space <b><a href="CppFor.htm">for</a></b> a subsegment, marking it dead.<br/>
<b><a href="CppVoid.htm">void</a></b> subsegdealloc(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; dyingsubseg<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> subsegtraverse()&nbsp;&nbsp; Traverse the subsegments, skipping dead ones.<br/>
<a href="CppComment.htm">//</a>SubSeg *subsegtraverse(Mesh&amp; m);<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> sweeplinedelaunay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> tallyencs()&nbsp;&nbsp; Traverse the entire list of subsegments, and check each<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to see <b><a href="CppIf.htm">if</a></b> it is encroached.&nbsp;&nbsp;If so, add it to the list.<br/>
<b><a href="CppVoid.htm">void</a></b> tallyencs(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> tallyfaces()&nbsp;&nbsp; Test every triangle in the mesh <b><a href="CppFor.htm">for</a></b> quality measures.<br/>
<b><a href="CppVoid.htm">void</a></b> tallyfaces(Mesh&amp; m,<b><a href="CppConst.htm">const</a></b> Arguments&amp; b);<br/>
<br/>
/<a href="CppComment.htm">//</a> testtriangle()&nbsp;&nbsp; Test a triangle <b><a href="CppFor.htm">for</a></b> quality and size.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Tests a triangle to see <b><a href="CppIf.htm">if</a></b> it satisfies the minimum angle condition and<br/>
/<a href="CppComment.htm">//</a> the maximum area condition.&nbsp;&nbsp;Triangles that aren't up to spec are added<br/>
/<a href="CppComment.htm">//</a> to the bad triangle queue.<br/>
<b><a href="CppVoid.htm">void</a></b> testtriangle(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; testtri<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> <a href="CppMain.htm">main</a>() or triangulate()&nbsp;&nbsp; Gosh, <b><a href="CppDo.htm">do</a></b> everything.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The sequence is roughly as follows.&nbsp;&nbsp;M<a href="CppAny.htm">any</a> of these steps can be skipped,<br/>
/<a href="CppComment.htm">//</a> depending on the command line <b><a href="CppSwitch.htm">switch</a></b>es.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> <a href="CppInitialize.htm">Initialize</a> constants and parse the command line.<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Read the vertices from a file and either<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppOperatorMinus.htm">-</a> triangulate them (no <a href="CppOperatorMinus.htm">-</a>r), or<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppOperatorMinus.htm">-</a> read an old mesh from files and re<a href="CppConstructor.htm">construct</a> it (-r).<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Insert the PSLG segments (-p), and possibly segments on the convex<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; hull (-c).<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Read the holes (-p), regional attributes (-pA), and regional area<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; constraints (-pa).&nbsp;&nbsp;Carve the holes and concavities, and spread the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; regional attributes and area constraints.<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Enforce the constraints on minimum angle (-q) and maximum area (-a).<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp; Also enforce the conforming Delaunay property (-q and <a href="CppOperatorMinus.htm">-</a>a).<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Compute the number of edges in the resulting mesh.<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Promote the mesh's linear triangles to higher order elements (-o).<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Write the output files and print the statistics.<br/>
/<a href="CppComment.htm">//</a> <a href="CppOperatorMinus.htm">-</a> Check the consistency and Delaunay property of the mesh (-C).<br/>
<b><a href="CppInt.htm">int</a></b> triangle_cpp_main(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> triangledealloc()&nbsp;&nbsp; Deallocate space <b><a href="CppFor.htm">for</a></b> a triangle, marking it dead.<br/>
<b><a href="CppVoid.htm">void</a></b> triangledealloc(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; m_m_triangles,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; dyingtriangle<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> triangledeinit()&nbsp;&nbsp; Free all remaining allocated <a href="CppMemory.htm">memory</a>.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> triangledeinit(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
/<a href="CppComment.htm">//</a> triangletraverse()&nbsp;&nbsp; Traverse the triangles, skipping dead ones.<br/>
<a href="CppComment.htm">//</a>Triangle * triangletraverse(Mesh&amp; m);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> triangulate(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> ,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> TriangulateIo * <b><a href="CppConst.htm">const</a></b> ,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> TriangulateIo * <b><a href="CppConst.htm">const</a></b> ,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> TriangulateIo * <b><a href="CppConst.htm">const</a></b><br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> triangulatepolygon()&nbsp;&nbsp; Find the Delaunay triangulation of a polygon that<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has a certain "nice" <a href="CppShape.htm">shape</a>.&nbsp;&nbsp;This includes the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polygons that result from deletion of a vertex or<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertion of a segment.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> This is a conceptually difficult routine.&nbsp;&nbsp;The starting assumption is<br/>
/<a href="CppComment.htm">//</a> that we have a polygon with n sides.&nbsp;&nbsp;n <a href="CppOperatorMinus.htm">-</a> 1 of these sides are currently<br/>
/<a href="CppComment.htm">//</a> represented as edges in the mesh.&nbsp;&nbsp;One side, called the "base", need not<br/>
/<a href="CppComment.htm">//</a> be.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Inside the polygon is a structure I call a "fan", consisting of n <a href="CppOperatorMinus.htm">-</a> 1<br/>
/<a href="CppComment.htm">//</a> triangles that share a common origin.&nbsp;&nbsp;For each of these triangles, the<br/>
/<a href="CppComment.htm">//</a> edge opposite the origin is one of the sides of the polygon.&nbsp;&nbsp;The<br/>
/<a href="CppComment.htm">//</a> primary edge of each triangle is the edge directed from the origin to<br/>
/<a href="CppComment.htm">//</a> the destination; note that <b><a href="CppThis.htm">this</a></b> is not the same edge that is a side of<br/>
/<a href="CppComment.htm">//</a> the polygon.&nbsp;&nbsp;`firstedge' is the primary edge of the first triangle.<br/>
/<a href="CppComment.htm">//</a> From there, the triangles follow in <a href="CppCounter.htm">counter</a>clockwise order <a href="CppAbout.htm">about</a> the<br/>
/<a href="CppComment.htm">//</a> polygon, until `lastedge', the primary edge of the last triangle.<br/>
/<a href="CppComment.htm">//</a> `firstedge' and `lastedge' are probably connected to other triangles<br/>
/<a href="CppComment.htm">//</a> beyond the extremes of the fan, but their identity is not important, as<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppLong.htm">long</a></b> as the fan remains connected to them.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Imagine the polygon oriented so that its base is at the bottom.&nbsp;&nbsp;This<br/>
/<a href="CppComment.htm">//</a> puts `firstedge' on the far right, and `lastedge' on the far left.<br/>
/<a href="CppComment.htm">//</a> The right vertex of the base is the destination of `firstedge', and the<br/>
/<a href="CppComment.htm">//</a> left vertex of the base is the apex of `lastedge'.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The challenge now is to find the right sequence of edge flips to<br/>
/<a href="CppComment.htm">//</a> transform the fan into a Delaunay triangulation of the polygon.&nbsp;&nbsp;Each<br/>
/<a href="CppComment.htm">//</a> edge flip effectively removes one triangle from the fan, committing it<br/>
/<a href="CppComment.htm">//</a> to the polygon.&nbsp;&nbsp;The resulting polygon has one fewer edge.&nbsp;&nbsp;If `doflip'<br/>
/<a href="CppComment.htm">//</a> is set, the <b><a href="CppFinal.htm">final</a></b> flip will be performed, resulting in a fan of one<br/>
/<a href="CppComment.htm">//</a> (useless?) triangle.&nbsp;&nbsp;If `doflip' is not set, the <b><a href="CppFinal.htm">final</a></b> flip is not<br/>
/<a href="CppComment.htm">//</a> performed, resulting in a fan of two triangles, and an unfinished<br/>
/<a href="CppComment.htm">//</a> triangular polygon that is not yet filled out with a single triangle.<br/>
/<a href="CppComment.htm">//</a> On completion of the routine, `lastedge' is the last remaining triangle,<br/>
/<a href="CppComment.htm">//</a> or the leftmost of the last two.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Although the flips are performed in the order described above, the<br/>
/<a href="CppComment.htm">//</a> decisions <a href="CppAbout.htm">about</a> what flips to perform are made in precisely the reverse<br/>
/<a href="CppComment.htm">//</a> order.&nbsp;&nbsp;The recursive triangulatepolygon() procedure <a href="CppMake.htm">make</a>s a decision,<br/>
/<a href="CppComment.htm">//</a> uses up to two recursive calls to triangulate the "subproblems"<br/>
/<a href="CppComment.htm">//</a> (polygons with fewer edges), and then performs an edge flip.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The "decision" it <a href="CppMake.htm">make</a>s is which vertex of the polygon should be<br/>
/<a href="CppComment.htm">//</a> connected to the base.&nbsp;&nbsp;This decision is made by testing every possible<br/>
/<a href="CppComment.htm">//</a> vertex.&nbsp;&nbsp;Once the best vertex is found, the two edges that connect <b><a href="CppThis.htm">this</a></b><br/>
/<a href="CppComment.htm">//</a> vertex to the base become the bases <b><a href="CppFor.htm">for</a></b> two smaller polygons.&nbsp;&nbsp;These<br/>
/<a href="CppComment.htm">//</a> are triangulated recursively.&nbsp;&nbsp;Unfortunately, <b><a href="CppThis.htm">this</a></b> approach can take<br/>
/<a href="CppComment.htm">//</a> O(n^2) <a href="CppTime.htm">time</a> not only in the worst <b><a href="CppCase.htm">case</a></b>, but in many common <b><a href="CppCase.htm">case</a></b>s.&nbsp;&nbsp;It's<br/>
/<a href="CppComment.htm">//</a> rarely a big deal <b><a href="CppFor.htm">for</a></b> vertex deletion, where n is rarely larger than<br/>
/<a href="CppComment.htm">//</a> ten, but it could be a big deal <b><a href="CppFor.htm">for</a></b> segment insertion, especially <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a> there's a lot of <b><a href="CppLong.htm">long</a></b> segments that each cut many triangles.&nbsp;&nbsp;I ought to<br/>
/<a href="CppComment.htm">//</a> code a faster <a href="CppAlgorithm.htm">algorithm</a> some day.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The `edgecount' parameter is the number of sides of the polygon,<br/>
/<a href="CppComment.htm">//</a> including its base.&nbsp;&nbsp;`triflaws' is a flag that determines whether the<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppNew.htm">new</a></b> triangles should be tested <b><a href="CppFor.htm">for</a></b> quality, and enqueued <b><a href="CppIf.htm">if</a></b> they are<br/>
/<a href="CppComment.htm">//</a> bad.<br/>
<b><a href="CppVoid.htm">void</a></b> triangulatepolygon(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; firstedge,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; lastedge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> edgecount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> doflip,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> triflaws<br/>
);<br/>
<br/>
<br/>
<br/>
/<a href="CppComment.htm">//</a> undovertex()&nbsp;&nbsp; Undo the most recent vertex insertion.<br/>
<a href="CppComment.htm">//</a><br/>
/<a href="CppComment.htm">//</a> Walks through the list of transformations (flips and a vertex insertion)<br/>
/<a href="CppComment.htm">//</a> in the reverse of the order in which they were done, and undoes them.<br/>
/<a href="CppComment.htm">//</a> The inserted vertex is removed from the triangulation and deallocated.<br/>
/<a href="CppComment.htm">//</a> Two triangles (possibly just one) are also deallocated.<br/>
<b><a href="CppVoid.htm">void</a></b> undovertex(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> unflip()&nbsp;&nbsp; Transform two triangles to two different triangles by<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flipping an edge clockwise within a quadrilateral.&nbsp;&nbsp;Reverses<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the flip() operation so that the data structures representing<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the triangles are back where they were before the flip().<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Imagine the original triangles, abc and bad, oriented so that the<br/>
/<a href="CppComment.htm">//</a> shared edge ab lies in a horizontal plane, with the vertex b on the left<br/>
/<a href="CppComment.htm">//</a> and the vertex a on the right.&nbsp;&nbsp;The vertex c lies below the edge, and<br/>
/<a href="CppComment.htm">//</a> the vertex d lies above the edge.&nbsp;&nbsp;The `flipedge' handle holds the edge<br/>
/<a href="CppComment.htm">//</a> ab of triangle abc, and is directed left, from vertex a to vertex b.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The triangles abc and bad are deleted and replaced by the triangles cdb<br/>
/<a href="CppComment.htm">//</a> and dca.&nbsp;&nbsp;The triangles that represent abc and bad are NOT deallocated;<br/>
/<a href="CppComment.htm">//</a> they are reused <b><a href="CppFor.htm">for</a></b> cdb and dca, respectively.&nbsp;&nbsp;Hence, <a href="CppAny.htm">any</a> handles that<br/>
/<a href="CppComment.htm">//</a> may have held the original triangles are still valid, although not<br/>
/<a href="CppComment.htm">//</a> directed as they were before.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Upon completion of <b><a href="CppThis.htm">this</a></b> routine, the `flipedge' handle holds the edge<br/>
/<a href="CppComment.htm">//</a> cd of triangle cdb, and is directed up, from vertex c to vertex d.<br/>
/<a href="CppComment.htm">//</a> (Hence, the two triangles have rotated clockwise.)<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> WARNING:&nbsp;&nbsp;This transformation is geometrically valid only <b><a href="CppIf.htm">if</a></b> the<br/>
/<a href="CppComment.htm">//</a> quadrilateral adbc is convex.&nbsp;&nbsp;Furthermore, <b><a href="CppThis.htm">this</a></b> transformation is<br/>
/<a href="CppComment.htm">//</a> valid only <b><a href="CppIf.htm">if</a></b> there is not a subsegment between the triangles abc and<br/>
/<a href="CppComment.htm">//</a> bad.&nbsp;&nbsp;This routine does not check either of these preconditions, and<br/>
/<a href="CppComment.htm">//</a> it is the responsibility of the calling routine to ensure that they are<br/>
/<a href="CppComment.htm">//</a> met.&nbsp;&nbsp;If they are not, the streets shall be filled with wailing and<br/>
/<a href="CppComment.htm">//</a> gnashing of teeth.<br/>
<b><a href="CppVoid.htm">void</a></b> unflip(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; flipedge<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> vertexdealloc()&nbsp;&nbsp; Deallocate space <b><a href="CppFor.htm">for</a></b> a vertex, marking it dead.<br/>
<b><a href="CppVoid.htm">void</a></b> vertexdealloc(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; dyingvertex<br/>
);<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> vertexdealloc(<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices,<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;Vertex&amp; dyingvertex<br/>
<a href="CppComment.htm">//</a>);<br/>
<br/>
/<a href="CppComment.htm">//</a> vertexmedian()&nbsp;&nbsp; An order statistic <a href="CppAlgorithm.htm">algorithm</a>, almost.&nbsp;&nbsp;Shuffles an<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppArray.htm">array</a> of vertices so that the first `median' vertices<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;occur lexicographically before the remaining vertices.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Uses the x-coordinate as the primary key <b><a href="CppIf.htm">if</a></b> axis <a href="CppOperatorEqual.htm">==</a> 0; the y-coordinate<br/>
/<a href="CppComment.htm">//</a> <b><a href="CppIf.htm">if</a></b> axis <a href="CppOperatorEqual.htm">==</a> 1.&nbsp;&nbsp;Very similar to the vertexsort() procedure, but runs in<br/>
/<a href="CppComment.htm">//</a> randomized linear <a href="CppTime.htm">time</a>.<br/>
<b><a href="CppVoid.htm">void</a></b> vertexmedian(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArray.htm">array</a>size,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> median,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axis<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> vertexsort()&nbsp;&nbsp; Sort an <a href="CppArray.htm">array</a> of vertices by x-coordinate, <b><a href="CppUsing.htm">using</a></b> the<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y-coordinate as a secondary key.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> Uses <a href="CppQuickSort.htm">quicksort</a>.&nbsp;&nbsp;Randomized O(n log n) <a href="CppTime.htm">time</a>.&nbsp;&nbsp;No, I did not <a href="CppMake.htm">make</a> <a href="CppAny.htm">any</a> of<br/>
/<a href="CppComment.htm">//</a> the usual <a href="CppQuickSort.htm">quicksort</a> mistakes.<br/>
<a href="CppComment.htm">//</a>Use vertex*, because a <a href="CppQuickSort.htm">quicksort</a> is used<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> vertexsort(<br/>
&nbsp;&nbsp;Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArray.htm">array</a>size<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
/<a href="CppComment.htm">//</a> writeedges()&nbsp;&nbsp; Write the edges to an .edge file.<br/>
<b><a href="CppVoid.htm">void</a></b> writeedges(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; edgefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> writeelements()&nbsp;&nbsp; Write the triangles to an .ele file.<br/>
<b><a href="CppVoid.htm">void</a></b> writeelements(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; elefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> writeneighbors(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; neighborfilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> writenodes()&nbsp;&nbsp; Number the vertices and write them to a .node file.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> To save <a href="CppMemory.htm">memory</a>, the vertex numbers are written over the boundary markers<br/>
/<a href="CppComment.htm">//</a> after the vertices are written to a file.<br/>
<b><a href="CppVoid.htm">void</a></b> writenodes(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; nodefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> writeoff()&nbsp;&nbsp; Write the triangulation to an .off file.<br/>
/<a href="CppComment.htm">//</a> OFF stands <b><a href="CppFor.htm">for</a></b> the Object File Format, a format used by the Geometry<br/>
/<a href="CppComment.htm">//</a> Center's Geomview package.<br/>
<b><a href="CppVoid.htm">void</a></b> writeoff(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; offfilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> writepoly()&nbsp;&nbsp; Write the segments and holes to a .poly file.<br/>
<b><a href="CppVoid.htm">void</a></b> writepoly(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; holes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> holelist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> holes,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; regions,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> regionlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> regions,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a> writevoronoi()&nbsp;&nbsp; Write the Voronoi diagram to a .v.node and .v.edge<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> The Voronoi diagram is the geometric dual of the Delaunay triangulation.<br/>
/<a href="CppComment.htm">//</a> Hence, the Voronoi vertices are listed by traversing the Delaunay<br/>
/<a href="CppComment.htm">//</a> triangles, and the Voronoi edges are listed by traversing the Delaunay<br/>
/<a href="CppComment.htm">//</a> edges.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a> WARNING:&nbsp;&nbsp;In order to assign numbers to the Voronoi vertices, <b><a href="CppThis.htm">this</a></b><br/>
/<a href="CppComment.htm">//</a> procedure messes up the subsegments or the extra nodes of every<br/>
/<a href="CppComment.htm">//</a> element.&nbsp;&nbsp;Hence, you should call <b><a href="CppThis.htm">this</a></b> procedure last.<br/>
<b><a href="CppVoid.htm">void</a></b> writevoronoi(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; vnodefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; vedgefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLE_CPP_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmain.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmain.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">//</a> http://code.google.com/p/poly2tri/<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppComment.htm">//</a><a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wsign-compare"<br/>
<a href="CppComment.htm">//</a><a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-parameter"<br/>
<a href="CppComment.htm">//</a><a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmain.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCmathH.htm">cmath</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCstdlibH.htm">cstdlib</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">cstring</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppFstreamH.htm">fstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdexceptH.htm">stdexcept</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppMake_shared.htm">make_shared</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/math/constants/constants.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "<a href="CppFileIo.htm">fileio</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "make_<a href="CppArray.htm">array</a>.h"<br/>
<a href="CppInclude.htm">#include</a> "polyfile.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmeshbuilder.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppbadsubseg.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpparguments.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppdefines.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppevent.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfile.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppglobals.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmesh.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpposub.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppotri.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppsplaynode.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppstring.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptrimalloc.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertextype.h"<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>There is a spot where is written to index 1, where I (RJCB) believe it should<br/>
<a href="CppComment.htm">//</a>be at index 2.<br/>
<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> one_or_two <a href="CppOperatorAssign.htm">=</a> 2; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> CARE_TODAY_20140602<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::dummyinit(<br/>
&nbsp;&nbsp;Mesh&amp; m<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> trianglebytes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subsegbytes<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set up `dummytri', the `triangle' that occupies "outer space."<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytribase <a href="CppOperatorAssign.htm">=</a> (Triangle *) TriMalloc(trianglebytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_triangles.m_alignbytes);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Align `dummytri' on a `triangles.alignbytes'-byte boundary.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_dummytribase;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri <a href="CppOperatorAssign.htm">=</a> (Triangle *)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_triangles.m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_triangles.m_alignbytes));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the three adjoining triangles to be "outer space."&nbsp;&nbsp;These<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;will eventually be changed by various bonding operations, but their<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;values don't really matter, as <b><a href="CppLong.htm">long</a></b> as they can legally be<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;dereferenced.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(m.m_dummytri);<br/>
&nbsp;&nbsp;m.m_dummytri-&gt;m_triangles.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;());<br/>
&nbsp;&nbsp;m.m_dummytri-&gt;m_triangles.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;());<br/>
&nbsp;&nbsp;m.m_dummytri-&gt;m_triangles.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetTriangle(*m.m_dummytri,0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetTriangle(*m.m_dummytri,1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetTriangle(*m.m_dummytri,2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Three <a href="CppNULL.htm">NULL</a> vertices.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetTriangle(<b><a href="CppNullptr.htm">nullptr</a></b>,3);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetTriangle(<b><a href="CppNullptr.htm">nullptr</a></b>,4);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetTriangle(<b><a href="CppNullptr.htm">nullptr</a></b>,5);<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set up `dummysub', the omnipresent subsegment <a href="CppPointer.htm">point</a>ed to by <a href="CppAny.htm">any</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle side or subsegment end that isn't attached to a real<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysubbase <a href="CppOperatorAssign.htm">=</a> (SubSeg *) TriMalloc(subsegbytes <a href="CppOperatorPlus.htm">+</a> m.m_subsegs.m_alignbytes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Align `dummysub' on a `subsegs.alignbytes'-byte boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_dummysubbase;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub <a href="CppOperatorAssign.htm">=</a> (SubSeg *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_subsegs.m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_subsegs.m_alignbytes));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the two adjoining subsegments to be the omnipresent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment.&nbsp;&nbsp;These will eventually be changed by various bonding<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;operations, but their values don't really matter, as <b><a href="CppLong.htm">long</a></b> as they<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;can legally be dereferenced.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummysub-&gt;m_subsegs.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;SubSeg&gt;());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummysub-&gt;m_subsegs.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;SubSeg&gt;());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetSubSeg(m.m_dummysub,0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetSubSeg(m.m_dummysub,1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Four <a href="CppNULL.htm">NULL</a> vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetSubSeg(<b><a href="CppNullptr.htm">nullptr</a></b>,2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetSubSeg(<b><a href="CppNullptr.htm">nullptr</a></b>,3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetSubSeg(<b><a href="CppNullptr.htm">nullptr</a></b>,4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetSubSeg(<b><a href="CppNullptr.htm">nullptr</a></b>,5);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the two adjoining triangles to be "outer space."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(m.m_dummytri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummysub-&gt;m_triangles.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummysub-&gt;m_triangles.push_back(<a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetTriangle(m.m_dummytri,6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysub-&gt;SetTriangle(m.m_dummytri,7);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the boundary marker to zero.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummysub-&gt;SetBoundaryMarker(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>* (<b><a href="CppInt.htm">int</a></b> *) (m.m_dummysub <a href="CppOperatorPlus.htm">+</a> 8) <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the three adjoining subsegments of `dummytri' to be<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the omnipresent subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummytri-&gt;m_subsegs.push_back(m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummytri-&gt;m_subsegs.push_back(m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_dummytri-&gt;m_subsegs.push_back(m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetSubSeg(m.m_dummysub,6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetSubSeg(m.m_dummysub,7);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri-&gt;SetSubSeg(m.m_dummysub,8);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppInitialize.htm">initialize</a>vertexpool(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(m.m_mesh_dim <a href="CppOperatorPlus.htm">+</a> m.m_nextras * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>) <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>) <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> 1,"m.m_vertexmarkindex is determined here"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_vertexmarkindex <a href="CppOperatorEqual.htm">==</a> (m.m_mesh_dim <a href="CppOperatorPlus.htm">+</a> m.m_nextras * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>) <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>) <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;,"m.m_vertexmarkindex is determined here"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>((m.m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 2) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>) <a href="CppOperatorEqual.htm">==</a> 12,"");<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertexsize_first <a href="CppOperatorAssign.htm">=</a> (m.m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 2) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>);<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(vertexsize_first&nbsp;&nbsp;<a href="CppOperatorEqual.htm">==</a> 12,"");<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(b.m_poly,"");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> The index within each vertex at which a triangle <a href="CppPointer.htm">pointer</a> is found.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; Ensure the <a href="CppPointer.htm">pointer</a> is aligned to a <b><a href="CppSizeof.htm">sizeof</a></b>(triangle)-byte <a href="CppAddress.htm">address</a>.<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>((vertexsize_first <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle) <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a><b><a href="CppSizeof.htm">sizeof</a></b>(Triangle) <a href="CppOperatorEqual.htm">==</a> 3,"");<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(m.m_vertex2triindex <a href="CppOperatorEqual.htm">==</a> (vertexsize_first <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle) <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a><b><a href="CppSizeof.htm">sizeof</a></b>(Triangle),"");<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertexsize <a href="CppOperatorAssign.htm">=</a> (m.m_vertex2triindex <a href="CppOperatorPlus.htm">+</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle);<br/>
&nbsp;&nbsp;<b><a href="CppStatic_assert.htm">static_assert</a></b>(vertexsize <a href="CppOperatorEqual.htm">==</a> 16,"");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> <a href="CppInitialize.htm">Initialize</a> the pool of vertices.<br/>
&nbsp;&nbsp;PoolInit(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;m.m_vertices,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexsize,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;VERTEXPERBLOCK,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_invertices &gt; VERTEXPERBLOCK ? m.m_invertices : VERTEXPERBLOCK,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>)<br/>
&nbsp;&nbsp;);<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppInitialize.htm">initialize</a>trisubpools(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The number of bytes occupied by a triangle.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> trisize <a href="CppOperatorAssign.htm">=</a> ((b.m_order <a href="CppOperatorPlus.htm">+</a> 1) * (b.m_order <a href="CppOperatorPlus.htm">+</a> 2) <a href="CppOperatorDivide.htm">/</a> 2 <a href="CppOperatorPlus.htm">+</a> (m.m_highorderindex <a href="CppOperatorMinus.htm">-</a> 3)) *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSizeof.htm">sizeof</a></b>(Triangle);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The index within each triangle at which its attributes are found,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;where the index is measured in <b><a href="CppDouble.htm">double</a></b>s.<br/>
&nbsp;&nbsp;m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorAssign.htm">=</a> (trisize <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>) <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The index within each triangle at which the maximum area constraint<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;is found, where the index is measured in <b><a href="CppDouble.htm">double</a></b>s.&nbsp;&nbsp;Note that <b><a href="CppIf.htm">if</a></b> the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;`regionattrib' flag is set, an additional attribute will be added.<br/>
&nbsp;&nbsp;m.m_areaboundindex <a href="CppOperatorAssign.htm">=</a> m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorPlus.htm">+</a> m.m_eextras <a href="CppOperatorPlus.htm">+</a> b.m_regionattrib;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If triangle attributes or an area bound are needed, increase the number<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;of bytes occupied by a triangle.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trisize <a href="CppOperatorAssign.htm">=</a> (m.m_areaboundindex <a href="CppOperatorPlus.htm">+</a> 1) * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>);<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (m.m_eextras <a href="CppOperatorPlus.htm">+</a> b.m_regionattrib &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trisize <a href="CppOperatorAssign.htm">=</a> m.m_areaboundindex * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If a Voronoi diagram or triangle neighbor graph is requested, <a href="CppMake.htm">make</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;sure there's room to store an <a href="CppInt.htm">integer</a> index in each triangle.&nbsp;&nbsp;This<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppInt.htm">integer</a> index can occupy the same space as the subsegment <a href="CppPointer.htm">pointer</a>s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;or attributes or area constraint or extra nodes.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((b.m_voronoi <a href="CppOperatorLogicalOr.htm">||</a> b.m_neighbors) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(trisize &lt; 6 * <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<b><a href="CppSizeof.htm">sizeof</a></b>(Triangle)) <a href="CppOperatorPlus.htm">+</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>)))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trisize <a href="CppOperatorAssign.htm">=</a> 6 * <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle) <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Having determined the <a href="CppMemory.htm">memory</a> size of a triangle, <a href="CppInitialize.htm">initialize</a> the pool.<br/>
&nbsp;&nbsp;PoolInit(&amp;m.m_triangles, trisize, g_triangles_per_block,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2 * m.m_invertices <a href="CppOperatorMinus.htm">-</a> 2) &gt; g_triangles_per_block ? (2 * m.m_invertices <a href="CppOperatorMinus.htm">-</a> 2) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_triangles_per_block, 4);<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the pool of subsegments.&nbsp;&nbsp;Take into account all eight<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppPointer.htm">pointer</a>s and one boundary marker.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PoolInit(&amp;m.m_subsegs, 8 * <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle) <a href="CppOperatorPlus.htm">+</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUBSEGPERBLOCK, SUBSEGPERBLOCK, 4);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the "outer space" triangle and omnipresent subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dummyinit(m, b, m.m_triangles.m_itembytes, m.m_subsegs.m_itembytes);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::triangledealloc(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; m_m_triangles,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; dyingtriangle<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the triangle as dead.&nbsp;&nbsp;This <a href="CppMake.htm">make</a>s it possible to detect dead<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangles when traversing the list of all triangles.<br/>
&nbsp;&nbsp;dyingtriangle-&gt;KillMe();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>killtri(dyingtriangle);<br/>
&nbsp;&nbsp;PoolDealloc(m_m_triangles,dyingtriangle);<br/>
}<br/>
<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Triangle * <a href="CppRibi.htm">ribi</a>::tricpp::triangletraverse(Mesh&amp; m)<br/>
{<br/>
&nbsp;&nbsp;Triangle *newtriangle <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newtriangle <a href="CppOperatorAssign.htm">=</a> (Triangle *) Traverse(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newtriangle <a href="CppOperatorEqual.htm">==</a> (Triangle *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (Triangle *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (newtriangle-&gt;IsDead()); <a href="CppComment.htm">//</a> Skip dead ones<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newtriangle;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::subsegdealloc(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SubSeg&gt;&amp; dyingsubseg<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the subsegment as dead.&nbsp;&nbsp;This <a href="CppMake.htm">make</a>s it possible to detect dead<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegments when traversing the list of all subsegments.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;killsubseg(dyingsubseg);<br/>
&nbsp;&nbsp;PoolDealloc(&amp;m.m_subsegs, (<b><a href="CppVoid.htm">void</a></b> *) dyingsubseg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;dyingsubseg-&gt;KillMe();<br/>
&nbsp;&nbsp;m.KillSubSeg(dyingsubseg);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::SubSeg * <a href="CppRibi.htm">ribi</a>::tricpp::subsegtraverse(<br/>
&nbsp;&nbsp;Mesh&amp; m<br/>
)<br/>
{<br/>
&nbsp;&nbsp;SubSeg *newsubseg <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsubseg <a href="CppOperatorAssign.htm">=</a> (SubSeg *) Traverse(&amp;m.m_subsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newsubseg <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (newsubseg.IsDead()); <a href="CppComment.htm">//</a>Skip dead ones.<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newsubseg;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::vertexdealloc(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; dyingvertex<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the vertex as dead.&nbsp;&nbsp;This <a href="CppMake.htm">make</a>s it possible to detect dead<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertices when traversing the list of all vertices.<br/>
&nbsp;&nbsp;dyingvertex-&gt;SetVertexType(VertexType::DEADVERTEX);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>PoolDealloc(&amp;m.m_vertices, (<b><a href="CppVoid.htm">void</a></b> *) &amp;dyingvertex[0]);<br/>
&nbsp;&nbsp;PoolDealloc(vertices, dyingvertex);<br/>
}<br/>
<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::badsubsegdealloc(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;BadSubSeg&gt;&amp; m_m_badsubsegs,<br/>
&nbsp;&nbsp;BadSubSeg&amp; dyingseg<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set subsegment's origin to <a href="CppNULL.htm">NULL</a>.&nbsp;&nbsp;This <a href="CppMake.htm">make</a>s it possible to detect dead<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;badsubsegs when traversing the list of all badsubsegs<br/>
&nbsp;&nbsp;dyingseg.m_subsegorg.Clear();<br/>
&nbsp;&nbsp;PoolDealloc(m_m_badsubsegs,dyingseg);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::BadSubSeg * <a href="CppRibi.htm">ribi</a>::tricpp::badsubsegtraverse(Mesh&amp; m)<br/>
{<br/>
&nbsp;&nbsp;BadSubSeg *newseg <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newseg <a href="CppOperatorAssign.htm">=</a> (BadSubSeg *) Traverse(&amp;m.m_badsubsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newseg <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (newseg-&gt;m_subsegorg.IsEmpty()); <a href="CppComment.htm">//</a> Skip dead ones.<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newseg;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Vertex <a href="CppRibi.htm">ribi</a>::tricpp::getvertex(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp;,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(vertices.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> vertices[index];<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> **getblock <a href="CppOperatorAssign.htm">=</a> vertices.m_firstblock;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> current <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Find the right block.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (current <a href="CppOperatorPlus.htm">+</a> vertices.m_itemsfirstblock <a href="CppOperatorLessEqual.htm">&lt;=</a> number) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;getblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) *getblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;current <a href="CppOperatorPlusAssign.htm">+=</a> vertices.m_itemsfirstblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (current <a href="CppOperatorPlus.htm">+</a> vertices.m_itemsperblock <a href="CppOperatorLessEqual.htm">&lt;=</a> number) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) *getblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current <a href="CppOperatorPlusAssign.htm">+=</a> vertices.m_itemsperblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Now find the right vertex.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (getblock <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> foundvertex <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppChar.htm">char</a></b> *) (alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) vertices.m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) vertices.m_alignbytes));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (Vertex)(foundvertex <a href="CppOperatorPlus.htm">+</a> vertices.m_itembytes * (number <a href="CppOperatorMinus.htm">-</a> current));<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::triangledeinit(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;PoolDeinit(m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDelete.htm">delete</a></b> m.m_dummytribase;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytribase <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PoolDeinit(m.m_subsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDelete.htm">delete</a></b> m.m_dummysubbase;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummysubbase <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;PoolDeinit(m.m_vertices);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_quality) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PoolDeinit(m.m_badsubsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((b.m_minangle &gt; 0.0) <a href="CppOperatorLogicalOr.htm">||</a> b.m_vararea <a href="CppOperatorLogicalOr.htm">||</a> b.m_fixedarea <a href="CppOperatorLogicalOr.htm">||</a> b.m_usertest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PoolDeinit(m.m_badtriangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PoolDeinit(m.m_flipstackers);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Otri&gt; <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppMake.htm">make</a>triangle(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; m_m_dummytri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SubSeg&gt;&amp; m_m_dummysub,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_m_eextras,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_vararea<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; newotri<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; newotri(<b><a href="CppNew.htm">new</a></b> Otri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newotri-&gt;m_tri <a href="CppOperatorAssign.htm">=</a> (Triangle *) PoolAlloc(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the three adjoining triangles to be "outer space".<br/>
&nbsp;&nbsp;newotri-&gt;m_triangles[0] <a href="CppOperatorAssign.htm">=</a> m_m_dummytri;<br/>
&nbsp;&nbsp;newotri-&gt;m_triangles[1] <a href="CppOperatorAssign.htm">=</a> m_m_dummytri;<br/>
&nbsp;&nbsp;newotri-&gt;m_triangles[2] <a href="CppOperatorAssign.htm">=</a> m_m_dummytri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Three <a href="CppNULL.htm">NULL</a> vertices.<br/>
&nbsp;&nbsp;newotri-&gt;m_triangles[3] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;newotri-&gt;m_triangles[4] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;newotri-&gt;m_triangles[5] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the three adjoining subsegments to be the omnipresent<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment.<br/>
&nbsp;&nbsp;newotri-&gt;SetSubSeg(m_m_dummysub,6);<br/>
&nbsp;&nbsp;newotri-&gt;SetSubSeg(m_m_dummysub,7);<br/>
&nbsp;&nbsp;newotri-&gt;SetSubSeg(m_m_dummysub,8);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m_m_eextras; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newotri-&gt;SetElemAttrib(i,0.0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_vararea)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newotri-&gt;SetAreaBound(-1.0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;newotri-&gt;SetOrient(0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newotri;<br/>
}<br/>
<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Osub&gt; <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppMake.htm">make</a>subseg(<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppMake.htm">make</a>subseg(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; m_m_dummytri,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SubSeg&gt;&amp; m_m_dummysub<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub&amp; newsubseg<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; newsubseg(<b><a href="CppNew.htm">new</a></b> Osub);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg <a href="CppOperatorAssign.htm">=</a> (SubSeg *) PoolAlloc(&amp;m.m_subsegs);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the two adjoining subsegments to be the omnipresent<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment.<br/>
&nbsp;&nbsp;newsubseg-&gt;m_subsegs.push_back(m_m_dummysub);<br/>
&nbsp;&nbsp;newsubseg-&gt;m_subsegs.push_back(m_m_dummysub);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Four <a href="CppNULL.htm">NULL</a> vertices.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg[2] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg[3] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg[4] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg[5] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the two adjoining triangles to be "outer space."<br/>
&nbsp;&nbsp;newsubseg-&gt;m_triangles.push_back(m_m_dummytri);<br/>
&nbsp;&nbsp;newsubseg-&gt;m_triangles.push_back(m_m_dummytri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg[6] <a href="CppOperatorAssign.htm">=</a> m_m_dummytri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newsubseg-&gt;m_subseg[7] <a href="CppOperatorAssign.htm">=</a> m_m_dummytri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the boundary marker to zero.<br/>
&nbsp;&nbsp;newsubseg-&gt;SetMark(0);<br/>
&nbsp;&nbsp;newsubseg-&gt;SetOrient(0);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newsubseg;<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::fast_expansion_sum_zeroelim(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen_original,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; e,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> e,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> flen_original,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; f<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> f,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; h<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> h<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(e.begin(),e.end(),0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(f.begin(),f.end(),0.0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(e.size());<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> flen <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(f.size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(elen_original <a href="CppOperatorEqual.htm">==</a> elen);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(flen_original <a href="CppOperatorEqual.htm">==</a> flen);<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> Q;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> Q<b><a href="CppNew.htm">new</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> hh;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> enow <a href="CppOperatorAssign.htm">=</a> e[0];<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> fnow <a href="CppOperatorAssign.htm">=</a> f[0];<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> eindex <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> findex <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((fnow &gt; enow) <a href="CppOperatorEqual.htm">==</a> (fnow &gt; <a href="CppOperatorMinus.htm">-</a>enow))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorAssign.htm">=</a> enow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>eindex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;enow <a href="CppOperatorAssign.htm">=</a> e[eindex];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorAssign.htm">=</a> fnow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>findex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fnow <a href="CppOperatorAssign.htm">=</a> f[findex];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> hindex <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (eindex &lt; elen <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> findex &lt; flen)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((fnow &gt; enow) <a href="CppOperatorEqual.htm">==</a> (fnow &gt; <a href="CppOperatorMinus.htm">-</a>enow))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<b><a href="CppNew.htm">new</a></b> <a href="CppOperatorAssign.htm">=</a> enow <a href="CppOperatorPlus.htm">+</a> Q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(a,b,x,y) : x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(enow, Q, Q<b><a href="CppNew.htm">new</a></b>, hh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>eindex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enow <a href="CppOperatorAssign.htm">=</a> e[eindex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<b><a href="CppNew.htm">new</a></b> <a href="CppOperatorAssign.htm">=</a> fnow <a href="CppOperatorPlus.htm">+</a> Q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(a,b,x,y) : x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(fnow, Q, Q<b><a href="CppNew.htm">new</a></b>, hh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>findex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fnow <a href="CppOperatorAssign.htm">=</a> f[findex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorAssign.htm">=</a> Q<b><a href="CppNew.htm">new</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (eindex &lt; elen <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> findex &lt; flen)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((fnow &gt; enow) <a href="CppOperatorEqual.htm">==</a> (fnow &gt; <a href="CppOperatorMinus.htm">-</a>enow))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorPlusAssign.htm">+=</a> enow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q<b><a href="CppNew.htm">new</a></b> <a href="CppOperatorAssign.htm">=</a> Q <a href="CppOperatorPlus.htm">+</a> enow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(Q, enow, Q<b><a href="CppNew.htm">new</a></b>, hh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>eindex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enow <a href="CppOperatorAssign.htm">=</a> e[eindex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorPlusAssign.htm">+=</a> fnow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q<b><a href="CppNew.htm">new</a></b> <a href="CppOperatorAssign.htm">=</a> Q <a href="CppOperatorPlus.htm">+</a> fnow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(Q, fnow, Q<b><a href="CppNew.htm">new</a></b>, hh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>findex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fnow <a href="CppOperatorAssign.htm">=</a> f[findex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q <a href="CppOperatorAssign.htm">=</a> Q<b><a href="CppNew.htm">new</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (eindex &lt; elen)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorPlusAssign.htm">+=</a> enow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q<b><a href="CppNew.htm">new</a></b> <a href="CppOperatorAssign.htm">=</a> Q <a href="CppOperatorPlus.htm">+</a> enow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(Q, enow, Q<b><a href="CppNew.htm">new</a></b>, hh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>eindex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;enow <a href="CppOperatorAssign.htm">=</a> e[eindex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q <a href="CppOperatorAssign.htm">=</a> Q<b><a href="CppNew.htm">new</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (findex &lt; flen)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorPlusAssign.htm">+=</a> fnow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q<b><a href="CppNew.htm">new</a></b> <a href="CppOperatorAssign.htm">=</a> Q <a href="CppOperatorPlus.htm">+</a> fnow;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(Q, fnow, Q<b><a href="CppNew.htm">new</a></b>, hh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>findex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fnow <a href="CppOperatorAssign.htm">=</a> f[findex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q <a href="CppOperatorAssign.htm">=</a> Q<b><a href="CppNew.htm">new</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (Q <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> hindex <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> Q;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> hindex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::scale_expansion_zeroelim(<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::scale_expansion_zeroelim(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen_original,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; e,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> e,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b>&amp; h<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> h<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(e.begin(),e.end(),0.0) * b;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(e.size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(elen <a href="CppOperatorEqual.htm">==</a> elen_original);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> Q;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> sum;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> product1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> product0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> hindex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> enow;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bhi <a href="CppOperatorAssign.htm">=</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> blo <a href="CppOperatorAssign.htm">=</a>0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split(b, bhi, blo);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> Q <a href="CppOperatorAssign.htm">=</a> e[0] * b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(e[0], b, bhi, blo, Q, hh);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> hindex <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> eindex <a href="CppOperatorAssign.htm">=</a> 1; eindex &lt; elen; eindex<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>enow <a href="CppOperatorAssign.htm">=</a> e[eindex];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> product1 <a href="CppOperatorAssign.htm">=</a> e[eindex] * b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> product0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(a,b,bhi,blo,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>_Presplit(enow, b, bhi, blo, product1, product0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sum <a href="CppOperatorAssign.htm">=</a> Q;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sum <a href="CppOperatorAssign.htm">=</a> Q <a href="CppOperatorPlus.htm">+</a> product0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Sum(Q, product0, sum, hh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Q <a href="CppOperatorAssign.htm">=</a> (e[eindex] * b) <a href="CppOperatorPlus.htm">+</a> sum;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Q <a href="CppOperatorAssign.htm">=</a> product1 <a href="CppOperatorPlus.htm">+</a> sum;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hh <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(a,b,x,y) : x <a href="CppOperatorAssign.htm">=</a> a <a href="CppOperatorPlus.htm">+</a> b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fast_Two_Sum(product1, sum, Q, hh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (hh <a href="CppOperatorNotEqual.htm">!=</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> hh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (Q <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> hindex <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;h[hindex<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> Q;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> hindex;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> Q;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>h <a href="CppOperatorAssign.htm">=</a> Q;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a> estimate()&nbsp;&nbsp; Produce a one-word estimate of an expansion's value.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppDouble.htm">double</a></b> estimate(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elen,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> e<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; v<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end(),0.0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><b><a href="CppDouble.htm">double</a></b> Q <a href="CppOperatorAssign.htm">=</a> e[0];<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> eindex <a href="CppOperatorAssign.htm">=</a> 1; eindex &lt; elen; <a href="CppOperatorIncrement.htm">++</a>eindex)<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>{<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;Q <a href="CppOperatorPlusAssign.htm">+=</a> e[eindex];<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>}<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><b><a href="CppReturn.htm">return</a></b> Q;<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppCounter.htm">counter</a>clockwiseadapt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> detsum<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> acxtail, acytail, bcxtail, bcytail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> detleft, detright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> detlefttail <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> detrighttail <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det, errbound;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; B(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> B[4];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; C1(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; C2(12,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; D(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> C1[8], C2[12], D[16];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> B3 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> C1length, C2length, Dlength;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; u(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> u[4];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> u3 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> s1, t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> s0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> t0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length acx <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length bcx <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length acy <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length bcy <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> detleft <a href="CppOperatorAssign.htm">=</a> acx * bcy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acx, bcy, detleft, detlefttail);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> detright <a href="CppOperatorAssign.htm">=</a> acy * bcx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acy, bcx, detright, detrighttail);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> B3 <a href="CppOperatorAssign.htm">=</a> detleft&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> detright <a href="CppOperatorMinus.htm">-</a> detrighttail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> B3 <a href="CppOperatorAssign.htm">=</a> detleft <a href="CppOperatorPlus.htm">+</a> detlefttail <a href="CppOperatorMinus.htm">-</a> detright <a href="CppOperatorMinus.htm">-</a> detrighttail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(detleft, detlefttail, detright, detrighttail,B3, B[2], B[1], B[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>B[3] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>B[3] <a href="CppOperatorAssign.htm">=</a> B3;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (0.0 <a href="CppOperatorGreaterEqual.htm">&gt;=</a> Global().m_ccwerrboundB * detsum)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> 0.0; <a href="CppComment.htm">//</a>B consisted of zeroes only<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(B.begin(),B.end(),0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det <a href="CppOperatorAssign.htm">=</a> estimate(B);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_ccwerrboundB * detsum;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length acxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>acx <a href="CppOperatorPlus.htm">+</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pa[0], pc[0], acx, acxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length bcxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bcx <a href="CppOperatorPlus.htm">+</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pb[0], pc[0], bcx, bcxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length acytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>acy <a href="CppOperatorPlus.htm">+</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pa[1], pc[1], acy, acytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length bcytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bcy <a href="CppOperatorPlus.htm">+</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pb[1], pc[1], bcy, bcytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( acxtail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> acytail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bcxtail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bcytail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_ccwerrboundC * detsum;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_ccwerrboundC * detsum <a href="CppOperatorPlus.htm">+</a> Global().m_resulterrbound * <a href="CppStdAbs.htm">std::abs</a>(det);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> ((acx * bcytail <a href="CppOperatorPlus.htm">+</a> bcy * acxtail) <a href="CppOperatorMinus.htm">-</a> (acy * bcxtail <a href="CppOperatorPlus.htm">+</a> bcx * acytail));<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> s1 <a href="CppOperatorAssign.htm">=</a> acxtail * bcy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acxtail, bcy, s1, s0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> t1 <a href="CppOperatorAssign.htm">=</a> acytail * bcx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acytail, bcx, t1, t0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorPlus.htm">+</a> s0 <a href="CppOperatorMinus.htm">-</a> t1 <a href="CppOperatorMinus.htm">-</a> t0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> C1 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> C1 <a href="CppOperatorAssign.htm">=</a> u3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>C1 <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(u.begin(),u.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>C1 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(B,u);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(B,u,C1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> C1length <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(B,u,C1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> C1length <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(4, B, 4, u, C1);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> (acxtail * bcytail) <a href="CppOperatorMinus.htm">-</a> (acytail * bcxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorPlus.htm">+</a> (&nbsp;&nbsp;&nbsp;&nbsp;acx * bcytail) <a href="CppOperatorMinus.htm">-</a> (&nbsp;&nbsp;&nbsp;&nbsp;acy * bcxtail);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> (acxtail * bcytail) <a href="CppOperatorMinus.htm">-</a> (acytail * bcxtail) <a href="CppOperatorPlus.htm">+</a> C2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> C2 <a href="CppOperatorAssign.htm">=</a> (acx * bcytail) <a href="CppOperatorMinus.htm">-</a> (acy * bcxtail);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>s1 <a href="CppOperatorAssign.htm">=</a> acx * bcytail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acx, bcytail, s1, s0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>t1 <a href="CppOperatorAssign.htm">=</a> acy * bcxtail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acy, bcxtail, t1, t0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> C2 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorMinus.htm">-</a> t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> C2 <a href="CppOperatorAssign.htm">=</a> C1 <a href="CppOperatorPlus.htm">+</a> s1 <a href="CppOperatorMinus.htm">-</a> t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorMinus.htm">-</a> t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorPlus.htm">+</a> s0 <a href="CppOperatorMinus.htm">-</a> t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorPlus.htm">+</a> s0 <a href="CppOperatorMinus.htm">-</a> t1 <a href="CppOperatorMinus.htm">-</a> t0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> C2 <a href="CppOperatorAssign.htm">=</a> C1 <a href="CppOperatorPlus.htm">+</a> u3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>C2 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(C1,u);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(C1,u,C2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> C2length <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(C1,u,C2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> C2length <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(C1length, C1, 4, u, C2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> (acxtail * bcytail) <a href="CppOperatorMinus.htm">-</a> (acytail * bcxtail) <a href="CppOperatorPlus.htm">+</a> C2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>s1 <a href="CppOperatorAssign.htm">=</a> acxtail * bcytail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acxtail, bcytail, s1, s0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>t1 <a href="CppOperatorAssign.htm">=</a> acytail * bcxtail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(acytail, bcxtail, t1, t0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> s1 <a href="CppOperatorMinus.htm">-</a> t1 <a href="CppOperatorPlus.htm">+</a> C2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorMinus.htm">-</a> t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorPlus.htm">+</a> s0 <a href="CppOperatorMinus.htm">-</a> t1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> s1 <a href="CppOperatorPlus.htm">+</a> s0 <a href="CppOperatorMinus.htm">-</a> t1 <a href="CppOperatorMinus.htm">-</a> t0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> u3 <a href="CppOperatorPlus.htm">+</a> C2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> fast_expansion_sum_zeroelim(C2,u);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> Dlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>D <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(C2,u);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> Dlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(C2,u,D);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> Dlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(C2length, C2, 4, u, D);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b>(D[Dlength <a href="CppOperatorMinus.htm">-</a> 1]);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppCounter.htm">counter</a>clockwise(<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc<br/>
)<br/>
{<br/>
<br/>
&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_m_<a href="CppCounter.htm">counter</a>clockcount;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> detleft&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ( (pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX()) * (pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY()) );<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> detright <a href="CppOperatorAssign.htm">=</a> ( (pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY()) * (pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX()) );<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> detleft <a href="CppOperatorMinus.htm">-</a> detright;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> detsum <a href="CppOperatorAssign.htm">=</a> detleft <a href="CppOperatorMinus.htm">-</a> detleft; <a href="CppComment.htm">//</a> 0.0 with the right unit<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(detsum);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_noexact)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (detleft &gt; 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (detright <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detsum <a href="CppOperatorAssign.htm">=</a> detleft <a href="CppOperatorPlus.htm">+</a> detright;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (detleft &lt; 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (detright <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detsum <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>detleft <a href="CppOperatorMinus.htm">-</a> detright;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_ccwerrboundA * detsum;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppCounter.htm">counter</a>clockwiseadapt(pa, pb, pc, detsum);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::incircleadapt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> permanent<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bdxcdy1, cdxbdy1, cdxady1, adxcdy1, adxbdy1, bdxady1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxcdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxbdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxcdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxbdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bc(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ca(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ab(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bc3, ca3, ab3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axbc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axxbc(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aybc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ayybc(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; adet(32,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> axbclen, axxbclen, aybclen, ayybclen, alen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxca(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxxca(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; byca(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; byyca(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bdet(32,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxab(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxxab(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cyab(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cyyab(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cdet(32,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> cxablen, cxxablen, cyablen, cyyablen, clen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; abdet(64,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> ablen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; fin1(1152,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; fin2(1152,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> fin1(1152], fin2(1152];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> *finnow,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> *finother;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> *finswap <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adxadx1, adyady1, bdxbdx1, bdybdy1, cdxcdx1, cdycdy1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxadx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adyady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxbdx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdybdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxcdx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdycdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aa(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bb(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cc(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> aa3, bb3, cc3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ti1, tj1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> ti0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> tj0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; u(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; v(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> u3, v3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp8(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp16a(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp16b(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp16c(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp32a(32,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp32b(32,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp48(48,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; temp64(64,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> temp8len, temp16alen, temp16blen, temp16clen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> temp32alen, temp32blen, temp48len, temp64len;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axtbb(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axtcc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aytbb(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aytcc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> axtbblen, axtcclen, aytbblen, aytcclen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxtaa(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxtcc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bytaa(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bytcc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> bxtaalen, bxtcclen, bytaalen, bytcclen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxtaa(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxtbb(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cytaa(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cytbb(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> cxtaalen, cxtbblen, cytaalen, cytbblen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axtbc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aytbc(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxtca(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bytca(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxtab(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cytab(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axtbct(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aytbct(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxtcat(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bytcat(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxtabt(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cytabt(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> axtbctlen, aytbctlen, bxtcatlen, bytcatlen, cxtabtlen, cytabtlen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; axtbctt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; aytbctt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bxtcatt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bytcatt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cxtabtt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cytabtt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> axtbcttlen, aytbcttlen, bxtcattlen, bytcattlen, cxtabttlen, cytabttlen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; abt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bct(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cat(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> abtlen, bctlen, catlen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; abtt(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bctt(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; catt(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> abttlen, bcttlen,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> cattlen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> abtt3, bctt3, catt3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> negate;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adx <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdx <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdx <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ady <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdy <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdy <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxcdy1 <a href="CppOperatorAssign.htm">=</a> bdx * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdx, cdy, bdxcdy1, bdxcdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxbdy1 <a href="CppOperatorAssign.htm">=</a> cdx * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdx, bdy, cdxbdy1, cdxbdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bc3 <a href="CppOperatorAssign.htm">=</a> bdxcdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bc3 <a href="CppOperatorAssign.htm">=</a> bdxcdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bc3 <a href="CppOperatorAssign.htm">=</a> bdxcdy1 <a href="CppOperatorPlus.htm">+</a> bdxcdy0 <a href="CppOperatorMinus.htm">-</a> cdxbdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(bdxcdy1, bdxcdy0, cdxbdy1, cdxbdy0, bc3, bc[2], bc[1], bc[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bc[3] <a href="CppOperatorAssign.htm">=</a> bc3;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>axbc[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>axbc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bc.begin(),bc.end()) * adx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>axbc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,adx);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bc,adx,axbc[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,adx,axbc);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bc, adx, axbc);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>axxbc[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adx * adx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>axxbc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axbc.begin(),axbc.end()) * adx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>axxbc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axbc,adx);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axbc,adx,axxbc[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axxbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axbc,adx,axxbc);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axxbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axbclen, axbc, adx, axxbc);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>aybc[0] <a href="CppOperatorAssign.htm">=</a> bc3 * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>aybc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bc.begin(),bc.end()) * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>aybc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,ady);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bc,ady,aybc[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aybclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,ady,aybc);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aybclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bc, ady, aybc);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ayybc[0] <a href="CppOperatorAssign.htm">=</a> bc3 * ady * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ayybc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aybc.begin(),aybc.end()) * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ayybc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aybc,ady);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aybc,ady,ayybc[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ayybclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aybc,ady,ayybc);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ayybclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aybclen, aybc, ady, ayybc);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adet <a href="CppOperatorAssign.htm">=</a> (bc3 * adx * adx) <a href="CppOperatorPlus.htm">+</a> (bc3 * ady * ady);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>adet <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(axxbc,ayybc);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(axxbc,ayybc,adet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(axxbc,ayybc,adet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(axxbclen, axxbc, ayybclen, ayybc, adet);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxady1 <a href="CppOperatorAssign.htm">=</a> cdx * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdx, ady, cdxady1, cdxady0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxcdy1 <a href="CppOperatorAssign.htm">=</a> adx * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adx, cdy, adxcdy1, adxcdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ca3 <a href="CppOperatorAssign.htm">=</a> cdxady1 <a href="CppOperatorMinus.htm">-</a> adxcdy1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ca3 <a href="CppOperatorAssign.htm">=</a> cdxady1 <a href="CppOperatorMinus.htm">-</a> adxcdy1 <a href="CppOperatorMinus.htm">-</a> adxcdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ca3 <a href="CppOperatorAssign.htm">=</a> cdxady1 <a href="CppOperatorPlus.htm">+</a> cdxady0 <a href="CppOperatorMinus.htm">-</a> adxcdy1 <a href="CppOperatorMinus.htm">-</a> adxcdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(cdxady1, cdxady0, adxcdy1, adxcdy0, ca3, ca[2], ca[1], ca[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ca[3] <a href="CppOperatorAssign.htm">=</a> ca3;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxca[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ca.begin(),ca.end()) * bdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxca[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdx);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ca,bdx,bxca[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdx,bxca);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ca, bdx, bxca);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxxca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdx * bdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxxca[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxca.begin(),bxca.end()) * bdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxxca[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxca,bdx);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxca,bdx,bxxca[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxxcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxca,bdx,bxxca);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxxcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxcalen, bxca, bdx, bxxca);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>byca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>byca[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ca.begin(),ca.end()) * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>byca[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdy);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ca,bdy,byca[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bycalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdy,byca);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bycalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ca, bdy, byca);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>byyca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdy * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>byyca[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(byca.begin(),byca.end()) * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>byyca[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(byca,bdy);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(byca,bdy,byyca[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> byycalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(byca,bdy,byyca);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> byycalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bycalen, byca, bdy, byyca);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdet <a href="CppOperatorAssign.htm">=</a> (ca3 * bdx * bdx) <a href="CppOperatorPlus.htm">+</a> (ca3 * bdy * bdy);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bdet <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(bxxca,byyca);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(bxxca,byyca,bdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(bxxca,byyca,bdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(bxxcalen, bxxca, byycalen, byyca, bdet);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxbdy1 <a href="CppOperatorAssign.htm">=</a> adx * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adx, bdy, adxbdy1, adxbdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxady1 <a href="CppOperatorAssign.htm">=</a> bdx * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdx, ady, bdxady1, bdxady0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ab3 <a href="CppOperatorAssign.htm">=</a> adxbdy1 <a href="CppOperatorMinus.htm">-</a> bdxady1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ab3 <a href="CppOperatorAssign.htm">=</a> adxbdy1 <a href="CppOperatorMinus.htm">-</a> bdxady1 <a href="CppOperatorMinus.htm">-</a> bdxady0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ab3 <a href="CppOperatorAssign.htm">=</a> adxbdy1 <a href="CppOperatorPlus.htm">+</a> adxbdy0 <a href="CppOperatorMinus.htm">-</a> bdxady1 <a href="CppOperatorMinus.htm">-</a> bdxady0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(adxbdy1, adxbdy0, bdxady1, bdxady0, ab3, ab[2], ab[1], ab[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ab[3] <a href="CppOperatorAssign.htm">=</a> ab3;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxab[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxab[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ab.begin(),ab.end()) * cdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxab[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdx);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ab,cdx,cxab[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdx,cxab);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ab, cdx, cxab);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxxab[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdx * cdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxxab[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxab.begin(),cxab.end()) * cdx;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxxab[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxab,cdx);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxab,cdx,cxxab[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxxablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxab,cdx,cxxab);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxxablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxablen, cxab, cdx, cxxab);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cyab[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cyab[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ab.begin(),ab.end()) * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cyab[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdy);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ab,cdy,cyab[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cyablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdy,cyab);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cyablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ab, cdy, cyab);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cyyab[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdy * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cyyab[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cyab.begin(),cyab.end()) * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cyyab[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cyab, cdy);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cyab, cdy, cyyab[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cyyablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cyab, cdy, cyyab);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cyyablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cyablen, cyab, cdy, cyyab);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdet <a href="CppOperatorAssign.htm">=</a> (ab3 * cdx * cdx) <a href="CppOperatorPlus.htm">+</a> (ab3 * cdy * cdy);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cdet <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(cxxab,cyyab);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(cxxab,cyyab,cdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> clen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(cxxab,cyyab,cdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> clen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(cxxablen, cxxab, cyyablen, cyyab, cdet);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abdet <a href="CppOperatorAssign.htm">=</a> adet <a href="CppOperatorPlus.htm">+</a> bdet;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>abdet <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(adet,bdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(adet,bdet,abdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ablen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(adet,bdet,abdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ablen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(alen, adet, blen, bdet, abdet);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> fin1 <a href="CppOperatorAssign.htm">=</a> abdet <a href="CppOperatorPlus.htm">+</a> cdet;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> fin1 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(abdet,cdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(abdet,cdet,fin1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(ablen, abdet, clen, cdet, fin1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(finlength <a href="CppOperatorEqual.htm">==</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(fin1.size()));<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> fin1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(fin1.begin(),fin1.end(),0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det <a href="CppOperatorAssign.htm">=</a> estimate(fin1);<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_iccerrboundB * permanent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adx <a href="CppOperatorPlus.htm">+</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pa[0], pd[0], adx, adxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>ady <a href="CppOperatorPlus.htm">+</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pa[1], pd[1], , adytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdx <a href="CppOperatorPlus.htm">+</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pb[0], pd[0], bdx, bdxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdy <a href="CppOperatorPlus.htm">+</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pb[1], pd[1], bdy, bdytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdx <a href="CppOperatorPlus.htm">+</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pc[0], pd[0], cdx, cdxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdy <a href="CppOperatorPlus.htm">+</a> pc-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pc[1], pd[1], cdy, cdytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( adxtail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bdxtail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> cdxtail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> adytail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bdytail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> cdytail <a href="CppOperatorEqual.htm">==</a> 0.0 * meter<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_iccerrboundC * permanent <a href="CppOperatorPlus.htm">+</a> Global().m_resulterrbound * <a href="CppStdAbs.htm">std::abs</a>(det);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;det <a href="CppOperatorPlusAssign.htm">+=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((adx * adx <a href="CppOperatorPlus.htm">+</a> ady * ady) * ((bdx * cdytail <a href="CppOperatorPlus.htm">+</a> cdy * bdxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> (bdy * cdxtail <a href="CppOperatorPlus.htm">+</a> cdx * bdytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> 2.0 * (adx * adxtail <a href="CppOperatorPlus.htm">+</a> ady * adytail) * (bdx * cdy <a href="CppOperatorMinus.htm">-</a> bdy * cdx))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> ((bdx * bdx <a href="CppOperatorPlus.htm">+</a> bdy * bdy) * ((cdx * adytail <a href="CppOperatorPlus.htm">+</a> ady * cdxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> (cdy * adxtail <a href="CppOperatorPlus.htm">+</a> adx * cdytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> 2.0 * (bdx * bdxtail <a href="CppOperatorPlus.htm">+</a> bdy * bdytail) * (cdx * ady <a href="CppOperatorMinus.htm">-</a> cdy * adx))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> ((cdx * cdx <a href="CppOperatorPlus.htm">+</a> cdy * cdy) * ((adx * bdytail <a href="CppOperatorPlus.htm">+</a> bdy * adxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> (ady * bdxtail <a href="CppOperatorPlus.htm">+</a> bdx * adytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> 2.0 * (cdx * cdxtail <a href="CppOperatorPlus.htm">+</a> cdy * cdytail) * (adx * bdy <a href="CppOperatorMinus.htm">-</a> ady * bdx)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> finnow <a href="CppOperatorAssign.htm">=</a> fin1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; finnow <a href="CppOperatorAssign.htm">=</a> fin1;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; finother(1152,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; finother <a href="CppOperatorAssign.htm">=</a> fin2;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> aa3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;? (adx * adx) <a href="CppOperatorPlus.htm">+</a> (ady * ady)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxadx1 <a href="CppOperatorAssign.htm">=</a> adx * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square(adx, adxadx1, adxadx0); <a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adyady1 <a href="CppOperatorAssign.htm">=</a> ady * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square(ady, adyady1, adyady0); <a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> aa3 <a href="CppOperatorAssign.htm">=</a> (adx * adx) <a href="CppOperatorPlus.htm">+</a> (ady * ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> aa3 <a href="CppOperatorAssign.htm">=</a> adxadx1 <a href="CppOperatorPlus.htm">+</a> adyady1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aa3 <a href="CppOperatorAssign.htm">=</a> adxadx1 <a href="CppOperatorPlus.htm">+</a> adyady1 <a href="CppOperatorPlus.htm">+</a> adyady0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aa3 <a href="CppOperatorAssign.htm">=</a> adxadx1 <a href="CppOperatorPlus.htm">+</a> adxadx0 <a href="CppOperatorPlus.htm">+</a> adyady1 <a href="CppOperatorPlus.htm">+</a> adyady0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(adxadx1, adxadx0, adyady1, adyady0, aa3, aa[2], aa[1], aa[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aa[3] <a href="CppOperatorAssign.htm">=</a> aa3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxbdx1 <a href="CppOperatorAssign.htm">=</a> bdx * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square(bdx, bdxbdx1, bdxbdx0); <a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdybdy1 <a href="CppOperatorAssign.htm">=</a> bdy * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square(bdy, bdybdy1, bdybdy0); <a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bb3 <a href="CppOperatorAssign.htm">=</a> bdxbdx1 <a href="CppOperatorPlus.htm">+</a> bdybdy1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bb3 <a href="CppOperatorAssign.htm">=</a> bdxbdx1 <a href="CppOperatorPlus.htm">+</a> bdybdy1 <a href="CppOperatorPlus.htm">+</a> bdybdy0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bb3 <a href="CppOperatorAssign.htm">=</a> bdxbdx1 <a href="CppOperatorPlus.htm">+</a> bdxbdx0 <a href="CppOperatorPlus.htm">+</a> bdybdy1 <a href="CppOperatorPlus.htm">+</a> bdybdy0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(bdxbdx1, bdxbdx0, bdybdy1, bdybdy0, bb3, bb[2], bb[1], bb[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bb[3] <a href="CppOperatorAssign.htm">=</a> bb3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cc3 <a href="CppOperatorAssign.htm">=</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;? (cdx * cdx) <a href="CppOperatorPlus.htm">+</a> (cdy * cdy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxcdx1 <a href="CppOperatorAssign.htm">=</a> cdx * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square(cdx, cdxcdx1, cdxcdx0); <a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdycdy1 <a href="CppOperatorAssign.htm">=</a> cdy * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Square(cdy, cdycdy1, cdycdy0); <a href="CppComment.htm">//</a>x <a href="CppOperatorAssign.htm">=</a> a * a, y <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cc3 <a href="CppOperatorAssign.htm">=</a> (cdx * cdx) <a href="CppOperatorPlus.htm">+</a> (cdy * cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cc3 <a href="CppOperatorAssign.htm">=</a> cdxcdx1 <a href="CppOperatorPlus.htm">+</a> cdycdy1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cc3 <a href="CppOperatorAssign.htm">=</a> cdxcdx1 <a href="CppOperatorPlus.htm">+</a> cdycdy1 <a href="CppOperatorPlus.htm">+</a> cdycdy0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cc3 <a href="CppOperatorAssign.htm">=</a> cdxcdx1 <a href="CppOperatorPlus.htm">+</a> cdxcdx0 <a href="CppOperatorPlus.htm">+</a> cdycdy1 <a href="CppOperatorPlus.htm">+</a> cdycdy0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(cdxcdx1, cdxcdx0, cdycdy1, cdycdy0, cc3, cc[2], cc[1], cc[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cc[3] <a href="CppOperatorAssign.htm">=</a> cc3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbc[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bc.begin(),bc.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc, adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bc, adxtail, axtbc[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc, adxtail, axtbc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bc, adxtail, axtbc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> bc3 * adxtail * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adxtail * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbc.begin(),axtbc.end()) * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbc,2.0 * adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbc,2.0 * adx,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbc,2.0 * adx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbclen, axtbc, 2.0 * adx,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtcc[0] <a href="CppOperatorAssign.htm">=</a> cc3 * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtcc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cc.begin(),cc.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtcc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cc,adxtail,axtcc[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,adxtail,axtcc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, cc, adxtail, axtcc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> cc3 * adxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> cc3 * adxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtcc.begin(),axtcc.end()) * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtcc,bdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtcc,bdy,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtcc,bdy,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtcclen, axtcc, bdy, temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbb[0] <a href="CppOperatorAssign.htm">=</a> bb3 * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbb[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bb.begin(),bb.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbb[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb, adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bb, adxtail, axtbb[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb, adxtail, axtbb);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bb, adxtail, axtbb);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16c <a href="CppOperatorAssign.htm">=</a> bb3 * adxtail * <a href="CppOperatorMinus.htm">-</a>cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> bb3 * adxtail * <a href="CppOperatorMinus.htm">-</a>cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbb.begin(),axtbb.end()) * <a href="CppOperatorMinus.htm">-</a>cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbb,-cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbb,-cdy,temp16c[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbb,-cdy,temp16c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbblen, axtbb, <a href="CppOperatorMinus.htm">-</a>cdy, temp16c);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16c <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16clen, temp16c,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbc[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bc.begin(),bc.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bc,adytail,aytbc[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,adytail,aytbc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bc, adytail, aytbc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> bc3 * adytail * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adytail * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbc.begin(),aytbc.end()) * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbc,2.0 * ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbc,2.0 * ady,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbc,2.0 * ady,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbclen, aytbc, 2.0 * ady,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbb[0] <a href="CppOperatorAssign.htm">=</a> bb3 * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbb[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bb.begin(),bb.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbb[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bb,adytail,aytbb[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,adytail,aytbb);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bb, adytail, aytbb);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> bb3 * adytail * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> bb3 * adytail * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbb.begin(),aytbb.end()) * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbb,cdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbb,cdx,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbb,cdx,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbblen, aytbb, cdx, temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytcc[0] <a href="CppOperatorAssign.htm">=</a> cc3 * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytcc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cc.begin(),cc.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytcc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cc,adytail,aytcc[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,adytail,aytcc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, cc, adytail, aytcc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16c <a href="CppOperatorAssign.htm">=</a> cc3 * adytail * <a href="CppOperatorMinus.htm">-</a>bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> cc3 * adytail * <a href="CppOperatorMinus.htm">-</a>bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytcc.begin(),aytcc.end()) * <a href="CppOperatorMinus.htm">-</a>bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytcc,-bdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytcc,-bdx,temp16c[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytcc,-bdx,temp16c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytcclen, aytcc, <a href="CppOperatorMinus.htm">-</a>bdx, temp16c);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16c <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16clen, temp16c,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtca[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ca.begin(),ca.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtca[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ca,bdxtail,bxtca[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdxtail,bxtca);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ca, bdxtail, bxtca);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ca3 * bdxtail * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdxtail * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtca.begin(),bxtca.end()) * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtca,2.0 * bdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtca,2.0 * bdx,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtca,2.0 * bdx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcalen, bxtca, 2.0 * bdx,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtaa[0] <a href="CppOperatorAssign.htm">=</a> aa3 * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtaa[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aa.begin(),aa.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtaa[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aa,bdxtail,bxtaa[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,bdxtail,bxtaa);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, aa, bdxtail, bxtaa);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> aa3 * bdxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> aa3 * bdxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtaa.begin(),bxtaa.end()) * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtaa,cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtaa,cdy,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtaa,cdy,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtaalen, bxtaa, cdy, temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcc[0] <a href="CppOperatorAssign.htm">=</a> cc3 * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cc.begin(),cc.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc, bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cc, bdxtail, bxtcc[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc, bdxtail, bxtcc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, cc, bdxtail, bxtcc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16c <a href="CppOperatorAssign.htm">=</a> cc3 * bdxtail * <a href="CppOperatorMinus.htm">-</a>ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> cc3 * bdxtail * <a href="CppOperatorMinus.htm">-</a>ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtcc.begin(),bxtcc.end()) * <a href="CppOperatorMinus.htm">-</a>ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcc,-ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtcc,-ady,temp16c[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcc,-ady,temp16c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcclen, bxtcc, <a href="CppOperatorMinus.htm">-</a>ady, temp16c);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16c <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16clen, temp16c,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytca[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytca[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ca.begin(),ca.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytca[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ca,bdytail,bytca[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdytail,bytca);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ca, bdytail, bytca);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ca3 * bdytail * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdytail * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytca.begin(),bytca.end()) * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytca,2.0 * bdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytca,2.0 * bdy,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytca,2.0 * bdy,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcalen, bytca, 2.0 * bdy,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcc[0] <a href="CppOperatorAssign.htm">=</a> cc3 * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcc[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cc.begin(),cc.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcc[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cc,bdytail,bytcc[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,bdytail,bytcc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcclen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, cc, bdytail, bytcc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b[0] <a href="CppOperatorAssign.htm">=</a> cc3 * bdytail * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> cc3 * bdytail * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytcc.begin(),bytcc.end()) * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcc,adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytcc,adx,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcc,adx,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcclen, bytcc, adx, temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytaa[0] <a href="CppOperatorAssign.htm">=</a> aa3 * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytaa[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aa.begin(),aa.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytaa[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aa,bdytail,bytaa[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,bdytail,bytaa);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, aa, bdytail, bytaa);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16c <a href="CppOperatorAssign.htm">=</a> aa3 * bdytail * <a href="CppOperatorMinus.htm">-</a>cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> aa3 * bdytail * <a href="CppOperatorMinus.htm">-</a>cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytaa.begin(),bytaa.end()) * <a href="CppOperatorMinus.htm">-</a>cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytaa,-cdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytaa,-cdx,temp16c[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytaa,-cdx,temp16c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytaalen, bytaa, <a href="CppOperatorMinus.htm">-</a>cdx, temp16c);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16c <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16clen, temp16c,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtab[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtab[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ab.begin(),ab.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtab[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ab,cdxtail,cxtab[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdxtail,cxtab);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ab, cdxtail, cxtab);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ab3 * cdxtail * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdxtail * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtab.begin(),cxtab.end()) * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtab,2.0 * cdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtab,2.0 * cdx,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtab,2.0 * cdx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtablen, cxtab, 2.0 * cdx,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtbb[0] <a href="CppOperatorAssign.htm">=</a> bb3 * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtbb[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bb.begin(),bb.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtbb[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bb,cdxtail,cxtbb[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,cdxtail,cxtbb);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bb, cdxtail, cxtbb);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> bb3 * cdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> bb3 * cdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtbb.begin(),cxtbb.end()) * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtbb,ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtbb,ady,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtbb,ady,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtbblen, cxtbb, ady, temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtaa[0] <a href="CppOperatorAssign.htm">=</a> aa3 * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtaa[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aa.begin(),aa.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtaa[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aa,cdxtail,cxtaa[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,cdxtail,cxtaa);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, aa, cdxtail, cxtaa);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16c <a href="CppOperatorAssign.htm">=</a> aa3 * cdxtail * <a href="CppOperatorMinus.htm">-</a>bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> aa3 * cdxtail * <a href="CppOperatorMinus.htm">-</a>bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtaa.begin(),cxtaa.end()) * <a href="CppOperatorMinus.htm">-</a>bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtaa,-bdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtaa,-bdy,temp16c[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtaa,-bdy,temp16c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtaalen, cxtaa, <a href="CppOperatorMinus.htm">-</a>bdy, temp16c);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16c <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16clen, temp16c,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytab[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytab[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ab.begin(),ab.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytab[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ab,cdytail,cytab[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdytail,cytab);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytablen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ab, cdytail, cytab);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ab3 * cdytail * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdytail * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cytab.begin(),cytab.end()) * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytab,2.0 * cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytab,2.0 * cdy,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytab,2.0 * cdy,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytablen, cytab, 2.0 * cdy,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytaa[0] <a href="CppOperatorAssign.htm">=</a> aa3 * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytaa[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aa.begin(),aa.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytaa[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa, cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aa, cdytail, cytaa[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa, cdytail, cytaa);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytaalen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, aa, cdytail, cytaa);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> aa3 * cdytail * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> aa3 * cdytail * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cytaa.begin(),cytaa.end()) * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytaa,bdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytaa,bdx,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytaa,bdx,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytaalen, cytaa, bdx, temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytbb[0] <a href="CppOperatorAssign.htm">=</a> bb3 * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytbb[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bb.begin(),bb.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytbb[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb, cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bb, cdytail, cytbb[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb, cdytail, cytbb);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytbblen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bb, cdytail, cytbb);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16c <a href="CppOperatorAssign.htm">=</a> bb3 * cdytail * <a href="CppOperatorMinus.htm">-</a>adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> bb3 * cdytail * <a href="CppOperatorMinus.htm">-</a>adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cytbb.begin(),cytbb.end()) * <a href="CppOperatorMinus.htm">-</a>adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16c[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytbb,-adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytbb,-adx,temp16c[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytbb,-adx,temp16c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytbblen, cytbb, <a href="CppOperatorMinus.htm">-</a>adx, temp16c);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16c <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16c,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16clen, temp16c,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Uses same conditional statement twice<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bct<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? ((bdxtail * cdy) <a href="CppOperatorPlus.htm">+</a> (bdx * cdytail)) <a href="CppOperatorPlus.htm">+</a> ((cdxtail * <a href="CppOperatorMinus.htm">-</a>bdy) <a href="CppOperatorPlus.htm">+</a> (cdx * <a href="CppOperatorMinus.htm">-</a>bdytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bctt3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? (bdxtail * cdytail) <a href="CppOperatorMinus.htm">-</a> (cdxtail * bdytail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> ti1 <a href="CppOperatorAssign.htm">=</a> bdxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, cdy, ti1, ti0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> tj1 <a href="CppOperatorAssign.htm">=</a> bdx * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdx, cdytail, tj1, tj0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> (bdxtail * cdy) <a href="CppOperatorPlus.htm">+</a> (bdx * cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(ti1, ti0, tj1, tj0, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> cdxtail * <a href="CppOperatorMinus.htm">-</a>bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> cdxtail * negate;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, negate, ti1, ti0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> cdx * <a href="CppOperatorMinus.htm">-</a>bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> cdx * negate;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdx, negate, tj1, tj0);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> v3 <a href="CppOperatorAssign.htm">=</a> (cdxtail * <a href="CppOperatorMinus.htm">-</a>bdy) <a href="CppOperatorPlus.htm">+</a> (cdx * <a href="CppOperatorMinus.htm">-</a>bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(ti1, ti0, tj1, tj0, v3, v[2], v[1], v[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[3] <a href="CppOperatorAssign.htm">=</a> v3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bct <a href="CppOperatorAssign.htm">=</a> ((bdxtail * cdy) <a href="CppOperatorPlus.htm">+</a> (bdx * cdytail)) <a href="CppOperatorPlus.htm">+</a> ((cdxtail * <a href="CppOperatorMinus.htm">-</a>bdy) <a href="CppOperatorPlus.htm">+</a> (cdx * <a href="CppOperatorMinus.htm">-</a>bdytail));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bct <a href="CppOperatorAssign.htm">=</a> u3 <a href="CppOperatorPlus.htm">+</a> v3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bct <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(u,v,bct);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bctlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v,bct);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bctlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(4, u, 4, v, bct);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> bdxtail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, cdytail, ti1, ti0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> cdxtail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, bdytail, tj1, tj0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bctt3 <a href="CppOperatorAssign.htm">=</a> (bdxtail * cdytail) <a href="CppOperatorMinus.htm">-</a> (cdxtail * bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bctt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorMinus.htm">-</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bctt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorMinus.htm">-</a> tj1 <a href="CppOperatorMinus.htm">-</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bctt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorMinus.htm">-</a> tj1 <a href="CppOperatorMinus.htm">-</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(ti1, ti0, tj1, tj0, bctt3, bctt[2], bctt[1], bctt[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bctt[3] <a href="CppOperatorAssign.htm">=</a> bctt3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bcttlen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bct[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bctlen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bctt[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bcttlen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bc3 * adxtail * adxtail) <a href="CppOperatorPlus.htm">+</a> (bct * adxtail * 2.0 * adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> bc3 * adxtail * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adxtail * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbc.begin(),axtbc.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbc,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbc,adxtail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbc,adxtail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbclen, axtbc, adxtail, temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbct[0] <a href="CppOperatorAssign.htm">=</a> bct * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbct[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bct.begin(),bct.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbct[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bct,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bct,adxtail,axtbct[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbctlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bct,adxtail,axtbct);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbctlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctlen, bct, adxtail, axtbct);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a <a href="CppOperatorPlus.htm">+</a> (bct * adxtail * 2.0 * adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> bct * adxtail * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> bct * adxtail * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbct.begin(),axtbct.end()) * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbct,2.0 * adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbct,2.0 * adx,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbct,2.0 * adx,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbctlen, axtbct, 2.0 * adx,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> cc3 * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cc.begin(),cc.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cc,adxtail,temp8[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc,adxtail,temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, cc, adxtail, temp8);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> (cc3 * adxtail) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> (cc3 * adxtail) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(temp8.begin(),temp8.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(temp8,bdytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,bdytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8len, temp8, bdytail,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> bb3 * <a href="CppOperatorMinus.htm">-</a>adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bb.begin(),bb.end()) * <a href="CppOperatorMinus.htm">-</a>adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,-adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bb,-adxtail,temp8[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,-adxtail,temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bb, <a href="CppOperatorMinus.htm">-</a>adxtail, temp8);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> (bb3 * <a href="CppOperatorMinus.htm">-</a>adxtail) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> (bb3 * <a href="CppOperatorMinus.htm">-</a>adxtail) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(temp8.begin(),temp8.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(temp8,cdytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,cdytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8len, temp8, cdytail,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> bct * adxtail * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> bct * adxtail * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbct.begin(),axtbct.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbct,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbct,adxtail,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbct,adxtail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbctlen, axtbct, adxtail,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbctt[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbctt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bctt.begin(),bctt.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>axtbctt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctt,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bctt,adxtail,axtbctt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbcttlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctt,adxtail,axtbctt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axtbcttlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bcttlen, bctt, adxtail, axtbctt);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adxtail * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adxtail * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbctt.begin(),axtbctt.end()) * 2.0 * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbctt,2.0 * adx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbctt,2.0 * adx,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbctt,2.0 * adx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbcttlen, axtbctt, 2.0 * adx,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> bctt3 * adxtail * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adxtail * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(axtbctt.begin(),axtbctt.end()) * adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbctt,adxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(axtbctt,adxtail,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbctt,adxtail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(axtbcttlen, axtbctt, adxtail,temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32b <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32b <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp64 <a href="CppOperatorAssign.htm">=</a> temp32a <a href="CppOperatorPlus.htm">+</a> temp32b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp64 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32alen, temp32a,temp32blen, temp32b, temp64);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp64len,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bc3 * adytail * adytail) <a href="CppOperatorPlus.htm">+</a> (bct * adytail * 2.0 * ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> bc3 * adytail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adytail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbc.begin(),aytbc.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbc,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbc,adytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbc,adytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbclen, aytbc, adytail, temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbct[0] <a href="CppOperatorAssign.htm">=</a> bct * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbct[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bct.begin(),bct.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbct[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bct,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bct,adytail,aytbct[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbctlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bct,adytail,aytbct);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbctlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctlen, bct, adytail, aytbct);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> (temp16a <a href="CppOperatorPlus.htm">+</a> (bct * adytail * 2.0 * ady));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> bct * adytail * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> bct * adytail * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbct.begin(),aytbct.end()) * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbct, 2.0 * ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbct, 2.0 * ady,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbct, 2.0 * ady,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbctlen, aytbct, 2.0 * ady,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> (temp16a <a href="CppOperatorPlus.htm">+</a> temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp32alen, temp32a, temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> bct * adytail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> bct * adytail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbct.begin(),aytbct.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbct,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbct,adytail,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbct,adytail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbctlen, aytbct, adytail,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbctt[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbctt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bctt.begin(),bctt.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aytbctt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctt,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bctt,adytail,aytbctt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbcttlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctt,adytail,aytbctt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aytbcttlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bcttlen, bctt, adytail, aytbctt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> bctt3 * adytail * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adytail * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbctt.begin(),aytbctt.end()) * 2.0 * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbctt,2.0 * ady);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbctt,2.0 * ady,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbctt,2.0 * ady,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbcttlen, aytbctt, 2.0 * ady,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> bctt3 * adytail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> bctt3 * adytail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aytbctt.begin(),aytbctt.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbctt,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aytbctt,adytail,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbctt,adytail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aytbcttlen, aytbctt, adytail,temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32b <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32b <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp64 <a href="CppOperatorAssign.htm">=</a> temp32a <a href="CppOperatorPlus.htm">+</a> temp32b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp64 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32alen, temp32a,temp32blen, temp32b, temp64);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp64len,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cat<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? (cdxtail * ady) <a href="CppOperatorPlus.htm">+</a> (cdx * adytail) <a href="CppOperatorPlus.htm">+</a> (adxtail * <a href="CppOperatorMinus.htm">-</a>cdy) <a href="CppOperatorPlus.htm">+</a> (adx * <a href="CppOperatorMinus.htm">-</a>cdytail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> catt3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? (cdxtail * adytail) <a href="CppOperatorMinus.htm">-</a> (adxtail * cdytail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cat <a href="CppOperatorAssign.htm">=</a> (cdxtail * ady) <a href="CppOperatorPlus.htm">+</a> (cdx * adytail) <a href="CppOperatorPlus.htm">+</a> (adxtail * <a href="CppOperatorMinus.htm">-</a>cdy) <a href="CppOperatorPlus.htm">+</a> (adx * <a href="CppOperatorMinus.htm">-</a>cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> (cdxtail * ady) <a href="CppOperatorPlus.htm">+</a> (cdx * adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> ti1 <a href="CppOperatorAssign.htm">=</a> cdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, ady, ti1, ti0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> tj1 <a href="CppOperatorAssign.htm">=</a> cdx * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdx, adytail, tj1, tj0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(ti1, ti0, tj1, tj0, u3, u[2], u[1], u[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v3 <a href="CppOperatorAssign.htm">=</a> (adxtail * <a href="CppOperatorMinus.htm">-</a>cdy) <a href="CppOperatorPlus.htm">+</a> (adx * <a href="CppOperatorMinus.htm">-</a>cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> adxtail * <a href="CppOperatorMinus.htm">-</a>cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> adxtail * negate;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, negate, ti1, ti0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> adx * <a href="CppOperatorMinus.htm">-</a>cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> adx * negate;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adx, negate, tj1, tj0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(ti1, ti0, tj1, tj0, v3, v[2], v[1], v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[3] <a href="CppOperatorAssign.htm">=</a> v3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cat <a href="CppOperatorAssign.htm">=</a> u3 <a href="CppOperatorPlus.htm">+</a> v3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cat <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(u,v,cat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> catlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v,cat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> catlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(4, u, 4, v, cat);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> catt3 <a href="CppOperatorAssign.htm">=</a> (cdxtail * adytail) <a href="CppOperatorMinus.htm">-</a> (adxtail * cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> cdxtail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, adytail, ti1, ti0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> adxtail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, cdytail, tj1, tj0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> catt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorMinus.htm">-</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>catt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorMinus.htm">-</a> tj1 <a href="CppOperatorMinus.htm">-</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>catt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorMinus.htm">-</a> tj1 <a href="CppOperatorMinus.htm">-</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(ti1, ti0, tj1, tj0, catt3, catt[2], catt[1], catt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>catt[3] <a href="CppOperatorAssign.htm">=</a> catt3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cattlen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;cat[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>catlen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>catt[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cattlen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ca3 * bdxtail * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdxtail * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtca.begin(),bxtca.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtca,bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtca,bdxtail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtca,bdxtail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcalen, bxtca, bdxtail, temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcat[0] <a href="CppOperatorAssign.htm">=</a> cat * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcat[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cat.begin(),cat.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcat[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cat,bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cat,bdxtail,bxtcat[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcatlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cat,bdxtail,bxtcat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcatlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catlen, cat, bdxtail, bxtcat);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> cat * bdxtail * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> cat * bdxtail * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtcat.begin(),bxtcat.end()) * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcat,2.0 * bdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtcat,2.0 * bdx,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcat,2.0 * bdx,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcatlen, bxtcat, 2.0 * bdx,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> aa3 * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aa.begin(),aa.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aa,bdxtail,temp8[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,bdxtail,temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, aa, bdxtail, temp8);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> (aa3 * bdxtail) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> (aa3 * bdxtail) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(temp8.begin(),temp8.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(temp8,cdytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,cdytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8len, temp8, cdytail,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> cc3 * <a href="CppOperatorMinus.htm">-</a>bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cc.begin(),cc.end()) * <a href="CppOperatorMinus.htm">-</a>bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc, <a href="CppOperatorMinus.htm">-</a>bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cc, <a href="CppOperatorMinus.htm">-</a>bdxtail, temp8[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cc, <a href="CppOperatorMinus.htm">-</a>bdxtail, temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, cc, <a href="CppOperatorMinus.htm">-</a>bdxtail, temp8);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> (cc3 * <a href="CppOperatorMinus.htm">-</a>bdxtail) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> (cc3 * <a href="CppOperatorMinus.htm">-</a>bdxtail) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(temp8.begin(),temp8.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(temp8,adytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,adytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8len, temp8, adytail,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> cat * bdxtail * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> cat * bdxtail * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtcat.begin(),bxtcat.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcat, bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtcat, bdxtail,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcat, bdxtail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcatlen, bxtcat, bdxtail,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bxtcatt <a href="CppOperatorAssign.htm">=</a> catt3 * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcatt[0] <a href="CppOperatorAssign.htm">=</a> catt3 * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcatt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(catt.begin(),catt.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bxtcatt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catt, bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(catt, bdxtail, bxtcatt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcattlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catt, bdxtail, bxtcatt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bxtcattlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cattlen, catt, bdxtail, bxtcatt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> catt3 * bdxtail * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> catt3 * bdxtail * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtcatt.begin(),bxtcatt.end()) * 2.0 * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcatt,2.0 * bdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtcatt,2.0 * bdx,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcatt,2.0 * bdx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcattlen, bxtcatt, 2.0 * bdx,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> catt3 * bdxtail * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> catt3 * bdxtail * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bxtcatt.begin(),bxtcatt.end()) * bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcatt,bdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bxtcatt,bdxtail,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcatt,bdxtail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bxtcattlen, bxtcatt, bdxtail,temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32b <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32b <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp64 <a href="CppOperatorAssign.htm">=</a> temp32a <a href="CppOperatorPlus.htm">+</a> temp32b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp64 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32alen, temp32a,temp32blen, temp32b, temp64);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp64len,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ca3 * bdytail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytca.begin(),bytca.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytca,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytca,bdytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytca,bdytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcalen, bytca, bdytail, temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcat[0] <a href="CppOperatorAssign.htm">=</a> cat * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcat[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cat.begin(),cat.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcat[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cat,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cat,bdytail,bytcat[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcatlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cat,bdytail,bytcat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcatlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catlen, cat, bdytail, bytcat);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> cat * bdytail * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> cat * bdytail * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytcat.begin(),bytcat.end()) * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcat,2.0 * bdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytcat,2.0 * bdy,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcat,2.0 * bdy,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcatlen, bytcat, 2.0 * bdy,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> cat * bdytail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> cat * bdytail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytcat.begin(),bytcat.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcat,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytcat,bdytail,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcat,bdytail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcatlen, bytcat, bdytail,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bytcatt <a href="CppOperatorAssign.htm">=</a> catt3 * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcatt[0] <a href="CppOperatorAssign.htm">=</a> catt3 * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcatt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(catt.begin(),catt.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bytcatt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catt,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(catt,bdytail,bytcatt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcattlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catt,bdytail,bytcatt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytcattlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cattlen, catt, bdytail, bytcatt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> bytcatt * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytcatt.begin(),bytcatt.end()) * 2.0 * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcatt,2.0 * bdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytcatt,2.0 * bdy,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcatt,2.0 * bdy,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcattlen, bytcatt, 2.0 * bdy,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> bytcatt * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bytcatt.begin(),bytcatt.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcatt, bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bytcatt, bdytail,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcatt, bdytail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bytcattlen, bytcatt, bdytail,temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32b <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32b <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp64 <a href="CppOperatorAssign.htm">=</a> temp32a <a href="CppOperatorPlus.htm">+</a> temp32b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp64 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32alen, temp32a,temp32blen, temp32b, temp64);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp64len,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Uses same conditional statement twice<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? (adxtail * bdy) <a href="CppOperatorPlus.htm">+</a> (adx * bdytail) <a href="CppOperatorPlus.htm">+</a> (bdxtail * <a href="CppOperatorMinus.htm">-</a>ady) <a href="CppOperatorPlus.htm">+</a> (bdx * <a href="CppOperatorMinus.htm">-</a>adytail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abtt3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? (adxtail * bdytail) <a href="CppOperatorMinus.htm">-</a> (bdxtail * adytail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abt <a href="CppOperatorAssign.htm">=</a> (adxtail * bdy) <a href="CppOperatorPlus.htm">+</a> (adx * bdytail) <a href="CppOperatorPlus.htm">+</a> (bdxtail * <a href="CppOperatorMinus.htm">-</a>ady) <a href="CppOperatorPlus.htm">+</a> (bdx * <a href="CppOperatorMinus.htm">-</a>adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> (adxtail * bdy) <a href="CppOperatorPlus.htm">+</a> (adx * bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> ti1 <a href="CppOperatorAssign.htm">=</a> adxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, bdy, ti1, ti0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> tj1 <a href="CppOperatorAssign.htm">=</a> adx * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adx, bdytail, tj1, tj0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(ti1, ti0, tj1, tj0, u3, u[2], u[1], u[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v3 <a href="CppOperatorAssign.htm">=</a> (bdxtail * <a href="CppOperatorMinus.htm">-</a>ady) <a href="CppOperatorPlus.htm">+</a> (bdx * <a href="CppOperatorMinus.htm">-</a>adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> bdxtail * <a href="CppOperatorMinus.htm">-</a>ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> bdxtail * negate;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, negate, ti1, ti0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> bdx * <a href="CppOperatorMinus.htm">-</a>adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> bdx * negate;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdx, negate, tj1, tj0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorPlus.htm">+</a> tj1 <a href="CppOperatorPlus.htm">+</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorPlus.htm">+</a> b1 <a href="CppOperatorPlus.htm">+</a> b0, x2=0.0, x1=0.0, x0=0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Sum(ti1, ti0, tj1, tj0, v3, v[2], v[1], v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[3] <a href="CppOperatorAssign.htm">=</a> v3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abt <a href="CppOperatorAssign.htm">=</a> u3 <a href="CppOperatorPlus.htm">+</a> v3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abt <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(u,v,abt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> abtlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v,abt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> abtlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(u,v, abt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> abtlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(4, u, 4, v, abt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abtt3 <a href="CppOperatorAssign.htm">=</a> (adxtail * bdytail) <a href="CppOperatorMinus.htm">-</a> (bdxtail * adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ti1 <a href="CppOperatorAssign.htm">=</a> adxtail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, bdytail, ti1, ti0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tj1 <a href="CppOperatorAssign.htm">=</a> bdxtail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, adytail, tj1, tj0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abtt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorMinus.htm">-</a> tj1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorMinus.htm">-</a> tj1 <a href="CppOperatorMinus.htm">-</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtt3 <a href="CppOperatorAssign.htm">=</a> ti1 <a href="CppOperatorPlus.htm">+</a> ti0 <a href="CppOperatorMinus.htm">-</a> tj1 <a href="CppOperatorMinus.htm">-</a> tj0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(ti1, ti0, tj1, tj0, abtt3, abtt[2], abtt[1], abtt[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtt[3] <a href="CppOperatorAssign.htm">=</a> abtt3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> abttlen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abt[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtlen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtt[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> abttlen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ab3 * cdxtail * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdxtail * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtab.begin(),cxtab.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtab,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtab,cdxtail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtablen, cxtab, cdxtail, temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtablen, cxtab, cdxtail, temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtabt[0] <a href="CppOperatorAssign.htm">=</a> abt * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtabt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(abt.begin(),abt.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtabt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abt,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abt,cdxtail,cxtabt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abtlen, abt, cdxtail, cxtabt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtabtlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abtlen, abt, cdxtail, cxtabt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> abt * cdxtail * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> abt * cdxtail * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtabt.begin(),cxtabt.end()) * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabt, 2.0 * cdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtabt, 2.0 * cdx,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cxtabt, 2.0 * cdx,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(1, cxtabt, 2.0 * cdx,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabtlen, cxtabt, 2.0 * cdx,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, temp16a,1,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,1,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp32alen, temp32a, temp48);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> ((bb3 * cdxtail) * adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> bb3 * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bb.begin(),bb.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bb,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bb,cdxtail,temp8[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, bb, cdxtail, temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bb, cdxtail, temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> (bb3 * cdxtail) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> (bb3 * cdxtail) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(temp8.begin(),temp8.end()) * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,adytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(temp8,adytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, temp8, adytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(1, temp8, adytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8len, temp8, adytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow,1,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> aa3 * <a href="CppOperatorMinus.htm">-</a>cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(aa.begin(),aa.end()) * <a href="CppOperatorMinus.htm">-</a>cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp8[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(aa,-cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(aa,-cdxtail,temp8[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, aa, <a href="CppOperatorMinus.htm">-</a>cdxtail, temp8);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp8len <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, aa, <a href="CppOperatorMinus.htm">-</a>cdxtail, temp8);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> (aa3 * <a href="CppOperatorMinus.htm">-</a>cdxtail) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> (aa3 * <a href="CppOperatorMinus.htm">-</a>cdxtail) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(temp8.begin(),temp8.end()) * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8,bdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(temp8,bdytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, temp8, bdytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(1, temp8, bdytail,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(temp8len, temp8, bdytail,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp16a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp16a,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow,1,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,temp16a, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> abt * cdxtail * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> abt * cdxtail * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtabt.begin(),cxtabt.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabt, cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtabt, cdxtail,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cxtabt, cdxtail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtabtlen, cxtabt, cdxtail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabtlen, cxtabt, cdxtail,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cxtabtt <a href="CppOperatorAssign.htm">=</a> abtt3 * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtabtt[0] <a href="CppOperatorAssign.htm">=</a> abtt3 * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtabtt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(abtt.begin(),abtt.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cxtabtt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abtt,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abtt,cdxtail,cxtabtt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abttlen, abtt, cdxtail, cxtabtt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cxtabttlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abttlen, abtt, cdxtail, cxtabtt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> cxtabtt * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtabtt.begin(),cxtabtt.end()) * 2.0 * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabtt,2.0 * cdx);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtabtt,2.0 * cdx,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cxtabtt, 2.0 * cdx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(1, cxtabtt, 2.0 * cdx,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabttlen, cxtabtt, 2.0 * cdx,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b[0] <a href="CppOperatorAssign.htm">=</a> cxtabtt * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cxtabtt.begin(),cxtabtt.end()) * cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabtt,cdxtail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtabtt,cdxtail,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cxtabtt, cdxtail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cxtabttlen, cxtabtt, cdxtail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cxtabttlen, cxtabtt, cdxtail,temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32b <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32b <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1,temp16a,temp16b, temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16b, temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp64 <a href="CppOperatorAssign.htm">=</a> temp32a <a href="CppOperatorPlus.htm">+</a> temp32b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp64 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, temp32a,temp32blen, temp32b, temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32alen, temp32a,temp32blen, temp32b, temp64);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp64len,temp64, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (ab3 * cdytail * cdytail) <a href="CppOperatorPlus.htm">+</a> (abt * cdytail * 2.0 * cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> ab3 * cdytail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdytail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cytab.begin(),cytab.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytab,cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytab,cdytail,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytablen, cytab, cdytail, temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytablen, cytab, cdytail, temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytabt[0] <a href="CppOperatorAssign.htm">=</a> abt * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytabt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(abt.begin(),abt.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytabt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abt,cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abt,cdytail,cytabt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abtlen, abt, cdytail, cytabt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytabtlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abtlen, abt, cdytail, cytabt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a <a href="CppOperatorPlus.htm">+</a> (abt * cdytail * 2.0 * cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> abt * cdytail * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> abt * cdytail * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabt) * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabt,2.0 * cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabt,2.0 * cdy,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cytabt, 2.0 * cdy,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabtlen, cytabt, 2.0 * cdy,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabtlen, cytabt, 2.0 * cdy,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp48 <a href="CppOperatorAssign.htm">=</a> temp16a <a href="CppOperatorPlus.htm">+</a> temp32a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp48 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1,temp16a,1,temp32a,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, temp16a,temp32alen, temp32a, temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp48len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp32alen, temp32a, temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp48;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp48,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp48len,temp48, finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32a <a href="CppOperatorAssign.htm">=</a> abt * cdytail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> abt * cdytail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabt) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabt, cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabt, cdytail,temp32a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cytabt, cdytail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabtlen, cytabt, cdytail,temp32a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabtlen, cytabt, cdytail,temp32a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cytabtt <a href="CppOperatorAssign.htm">=</a> abtt3 * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytabtt[0] <a href="CppOperatorAssign.htm">=</a> abtt3 * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytabtt[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(abtt.begin(),abtt.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cytabtt[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abtt,cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abtt,cdytail,cytabtt[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abttlen, abtt, cdytail, cytabtt);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> cytabttlen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abttlen, abtt, cdytail, cytabtt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16a <a href="CppOperatorAssign.htm">=</a> cytabtt * 2.0 * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16a[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabtt, 2.0 * cdy);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabtt, 2.0 * cdy,temp16a[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cytabtt, 2.0 * cdy,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabttlen, cytabtt, 2.0 * cdy,temp16a);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabttlen, cytabtt, 2.0 * cdy,temp16a);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp16b <a href="CppOperatorAssign.htm">=</a> cytabtt * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cytabtt.begin(),cytabtt.end()) * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp16b[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabtt, cdytail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabtt, cdytail,temp16b[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(1, cytabtt, cdytail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cytabttlen, cytabtt, cdytail,temp16b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp32b <a href="CppOperatorAssign.htm">=</a> temp16a * temp16b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp32b <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16a,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, temp16a,1,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,1,temp16b,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp16blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cytabttlen, cytabtt, cdytail,temp16b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp32blen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp16alen, temp16a,temp16blen, temp16b, temp32b);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> temp64 <a href="CppOperatorAssign.htm">=</a> temp32a <a href="CppOperatorPlus.htm">+</a> temp32b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>temp64 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32a,temp32b,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, temp32a,temp32blen, temp32b, temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> temp64len <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(temp32alen, temp32a,temp32blen, temp32b, temp64);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> temp64;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,temp64,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, temp64len,temp64, finother);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> finnow;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> finnow[finlength <a href="CppOperatorMinus.htm">-</a> 1];<br/>
}<br/>
<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::incircle(<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_incirclecount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_m_incirclecount;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adx <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdx <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdx <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ady <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdy <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdy <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxcdy <a href="CppOperatorAssign.htm">=</a> bdx * cdy;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxbdy <a href="CppOperatorAssign.htm">=</a> cdx * bdy;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> alift <a href="CppOperatorAssign.htm">=</a> adx * adx <a href="CppOperatorPlus.htm">+</a> ady * ady;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxady <a href="CppOperatorAssign.htm">=</a> cdx * ady;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxcdy <a href="CppOperatorAssign.htm">=</a> adx * cdy;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> blift <a href="CppOperatorAssign.htm">=</a> bdx * bdx <a href="CppOperatorPlus.htm">+</a> bdy * bdy;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxbdy <a href="CppOperatorAssign.htm">=</a> adx * bdy;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxady <a href="CppOperatorAssign.htm">=</a> bdx * ady;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> clift <a href="CppOperatorAssign.htm">=</a> cdx * cdx <a href="CppOperatorPlus.htm">+</a> cdy * cdy;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alift * (bdxcdy <a href="CppOperatorMinus.htm">-</a> cdxbdy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> blift * (cdxady <a href="CppOperatorMinus.htm">-</a> adxcdy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> clift * (adxbdy <a href="CppOperatorMinus.htm">-</a> bdxady)<br/>
&nbsp;&nbsp;).value();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_noexact)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> permanent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (<a href="CppStdAbs.htm">std::abs</a>(bdxcdy) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAbs.htm">std::abs</a>(cdxbdy)) * alift<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (<a href="CppStdAbs.htm">std::abs</a>(cdxady) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAbs.htm">std::abs</a>(adxcdy)) * blift<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (<a href="CppStdAbs.htm">std::abs</a>(adxbdy) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAbs.htm">std::abs</a>(bdxady)) * clift<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_iccerrboundA * permanent;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det &gt; errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det &gt; errbound)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> incircleadapt(pa, pb, pc, pd, permanent);<br/>
}<br/>
<br/>
<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::orient3dadapt(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> aheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> permanent<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det, errbound;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bdxcdy1, cdxbdy1, cdxady1, adxcdy1, adxbdy1, bdxady1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxcdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxbdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxcdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxbdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bc[4], ca[4], ab[4];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bc(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ca(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ab(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bc3, ca3, ab3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; adet(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bdet(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cdet(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adet(8,0.0), bdet(8,0.0), cdet(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; abdet(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> abdet[16];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> *finnow, *finother, *finswap;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; fin1(192,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; fin2(192,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> fin1[192], fin2[192];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adxtail, bdxtail, cdxtail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adytail, bdytail, cdytail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adheighttail, bdheighttail, cdheighttail;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> at_blarge,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> at_clarge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bt_clarge,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bt_alarge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ct_alarge,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ct_blarge;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; at_b(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; at_c(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bt_c(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bt_a(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ct_a(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; ct_b(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> at_blen, at_clen, bt_clen, bt_alen, ct_alen, ct_blen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bdxt_cdy1, cdxt_bdy1, cdxt_ady1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adxt_cdy1, adxt_bdy1, bdxt_ady1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxt_cdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxt_bdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxt_ady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxt_cdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxt_bdy0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxt_ady0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bdyt_cdx1, cdyt_bdx1, cdyt_adx1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adyt_cdx1, adyt_bdx1, bdyt_adx1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdyt_cdx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdyt_bdx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdyt_adx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adyt_cdx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adyt_bdx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdyt_adx0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; bct(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; cat(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; abt(8,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> bctlen, catlen, abtlen;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bdxt_cdyt1, cdxt_bdyt1, cdxt_adyt1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> adxt_cdyt1, adxt_bdyt1, bdxt_adyt1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxt_cdyt0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxt_bdyt0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cdxt_adyt0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxt_cdyt0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxt_bdyt0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bdxt_adyt0 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; u(4,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; v(12,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; w(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> u3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> vlength, wlength;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> negate;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adx <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdx <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdx <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ady <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdy <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdy <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adheight <a href="CppOperatorAssign.htm">=</a> aheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdheight <a href="CppOperatorAssign.htm">=</a> bheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdheight <a href="CppOperatorAssign.htm">=</a> cheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxcdy1 <a href="CppOperatorAssign.htm">=</a> bdx * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdx, cdy, bdxcdy1, bdxcdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxbdy1 <a href="CppOperatorAssign.htm">=</a> cdx * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdx, bdy, cdxbdy1, cdxbdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bc3 <a href="CppOperatorAssign.htm">=</a> bdxcdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bc3 <a href="CppOperatorAssign.htm">=</a> bdxcdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> bc3 <a href="CppOperatorAssign.htm">=</a> bdxcdy1 <a href="CppOperatorPlus.htm">+</a> bdxcdy0 <a href="CppOperatorMinus.htm">-</a> cdxbdy1 <a href="CppOperatorMinus.htm">-</a> cdxbdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(bdxcdy1, bdxcdy0, cdxbdy1, cdxbdy0, bc3, bc[2], bc[1], bc[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bc[3] <a href="CppOperatorAssign.htm">=</a> bc3;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>adet[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>adet[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bc.begin(),bc.end()) * adheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>adet[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,adheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bc,adheight,adet[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, bc, adheight, adet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> alen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bc, adheight, adet);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxady1 <a href="CppOperatorAssign.htm">=</a> cdx * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdx, ady, cdxady1, cdxady0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxcdy1 <a href="CppOperatorAssign.htm">=</a> adx * cdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adx, cdy, adxcdy1, adxcdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ca3 <a href="CppOperatorAssign.htm">=</a> cdxady1 <a href="CppOperatorMinus.htm">-</a> adxcdy1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ca3 <a href="CppOperatorAssign.htm">=</a> cdxady1 <a href="CppOperatorMinus.htm">-</a> adxcdy1 <a href="CppOperatorMinus.htm">-</a> adxcdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ca3 <a href="CppOperatorAssign.htm">=</a> cdxady1 <a href="CppOperatorPlus.htm">+</a> cdxady0 <a href="CppOperatorMinus.htm">-</a> adxcdy1 <a href="CppOperatorMinus.htm">-</a> adxcdy0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(cdxady1, cdxady0, adxcdy1, adxcdy0, ca3, ca[2], ca[1], ca[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ca[3] <a href="CppOperatorAssign.htm">=</a> ca3;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bdet[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bdet[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ca.begin(),ca.end()) * bdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bdet[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ca,bdheight,bdet[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, ca, bdheight, bdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> blen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ca, bdheight, bdet);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxbdy1 <a href="CppOperatorAssign.htm">=</a> adx * bdy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adx, bdy, adxbdy1, adxbdy0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxady1 <a href="CppOperatorAssign.htm">=</a> bdx * ady;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdx, ady, bdxady1, bdxady0);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ab3 <a href="CppOperatorAssign.htm">=</a> adxbdy1 <a href="CppOperatorMinus.htm">-</a> bdxady1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ab3 <a href="CppOperatorAssign.htm">=</a> adxbdy1 <a href="CppOperatorMinus.htm">-</a> bdxady1 <a href="CppOperatorMinus.htm">-</a> bdxady0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ab3 <a href="CppOperatorAssign.htm">=</a> adxbdy1 <a href="CppOperatorPlus.htm">+</a> adxbdy0 <a href="CppOperatorMinus.htm">-</a> bdxady1 <a href="CppOperatorMinus.htm">-</a> bdxady0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(adxbdy1, adxbdy0, bdxady1, bdxady0, ab3, ab[2], ab[1], ab[0]);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ab[3] <a href="CppOperatorAssign.htm">=</a> ab3;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cdet[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cdet[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ab.begin(),ab.end()) * cdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cdet[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ab,cdheight,cdet[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, ab, cdheight, cdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> clen <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ab, cdheight, cdet);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abdet <a href="CppOperatorAssign.htm">=</a> (bc3 * adheight) <a href="CppOperatorPlus.htm">+</a> (ca3 * bdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>abdet <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(adet,bdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(adet,bdet,abdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ablen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(adet,bdet,abdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ablen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, adet, 1, bdet, abdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ablen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(1, adet, blen, bdet, abdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> ablen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(alen, adet, blen, bdet, abdet);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> fin1 <a href="CppOperatorAssign.htm">=</a> (bc3 * adheight) <a href="CppOperatorPlus.htm">+</a> (ca3 * bdheight) <a href="CppOperatorPlus.htm">+</a> (ab3 * cdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fin1 <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(abdet,cdet);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(abdet,cdet,fin1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(ablen, abdet, 1, cdet, fin1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(ablen, abdet, clen, cdet, fin1);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> det <a href="CppOperatorAssign.htm">=</a> fin1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(fin1.begin(),fin1.end(),0.0).value();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> det <a href="CppOperatorAssign.htm">=</a> estimate(fin1);<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_o3derrboundB * permanent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adx <a href="CppOperatorPlus.htm">+</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pa[0], pd[0], adx, adxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdx <a href="CppOperatorPlus.htm">+</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pb[0], pd[0], bdx, bdxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxtail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdx <a href="CppOperatorPlus.htm">+</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pc[0], pd[0], cdx, cdxtail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>ady <a href="CppOperatorPlus.htm">+</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pa[1], pd[1], ady, adytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdy <a href="CppOperatorPlus.htm">+</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pb[1], pd[1], bdy, bdytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdytail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdy <a href="CppOperatorPlus.htm">+</a> pc-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(pc[1], pd[1], cdy, cdytail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adheighttail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adheight <a href="CppOperatorPlus.htm">+</a> aheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(aheight, dheight, adheight, adheighttail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdheighttail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdheight <a href="CppOperatorPlus.htm">+</a> bheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(bheight, dheight, bdheight, bdheighttail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdheighttail <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdheight <a href="CppOperatorPlus.htm">+</a> cheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(a,b,x,y): y <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>x <a href="CppOperatorPlus.htm">+</a> a <a href="CppOperatorMinus.htm">-</a> b;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Diff_Tail(cheight, dheight, cdheight, cdheighttail);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorEqual.htm">==</a> 0.0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bdxtail <a href="CppOperatorEqual.htm">==</a> 0.0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> cdxtail <a href="CppOperatorEqual.htm">==</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> adytail <a href="CppOperatorEqual.htm">==</a> 0.0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bdytail <a href="CppOperatorEqual.htm">==</a> 0.0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> cdytail <a href="CppOperatorEqual.htm">==</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> adheighttail <a href="CppOperatorEqual.htm">==</a> 0.0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> bdheighttail <a href="CppOperatorEqual.htm">==</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> cdheighttail <a href="CppOperatorEqual.htm">==</a> 0.0<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_o3derrboundC * permanent <a href="CppOperatorPlus.htm">+</a> Global().m_resulterrbound * <a href="CppStdAbs.htm">std::abs</a>(det);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;det <a href="CppOperatorPlusAssign.htm">+=</a> (adheight * ((bdx * cdytail <a href="CppOperatorPlus.htm">+</a> cdy * bdxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> (bdy * cdxtail <a href="CppOperatorPlus.htm">+</a> cdx * bdytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> adheighttail * (bdx * cdy <a href="CppOperatorMinus.htm">-</a> bdy * cdx))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (bdheight * ((cdx * adytail <a href="CppOperatorPlus.htm">+</a> ady * cdxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> (cdy * adxtail <a href="CppOperatorPlus.htm">+</a> adx * cdytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> bdheighttail * (cdx * ady <a href="CppOperatorMinus.htm">-</a> cdy * adx))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (cdheight * ((adx * bdytail <a href="CppOperatorPlus.htm">+</a> bdy * adxtail)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a> (ady * bdxtail <a href="CppOperatorPlus.htm">+</a> bdx * adytail))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> cdheighttail * (adx * bdy <a href="CppOperatorMinus.htm">-</a> ady * bdx))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det <a href="CppOperatorGreaterEqual.htm">&gt;=</a> errbound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> finnow <a href="CppOperatorAssign.htm">=</a> fin1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; finother(192,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; finother <a href="CppOperatorAssign.htm">=</a> fin2;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_b[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_blen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_c[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_clen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> at_blarge <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adytail * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> at_blarge <a href="CppOperatorAssign.htm">=</a> negate * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, bdx, at_blarge, at_b[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_b[1] <a href="CppOperatorAssign.htm">=</a> at_blarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_blen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> at_clarge <a href="CppOperatorAssign.htm">=</a> adytail * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adytail, cdx, at_clarge, at_c[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_c[1] <a href="CppOperatorAssign.htm">=</a> at_clarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_clen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> at_blarge <a href="CppOperatorAssign.htm">=</a> adxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, bdy, at_blarge, at_b[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_b[one_or_two] <a href="CppOperatorAssign.htm">=</a> at_blarge; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_blen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> at_clarge <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> at_clarge <a href="CppOperatorAssign.htm">=</a> negate * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, cdy, at_clarge, at_c[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_c[one_or_two] <a href="CppOperatorAssign.htm">=</a> at_clarge; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_clen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxt_bdy1 <a href="CppOperatorAssign.htm">=</a> adxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, bdy, adxt_bdy1, adxt_bdy0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adyt_bdx1 <a href="CppOperatorAssign.htm">=</a> adytail * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adytail, bdx, adyt_bdx1, adyt_bdx0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> at_blarge <a href="CppOperatorAssign.htm">=</a> adxt_bdy1 <a href="CppOperatorMinus.htm">-</a> adyt_bdx1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_blarge <a href="CppOperatorAssign.htm">=</a> adxt_bdy1 <a href="CppOperatorMinus.htm">-</a> adyt_bdx1 <a href="CppOperatorMinus.htm">-</a> adyt_bdx0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_blarge <a href="CppOperatorAssign.htm">=</a> adxt_bdy1 <a href="CppOperatorPlus.htm">+</a> adxt_bdy0 <a href="CppOperatorMinus.htm">-</a> adyt_bdx1 <a href="CppOperatorMinus.htm">-</a> adyt_bdx0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(adxt_bdy1, adxt_bdy0, adyt_bdx1, adyt_bdx0,at_blarge, at_b[2], at_b[1], at_b[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_b[3] <a href="CppOperatorAssign.htm">=</a> at_blarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_blen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adyt_cdx1 <a href="CppOperatorAssign.htm">=</a> adytail * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adytail, cdx, adyt_cdx1, adyt_cdx0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxt_cdy1 <a href="CppOperatorAssign.htm">=</a> adxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, cdy, adxt_cdy1, adxt_cdy0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> at_clarge <a href="CppOperatorAssign.htm">=</a> adyt_cdx1 <a href="CppOperatorMinus.htm">-</a> adxt_cdy1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_clarge <a href="CppOperatorAssign.htm">=</a> adyt_cdx1 <a href="CppOperatorPlus.htm">+</a> adyt_cdx0 <a href="CppOperatorMinus.htm">-</a> adxt_cdy1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_clarge <a href="CppOperatorAssign.htm">=</a> adyt_cdx1 <a href="CppOperatorPlus.htm">+</a> adyt_cdx0 <a href="CppOperatorMinus.htm">-</a> adxt_cdy1 <a href="CppOperatorMinus.htm">-</a> adxt_cdy0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(adyt_cdx1, adyt_cdx0, adxt_cdy1, adxt_cdy0,at_clarge, at_c[2], at_c[1], at_c[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at_c[3] <a href="CppOperatorAssign.htm">=</a> at_clarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>at_clen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_c[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_clen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_a[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bt_clarge <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdytail * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bt_clarge <a href="CppOperatorAssign.htm">=</a> negate * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, cdx, bt_clarge, bt_c[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_c[1] <a href="CppOperatorAssign.htm">=</a> bt_clarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_clen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> bt_alarge <a href="CppOperatorAssign.htm">=</a> bdytail * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdytail, adx, bt_alarge, bt_a[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_a[1] <a href="CppOperatorAssign.htm">=</a> bt_alarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bt_clarge <a href="CppOperatorAssign.htm">=</a> bdxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, cdy, bt_clarge, bt_c[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_c[one_or_two] <a href="CppOperatorAssign.htm">=</a> bt_clarge; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_clen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_alarge <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alarge <a href="CppOperatorAssign.htm">=</a> negate * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, ady, bt_alarge, bt_a[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_a[one_or_two] <a href="CppOperatorAssign.htm">=</a> bt_alarge; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxt_cdy1 <a href="CppOperatorAssign.htm">=</a> bdxtail * cdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, cdy, bdxt_cdy1, bdxt_cdy0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdyt_cdx1 <a href="CppOperatorAssign.htm">=</a> bdytail * cdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdytail, cdx, bdyt_cdx1, bdyt_cdx0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bt_clarge <a href="CppOperatorAssign.htm">=</a> bdxt_cdy1 <a href="CppOperatorMinus.htm">-</a> bdyt_cdx1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_clarge <a href="CppOperatorAssign.htm">=</a> bdxt_cdy1 <a href="CppOperatorMinus.htm">-</a> bdyt_cdx1 <a href="CppOperatorMinus.htm">-</a> bdyt_cdx0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_clarge <a href="CppOperatorAssign.htm">=</a> bdxt_cdy1 <a href="CppOperatorPlus.htm">+</a> bdxt_cdy0 <a href="CppOperatorMinus.htm">-</a> bdyt_cdx1 <a href="CppOperatorMinus.htm">-</a> bdyt_cdx0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(bdxt_cdy1, bdxt_cdy0, bdyt_cdx1, bdyt_cdx0,bt_clarge, bt_c[2], bt_c[1], bt_c[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_c[3] <a href="CppOperatorAssign.htm">=</a> bt_clarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_clen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdyt_adx1 <a href="CppOperatorAssign.htm">=</a> bdytail * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdytail, adx, bdyt_adx1, bdyt_adx0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxt_ady1 <a href="CppOperatorAssign.htm">=</a> bdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, ady, bdxt_ady1, bdxt_ady0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bt_alarge <a href="CppOperatorAssign.htm">=</a> bdyt_adx1 <a href="CppOperatorMinus.htm">-</a> bdxt_ady1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alarge <a href="CppOperatorAssign.htm">=</a> bdyt_adx1 <a href="CppOperatorPlus.htm">+</a> bdyt_adx0 <a href="CppOperatorMinus.htm">-</a> bdxt_ady1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alarge <a href="CppOperatorAssign.htm">=</a> bdyt_adx1 <a href="CppOperatorPlus.htm">+</a> bdyt_adx0 <a href="CppOperatorMinus.htm">-</a> bdxt_ady1 <a href="CppOperatorMinus.htm">-</a> bdxt_ady0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(bdyt_adx1, bdyt_adx0, bdxt_ady1, bdxt_ady0,bt_alarge, bt_a[2], bt_a[1], bt_a[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_a[3] <a href="CppOperatorAssign.htm">=</a> bt_alarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>bt_alen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_a[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_alen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_b[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blen <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ct_alarge <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdytail * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> ct_alarge <a href="CppOperatorAssign.htm">=</a> negate * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, adx, ct_alarge, ct_a[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_a[1] <a href="CppOperatorAssign.htm">=</a> ct_alarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_alen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_blarge <a href="CppOperatorAssign.htm">=</a> cdytail * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdytail, bdx, ct_blarge, ct_b[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_b[1] <a href="CppOperatorAssign.htm">=</a> ct_blarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ct_alarge <a href="CppOperatorAssign.htm">=</a> cdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, ady, ct_alarge, ct_a[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_a[one_or_two] <a href="CppOperatorAssign.htm">=</a> ct_alarge; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_alen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_blarge <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blarge <a href="CppOperatorAssign.htm">=</a> negate * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, bdy, ct_blarge, ct_b[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_b[one_or_two] <a href="CppOperatorAssign.htm">=</a> ct_blarge; <a href="CppComment.htm">//</a>RJCB: Shouldn't <b><a href="CppThis.htm">this</a></b> index be 2?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blen <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxt_ady1 <a href="CppOperatorAssign.htm">=</a> cdxtail * ady;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, ady, cdxt_ady1, cdxt_ady0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdyt_adx1 <a href="CppOperatorAssign.htm">=</a> cdytail * adx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdytail, adx, cdyt_adx1, cdyt_adx0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ct_alarge <a href="CppOperatorAssign.htm">=</a> cdxt_ady1 <a href="CppOperatorMinus.htm">-</a> cdyt_adx1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_alarge <a href="CppOperatorAssign.htm">=</a> cdxt_ady1 <a href="CppOperatorMinus.htm">-</a> cdyt_adx1 <a href="CppOperatorMinus.htm">-</a> cdyt_adx0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_alarge <a href="CppOperatorAssign.htm">=</a> cdxt_ady1 <a href="CppOperatorPlus.htm">+</a> cdxt_ady0 <a href="CppOperatorMinus.htm">-</a> cdyt_adx1 <a href="CppOperatorMinus.htm">-</a> cdyt_adx0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(cdxt_ady1, cdxt_ady0, cdyt_adx1, cdyt_adx0,ct_alarge, ct_a[2], ct_a[1], ct_a[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_a[3] <a href="CppOperatorAssign.htm">=</a> ct_alarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_alen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdyt_bdx1 <a href="CppOperatorAssign.htm">=</a> cdytail * bdx;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdytail, bdx, cdyt_bdx1, cdyt_bdx0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxt_bdy1 <a href="CppOperatorAssign.htm">=</a> cdxtail * bdy;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, bdy, cdxt_bdy1, cdxt_bdy0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_blarge <a href="CppOperatorAssign.htm">=</a> cdyt_bdx1 <a href="CppOperatorMinus.htm">-</a> cdxt_bdy1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blarge <a href="CppOperatorAssign.htm">=</a> cdyt_bdx1 <a href="CppOperatorPlus.htm">+</a> cdyt_bdx0 <a href="CppOperatorMinus.htm">-</a> cdxt_bdy1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blarge <a href="CppOperatorAssign.htm">=</a> cdyt_bdx1 <a href="CppOperatorPlus.htm">+</a> cdyt_bdx0 <a href="CppOperatorMinus.htm">-</a> cdxt_bdy1 <a href="CppOperatorMinus.htm">-</a> cdxt_bdy0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(a1,a0,b1,b0,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> a1 <a href="CppOperatorPlus.htm">+</a> a0 <a href="CppOperatorMinus.htm">-</a> b0 <a href="CppOperatorMinus.htm">-</a> b1, x2 <a href="CppOperatorAssign.htm">=</a> 0.0, x1 <a href="CppOperatorAssign.htm">=</a> 0.0, x0 <a href="CppOperatorAssign.htm">=</a> 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_Two_Diff(cdyt_bdx1, cdyt_bdx0, cdxt_bdy1, cdxt_bdy0,ct_blarge, ct_b[2], ct_b[1], ct_b[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct_b[3] <a href="CppOperatorAssign.htm">=</a> ct_blarge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>ct_blen <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bct <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bt_c.begin(),bt_c.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ct_b.begin(),ct_b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bct <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(bt_c,ct_b);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(bt_c,ct_b,bct);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bctlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(bt_c,ct_b,bct);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>bctlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(bt_clen, bt_c, ct_blen, ct_b, bct);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> bct * adheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> bct * adheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bct.begin(),bct.end()) * adheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bct,adheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bct,adheight,w[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bctlen, bct, adheight, w);<br/>
<br/>
&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> w;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> w;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, w,finother);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>wlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctlen, bct, adheight, w);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,finother);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cat <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ct_a.begin(),ct_a.end(),0.0) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(at_c.begin(),at_c.end(),0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>cat <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(ct_a,at_c);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(ct_a,at_c,cat);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>catlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(ct_a,at_c,cat);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>catlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(ct_alen, ct_a, at_clen, at_c, cat);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> cat * bdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cat.begin(),cat.end()) * bdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cat,bdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cat,bdheight,w[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(catlen, cat, bdheight, w);<br/>
<br/>
&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> w;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> w;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>wlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catlen, cat, bdheight, w);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> abt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(at_b.begin(),at_b.end(),0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bt_a.begin(),bt_a.end(),0.0)<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>abt <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(at_b,bt_a);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(at_b,bt_a,abt);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(at_b,bt_a,abt);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>abtlen <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(at_blen, at_b, bt_alen, bt_a, abt);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> abt * cdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(abt.begin(),abt.end()) * cdheight;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abt,cdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abt,cdheight,w[0]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abtlen, abt, cdheight, w);<br/>
<br/>
&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (abt * cdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (abt * cdheight);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>wlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abtlen, abt, cdheight, w);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> bc3 * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bc.begin(),bc.end()) * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bc,adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bc,adheighttail,v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, bc, adheighttail, v);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bc3 * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (bc3 * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, bc, adheighttail, v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, vlength, v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> ca3 * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ca.begin(),ca.end()) * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ca,bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ca,bdheighttail,v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, ca, bdheighttail, v);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (ca3 * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (ca3 * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ca, bdheighttail, v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, vlength, v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> ab3 * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(ab.begin(),ab.end()) * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>v[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(ab,cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(ab,cdheighttail,v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(4, ab, cdheighttail, v);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (ab3 * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (ab3 * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(4, ab, cdheighttail, v);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, vlength, v,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxt_bdyt1 <a href="CppOperatorAssign.htm">=</a> adxtail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(adxtail, bdytail, adxt_bdyt1, adxt_bdyt0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> adxt_bdyt1 * cdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (adxt_bdyt1 <a href="CppOperatorPlus.htm">+</a> adxt_bdyt0) * cdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(adxt_bdyt1, adxt_bdyt0, cdheight, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (adxt_bdyt1 * cdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (adxt_bdyt1 * cdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> adxt_bdyt1 * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (adxt_bdyt1 <a href="CppOperatorPlus.htm">+</a> adxt_bdyt0) * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(adxt_bdyt1, adxt_bdyt0, cdheighttail,u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (adxt_bdyt1 * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (adxt_bdyt1 * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxt_cdyt1 <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adxtail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>adxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> adxt_cdyt1 <a href="CppOperatorAssign.htm">=</a> negate * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, cdytail, adxt_cdyt1, adxt_cdyt0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> adxt_cdyt1 * bdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (adxt_cdyt1 <a href="CppOperatorPlus.htm">+</a> adxt_cdyt0) * bdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(adxt_cdyt1, adxt_cdyt0, bdheight, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (adxt_cdyt1 * bdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (adxt_cdyt1 * bdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> adxt_cdyt1 * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (adxt_cdyt1 <a href="CppOperatorPlus.htm">+</a> adxt_cdyt0) * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(adxt_cdyt1, adxt_cdyt0, bdheighttail,u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (adxt_cdyt1 * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (adxt_cdyt1 * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxt_cdyt1 <a href="CppOperatorAssign.htm">=</a> bdxtail * cdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(bdxtail, cdytail, bdxt_cdyt1, bdxt_cdyt0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> bdxt_cdyt1 * adheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (bdxt_cdyt1 <a href="CppOperatorPlus.htm">+</a> bdxt_cdyt0) * adheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(bdxt_cdyt1, bdxt_cdyt0, adheight, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bdxt_cdyt1 * adheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (bdxt_cdyt1 * adheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> bdxt_cdyt1 * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (bdxt_cdyt1 <a href="CppOperatorPlus.htm">+</a> bdxt_cdyt0) * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(bdxt_cdyt1, bdxt_cdyt0, adheighttail,u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bdxt_cdyt1 * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (bdxt_cdyt1 * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxt_adyt1 <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdxtail; * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>bdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxt_adyt1 <a href="CppOperatorAssign.htm">=</a> negate * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, adytail, bdxt_adyt1, bdxt_adyt0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> bdxt_adyt1 * cdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (bdxt_adyt1 <a href="CppOperatorPlus.htm">+</a> bdxt_adyt0) * cdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(bdxt_adyt1, bdxt_adyt0, cdheight, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bdxt_adyt1 * cdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (bdxt_adyt1 * cdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> bdxt_adyt1 * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (bdxt_adyt1 <a href="CppOperatorPlus.htm">+</a> bdxt_adyt0) * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(bdxt_adyt1, bdxt_adyt0, cdheighttail,u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bdxt_adyt1 * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (bdxt_adyt1 * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdxtail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxt_adyt1 <a href="CppOperatorAssign.htm">=</a> cdxtail * adytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(cdxtail, adytail, cdxt_adyt1, cdxt_adyt0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> cdxt_adyt1 * bdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (cdxt_adyt1 <a href="CppOperatorPlus.htm">+</a> cdxt_adyt0) * bdheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(cdxt_adyt1, cdxt_adyt0, bdheight, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (cdxt_adyt1 * bdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (cdxt_adyt1 * bdheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> cdxt_adyt1 * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (cdxt_adyt1 <a href="CppOperatorPlus.htm">+</a> cdxt_adyt0) * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(cdxt_adyt1, cdxt_adyt0, bdheighttail,u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (cdxt_adyt1 * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (cdxt_adyt1 * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdytail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxt_bdyt1 <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdxtail * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>negate <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>cdxtail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxt_bdyt1 <a href="CppOperatorAssign.htm">=</a> negate * bdytail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(a,b,x,y): x <a href="CppOperatorAssign.htm">=</a> a*b, y <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_<a href="CppProduct.htm">Product</a>(negate, bdytail, cdxt_bdyt1, cdxt_bdyt0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> cdxt_bdyt1 * adheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (cdxt_bdyt1 <a href="CppOperatorPlus.htm">+</a> cdxt_bdyt0) * adheight;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(cdxt_bdyt1, cdxt_bdyt0, adheight, u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (cdxt_bdyt1 * adheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (cdxt_bdyt1 * adheight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> u3 <a href="CppOperatorAssign.htm">=</a> cdxt_bdyt1 * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u3 <a href="CppOperatorAssign.htm">=</a> (cdxt_bdyt1 <a href="CppOperatorPlus.htm">+</a> cdxt_bdyt0) * adheighttail,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(a1,a0,b,x3,x2,x1,x0): x3 <a href="CppOperatorAssign.htm">=</a> (a1 <a href="CppOperatorPlus.htm">+</a> a0) * b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Two_One_<a href="CppProduct.htm">Product</a>(cdxt_bdyt1, cdxt_bdyt0, adheighttail,u3, u[2], u[1], u[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>u[3] <a href="CppOperatorAssign.htm">=</a> u3;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (cdxt_bdyt1 * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (cdxt_bdyt1 * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 4, u,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (adheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> bct * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(bct) * adheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bct,adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bct,adheighttail,w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(bctlen, bct, adheighttail, w);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (bct * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (bct * adheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1,w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>wlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(bctlen, bct, adheighttail, w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> cat * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(cat.begin(),cat.end()) * bdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(cat,bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(cat,bdheighttail,w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(catlen, cat, bdheighttail, w);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (cat * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (cat * bdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>wlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(catlen, cat, bdheighttail, w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cdheighttail <a href="CppOperatorNotEqual.htm">!=</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> abt * cdheighttail;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(v,s): <b><a href="CppReturn.htm">return</a></b> <a href="CppStdAccumulate.htm">std::accumulate</a>(v.begin(),v.end()) * s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>w[0] <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abt,cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abt,cdheighttail,w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>scale_expansion_zeroelim(abtlen, abt, cdheighttail, w);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;finnow <a href="CppOperatorPlusAssign.htm">+=</a> (abt * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> finnow <a href="CppOperatorPlus.htm">+</a> (abt * cdheighttail);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finother <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fast_expansion_sum_zeroelim(a,b,c): c <a href="CppOperatorAssign.htm">=</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(a.begin(),a.end()) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAccumulate.htm">std::accumulate</a>(b.begin(),b.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finnow,w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, 1, w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>wlength <a href="CppOperatorAssign.htm">=</a> scale_expansion_zeroelim(abtlen, abt, cdheighttail, w);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finlength <a href="CppOperatorAssign.htm">=</a> fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdSwap.htm">std::swap</a>(finnow,finother);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>finswap <a href="CppOperatorAssign.htm">=</a> finnow; finnow <a href="CppOperatorAssign.htm">=</a> finother; finother <a href="CppOperatorAssign.htm">=</a> finswap;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> finnow;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> finnow[finlength <a href="CppOperatorMinus.htm">-</a> 1];<br/>
}<br/>
<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::orient3d(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_orient3dcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length aheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length bheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length cheight,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length dheight<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_m_orient3dcount;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adx <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdx <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdx <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ady <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdy <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdy <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pd-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adheight <a href="CppOperatorAssign.htm">=</a> aheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdheight <a href="CppOperatorAssign.htm">=</a> bheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdheight <a href="CppOperatorAssign.htm">=</a> cheight <a href="CppOperatorMinus.htm">-</a> dheight;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxcdy <a href="CppOperatorAssign.htm">=</a> bdx * cdy;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxbdy <a href="CppOperatorAssign.htm">=</a> cdx * bdy;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> cdxady <a href="CppOperatorAssign.htm">=</a> cdx * ady;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxcdy <a href="CppOperatorAssign.htm">=</a> adx * cdy;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> adxbdy <a href="CppOperatorAssign.htm">=</a> adx * bdy;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdxady <a href="CppOperatorAssign.htm">=</a> bdx * ady;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> det<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (adheight * (bdxcdy <a href="CppOperatorMinus.htm">-</a> cdxbdy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> bdheight * (cdxady <a href="CppOperatorMinus.htm">-</a> adxcdy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> cdheight * (adxbdy <a href="CppOperatorMinus.htm">-</a> bdxady)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).value();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_noexact)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> permanent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (<a href="CppStdAbs.htm">std::abs</a>(bdxcdy) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAbs.htm">std::abs</a>(cdxbdy)) * <a href="CppStdAbs.htm">std::abs</a>(adheight)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (<a href="CppStdAbs.htm">std::abs</a>(cdxady) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAbs.htm">std::abs</a>(adxcdy)) * <a href="CppStdAbs.htm">std::abs</a>(bdheight)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (<a href="CppStdAbs.htm">std::abs</a>(adxbdy) <a href="CppOperatorPlus.htm">+</a> <a href="CppStdAbs.htm">std::abs</a>(bdxady)) * <a href="CppStdAbs.htm">std::abs</a>(cdheight)<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> errbound <a href="CppOperatorAssign.htm">=</a> Global().m_o3derrboundA * permanent;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (det &gt; errbound <a href="CppOperatorLogicalOr.htm">||</a> <a href="CppOperatorMinus.htm">-</a>det &gt; errbound)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> det;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> orient3dadapt(pa, pb, pc, pd, aheight, bheight, cheight, dheight,permanent);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::nonregular(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; incirclecount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pd<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (b.m_weighted <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> incircle(incirclecount, b_m_noexact, pa, pb, pc, pd);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (b.m_weighted <a href="CppOperatorEqual.htm">==</a> 1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> orient3d(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m, b, pa, pb, pc, pd,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pa[0] * pa[0] <a href="CppOperatorPlus.htm">+</a> pa[1] * pa[1] <a href="CppOperatorMinus.htm">-</a> pa[2],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pb[0] * pb[0] <a href="CppOperatorPlus.htm">+</a> pb[1] * pb[1] <a href="CppOperatorMinus.htm">-</a> pb[2],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc[0] * pc[0] <a href="CppOperatorPlus.htm">+</a> pc[1] * pc[1] <a href="CppOperatorMinus.htm">-</a> pc[2],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pd[0] * pd[0] <a href="CppOperatorPlus.htm">+</a> pd[1] * pd[1] <a href="CppOperatorMinus.htm">-</a> pd[2]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> orient3d(m, b, pa, pb, pc, pd, pa[2], pb[2], pc[2], pd[2]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::findcircumcenter(<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_circumcentercount,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> b_m_offconstant,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; torg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; tdest,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; tapex,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; circumcenter,<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b>&amp; xi,<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b>&amp; eta,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> offcenter<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> xdo, ydo, xao, yao;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dodist, aodist, dadist;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> denominator <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dx, dy, dxoff, dyoff;<br/>
<br/>
&nbsp;&nbsp;m_m_circumcentercount<a href="CppOperatorIncrement.htm">++</a>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Compute the circumcenter of the triangle.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> xdo <a href="CppOperatorAssign.htm">=</a> tdest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ydo <a href="CppOperatorAssign.htm">=</a> tdest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> xao <a href="CppOperatorAssign.htm">=</a> tapex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> yao <a href="CppOperatorAssign.htm">=</a> tapex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dodist <a href="CppOperatorAssign.htm">=</a> xdo * xdo <a href="CppOperatorPlus.htm">+</a> ydo * ydo;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> aodist <a href="CppOperatorAssign.htm">=</a> xao * xao <a href="CppOperatorPlus.htm">+</a> yao * yao;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dadist <a href="CppOperatorAssign.htm">=</a> (tdest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tapex-&gt;GetX()) * (tdest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tapex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (tdest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tapex-&gt;GetY()) * (tdest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tapex-&gt;GetY());<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_noexact)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;denominator <a href="CppOperatorAssign.htm">=</a> 0.5 <a href="CppOperatorDivide.htm">/</a> (xdo * yao <a href="CppOperatorMinus.htm">-</a> xao * ydo);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use the <a href="CppCounter.htm">counter</a>clockwise() routine to ensure a positive (and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;reasonably accurate) result, avoiding <a href="CppAny.htm">any</a> possibility of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;division by zero.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;denominator <a href="CppOperatorAssign.htm">=</a> 0.5 <a href="CppOperatorDivide.htm">/</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, tdest, tapex, torg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Don't count the above as an orientation test.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_m_<a href="CppCounter.htm">counter</a>clockcount<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> dx <a href="CppOperatorAssign.htm">=</a> (yao * dodist <a href="CppOperatorMinus.htm">-</a> ydo * aodist) * denominator;<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> dy <a href="CppOperatorAssign.htm">=</a> (xdo * aodist <a href="CppOperatorMinus.htm">-</a> xao * dodist) * denominator;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the (squared) length of the triangle's shortest edge.&nbsp;&nbsp;This<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;serves as a conservative estimate of the insertion radius of the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;circumcenter's parent.&nbsp;&nbsp;The estimate is used to ensure that<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the <a href="CppAlgorithm.htm">algorithm</a> terminates even <b><a href="CppIf.htm">if</a></b> very small angles appear in<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the input PSLG.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dodist &lt; aodist <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> dodist &lt; dadist)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (offcenter <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> b_m_offconstant &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the position of the off-center, as described by Alper Ungor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxoff <a href="CppOperatorAssign.htm">=</a> 0.5 * xdo <a href="CppOperatorMinus.htm">-</a> b_m_offconstant * ydo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyoff <a href="CppOperatorAssign.htm">=</a> 0.5 * ydo <a href="CppOperatorPlus.htm">+</a> b_m_offconstant * xdo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the off-center is closer to the origin than the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;circumcenter, use the off-center instead.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dxoff * dxoff <a href="CppOperatorPlus.htm">+</a> dyoff * dyoff &lt; dx * dx <a href="CppOperatorPlus.htm">+</a> dy * dy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx <a href="CppOperatorAssign.htm">=</a> dxoff;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy <a href="CppOperatorAssign.htm">=</a> dyoff;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (aodist &lt; dadist)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (offcenter <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (b_m_offconstant &gt; 0.0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxoff <a href="CppOperatorAssign.htm">=</a> 0.5 * xao <a href="CppOperatorPlus.htm">+</a> b_m_offconstant * yao;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyoff <a href="CppOperatorAssign.htm">=</a> 0.5 * yao <a href="CppOperatorMinus.htm">-</a> b_m_offconstant * xao;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the off-center is closer to the origin than the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;circumcenter, use the off-center instead.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dxoff * dxoff <a href="CppOperatorPlus.htm">+</a> dyoff * dyoff &lt; dx * dx <a href="CppOperatorPlus.htm">+</a> dy * dy)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx <a href="CppOperatorAssign.htm">=</a> dxoff;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy <a href="CppOperatorAssign.htm">=</a> dyoff;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (offcenter <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (b_m_offconstant &gt; 0.0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxoff <a href="CppOperatorAssign.htm">=</a> 0.5 * (tapex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tdest-&gt;GetX()) <a href="CppOperatorMinus.htm">-</a> b_m_offconstant * (tapex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tdest-&gt;GetY());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyoff <a href="CppOperatorAssign.htm">=</a> 0.5 * (tapex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tdest-&gt;GetY()) <a href="CppOperatorPlus.htm">+</a> b_m_offconstant * (tapex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tdest-&gt;GetX());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the off-center is closer to the destination than the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;circumcenter, use the off-center instead.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dxoff * dxoff <a href="CppOperatorPlus.htm">+</a> dyoff * dyoff &lt; (dx <a href="CppOperatorMinus.htm">-</a> xdo) * (dx <a href="CppOperatorMinus.htm">-</a> xdo) <a href="CppOperatorPlus.htm">+</a> (dy <a href="CppOperatorMinus.htm">-</a> ydo) * (dy <a href="CppOperatorMinus.htm">-</a> ydo))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx <a href="CppOperatorAssign.htm">=</a> xdo <a href="CppOperatorPlus.htm">+</a> dxoff;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy <a href="CppOperatorAssign.htm">=</a> ydo <a href="CppOperatorPlus.htm">+</a> dyoff;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;circumcenter-&gt;SetX(torg-&gt;GetX() <a href="CppOperatorPlus.htm">+</a> dx);<br/>
&nbsp;&nbsp;circumcenter-&gt;SetY(torg-&gt;GetY() <a href="CppOperatorPlus.htm">+</a> dy);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To interpolate vertex attributes <b><a href="CppFor.htm">for</a></b> the <b><a href="CppNew.htm">new</a></b> vertex inserted at<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the circumcenter, define a coordinate system with a xi-axis,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;directed from the triangle's origin to its destination, and<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;an eta-axis, directed from its origin to its apex.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Calculate the xi and eta coordinates of the circumcenter.<br/>
&nbsp;&nbsp;xi <a href="CppOperatorAssign.htm">=</a> (yao * dx <a href="CppOperatorMinus.htm">-</a> xao * dy) * (2.0 * denominator);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*xi <a href="CppOperatorAssign.htm">=</a> (yao * dx <a href="CppOperatorMinus.htm">-</a> xao * dy) * (2.0 * denominator);<br/>
&nbsp;&nbsp;eta <a href="CppOperatorAssign.htm">=</a> (xdo * dy <a href="CppOperatorMinus.htm">-</a> ydo * dx) * (2.0 * denominator);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*eta <a href="CppOperatorAssign.htm">=</a> (xdo * dy <a href="CppOperatorMinus.htm">-</a> ydo * dx) * (2.0 * denominator);<br/>
}<br/>
<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::checkmesh(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; m_m_triangles,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Arguments&amp; b<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri oppotri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri oppooppotri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex triorg, tridest, triapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporarily turn on exact arithmetic <b><a href="CppIf.htm">if</a></b> it's off.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> noexact <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>; <a href="CppComment.htm">//</a>b_m_noexact;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>b_m_noexact <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Run through the list of triangles, checking each one.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_tri <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_tri <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop-&gt;IsDead()) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_triangles.push_back(triangleloop);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check all three edges of the triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient <a href="CppOperatorNotEqual.htm">!=</a> 3; <a href="CppOperatorIncrement.htm">++</a>triangleloop-&gt;m_orient)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triorg <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(triangleloop, triorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tridest <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tridest <a href="CppOperatorAssign.htm">=</a> triangleloop.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only test <b><a href="CppFor.htm">for</a></b> in<a href="CppVersion.htm">version</a> once.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test <b><a href="CppIf.htm">if</a></b> the triangle is flat or inverted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triapex <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triapex <a href="CppOperatorAssign.htm">=</a> triangleloop.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, noexact, triorg, tridest, triapex) &gt; 0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, triorg, tridest, triapex) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("Inverted triangle");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the neighboring triangle on <b><a href="CppThis.htm">this</a></b> edge.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppotri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, oppotri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (oppotri.m_triangles[0] <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check that the triangle's neighbor knows it's a neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppooppotri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(oppotri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(oppotri, oppooppotri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(triangleloop-&gt;m_triangles <a href="CppOperatorNotEqual.htm">!=</a> oppooppotri.m_triangles <a href="CppOperatorLogicalOr.htm">||</a> triangleloop-&gt;m_orient <a href="CppOperatorNotEqual.htm">!=</a> oppooppotri.m_orient));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> ((triangleloop.m_tri <a href="CppOperatorNotEqual.htm">!=</a> oppooppotri.m_tri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> (triangleloop.m_orient <a href="CppOperatorNotEqual.htm">!=</a> oppooppotri.m_orient))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;!! !! Asymmetric triangle-triangle bond:\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop.m_tri <a href="CppOperatorEqual.htm">==</a> oppooppotri.m_tri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp; (Right triangle, wrong orientation)\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;printtriangle(m, b, &amp;triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Second (nonreciprocating) ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;printtriangle(m, b, &amp;oppotri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check that both triangles agree on the identities<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;of their shared vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppoorg <a href="CppOperatorAssign.htm">=</a> oppotri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(oppotri, oppoorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppodest <a href="CppOperatorAssign.htm">=</a> oppotri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(oppotri, oppodest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(triorg <a href="CppOperatorNotEqual.htm">!=</a> oppodest <a href="CppOperatorLogicalOr.htm">||</a> tridest <a href="CppOperatorNotEqual.htm">!=</a> oppoorg));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> ((triorg <a href="CppOperatorNotEqual.htm">!=</a> oppodest) <a href="CppOperatorLogicalOr.htm">||</a> (tridest <a href="CppOperatorNotEqual.htm">!=</a> oppoorg))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppTRACE.htm">TRACE</a>("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;!! !! Mismatched edge coordinates between two triangles:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First mismatched ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;printtriangle(m, b, &amp;triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Second mismatched ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;printtriangle(m, b, &amp;oppotri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_tri <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::checkdelaunay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; incirclecount<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> m_m_noexact,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Arguments&amp; b<br/>
)<br/>
{<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri oppotri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub opposubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex triorg, tridest, triapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex oppoapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> shouldbedelaunay;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporarily turn on exact arithmetic <b><a href="CppIf.htm">if</a></b> it's off.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>b.m_noexact <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Run through the list of triangles, checking each one.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_tri <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_tri <a href="CppOperatorNotEqual.htm">!=</a> (Triangle *) <a href="CppNULL.htm">NULL</a>)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop-&gt;IsDead()) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (my_triangle-&gt;IsDead()) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles[0] <a href="CppOperatorAssign.htm">=</a> my_triangle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check all three edges of the triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient &lt; 3; triangleloop-&gt;m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triorg <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tridest <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triapex <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppotri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, oppotri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppoapex <a href="CppOperatorAssign.htm">=</a> oppotri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(oppotri, oppoapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Only test that the edge is locally Delaunay <b><a href="CppIf.htm">if</a></b> there is an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjoining triangle whose <a href="CppPointer.htm">pointer</a> is larger (to ensure that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;each pair isn't tested twice).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> shouldbedelaunay<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;oppotri.m_triangles[0] <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !oppotri.m_triangles[0]-&gt;IsDead() <a href="CppComment.htm">//</a>!deadtri(oppotri.m_tri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> triangleloop-&gt;m_triangles &lt; oppotri.m_triangles<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *triorg <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *triorg <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *triorg <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *tridest <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *tridest <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *tridest <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *triapex <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *triapex <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *triapex <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *oppoapex <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *oppoapex <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> *oppoapex <a href="CppOperatorNotEqual.htm">!=</a> *m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> shouldbedelaunay)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If a subsegment separates the triangles, then the edge is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;constrained, so no local Delaunay test should be done.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> opposubseg <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.Tspivot(opposubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(triangleloop, opposubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (opposubseg-&gt;m_subsegs[0] <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shouldbedelaunay <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (shouldbedelaunay)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> saveexact <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>; <a href="CppComment.htm">//</a>b.m_noexact;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nonregular(incirclecount,triorg, tridest, triapex, oppoapex) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Should not get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!b.m_weighted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;!! !! Non-Delaunay pair of triangles:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First non-Delaunay ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Second non-Delaunay ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;!! !! Non-regular pair of triangles:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;First non-regular ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Second non-regular ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;oppotri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horrors<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_tri <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Restore the status of exact arithmetic.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>b.m_noexact <a href="CppOperatorAssign.htm">=</a> saveexact;<br/>
}<br/>
<br/>
<br/>
<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::BadTriang&gt; <a href="CppRibi.htm">ribi</a>::tricpp::dequeuebadtriang(Mesh&amp; m)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt; result;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If no queues are nonempty, <b><a href="CppReturn.htm">return</a></b> <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_firstnonemptyq &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the first triangle of the highest-priority queue.<br/>
&nbsp;&nbsp;result <a href="CppOperatorAssign.htm">=</a> m.m_queuefront[m.m_firstnonemptyq];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remove the triangle from the queue.<br/>
&nbsp;&nbsp;m.m_queuefront[m.m_firstnonemptyq] <a href="CppOperatorAssign.htm">=</a> result-&gt;m_nexttriang;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If <b><a href="CppThis.htm">this</a></b> queue is now empty, note the <b><a href="CppNew.htm">new</a></b> highest-priority<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;nonempty queue.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (result <a href="CppOperatorEqual.htm">==</a> m.m_queuetail[m.m_firstnonemptyq])<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_firstnonemptyq <a href="CppOperatorAssign.htm">=</a> m.m_nextnonemptyq[m.m_firstnonemptyq];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::checkseg4encroach(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; m_m_dummytri,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_conformdel,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Angle b_m_goodangle,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_nobisect,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; testsubseg<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri neighbortri;<br/>
&nbsp;&nbsp;Osub testsym;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>BadSubSeg *encroachedseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dotproduct;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_encroached <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_sides <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex eorg, edest, eapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by stpivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>encroached <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sides <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> eorg <a href="CppOperatorAssign.htm">=</a> testsubseg-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*testsubseg, eorg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edest <a href="CppOperatorAssign.htm">=</a> testsubseg-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*testsubseg, edest);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check one neighbor of the subsegment.<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> neighbortri <a href="CppOperatorAssign.htm">=</a> testsubseg-&gt;GetStPivot();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>stpivot(*testsubseg, neighbortri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does the neighbor exist, or is <b><a href="CppThis.htm">this</a></b> a boundary edge?<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbortri-&gt;m_triangles[0] <a href="CppOperatorNotEqual.htm">!=</a> m_m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>n_sides;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a vertex opposite <b><a href="CppThis.htm">this</a></b> subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> eapex <a href="CppOperatorAssign.htm">=</a> neighbortri-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(neighbortri, eapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the apex is in the diametral lens of the subsegment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(the diametral circle <b><a href="CppIf.htm">if</a></b> `conformdel' is set).&nbsp;&nbsp;A dot product<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;of two sides of the triangle is used to check whether the angle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;at the apex is greater than (180 <a href="CppOperatorMinus.htm">-</a> 2 `minangle') degrees (<b><a href="CppFor.htm">for</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;lenses; 90 degrees <b><a href="CppFor.htm">for</a></b> diametral circles).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dotproduct<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (eorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()) * (edest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).value();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) * (edest[0] <a href="CppOperatorMinus.htm">-</a> eapex[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dotproduct &lt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_conformdel<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a>&nbsp;&nbsp;( dotproduct * dotproduct <a href="CppOperatorGreaterEqual.htm">&gt;=</a> (2.0 * b_m_goodangle <a href="CppOperatorMinus.htm">-</a> 1.0) * (2.0 * b_m_goodangle <a href="CppOperatorMinus.htm">-</a> 1.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* ((eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(eorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()) * (eorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* ((edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(edest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()) * (edest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY())))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorLogicalOr.htm">||</a>&nbsp;&nbsp;( dotproduct * dotproduct <a href="CppOperatorGreaterEqual.htm">&gt;=</a> (2.0 * b.m_goodangle <a href="CppOperatorMinus.htm">-</a> 1.0) * (2.0 * b.m_goodangle <a href="CppOperatorMinus.htm">-</a> 1.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;* ((eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) * (eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;* ((edest[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) * (edest[0] <a href="CppOperatorMinus.htm">-</a> eapex[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1])))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_encroached <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the other neighbor of the subsegment.<br/>
&nbsp;&nbsp;testsym.Ssym(*testsubseg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ssym(*testsubseg, testsym);<br/>
<br/>
&nbsp;&nbsp;neighbortri <a href="CppOperatorAssign.htm">=</a> testsym.GetStPivot();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>stpivot(testsym, neighbortri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does the neighbor exist, or is <b><a href="CppThis.htm">this</a></b> a boundary edge?<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbortri-&gt;m_triangles[0] <a href="CppOperatorNotEqual.htm">!=</a> m_m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n_sides<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the other vertex opposite <b><a href="CppThis.htm">this</a></b> subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> eapex <a href="CppOperatorAssign.htm">=</a> neighbortri-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(neighbortri, eapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the apex is in the diametral lens of the subsegment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(or the diametral circle, <b><a href="CppIf.htm">if</a></b> `conformdel' is set).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dotproduct<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (eorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()) * (edest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorAssign.htm">=</a> (eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) * (edest[0] <a href="CppOperatorMinus.htm">-</a> eapex[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorPlus.htm">+</a> (eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dotproduct &lt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b_m_conformdel <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dotproduct * dotproduct <a href="CppOperatorGreaterEqual.htm">&gt;=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2.0 * b_m_goodangle <a href="CppOperatorMinus.htm">-</a> 1.0) * (2.0 * b_m_goodangle <a href="CppOperatorMinus.htm">-</a> 1.0) *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (( eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * ( eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( eorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()) * ( eorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY())) *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(edest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()) * (edest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetY()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).value()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>((eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) * (eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a> (eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1])) *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>((edest[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) * (edest[0] <a href="CppOperatorMinus.htm">-</a> eapex[0]) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a> (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_encroached <a href="CppOperatorPlusAssign.htm">+=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_encroached <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (!b_m_nobisect <a href="CppOperatorLogicalOr.htm">||</a> ((b_m_nobisect <a href="CppOperatorEqual.htm">==</a> 1) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (n_sides <a href="CppOperatorEqual.htm">==</a> 2))))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Queueing encroached subsegment (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eorg[0], eorg[1], edest[0], edest[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> the subsegment to the list of encroached subsegments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Be sure to get the orientation right.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadSubSeg&gt; encroachedseg(<b><a href="CppNew.htm">new</a></b> BadSubSeg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>encroachedseg <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> BadSubSeg *) PoolAlloc(&amp;m.m_badsubsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_encroached <a href="CppOperatorEqual.htm">==</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroachedseg-&gt;m_encsubseg <a href="CppOperatorAssign.htm">=</a> testsubseg-&gt;Sencode();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>encroachedseg-&gt;m_encsubseg <a href="CppOperatorAssign.htm">=</a> sencode(*testsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroachedseg-&gt;m_subsegorg <a href="CppOperatorAssign.htm">=</a> eorg;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroachedseg-&gt;m_subsegdest <a href="CppOperatorAssign.htm">=</a> edest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroachedseg-&gt;m_encsubseg <a href="CppOperatorAssign.htm">=</a> testsym.Sencode();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroachedseg-&gt;m_subsegorg <a href="CppOperatorAssign.htm">=</a> edest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroachedseg-&gt;m_subsegdest <a href="CppOperatorAssign.htm">=</a> eorg;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> n_encroached;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::testtriangle(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; testtri<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; tri1;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; tri2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; testsub;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex torg, tdest, tapex;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; base1;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; base2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex org1, dest1,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex org2, dest2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex joinvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dxod, dyod, dxda, dyda, dxao, dyao;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dxod2, dyod2, dxda2, dyda2, dxao2, dyao2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> apexlen, orglen, destlen, minedge;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> minedge <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;Angle angle <a href="CppOperatorAssign.htm">=</a> 0.0 * radian;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> area;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dist1, dist2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by oprev() and dnext().<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> testtri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> testtri-&gt;GetDest();<a href="CppComment.htm">//</a>dest(*testtri, tdest);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tapex <a href="CppOperatorAssign.htm">=</a> testtri-&gt;GetApex();<a href="CppComment.htm">//</a>apex(*testtri, tapex);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Length dxod <a href="CppOperatorAssign.htm">=</a> torg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tdest-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyod <a href="CppOperatorAssign.htm">=</a> torg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tdest-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxda <a href="CppOperatorAssign.htm">=</a> tdest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tapex-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyda <a href="CppOperatorAssign.htm">=</a> tdest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tapex-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxao <a href="CppOperatorAssign.htm">=</a> tapex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyao <a href="CppOperatorAssign.htm">=</a> tapex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxod2 <a href="CppOperatorAssign.htm">=</a> dxod * dxod;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyod2 <a href="CppOperatorAssign.htm">=</a> dyod * dyod;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxda2 <a href="CppOperatorAssign.htm">=</a> dxda * dxda;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyda2 <a href="CppOperatorAssign.htm">=</a> dyda * dyda;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxao2 <a href="CppOperatorAssign.htm">=</a> dxao * dxao;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyao2 <a href="CppOperatorAssign.htm">=</a> dyao * dyao;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the lengths of the triangle's three edges.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> apexlen <a href="CppOperatorAssign.htm">=</a> dxod2 <a href="CppOperatorPlus.htm">+</a> dyod2;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> orglen <a href="CppOperatorAssign.htm">=</a> dxda2 <a href="CppOperatorPlus.htm">+</a> dyda2;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> destlen <a href="CppOperatorAssign.htm">=</a> dxao2 <a href="CppOperatorPlus.htm">+</a> dyao2;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (apexlen &lt; orglen <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> apexlen &lt; destlen)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The edge opposite the apex is shortest.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;minedge <a href="CppOperatorAssign.htm">=</a> apexlen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the square of the cosine of the angle at the apex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angle <a href="CppOperatorAssign.htm">=</a> dxda * dxao <a href="CppOperatorPlus.htm">+</a> dyda * dyao;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angle <a href="CppOperatorAssign.htm">=</a> angle * angle <a href="CppOperatorDivide.htm">/</a> (orglen * destlen);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;base1 <a href="CppOperatorAssign.htm">=</a> torg;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;base2 <a href="CppOperatorAssign.htm">=</a> tdest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(*testtri, tri1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tri1 <a href="CppOperatorAssign.htm">=</a> testtri;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (orglen &lt; destlen)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The edge opposite the origin is shortest.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;minedge <a href="CppOperatorAssign.htm">=</a> orglen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the square of the cosine of the angle at the origin.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angle <a href="CppOperatorAssign.htm">=</a> dxod * dxao <a href="CppOperatorPlus.htm">+</a> dyod * dyao;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angle <a href="CppOperatorAssign.htm">=</a> angle * angle <a href="CppOperatorDivide.htm">/</a> (apexlen * destlen);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;base1 <a href="CppOperatorAssign.htm">=</a> tdest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;base2 <a href="CppOperatorAssign.htm">=</a> tapex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;SetLnext(*testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*testtri, tri1);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The edge opposite the destination is shortest.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;minedge <a href="CppOperatorAssign.htm">=</a> destlen;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the square of the cosine of the angle at the destination.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angle <a href="CppOperatorAssign.htm">=</a> dxod * dxda <a href="CppOperatorPlus.htm">+</a> dyod * dyda;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angle <a href="CppOperatorAssign.htm">=</a> angle * angle <a href="CppOperatorDivide.htm">/</a> (apexlen * orglen);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;base1 <a href="CppOperatorAssign.htm">=</a> tapex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;base2 <a href="CppOperatorAssign.htm">=</a> torg;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Lprev(*testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*testtri, tri1);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea <a href="CppOperatorLogicalOr.htm">||</a> b.m_fixedarea <a href="CppOperatorLogicalOr.htm">||</a> b.m_usertest)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the area is larger than permitted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Area area <a href="CppOperatorAssign.htm">=</a> 0.5 * (dxod * dyda <a href="CppOperatorMinus.htm">-</a> dyod * dxda);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_fixedarea <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> area &gt; b.m_maxarea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppThis.htm">this</a></b> triangle to the list of bad triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Enqueuebadtri(testtri, minedge, tapex, torg, tdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Nonpositive area constraints are treated as unconstrained.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> area &gt; testtri-&gt;GetAreaBound() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> testtri-&gt;GetAreaBound() &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (b.m_vararea <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> area &gt; areabound(*testtri) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> areabound(*testtri) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppThis.htm">this</a></b> triangle to the list of bad triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Enqueuebadtri(testtri, minedge, tapex, torg, tdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_usertest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the user thinks <b><a href="CppThis.htm">this</a></b> triangle is too large.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (IsTriangleUnsuitable(torg, tdest, tapex))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Enqueuebadtri(testtri, minedge, tapex, torg, tdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the angle is smaller than permitted.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (angle &gt; b.m_goodangle)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use the rules of Miller, Pav, and Walkington to decide that certain<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangles should not be split, even <b><a href="CppIf.htm">if</a></b> they have bad angles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;A skinny triangle is not split <b><a href="CppIf.htm">if</a></b> its shortest edge subtends a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;small input angle, and both endpoints of the edge lie on a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;concentric circular shell.&nbsp;&nbsp;For convenience, I <a href="CppMake.htm">make</a> a small<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjustment to that rule:&nbsp;&nbsp;I check <b><a href="CppIf.htm">if</a></b> the endpoints of the edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;both lie in segment interiors, equidistant from the apex where<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the two segments meet.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>First, check <b><a href="CppIf.htm">if</a></b> both <a href="CppPointer.htm">point</a>s lie in segment interiors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (base1-&gt;GetVertexType() <a href="CppOperatorEqual.htm">==</a> VertexType::SEGMENTVERTEX <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base2-&gt;GetVertexType() <a href="CppOperatorEqual.htm">==</a> VertexType::SEGMENTVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> both <a href="CppPointer.htm">point</a>s lie in a common segment.&nbsp;&nbsp;If they <b><a href="CppDo.htm">do</a></b>, the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;skinny triangle is enqueued to be split as usual.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsub <a href="CppOperatorAssign.htm">=</a> tri1-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tri1-&gt;Tspivot(testsub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(tri1, testsub);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (testsub-&gt;m_subsegs[0] <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>No common segment.&nbsp;&nbsp;Find a subsegment that contains `torg'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2 <a href="CppOperatorAssign.htm">=</a> tri1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(tri1, tri2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Oprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprevself(tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsub <a href="CppOperatorAssign.htm">=</a> tri1-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Tspivot(*testsub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(tri1, testsub);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (testsub-&gt;m_subsegs[0] <a href="CppOperatorEqual.htm">==</a> m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the endpoints of the containing segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> org1 <a href="CppOperatorAssign.htm">=</a> testsub-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrg(testsub, org1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dest1 <a href="CppOperatorAssign.htm">=</a> testsub-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(testsub, dest1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a subsegment that contains `tdest'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;Dnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dnextself(tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsub <a href="CppOperatorAssign.htm">=</a> tri2-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tri2-&gt;Tspivot(testsub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(tri2, testsub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (testsub-&gt;m_subsegs[0] <a href="CppOperatorEqual.htm">==</a> m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the endpoints of the containing segment.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> org2 <a href="CppOperatorAssign.htm">=</a> testsub-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrg(testsub, org2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dest2 <a href="CppOperatorAssign.htm">=</a> testsub-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(testsub, dest2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the two containing segments have an endpoint in common.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; joinvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdRemove.htm">std::remove</a>_const&lt;decltype(dest1)&gt;::type joinvertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dest1-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> org2-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> dest1-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> org2-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;joinvertex <a href="CppOperatorAssign.htm">=</a> dest1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (org1-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> dest2-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> org1-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> dest2-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;joinvertex <a href="CppOperatorAssign.htm">=</a> org1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (joinvertex)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Compute the distance from the common endpoint (of the two<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segments) to each of the endpoints of the shortest edge.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dist1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ((base1-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetX()) * (base1-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(base1-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetY()) * (base1-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetY()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dist2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ((base2-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetX()) * (base2-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(base2-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetY()) * (base2-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> joinvertex-&gt;GetY()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the two distances are equal, don't split the triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dist1 &lt; 1.001 * dist2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> dist1 &gt; 0.999 * dist2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Return now to avoid enqueueing the bad triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> <b><a href="CppThis.htm">this</a></b> triangle to the list of bad triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.Enqueuebadtri(testtri, minedge, tapex, torg, tdest);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppMake.htm">make</a>vertexmap(<br/>
&nbsp;&nbsp;Mesh&amp; m<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex triorg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppConstructor.htm">Construct</a>ing mapping from vertices to triangles.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> my_triangle: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (my_triangle-&gt;IsDead()) <b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; triangleloop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;tri <a href="CppOperatorAssign.htm">=</a> my_triangle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient <a href="CppOperatorNotEqual.htm">!=</a> 3; <a href="CppOperatorIncrement.htm">++</a>triangleloop-&gt;m_orient)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triorg <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(triangleloop, triorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_tri[triangleloop-&gt;m_orient] <a href="CppOperatorAssign.htm">=</a> triorg;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertex2tri(triorg, encode(triangleloop));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;triangleloop.m_tri <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (triangleloop.m_tri <a href="CppOperatorNotEqual.htm">!=</a> (Triangle *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check all three vertices of the triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop.m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop.m_orient &lt; 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; triangleloop.m_orient<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org(triangleloop, triorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertex2tri(triorg, encode(triangleloop));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop.m_tri <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::LocateResult <a href="CppRibi.htm">ribi</a>::tricpp::preciselocate(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> m_m_checksegments,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> b_m_noexact,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> stopatsubsegment<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; backtracktri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub checkedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex forg, fdest, fapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> orgorient, destorient;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> moveleft <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Searching <b><a href="CppFor.htm">for</a></b> <a href="CppPointer.htm">point</a> (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; search<a href="CppPointer.htm">point</a>[0], search<a href="CppPointer.htm">point</a>[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Where are we?<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> forg <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*searchtri, forg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> fdest <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(*searchtri, fdest);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> fapex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(*searchtri, fapex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;At (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forg[0], forg[1], fdest[0], fdest[1], fapex[0], fapex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the apex is the <a href="CppPointer.htm">point</a> we seek.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (fapex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> fapex-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONVERTEX;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does the <a href="CppPointer.htm">point</a> lie on the other side of the line defined by the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle edge opposite the triangle's destination?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> destorient <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, forg, fapex, search<a href="CppPointer.htm">point</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does the <a href="CppPointer.htm">point</a> lie on the other side of the line defined by the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle edge opposite the triangle's origin?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> orgorient <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, fapex, fdest, search<a href="CppPointer.htm">point</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (destorient &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (orgorient &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Move left <b><a href="CppIf.htm">if</a></b> the inner product of (fapex <a href="CppOperatorMinus.htm">-</a> search<a href="CppPointer.htm">point</a>) and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(fdest <a href="CppOperatorMinus.htm">-</a> forg) is positive.&nbsp;&nbsp;This is equivalent to drawing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;a line perpendicular to the line (forg, fdest) and passing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;through `fapex', and determining which side of <b><a href="CppThis.htm">this</a></b> line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;`search<a href="CppPointer.htm">point</a>' falls on.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveleft<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (fapex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> search<a href="CppPointer.htm">point</a>-&gt;GetX()) * (fdest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> forg-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (fapex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> search<a href="CppPointer.htm">point</a>-&gt;GetY()) * (fdest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> forg-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt; 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveleft <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (orgorient &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveleft <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The <a href="CppPointer.htm">point</a> we seek must be on the boundary of or inside <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (destorient <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONEDGE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (orgorient <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONEDGE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> INTRIANGLE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Move to another triangle.&nbsp;&nbsp;Leave a <a href="CppTrace.htm">trace</a> `backtracktri' in <b><a href="CppCase.htm">case</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;floating-<a href="CppPointer.htm">point</a> roundoff or some such bogey causes us to walk<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;off a boundary of the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (moveleft)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtracktri-&gt;Lprev(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*searchtri, backtracktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fdest <a href="CppOperatorAssign.htm">=</a> fapex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backtracktri-&gt;SetLnext(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*searchtri, backtracktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forg <a href="CppOperatorAssign.htm">=</a> fapex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Sym(backtracktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(backtracktri, *searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m_m_checksegments <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> stopatsubsegment)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> walking through a subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> backtracktri-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>backtracktri.Tspivot(checkedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(backtracktri, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkedge.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Go back to the last triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> backtracktri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(backtracktri, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> OUTSIDE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> walking right out of the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (searchtri-&gt;m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Go back to the last triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> backtracktri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(backtracktri, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> OUTSIDE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fapex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*searchtri, fapex);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::LocateResult <a href="CppRibi.htm">ribi</a>::tricpp::locate(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_<a href="CppCounter.htm">counter</a>clockcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a>,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Searches in m.m_triangles, see 'MARK 2014-05-27-1'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> **sampleblock <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppChar.htm">char</a></b> *firsttri <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> sampletri <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>_ptr&lt;Otri&gt;();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex torg, tdest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> searchdist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dist;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ahead;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> samplesperblock, totalsamplesleft, samplesleft;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> population, totalpopulation;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Randomly sampling <b><a href="CppFor.htm">for</a></b> a triangle near <a href="CppPointer.htm">point</a> (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; search<a href="CppPointer.htm">point</a>[0], search<a href="CppPointer.htm">point</a>[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Record the distance from the suggested starting triangle to the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppPointer.htm">point</a> we seek.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*searchtri, torg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> searchdist<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX()) * (search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY()) * (search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Boundary triangle has origin (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; torg[0], torg[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If a recently en<a href="CppCounter.htm">counter</a>ed triangle has been recorded and has not been<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;deallocated, test it as a good starting <a href="CppPointer.htm">point</a>.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!m.m_recenttri.m_triangles.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!deadtri(m.m_recenttri.m_triangles))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torg <a href="CppOperatorAssign.htm">=</a> m.m_recenttri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(m.m_recenttri, torg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (torg-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> torg-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*searchtri <a href="CppOperatorAssign.htm">=</a> m.m_recenttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(m.m_recenttri, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONVERTEX;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> dist<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> (search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX()) * (search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> (search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY()) * (search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dist &lt; searchdist)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*searchtri <a href="CppOperatorAssign.htm">=</a> m.m_recenttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(m.m_recenttri, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchdist <a href="CppOperatorAssign.htm">=</a> dist;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Choosing recent triangle with origin (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; torg[0], torg[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The number of random samples taken is proportional to the cube root of<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the number of triangles in the mesh.&nbsp;&nbsp;The next bit of code assumes<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;that the number of triangles increases monotonically (or at least<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;doesn't decrease enough to matter).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (SAMPLEFACTOR * m.m_samples * m.m_samples * m.m_samples &lt; m.m_triangles.size())<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;m.m_samples<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>We'll draw ceiling(samples * triangles_per_block <a href="CppOperatorDivide.htm">/</a> maxitems) random samples<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;from each block of triangles (except the first)<a href="CppOperatorDecrement.htm">--</a>until we meet the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;sample quota.&nbsp;&nbsp;The ceiling means that blocks at the end might be<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;neglected, but I don't care.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> samplesperblock <a href="CppOperatorAssign.htm">=</a> (m.m_samples * g_triangles_per_block <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a> m.m_triangles.m_maxitems <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>We'll draw ceiling(samples * itemsfirstblock <a href="CppOperatorDivide.htm">/</a> maxitems) random samples<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;from the first block of triangles.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> samplesleft <a href="CppOperatorAssign.htm">=</a> (m.m_samples * m.m_triangles.m_itemsfirstblock <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_triangles.m_maxitems <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> totalsamplesleft <a href="CppOperatorAssign.htm">=</a> m.m_samples;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> population <a href="CppOperatorAssign.htm">=</a> m.m_triangles.m_itemsfirstblock;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> totalpopulation <a href="CppOperatorAssign.htm">=</a> m.m_triangles.m_maxitems;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> sampleblock <a href="CppOperatorAssign.htm">=</a> m.m_triangles.m_firstblock; <a href="CppComment.htm">//</a>MARK 2014-05-27-1<br/>
<br/>
&nbsp;&nbsp;sampletri-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sampletri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (totalsamplesleft &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If we're in the last block, `population' needs to be corrected.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (population &gt; totalpopulation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>population <a href="CppOperatorAssign.htm">=</a> totalpopulation;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a <a href="CppPointer.htm">pointer</a> to the first triangle in the block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (sampleblock <a href="CppOperatorPlus.htm">+</a> 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;firsttri <a href="CppOperatorAssign.htm">=</a> m.m_triangles[0]; <a href="CppComment.htm">//</a>RJCB<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>firsttri <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppChar.htm">char</a></b> *) (alignptr <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_triangles.m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) m.m_triangles.m_alignbytes));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Choose `samplesleft' randomly sampled triangles in <b><a href="CppThis.htm">this</a></b> block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1<a href="CppOperatorEqual.htm">==</a>2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sampletri.m_triangles<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> firsttri <a href="CppOperatorPlus.htm">+</a> ( (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> population) * m.m_triangles.m_itembytes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!sampletri-&gt;m_triangles[0]-&gt;IsDead())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!deadtri(sampletri.m_triangles))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;torg <a href="CppOperatorAssign.htm">=</a> sampletri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(sampletri, torg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist <a href="CppOperatorAssign.htm">=</a> (search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX()) * (search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX()) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY()) * (search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetY());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dist &lt; searchdist)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> sampletri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(sampletri, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchdist <a href="CppOperatorAssign.htm">=</a> dist;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Choosing triangle with origin (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; torg[0], torg[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>samplesleft<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>totalsamplesleft<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (samplesleft &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> totalsamplesleft &gt; 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (totalsamplesleft &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sampleblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) *sampleblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>samplesleft <a href="CppOperatorAssign.htm">=</a> samplesperblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>totalpopulation <a href="CppOperatorMinusAssign.htm">-=</a> population;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>population <a href="CppOperatorAssign.htm">=</a> g_triangles_per_block;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Where are we?<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*searchtri, torg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(*searchtri, tdest);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the starting triangle's vertices.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (torg-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> torg-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetY())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONVERTEX;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tdest-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> tdest-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> search<a href="CppPointer.htm">point</a>-&gt;GetY())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONVERTEX;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Orient `searchtri' to fit the preconditions of calling preciselocate().<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ahead <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, torg, tdest, search<a href="CppPointer.htm">point</a>);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (ahead &lt; 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Turn around so that `search<a href="CppPointer.htm">point</a>' is to the left of the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge specified by `searchtri'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(*searchtri);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (ahead <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> `search<a href="CppPointer.htm">point</a>' is between `torg' and `tdest'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( ((torg-&gt;GetX() &lt; search<a href="CppPointer.htm">point</a>-&gt;GetX()) <a href="CppOperatorEqual.htm">==</a> (search<a href="CppPointer.htm">point</a>-&gt;GetX() &lt; tdest-&gt;GetX()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((torg-&gt;GetY() &lt; search<a href="CppPointer.htm">point</a>-&gt;GetY()) <a href="CppOperatorEqual.htm">==</a> (search<a href="CppPointer.htm">point</a>-&gt;GetY() &lt; tdest-&gt;GetY()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> ONEDGE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> preciselocate(m.m_checksegments,m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, search<a href="CppPointer.htm">point</a>, searchtri, 0);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::insertsubseg(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; tri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subsegmark<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri oppotri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub newsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex triorg, tridest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triorg <a href="CppOperatorAssign.htm">=</a> tri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*tri, triorg);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tridest <a href="CppOperatorAssign.htm">=</a> tri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(*tri, tridest);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark vertices <b><a href="CppIf.htm">if</a></b> possible.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triorg-&gt;GetVertexMark() <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triorg-&gt;SetMark(subsegmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(triorg, subsegmark);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tridest-&gt;GetVertexMark() <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tridest-&gt;SetMark(subsegmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(tridest, subsegmark);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> there's already a subsegment here.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newsubseg <a href="CppOperatorAssign.htm">=</a> tri-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>tri-&gt;Tspivot(newsubseg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(*tri, newsubseg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make <b><a href="CppNew.htm">new</a></b> subsegment and <a href="CppInitialize.htm">initialize</a> its vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newsubseg <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>subseg(m.m_dummytri,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>subseg(m.m_dummytri,m.m_dummysub,&amp;newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>subseg(m, &amp;newsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsubseg.SetOrigin(tridest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetsOrigin(newsubseg, tridest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsubseg.SetDest(triorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(newsubseg, triorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;setsegorg(newsubseg, tridest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;setsegdest(newsubseg, triorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Bond <b><a href="CppNew.htm">new</a></b> subsegment to the two triangles it is sandwiched between.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Note that the facing triangle `oppotri' might be equal to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;`dummytri' (outer space), but the <b><a href="CppNew.htm">new</a></b> subsegment is bonded to it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;all the same.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tsbond(*tri, newsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> oppotri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*tri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*tri, oppotri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ssymself(newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tsbond(oppotri, newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;setmark(newsubseg, subsegmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Inserting <b><a href="CppNew.htm">new</a></b> ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printsubseg(m.m_dummysub,m_dummytri, &amp;newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newsubseg-&gt;GetMark() <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (mark(newsubseg) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newsubseg-&gt;SetMark(subsegmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setmark(newsubseg, subsegmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> Terminology<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> A "local transformation" replaces a small set of triangles with another<br/>
<a href="CppComment.htm">//</a> set of triangles.&nbsp;&nbsp;This may or may not involve inserting or deleting a<br/>
<a href="CppComment.htm">//</a> vertex.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> The term "casing" is used to describe the set of triangles that are<br/>
<a href="CppComment.htm">//</a> attached to the triangles being transformed, but are not transformed<br/>
<a href="CppComment.htm">//</a> themselves.&nbsp;&nbsp;Think of the casing as a fixed hollow structure inside<br/>
<a href="CppComment.htm">//</a> which all the action happens.&nbsp;&nbsp;A "casing" is only defined relative to<br/>
<a href="CppComment.htm">//</a> a single transformation; each occurrence of a transformation will<br/>
<a href="CppComment.htm">//</a> involve a different casing.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::flip(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; flipedge<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoost.htm">boost</a>::sharedOtri botleft, botright;<br/>
&nbsp;&nbsp;Otri topleft, topright;<br/>
&nbsp;&nbsp;Otri top;<br/>
&nbsp;&nbsp;Otri botlcasing, botrcasing;<br/>
&nbsp;&nbsp;Otri toplcasing, toprcasing;<br/>
&nbsp;&nbsp;Osub botlsubseg, botrsubseg;<br/>
&nbsp;&nbsp;Osub toplsubseg, toprsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex leftvertex, rightvertex, botvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex farvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Identify the vertices of the quadrilateral.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> flipedge-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*flipedge, rightvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> flipedge-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(*flipedge, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botvertex <a href="CppOperatorAssign.htm">=</a> flipedge-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(*flipedge, botvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> top <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*flipedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*flipedge, top);<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (top.tri <a href="CppOperatorEqual.htm">==</a> m.dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in flip():&nbsp;&nbsp;Attempt to flip on boundary.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;lnextself(*flipedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.checksegments) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tspivot(*flipedge, toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toplsubseg.ss <a href="CppOperatorNotEqual.htm">!=</a> m.dummysub) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in flip():&nbsp;&nbsp;Attempt to flip a segment.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lnextself(*flipedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farvertex <a href="CppOperatorAssign.htm">=</a> top.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(top, farvertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Identify the casing of the quadrilateral.<br/>
&nbsp;&nbsp;topleft.Lprev(top);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(top, topleft);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toplcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topleft);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topleft, toplcasing);<br/>
<br/>
&nbsp;&nbsp;topright.SetLnext(top);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(top, topright);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topright);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topright, toprcasing);<br/>
<br/>
&nbsp;&nbsp;botleft.SetLnext(*flipedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*flipedge, botleft);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botleft);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botleft, botlcasing);<br/>
<br/>
&nbsp;&nbsp;botright.Lprev(*flipedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*flipedge, botright);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppRotate.htm">Rotate</a> the quadrilateral one-quarter turn <a href="CppCounter.htm">counter</a>clockwise.<br/>
&nbsp;&nbsp;Bond(topleft, botlcasing);<br/>
&nbsp;&nbsp;Bond(botleft, botrcasing);<br/>
&nbsp;&nbsp;Bond(botright, toprcasing);<br/>
&nbsp;&nbsp;Bond(topright, toplcasing);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> subsegments and rebond them to the quadrilateral.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toplsubseg <a href="CppOperatorAssign.htm">=</a> topleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topleft.Tspivot(toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topleft, toplsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlsubseg <a href="CppOperatorAssign.htm">=</a> botleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botleft.Tspivot(botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botleft, botlsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprsubseg <a href="CppOperatorAssign.htm">=</a> topright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topright.Tspivot(toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topright, toprsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toplsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(topright, toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botlsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topleft,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(topleft, botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botrsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botleft,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(botleft, botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toprsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(botright, toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>New vertex assignments <b><a href="CppFor.htm">for</a></b> the rotated quadrilateral.<br/>
&nbsp;&nbsp;flipedge-&gt;SetOrigin(farvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(*flipedge, farvertex);<br/>
<br/>
&nbsp;&nbsp;flipedge-&gt;SetDest(botvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(*flipedge, botvertex);<br/>
<br/>
&nbsp;&nbsp;flipedge-&gt;SetApex(rightvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(*flipedge, rightvertex);<br/>
<br/>
&nbsp;&nbsp;top-&gt;SetOrigin(botvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(top, botvertex);<br/>
<br/>
&nbsp;&nbsp;top-&gt;SetDest(farvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(top, farvertex);<br/>
<br/>
&nbsp;&nbsp;top-&gt;SetApex(leftvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(top, leftvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Edge flip results in left ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;top);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and right ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, flipedge);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::unflip(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; <a href="CppComment.htm">/*</a>b<a href="CppComment.htm">*/</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; flipedge<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri botleft, botright;<br/>
&nbsp;&nbsp;Otri topleft, topright;<br/>
&nbsp;&nbsp;Otri top;<br/>
&nbsp;&nbsp;Otri botlcasing, botrcasing;<br/>
&nbsp;&nbsp;Otri toplcasing, toprcasing;<br/>
&nbsp;&nbsp;Osub botlsubseg, botrsubseg;<br/>
&nbsp;&nbsp;Osub toplsubseg, toprsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex leftvertex, rightvertex, botvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex farvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Identify the vertices of the quadrilateral.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> flipedge-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*flipedge, rightvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> flipedge-&gt;GetDes();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(*flipedge, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botvertex <a href="CppOperatorAssign.htm">=</a> flipedge-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(*flipedge, botvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> top <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*flipedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*flipedge, top);<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (top.tri <a href="CppOperatorEqual.htm">==</a> m.dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in unflip():&nbsp;&nbsp;Attempt to flip on boundary.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;lnextself(*flipedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.checksegments) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tspivot(*flipedge, toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toplsubseg.ss <a href="CppOperatorNotEqual.htm">!=</a> m.dummysub) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in unflip():&nbsp;&nbsp;Attempt to flip a subsegment.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lnextself(*flipedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farvertex <a href="CppOperatorAssign.htm">=</a> top.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(top, farvertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Identify the casing of the quadrilateral.<br/>
&nbsp;&nbsp;topleft.Lprev(top);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(top, topleft);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toplcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topleft);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topleft, toplcasing);<br/>
<br/>
&nbsp;&nbsp;topright.SetLnext(top);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(top, topright);<br/>
<br/>
&nbsp;&nbsp;toprcasing.sym(topright);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topright, toprcasing);<br/>
<br/>
&nbsp;&nbsp;botleft.SetLnext(*flipedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*flipedge, botleft);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botleft);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botleft, botlcasing);<br/>
<br/>
&nbsp;&nbsp;botright.Lprev(*flipedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*flipedge, botright);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppRotate.htm">Rotate</a> the quadrilateral one-quarter turn clockwise.<br/>
&nbsp;&nbsp;Bond(topleft, toprcasing);<br/>
&nbsp;&nbsp;Bond(botleft, toplcasing);<br/>
&nbsp;&nbsp;Bond(botright, botlcasing);<br/>
&nbsp;&nbsp;Bond(topright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> subsegments and rebond them to the quadrilateral.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toplsubseg <a href="CppOperatorAssign.htm">=</a> topleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topleft.Tspivot(toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topleft, toplsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlsubseg <a href="CppOperatorAssign.htm">=</a> botleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botleft.Tspivot(botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botleft, botlsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprsubseg <a href="CppOperatorAssign.htm">=</a> topright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topright.Tspivot(toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topright, toprsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toplsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botleft,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(botleft, toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botlsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(botright, botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botrsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(topright, botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toprsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topleft,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(topleft, toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>New vertex assignments <b><a href="CppFor.htm">for</a></b> the rotated quadrilateral.<br/>
&nbsp;&nbsp;flipedge-&gt;SetOrigin(botvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(*flipedge, botvertex);<br/>
&nbsp;&nbsp;flipedge-&gt;SetDest(farvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(*flipedge, farvertex);<br/>
&nbsp;&nbsp;flipedge-&gt;SetApex(leftvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(*flipedge, leftvertex);<br/>
&nbsp;&nbsp;top-&gt;SetOrigin(farvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(top, farvertex);<br/>
&nbsp;&nbsp;top-&gt;SetDest(botvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(top, botvertex);<br/>
&nbsp;&nbsp;top-&gt;SetApex(rightvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(top, rightvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Edge unflip results in left ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, flipedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and right ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;top);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::InsertVertexResult <a href="CppRibi.htm">ribi</a>::tricpp::insertvertex(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; newvertex,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt;&amp; splitseg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> segmentflaws,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> triflaws<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; horiz;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri top;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; botleft;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; botright;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; topleft;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; topright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri newbotleft, newbotright;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; newtopright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri botlcasing, botrcasing;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; toplcasing;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; toprcasing;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri testtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; botlsubseg;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; botrsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; toplsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; toprsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; brokensubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; checksubseg;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; rightsubseg;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; newsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>BadSubSeg *encroached;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>FlipStacker *newflip;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex first;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex leftvertex, rightvertex, botvertex, topvertex, farvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex segmentorg, segmentdest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> attrib;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> area;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>InsertVertexResult success;<br/>
&nbsp;&nbsp;LocateResult intersect;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> doflip <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> mirrorflag;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> enq;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by spivot() and tspivot().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Inserting (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n", newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (splitseg <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the location of the vertex to be inserted.&nbsp;&nbsp;Check <b><a href="CppIf.htm">if</a></b> a good<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;starting triangle has already been provided by the caller.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (searchtri-&gt;m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a boundary triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz-&gt;m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> a triangle containing `newvertex'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersect <a href="CppOperatorAssign.htm">=</a> locate(m, b, newvertex, &amp;horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start searching from the triangle provided by the caller.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz <a href="CppOperatorAssign.htm">=</a> searchtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(*searchtri, horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersect <a href="CppOperatorAssign.htm">=</a> preciselocate(m.m_checksegments,m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, newvertex, &amp;horiz, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The calling routine provides the subsegment in which<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the vertex is inserted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;horiz <a href="CppOperatorAssign.htm">=</a> searchtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(*searchtri, horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intersect <a href="CppOperatorAssign.htm">=</a> ONEDGE;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (intersect <a href="CppOperatorEqual.htm">==</a> ONVERTEX)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There's already a vertex there.&nbsp;&nbsp;Return in `searchtri' a triangle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;whose origin is the existing vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> horiz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(horiz, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_recenttri <a href="CppOperatorAssign.htm">=</a> horiz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(horiz, m.m_recenttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> DUPLICATEVERTEX;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (intersect <a href="CppOperatorEqual.htm">==</a> ONEDGE <a href="CppOperatorLogicalOr.htm">||</a> intersect <a href="CppOperatorEqual.htm">==</a> OUTSIDE)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The vertex falls on an edge or boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> splitseg <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the vertex falls on a subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> brokensubseg <a href="CppOperatorAssign.htm">=</a> horiz.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>horiz.Tspivot(brokensubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(horiz, brokensubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (brokensubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The vertex falls on a subsegment, and hence will not be inserted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (segmentflaws)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enq <a href="CppOperatorAssign.htm">=</a> b.m_nobisect <a href="CppOperatorNotEqual.htm">!=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (enq <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (b.m_nobisect <a href="CppOperatorEqual.htm">==</a> 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>This subsegment may be split only <b><a href="CppIf.htm">if</a></b> it is an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;internal boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testtri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(horiz, testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enq <a href="CppOperatorAssign.htm">=</a> testtri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (enq)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> the subsegment to the list of encroached subsegments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>encroached <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> BadSubSeg *) PoolAlloc(&amp;m.m_badsubsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BadSubSeg encroached;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroached-&gt;m_encsubseg <a href="CppOperatorAssign.htm">=</a> brokensubseg.Sencode();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>encroached-&gt;m_encsubseg <a href="CppOperatorAssign.htm">=</a> sencode(brokensubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroached-&gt;m_subsegorg <a href="CppOperatorAssign.htm">=</a> brokensubseg.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(brokensubseg, encroached-&gt;m_subsegorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encroached-&gt;m_subsegdest <a href="CppOperatorAssign.htm">=</a> brokensubseg.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(brokensubseg, encroached-&gt;m_subsegdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Queueing encroached subsegment (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encroached-&gt;m_subsegorg[0], encroached-&gt;m_subsegorg[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encroached-&gt;m_subsegdest[0], encroached-&gt;m_subsegdest[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Return a handle whose primary edge contains the vertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;which has not been inserted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> horiz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(horiz, *searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_recenttri <a href="CppOperatorAssign.htm">=</a> horiz;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(horiz, m.m_recenttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> VIOLATINGVERTEX;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the vertex on an edge, dividing one triangle into two (<b><a href="CppIf.htm">if</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the edge lies on a boundary) or two triangles into four.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;botright.Lprev(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(horiz, botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> topright <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(horiz, topright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is there a second triangle?&nbsp;&nbsp;(Or does <b><a href="CppThis.htm">this</a></b> edge lie on a boundary?)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mirrorflag <a href="CppOperatorAssign.htm">=</a> topright.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mirrorflag)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topright.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(topright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topright, toprcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newtopright <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;newtopright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;newtopright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Splitting a boundary edge increases the number of boundary edges.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_hullsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newbotright <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;newbotright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the vertices of changed and <b><a href="CppNew.htm">new</a></b> triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> horiz.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(horiz, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> horiz.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(horiz, leftvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botvertex <a href="CppOperatorAssign.htm">=</a> horiz.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(horiz, botvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetOrigin(botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(newbotright, botvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetDest(rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(newbotright, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetApex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(newbotright, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetOrg(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(horiz, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_eextras; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the element attributes of a <b><a href="CppNew.htm">new</a></b> triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetElemAttrib(i,botright.GetElemAttrib(i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(newbotright, i, elemattribute(botright, i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the area constraint of a <b><a href="CppNew.htm">new</a></b> triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetAreaBound(botright.GetAreaBound());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(newbotright, botright.GetAreaBound());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(newbotright, areabound(botright));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mirrorflag)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> topvertex <a href="CppOperatorAssign.htm">=</a> topright.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(topright, topvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> newtopright.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(newtopright, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newtopright.SetDest(topvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(newtopright, topvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newtopright.SetApex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(newtopright, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topright.SetOrigin(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(topright, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_eextras; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the element attributes of another <b><a href="CppNew.htm">new</a></b> triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newtopright.SetElemAttrib(i,topright.GetElemAttrib(i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(newtopright, i, elemattribute(topright, i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the area constraint of another <b><a href="CppNew.htm">new</a></b> triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newtopright.SetAreaBound(topright.GetAreaBound());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(newtopright, areabound(topright));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There may be subsegments that need to be bonded<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to the <b><a href="CppNew.htm">new</a></b> triangle(s).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreatTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botrsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(newbotright, botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mirrorflag)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprsubseg <a href="CppOperatorAssign.htm">=</a> topright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topright.Tspivot(toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topright, toprsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toprsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(newtopright, toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Bond the <b><a href="CppNew.htm">new</a></b> triangle(s) to the surrounding triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(newbotright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(newbotright, botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mirrorflag)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(newtopright, toprcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newtopright.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(newtopright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(newtopright, topright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newtopright.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(newtopright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(newtopright, newbotright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (splitseg <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split the subsegment into two.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitseg-&gt;SetDest(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(*splitseg, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> segmentorg <a href="CppOperatorAssign.htm">=</a> splitseg-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrg(*splitseg, segmentorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> segmentdest <a href="CppOperatorAssign.htm">=</a> splitseg-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*splitseg, segmentdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssymself(*splitseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spivot(*splitseg, rightsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, &amp;newbotright, mark(*splitseg));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotright.Tspivot(newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(newbotright, newsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setsegorg(newsubseg, segmentorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setsegdest(newsubseg, segmentdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbond(*splitseg, newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssymself(newsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbond(newsubseg, rightsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssymself(*splitseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Transfer the subsegment's boundary marker to the vertex<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> required.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertexmark(newvertex) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertexmark(newvertex, mark(*splitseg));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checkquality) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PoolRestart(m.m_flipstackers);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_lastflip <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> FlipStacker *) PoolAlloc(&amp;m.m_flipstackers);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip-&gt;m_flippedtri <a href="CppOperatorAssign.htm">=</a> horiz.m_tri[horiz.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_lastflip-&gt;m_flippedtri <a href="CppOperatorAssign.htm">=</a> encode(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip-&gt;m_prevflip <a href="CppOperatorAssign.htm">=</a> &amp;insertvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, rightvertex, leftvertex, botvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Clockwise triangle prior to edge vertex insertion (bottom).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mirrorflag) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, leftvertex, rightvertex, topvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle prior to edge vertex insertion (top).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, rightvertex, topvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Clockwise triangle after edge vertex insertion (top right).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, topvertex, leftvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Clockwise triangle after edge vertex insertion (top left).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, leftvertex, botvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Clockwise triangle after edge vertex insertion (bottom left).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, botvertex, rightvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Clockwise triangle after edge vertex insertion (bottom right).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Updating bottom left ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mirrorflag) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Updating top left ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;topright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating top right ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;newtopright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating bottom right ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;newbotright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Position `horiz' on the first edge to check <b><a href="CppFor.htm">for</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the Delaunay property.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;horiz.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(horiz);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the vertex in a triangle, splitting it into three.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;botleft.SetLnext(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(horiz, botleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;botright.Lprev(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(horiz, botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botleft, botlcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newbotleft <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;newbotleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;newbotleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newbotright <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;newbotright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the vertices of changed and <b><a href="CppNew.htm">new</a></b> triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> horiz-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(horiz, rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> horiz-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(horiz, leftvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botvertex <a href="CppOperatorAssign.htm">=</a> horiz-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(horiz, botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.SetOrigin(leftvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(newbotleft, leftvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.SetDest(botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(newbotleft, botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.SetApex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(newbotleft, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetOrigin(botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(newbotright, botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetDest(rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(newbotright, rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetApex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(newbotright, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetApex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(horiz, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_eextras; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the element attributes of the <b><a href="CppNew.htm">new</a></b> triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> attrib <a href="CppOperatorAssign.htm">=</a> horiz.GetElemAttrib(i);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>attrib <a href="CppOperatorAssign.htm">=</a> elemattribute(horiz, i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.SetElemAttrib(attrib,i);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(newbotleft, i, attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetElemAttrib(attrib,i);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetElemAttrib(attrib,i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(newbotright, i, attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the area constraint of the <b><a href="CppNew.htm">new</a></b> triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> area <a href="CppOperatorAssign.htm">=</a> horiz.GetAreaBound();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>area <a href="CppOperatorAssign.htm">=</a> areabound(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.SetAreaBound(area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(newbotleft, area);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newbotright.SetAreaBound(area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(newbotright, area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There may be subsegments that need to be bonded<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to the <b><a href="CppNew.htm">new</a></b> triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlsubseg <a href="CppOperatorAssign.htm">=</a> botleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botleft.Tspivot(botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botleft, botlsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botlsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botleft,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(newbotleft, botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botrsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botright,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(newbotright, botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Bond the <b><a href="CppNew.htm">new</a></b> triangles to the surrounding triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(newbotleft, botlcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(newbotright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(newbotleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(newbotleft, newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotleft.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(newbotleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(botleft, newbotleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newbotright.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(botright, newbotright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checkquality)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PoolRestart(&amp;m.m_flipstackers);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;FlipStacker&gt;();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_lastflip <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> FlipStacker *) PoolAlloc(&amp;m.m_flipstackers);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip-&gt;m_flippedtri <a href="CppOperatorAssign.htm">=</a> horiz.m_tri[horiz.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_lastflip-&gt;m_flippedtri <a href="CppOperatorAssign.htm">=</a> encode(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip-&gt;m_prevflip <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, rightvertex, leftvertex, botvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle prior to vertex insertion.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, rightvertex, leftvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle after vertex insertion (top).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, leftvertex, botvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle after vertex insertion (left).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, botvertex, rightvertex, newvertex) &lt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle after vertex insertion (right).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Updating top ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating left ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;newbotleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating right ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;newbotright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The insertion is successful by <b><a href="CppDefault.htm">default</a></b>, unless an encroached<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment is found.<br/>
&nbsp;&nbsp;InsertVertexResult success <a href="CppOperatorAssign.htm">=</a> SUCCESSFULVERTEX;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Circle around the newly inserted vertex, checking each edge opposite<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;it <b><a href="CppFor.htm">for</a></b> the Delaunay property.&nbsp;&nbsp;Non-Delaunay edges are flipped.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;`horiz' is always the edge being checked.&nbsp;&nbsp;`first' marks where to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;stop circling.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> first <a href="CppOperatorAssign.htm">=</a> horiz.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(horiz, first);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> first;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> horiz.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(horiz, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Circle until finished.<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>By <b><a href="CppDefault.htm">default</a></b>, the edge will be flipped.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> doflip <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> a subsegment, which cannot be flipped.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checksubseg <a href="CppOperatorAssign.htm">=</a> horiz.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>horiz.Tspivot(checksubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(horiz, checksubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checksubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The edge is a subsegment and cannot be flipped.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doflip <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (segmentflaws)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does the <b><a href="CppNew.htm">new</a></b> vertex encroach upon <b><a href="CppThis.htm">this</a></b> subsegment?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkseg4encroach(m.m_dummytri,b.m_conformdel,b.m_goodangle,b.m_nobisect,&amp;checksubseg))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (checkseg4encroach(m, b, &amp;checksubseg))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success <a href="CppOperatorAssign.htm">=</a> ENCROACHINGVERTEX;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (doflip)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the edge is a boundary edge.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> top <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(horiz, top);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (top.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The edge is a boundary edge and cannot be flipped.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doflip <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the vertex on the other side of the edge.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farvertex <a href="CppOperatorAssign.htm">=</a> top.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(top, farvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>In the incremental Delaunay triangulation <a href="CppAlgorithm.htm">algorithm</a>, <a href="CppAny.htm">any</a> of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;`leftvertex', `rightvertex', and `farvertex' could be vertices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;of the triangular bounding box.&nbsp;&nbsp;These vertices must be<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;treated as <b><a href="CppIf.htm">if</a></b> they are infinitely distant, even though their<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;"coordinates" are not.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( leftvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> leftvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> leftvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>`leftvertex' is infinitely distant.&nbsp;&nbsp;Check the convexity of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the boundary of the triangulation.&nbsp;&nbsp;'farvertex' might be<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;infinite as well, but trust me, <b><a href="CppThis.htm">this</a></b> same condition should<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;be applied.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doflip <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, newvertex, rightvertex, farvertex)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (rightvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> rightvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> rightvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>`rightvertex' is infinitely distant.&nbsp;&nbsp;Check the convexity of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the boundary of the triangulation.&nbsp;&nbsp;'farvertex' might be<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;infinite as well, but trust me, <b><a href="CppThis.htm">this</a></b> same condition should<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;be applied.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doflip <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, farvertex, leftvertex, newvertex)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; farvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> farvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> farvertex <a href="CppOperatorEqual.htm">==</a> m.m_infvertex3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>`farvertex' is infinitely distant and cannot be inside<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the circumcircle of the triangle `horiz'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doflip <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test whether the edge is locally Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doflip <a href="CppOperatorAssign.htm">=</a> incircle(m.m_incirclecount,b.m_noexact, leftvertex, newvertex, rightvertex,farvertex) &gt; 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (doflip)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We made it!&nbsp;&nbsp;Flip the edge `horiz' by rotating its containing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;quadrilateral (the two triangles adjacent to `horiz').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Identify the casing of the quadrilateral.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topleft.Lprev(top);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(top, topleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toplcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topleft, toplcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topright.SetLnext(top);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(top, topright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topright, toprcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botleft.SetLnext(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(horiz, botleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botleft, botlcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botright.Lprev(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(horiz, botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppRotate.htm">Rotate</a> the quadrilateral one-quarter turn <a href="CppCounter.htm">counter</a>clockwise.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(topleft, botlcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(botleft, botrcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(botright, toprcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(topright, toplcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checksegments)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> subsegments and rebond them to the quadrilateral.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toplsubseg <a href="CppOperatorAssign.htm">=</a> topleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topleft.Tspivot(toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topleft, toplsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlsubseg <a href="CppOperatorAssign.htm">=</a> botleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botleft.Tspivot(botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botleft, botlsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprsubseg <a href="CppOperatorAssign.htm">=</a> topright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topright.Tspivot(toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topright, toprsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toplsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(topright, toplsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botlsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(topleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(topleft, botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (botrsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(botleft, botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (toprsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(botright, toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>New vertex assignments <b><a href="CppFor.htm">for</a></b> the rotated quadrilateral.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetOrigin(farvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(horiz, farvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetDest(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(horiz, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetApex(rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(horiz, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top.SetOrigin(bewvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(top, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top.SetDest(farvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(top, farvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top.SetApex(leftvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(top, leftvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_eextras; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Take the average of the two triangles' attributes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> attrib <a href="CppOperatorAssign.htm">=</a> 0.5 * top.GetElemAttrib(i) <a href="CppOperatorPlus.htm">+</a> horiz.GetElemAttrib(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>attrib <a href="CppOperatorAssign.htm">=</a> 0.5 * (elemattribute(top, i) <a href="CppOperatorPlus.htm">+</a> elemattribute(horiz, i));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top.SetElemAttrib(i,attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(top, i, attrib);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetElemAttrib(i,attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(horiz, i, attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> area <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (top.GetAreaBound() <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> horiz.GetAreaBound() <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (areabound(top) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0 <a href="CppOperatorLogicalOr.htm">||</a> areabound(horiz) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Take the average of the two triangles' area constraints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;This prevents small area constraints from migrating a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b>, <b><a href="CppLong.htm">long</a></b> way from their original location due to flips.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area <a href="CppOperatorAssign.htm">=</a> 0.5 * top.GetAreaBound() <a href="CppOperatorPlus.htm">+</a> horiz.GetAreaBound();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>area <a href="CppOperatorAssign.htm">=</a> 0.5 * (areabound(top) <a href="CppOperatorPlus.htm">+</a> areabound(horiz));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top.SetAreaBound(area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(top, area);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetAreaBound(area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(horiz, area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_checkquality)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;FlipStacker&gt; newflip(<b><a href="CppNew.htm">new</a></b> FlipStacker);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>newflip <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> FlipStacker *) PoolAlloc(&amp;m.m_flipstackers);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newflip-&gt;m_flippedtri <a href="CppOperatorAssign.htm">=</a> horiz.m_tri[horiz.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>newflip-&gt;m_flippedtri <a href="CppOperatorAssign.htm">=</a> encode(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newflip-&gt;m_prevflip <a href="CppOperatorAssign.htm">=</a> m.m_lastflip;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip <a href="CppOperatorAssign.htm">=</a> newflip;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newvertex <a href="CppOperatorNotEqual.htm">!=</a> (vertex) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, leftvertex, newvertex, rightvertex) &lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle prior to edge flip (bottom).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The following test has been removed because constrainededge()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;some<a href="CppTime.htm">time</a>s generates inverted triangles that insertvertex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;removes.<br/>
<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, rightvertex, farvertex, leftvertex) &lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle prior to edge flip (top).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, farvertex, leftvertex, newvertex) &lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle after edge flip (left).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m.m_<a href="CppCounter.htm">counter</a>clockcount, b.m_noexact, newvertex, rightvertex, farvertex) &lt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in insertvertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Clockwise triangle after edge flip (right).\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Edge flip results in left ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topleft.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(topleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;topleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;and right ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>On the next iterations, consider the two edges that were<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;exposed (<b><a href="CppThis.htm">this</a></b> is, are now visible to the newly inserted<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertex) by the edge flip.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> farvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!doflip)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The handle `horiz' is accepted as locally Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triflaws)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the triangle `horiz' <b><a href="CppFor.htm">for</a></b> quality.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtriangle(m, b, &amp;horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Look <b><a href="CppFor.htm">for</a></b> the next edge around the newly inserted vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testtri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(horiz, testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> finishing a complete revolution <a href="CppAbout.htm">about</a> the <b><a href="CppNew.htm">new</a></b> vertex, or<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;falling outside&nbsp;&nbsp;of the triangulation.&nbsp;&nbsp;The latter will happen<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;when a vertex is inserted at a boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftvertex <a href="CppOperatorEqual.htm">==</a> first <a href="CppOperatorLogicalOr.htm">||</a> testtri.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We're done.&nbsp;&nbsp;Return a triangle whose origin is the <b><a href="CppNew.htm">new</a></b> vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;SetLnext(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(horiz, *searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_recenttri.SetLnext(horiz);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(horiz, m.m_recenttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> success;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Finish finding the next edge around the newly inserted vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horiz.SetLnext(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(testtri, horiz);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightvertex <a href="CppOperatorAssign.htm">=</a> leftvertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> horiz.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(horiz, leftvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::triangulatepolygon(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; firstedge,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; lastedge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> edgecount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> doflip,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> triflaws<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; testtri;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; besttri;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; tempedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex leftbasevertex, rightbasevertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex testvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex bestvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> bestnumber;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym(), onext(), and oprev().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Identify the base vertices.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftbasevertex <a href="CppOperatorAssign.htm">=</a> lastedge-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*lastedge, leftbasevertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightbasevertex <a href="CppOperatorAssign.htm">=</a> firstedge-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*firstedge, rightbasevertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangulating interior polygon at edge\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n", leftbasevertex[0],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftbasevertex[1], rightbasevertex[0], rightbasevertex[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the best vertex to connect the base to.<br/>
&nbsp;&nbsp;besttri.Onext(*firstedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(*firstedge, besttri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> bestvertex <a href="CppOperatorAssign.htm">=</a> besttri.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(besttri, bestvertex);<br/>
<br/>
&nbsp;&nbsp;testtri <a href="CppOperatorAssign.htm">=</a> besttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(besttri, testtri);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> bestnumber <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 2; i <a href="CppOperatorLessEqual.htm">&lt;=</a> edgecount <a href="CppOperatorMinus.htm">-</a> 2; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri-&gt;Onextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onextself(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testvertex <a href="CppOperatorAssign.htm">=</a> testtri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(testtri, testvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is <b><a href="CppThis.htm">this</a></b> a better vertex?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (incircle(m.m_incirclecount,b.m_noexact, leftbasevertex, rightbasevertex, bestvertex,testvertex) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;besttri <a href="CppOperatorAssign.htm">=</a> testtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(testtri, besttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestvertex <a href="CppOperatorAssign.htm">=</a> testvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestnumber <a href="CppOperatorAssign.htm">=</a> i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Connecting edge to (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n", bestvertex[0],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bestvertex[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bestnumber &gt; 1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively triangulate the smaller polygon on the right.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tempedge.Oprev(besttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(besttri, tempedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangulatepolygon(m, b, firstedge, &amp;tempedge, bestnumber <a href="CppOperatorPlus.htm">+</a> 1, 1, triflaws);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (bestnumber &lt; edgecount <a href="CppOperatorMinus.htm">-</a> 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively triangulate the smaller polygon on the left.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tempedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(besttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(besttri, tempedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangulatepolygon(m, b, &amp;besttri, lastedge, edgecount <a href="CppOperatorMinus.htm">-</a> bestnumber, 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; triflaws);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find `besttri' again; it may have been lost to edge flips.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> besttri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(tempedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(tempedge, besttri);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (doflip)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do one <b><a href="CppFinal.htm">final</a></b> edge flip.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;flip(m, b, &amp;besttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triflaws)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the quality of the newly committed triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testtri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(besttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(besttri, testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtriangle(m, b, &amp;testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Return the base triangle.<br/>
&nbsp;&nbsp;lastedge <a href="CppOperatorAssign.htm">=</a> besttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(besttri, *lastedge);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::deletevertex(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; deltri<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri countingtri;<br/>
&nbsp;&nbsp;Otri firstedge, lastedge;<br/>
&nbsp;&nbsp;Otri deltriright;<br/>
&nbsp;&nbsp;Otri lefttri, righttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri leftcasing, rightcasing;<br/>
&nbsp;&nbsp;Osub leftsubseg, rightsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex delvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex neworg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> edgecount;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym(), onext(), and oprev().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> delvertex <a href="CppOperatorAssign.htm">=</a> deltri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*deltri, delvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Deleting (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n", delvertex[0], delvertex[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;vertexdealloc(m.m_vertices, delvertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Count the degree of the vertex being deleted.<br/>
&nbsp;&nbsp;countingtri.Onext(*deltri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(*deltri, countingtri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> edgecount <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (*deltri <a href="CppOperatorNotEqual.htm">!=</a> countingtri)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (!otriequal(*deltri, countingtri))<br/>
&nbsp;&nbsp;{<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (countingtri.tri <a href="CppOperatorEqual.htm">==</a> m.dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in deletevertex():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Attempt to <b><a href="CppDelete.htm">delete</a></b> boundary vertex.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edgecount<a href="CppOperatorIncrement.htm">++</a>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;countingtri.Onextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onextself(countingtri);<br/>
&nbsp;&nbsp;}<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SELF_CHECK<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgecount &lt; 3) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in deletevertex():\n&nbsp;&nbsp;Vertex has degree <a href="CppOperatorModulus.htm">%</a>d.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgecount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;}<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a>SELF_CHECK<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgecount &gt; 3)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangulate the polygon defined by the <b><a href="CppUnion.htm">union</a></b> of all triangles<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent to the vertex being deleted.&nbsp;&nbsp;Check the quality of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the resulting triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;firstedge.Onext(*deltri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(*deltri, firstedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;lastedge.Oprev(*deltri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(*deltri, lastedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangulatepolygon(m, b, &amp;firstedge, &amp;lastedge, edgecount, 0, !b.m_nobisect);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Splice out two triangles.<br/>
&nbsp;&nbsp;deltriright.Lprev(*deltri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*deltri, deltriright);<br/>
<br/>
&nbsp;&nbsp;lefttri.Dnext(*deltri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dnext(*deltri, lefttri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(lefttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(lefttri, leftcasing);<br/>
<br/>
&nbsp;&nbsp;righttri.Oprev(deltriright);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(deltriright, righttri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(righttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(righttri, rightcasing);<br/>
<br/>
&nbsp;&nbsp;Bond(*deltri, leftcasing);<br/>
&nbsp;&nbsp;Bond(deltriright, rightcasing);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftsubseg <a href="CppOperatorAssign.htm">=</a> lefttri.CreateTspivot();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lefttri.Tspivot(leftsubseg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(lefttri, leftsubseg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tsbond(*deltri, leftsubseg);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightsubseg <a href="CppOperatorAssign.htm">=</a> righttri.CreateTspivot();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>righttri.Tspivot(rightsubseg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(righttri, rightsubseg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tsbond(deltriright, rightsubseg);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the <b><a href="CppNew.htm">new</a></b> origin of `deltri' and check its quality.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> neworg <a href="CppOperatorAssign.htm">=</a> lefttri.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(lefttri, neworg);<br/>
<br/>
&nbsp;&nbsp;deltri-&gt;SetOrigin(neworg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(*deltri, neworg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_nobisect) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtriangle(m, b, deltri);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the two spliced-out triangles.<br/>
&nbsp;&nbsp;m.KillTriange(lefttri.m_triangles);<br/>
&nbsp;&nbsp;m.KillTriange(righttri.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, lefttri.m_tri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, righttri.m_tri);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::undovertex(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri fliptri;<br/>
&nbsp;&nbsp;Otri botleft, botright, topright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri botlcasing, botrcasing, toprcasing;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri gluetri;<br/>
&nbsp;&nbsp;Osub botlsubseg, botrsubseg, toprsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex botvertex, rightvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Walk through the list of transformations (flips and a vertex insertion)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;in the reverse of the order in which they were done, and undo them.<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m.m_lastflip <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle involved in the last unreversed transformation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> fliptri <a href="CppOperatorAssign.htm">=</a> m.m_lastflip-&gt;m_flippedtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(m.m_lastflip-&gt;m_flippedtri, fliptri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We are <a href="GameReversi.htm">reversi</a>ng one of three transformations:&nbsp;&nbsp;a trisection of one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle into three (by inserting a vertex in the triangle), a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;bisection of two triangles into four (by inserting a vertex in an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge), or an edge flip.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_lastflip-&gt;m_prevflip <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Restore a triangle that was split into three triangles,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;so it is again one triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botleft.Dprev(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dprev(fliptri, botleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botleft.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(botleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botright.Onext(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(fliptri, botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botright.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botleft, botlcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botvertex <a href="CppOperatorAssign.htm">=</a> botleft.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(botleft, botvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fliptri.SetApex(botvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(fliptri, botvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fliptri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(fliptri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(fliptri, botlcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botlsubseg <a href="CppOperatorAssign.htm">=</a> botleft.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botleft.Tspivot(botlsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botleft, botlsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(fliptri, botlsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fliptri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(fliptri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(fliptri, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(fliptri, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the two spliced-out triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillTriangle(botleft.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillTriangle(botright.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, botleft.m_tri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, botright.m_tri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (m.m_lastflip-&gt;m_prevflip <a href="CppOperatorEqual.htm">==</a> &amp;insertvertex)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Restore two triangles that were split into four triangles,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;so they are again two triangles.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gluetri.Lprev(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(fliptri, gluetri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botright <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(gluetri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(gluetri, botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;botright.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(botright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(botright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(botright, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> botright.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(botright, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fliptri.SetOrigin(rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(fliptri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(gluetri, botrcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> botrsubseg <a href="CppOperatorAssign.htm">=</a> botright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>botright.Tspivot(botrsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(botright, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(gluetri, botrsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the spliced-out triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillTriangle(botright.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, botright.m_tri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> gluetri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(fliptri, gluetri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (gluetri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gluetri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(gluetri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topright.Dnext(gluetri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dnext(gluetri, topright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(topright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(topright, toprcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gluetri.SetOrigin(rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(gluetri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(gluetri, toprcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> toprsubseg <a href="CppOperatorAssign.htm">=</a> topright.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>topright.Tspivot(toprsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(topright, toprsubseg);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(gluetri, toprsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the spliced-out triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillTriangle(topright.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, topright.m_tri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>This is the end of the list, sneakily encoded.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip-&gt;m_prevflip <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Undo an edge flip.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unflip(m, b, &amp;fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Go on and process the next transformation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_lastflip <a href="CppOperatorAssign.htm">=</a> m.m_lastflip-&gt;m_prevflip;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> The divide-and-conquer bounding box<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> I originally implemented the divide-and-conquer and incremental Delaunay<br/>
<a href="CppComment.htm">//</a> triangulations <b><a href="CppUsing.htm">using</a></b> the edge-based data structure presented by Guibas<br/>
<a href="CppComment.htm">//</a> and Stolfi.&nbsp;&nbsp;Switching to a triangle-based data structure <b><a href="CppDouble.htm">double</a></b>d the<br/>
<a href="CppComment.htm">//</a> speed.&nbsp;&nbsp;However, I had to think of a few extra tricks to maintain the<br/>
<a href="CppComment.htm">//</a> elegance of the original <a href="CppAlgorithm.htm">algorithm</a>s.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> The "bounding box" used by my variant of the divide-and-conquer<br/>
<a href="CppComment.htm">//</a> <a href="CppAlgorithm.htm">algorithm</a> uses one triangle <b><a href="CppFor.htm">for</a></b> each edge of the convex hull of the<br/>
<a href="CppComment.htm">//</a> triangulation.&nbsp;&nbsp;These bounding triangles all share a common apical<br/>
<a href="CppComment.htm">//</a> vertex, which is represented by <a href="CppNULL.htm">NULL</a> and which represents nothing.<br/>
<a href="CppComment.htm">//</a> The bounding triangles are <a href="CppLink.htm">link</a>ed in a circular fan <a href="CppAbout.htm">about</a> <b><a href="CppThis.htm">this</a></b> <a href="CppNULL.htm">NULL</a><br/>
<a href="CppComment.htm">//</a> vertex, and the edges on the convex hull of the triangulation appear<br/>
<a href="CppComment.htm">//</a> opposite the <a href="CppNULL.htm">NULL</a> vertex.&nbsp;&nbsp;You might find it easiest to imagine that<br/>
<a href="CppComment.htm">//</a> the <a href="CppNULL.htm">NULL</a> vertex is a <a href="CppPointer.htm">point</a> in 3D space behind the center of the<br/>
<a href="CppComment.htm">//</a> triangulation, and that the bounding triangles form a sort of cone.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> This bounding box <a href="CppMake.htm">make</a>s it easy to represent degenerate <b><a href="CppCase.htm">case</a></b>s.&nbsp;&nbsp;For<br/>
<a href="CppComment.htm">//</a> <a href="CppInstance.htm">instance</a>, the triangulation of two vertices is a single edge.&nbsp;&nbsp;This edge<br/>
<a href="CppComment.htm">//</a> is represented by two bounding box triangles, one on each "side" of the<br/>
<a href="CppComment.htm">//</a> edge.&nbsp;&nbsp;These triangles are also <a href="CppLink.htm">link</a>ed together in a fan <a href="CppAbout.htm">about</a> the <a href="CppNULL.htm">NULL</a><br/>
<a href="CppComment.htm">//</a> vertex.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> The bounding box also <a href="CppMake.htm">make</a>s it easy to traverse the convex hull, as the<br/>
<a href="CppComment.htm">//</a> divide-and-conquer <a href="CppAlgorithm.htm">algorithm</a> needs to <b><a href="CppDo.htm">do</a></b>.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>Use vertex*, because a <a href="CppQuickSort.htm">quicksort</a> is used<br/>
<a href="CppComment.htm">//</a>Sort to x_left &lt; x_right, then y_left &lt; y_right (as I'd expect)<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::vertexsort(<br/>
&nbsp;&nbsp;Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArray.htm">array</a>size<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> left, right;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> pivot;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> pivotx, pivoty;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex temp;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArray.htm">array</a>size <a href="CppOperatorEqual.htm">==</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursive base <b><a href="CppCase.htm">case</a></b>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (sort<a href="CppArray.htm">array</a>[0].GetX() &gt; sort<a href="CppArray.htm">array</a>[1].GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort<a href="CppArray.htm">array</a>[0].GetX() <a href="CppOperatorEqual.htm">==</a> sort<a href="CppArray.htm">array</a>[1].GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> sort<a href="CppArray.htm">array</a>[0].GetY() &gt; sort<a href="CppArray.htm">array</a>[1].GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(sort<a href="CppArray.htm">array</a>[0],sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Choose a random pivot to split the <a href="CppArray.htm">array</a>.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> pivot <a href="CppOperatorAssign.htm">=</a> <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> <a href="CppArray.htm">array</a>size;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> pivotx <a href="CppOperatorAssign.htm">=</a> sort<a href="CppArray.htm">array</a>[pivot].GetX();<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> pivoty <a href="CppOperatorAssign.htm">=</a> sort<a href="CppArray.htm">array</a>[pivot].GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split the <a href="CppArray.htm">array</a>.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> left <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> right <a href="CppOperatorAssign.htm">=</a> <a href="CppArray.htm">array</a>size;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (left &lt; right)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> a vertex whose x-coordinate is too large <b><a href="CppFor.htm">for</a></b> the left.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>left;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (left <a href="CppOperatorLessEqual.htm">&lt;=</a> right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((sort<a href="CppArray.htm">array</a>[left][0] &lt; pivotx) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sort<a href="CppArray.htm">array</a>[left][0] <a href="CppOperatorEqual.htm">==</a> pivotx <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> sort<a href="CppArray.htm">array</a>[left][1] &lt; pivoty)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> a vertex whose x-coordinate is too small <b><a href="CppFor.htm">for</a></b> the right.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((left <a href="CppOperatorLessEqual.htm">&lt;=</a> right) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((sort<a href="CppArray.htm">array</a>[right][0] &gt; pivotx) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((sort<a href="CppArray.htm">array</a>[right][0] <a href="CppOperatorEqual.htm">==</a> pivotx) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sort<a href="CppArray.htm">array</a>[right][1] &gt; pivoty))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (left &lt; right) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(sort<a href="CppArray.htm">array</a>[left],sort<a href="CppArray.htm">array</a>[right]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (left &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively sort the left subset.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexsort(sort<a href="CppArray.htm">array</a>, left);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (right &lt; <a href="CppArray.htm">array</a>size <a href="CppOperatorMinus.htm">-</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively sort the right subset.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexsort(&amp;sort<a href="CppArray.htm">array</a>[right <a href="CppOperatorPlus.htm">+</a> 1], <a href="CppArray.htm">array</a>size <a href="CppOperatorMinus.htm">-</a> right <a href="CppOperatorMinus.htm">-</a> 1);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::vertexmedian(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArray.htm">array</a>size,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> median,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axis<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdPartial_sort.htm">std::partial_sort</a>(vertices.begin(),vertices.begin() <a href="CppOperatorPlus.htm">+</a> median,vertices.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lhs, <b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetX() &lt; rhs-&gt;GetX()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetX() &gt; rhs-&gt;GetX()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs-&gt;GetY() &lt; rhs-&gt;GetY();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> left, right;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> pivot;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> pivot1, pivot2;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArray.htm">array</a>size <a href="CppOperatorEqual.htm">==</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursive base <b><a href="CppCase.htm">case</a></b>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((sort<a href="CppArray.htm">array</a>[0][axis] &gt; sort<a href="CppArray.htm">array</a>[1][axis]) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((sort<a href="CppArray.htm">array</a>[0][axis] <a href="CppOperatorEqual.htm">==</a> sort<a href="CppArray.htm">array</a>[1][axis]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (sort<a href="CppArray.htm">array</a>[0][1 <a href="CppOperatorMinus.htm">-</a> axis] &gt; sort<a href="CppArray.htm">array</a>[1][1 <a href="CppOperatorMinus.htm">-</a> axis])))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(sort<a href="CppArray.htm">array</a>[0],sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Choose a random pivot to split the <a href="CppArray.htm">array</a>.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> pivot <a href="CppOperatorAssign.htm">=</a> <a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> <a href="CppArray.htm">array</a>size;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> pivot1 <a href="CppOperatorAssign.htm">=</a> sort<a href="CppArray.htm">array</a>[pivot][axis];<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> pivot2 <a href="CppOperatorAssign.htm">=</a> sort<a href="CppArray.htm">array</a>[pivot][1 <a href="CppOperatorMinus.htm">-</a> axis];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split the <a href="CppArray.htm">array</a>.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> left <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> right <a href="CppOperatorAssign.htm">=</a> <a href="CppArray.htm">array</a>size;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (left &lt; right) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> a vertex whose x-coordinate is too large <b><a href="CppFor.htm">for</a></b> the left.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((left <a href="CppOperatorLessEqual.htm">&lt;=</a> right) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((sort<a href="CppArray.htm">array</a>[left][axis] &lt; pivot1) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((sort<a href="CppArray.htm">array</a>[left][axis] <a href="CppOperatorEqual.htm">==</a> pivot1) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sort<a href="CppArray.htm">array</a>[left][1 <a href="CppOperatorMinus.htm">-</a> axis] &lt; pivot2))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> a vertex whose x-coordinate is too small <b><a href="CppFor.htm">for</a></b> the right.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((left <a href="CppOperatorLessEqual.htm">&lt;=</a> right) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((sort<a href="CppArray.htm">array</a>[right][axis] &gt; pivot1) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((sort<a href="CppArray.htm">array</a>[right][axis] <a href="CppOperatorEqual.htm">==</a> pivot1) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sort<a href="CppArray.htm">array</a>[right][1 <a href="CppOperatorMinus.htm">-</a> axis] &gt; pivot2))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (left &lt; right)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(sort<a href="CppArray.htm">array</a>[left],sort<a href="CppArray.htm">array</a>[right]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Unlike in vertexsort(), at most one of the following<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;conditionals is <b><a href="CppTrue.htm">true</a></b>.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (left &gt; median) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively shuffle the left subset.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexmedian(sort<a href="CppArray.htm">array</a>, left, median, axis);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (right &lt; median <a href="CppOperatorMinus.htm">-</a> 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively shuffle the right subset.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexmedian(&amp;sort<a href="CppArray.htm">array</a>[right <a href="CppOperatorPlus.htm">+</a> 1], <a href="CppArray.htm">array</a>size <a href="CppOperatorMinus.htm">-</a> right <a href="CppOperatorMinus.htm">-</a> 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; median <a href="CppOperatorMinus.htm">-</a> right <a href="CppOperatorMinus.htm">-</a> 1, axis);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::alternateaxes(<br/>
&nbsp;&nbsp;Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArray.htm">array</a>size,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> axis<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> divider;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> divider <a href="CppOperatorAssign.htm">=</a> <a href="CppArray.htm">array</a>size <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArray.htm">array</a>size <a href="CppOperatorLessEqual.htm">&lt;=</a> 3) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursive base <b><a href="CppCase.htm">case</a></b>:&nbsp;&nbsp;subsets of two or three vertices will be<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;handled specially, and should always be sorted by x-coordinate.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;axis <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Partition with a horizontal or vertical cut.<br/>
&nbsp;&nbsp;vertexmedian(sort<a href="CppArray.htm">array</a>, <a href="CppArray.htm">array</a>size, divider, axis);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively partition the subsets with a cross cut.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppArray.htm">array</a>size <a href="CppOperatorMinus.htm">-</a> divider <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (divider <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternateaxes(sort<a href="CppArray.htm">array</a>, divider, 1 <a href="CppOperatorMinus.htm">-</a> axis);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;alternateaxes(&amp;sort<a href="CppArray.htm">array</a>[divider], <a href="CppArray.htm">array</a>size <a href="CppOperatorMinus.htm">-</a> divider, 1 <a href="CppOperatorMinus.htm">-</a> axis);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::mergehulls(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farleft,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; innerleft,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; innerright,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farright,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axis<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri leftcand, rightcand;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri baseedge;<br/>
&nbsp;&nbsp;Otri nextedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri sidecasing, topcasing, outercasing;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri checkedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex innerleftdest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex innerrightorg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex innerleftapex, innerrightapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex farleftpt, farrightpt;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex farleftapex, farrightapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex lowerleft, lowerright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex upperleft, upperright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex nextapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex checkvertex;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> changemade;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> badedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> leftfinished, rightfinished;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerleftdest <a href="CppOperatorAssign.htm">=</a> innerleft-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*innerleft, innerleftdest);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerleftapex <a href="CppOperatorAssign.htm">=</a> innerleft-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*innerleft, innerleftapex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerrightorg <a href="CppOperatorAssign.htm">=</a> innerright-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*innerright, innerrightorg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerrightapex <a href="CppOperatorAssign.htm">=</a> innerright-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*innerright, innerrightapex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Special treatment <b><a href="CppFor.htm">for</a></b> horizontal cuts.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_dwyer <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (axis <a href="CppOperatorEqual.htm">==</a> 1))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftpt <a href="CppOperatorAssign.htm">=</a> farleft-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*farleft, farleftpt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftapex <a href="CppOperatorAssign.htm">=</a> farleft-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*farleft, farleftapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightpt <a href="CppOperatorAssign.htm">=</a> farright-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*farright, farrightpt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightapex <a href="CppOperatorAssign.htm">=</a> farright-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*farright, farrightapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The <a href="CppPointer.htm">pointer</a>s to the extremal vertices are shifted to <a href="CppPointer.htm">point</a> to the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;topmost and bottommost vertex of each hull, rather than the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;leftmost and rightmost vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (farleftapex[1] &lt; farleftpt[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(*farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleftpt <a href="CppOperatorAssign.htm">=</a> farleftapex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleftapex <a href="CppOperatorAssign.htm">=</a> farleft-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*farleft, farleftapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*innerleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*innerleft, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> checkedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(checkedge, checkvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (checkvertex[1] &gt; innerleftdest[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerleft-&gt;SetLnext(checkedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(checkedge, *innerleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerleftapex <a href="CppOperatorAssign.htm">=</a> innerleftdest;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerleftdest <a href="CppOperatorAssign.htm">=</a> checkvertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*innerleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*innerleft, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> checkedge-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(checkedge, checkvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (innerrightapex[1] &lt; innerrightorg[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerright-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*innerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerright-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(*innerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerrightorg <a href="CppOperatorAssign.htm">=</a> innerrightapex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerrightapex <a href="CppOperatorAssign.htm">=</a> innerright-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*innerright, innerrightapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*farright, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> checkedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(checkedge, checkvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (checkvertex[1] &gt; farrightpt[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;SetLnext(checkedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(checkedge, *farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightapex <a href="CppOperatorAssign.htm">=</a> farrightpt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightpt <a href="CppOperatorAssign.htm">=</a> checkvertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*farright, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> checkedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(checkedge, checkvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a line tangent to and below both hulls.<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;changemade <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make innerleftdest the "bottommost" vertex of the left hull.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, innerleftdest, innerleftapex, innerrightorg) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerleft-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*innerleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerleft-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(*innerleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerleftdest <a href="CppOperatorAssign.htm">=</a> innerleftapex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerleftapex <a href="CppOperatorAssign.htm">=</a> innerleft-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*innerleft, innerleftapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changemade <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make innerrightorg the "bottommost" vertex of the right hull.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, innerrightapex, innerrightorg, innerleftdest) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerright-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*innerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;innerright-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(*innerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerrightorg <a href="CppOperatorAssign.htm">=</a> innerrightapex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> innerrightapex <a href="CppOperatorAssign.htm">=</a> innerright-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*innerright, innerrightapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changemade <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (changemade);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the two candidates to be the next "gear tooth."<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftcand <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*innerleft);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*innerleft, leftcand);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightcand <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*innerright);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*innerright, rightcand);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the bottom <b><a href="CppNew.htm">new</a></b> bounding triangle.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> baseedge <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;baseedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;baseedge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Connect it to the bounding boxes of the left and right triangulations.<br/>
&nbsp;&nbsp;Bond(baseedge, *innerleft);<br/>
<br/>
&nbsp;&nbsp;baseedge.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(baseedge);<br/>
<br/>
&nbsp;&nbsp;Bond(baseedge, *innerright);<br/>
<br/>
&nbsp;&nbsp;baseedge.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(baseedge);<br/>
<br/>
&nbsp;&nbsp;baseedge.SetOrigin(innerrightorg);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(baseedge, innerrightorg);<br/>
<br/>
&nbsp;&nbsp;baseedge.SetDest(innerleftdest);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(baseedge, innerleftdest);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Apex is intentionally left <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating base bounding ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;baseedge);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fix the extreme triangles <b><a href="CppIf.htm">if</a></b> necessary.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftpt <a href="CppOperatorAssign.htm">=</a> farleft-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*farleft, farleftpt);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (innerleftdest <a href="CppOperatorEqual.htm">==</a> farleftpt)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;SetLnext(baseedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(baseedge, *farleft);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightpt <a href="CppOperatorAssign.htm">=</a> farright-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*farright, farrightpt);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (innerrightorg <a href="CppOperatorEqual.htm">==</a> farrightpt)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;Lprev(baseedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(baseedge, *farright);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The vertices of the current knitting edge.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lowerleft <a href="CppOperatorAssign.htm">=</a> innerleftdest;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lowerright <a href="CppOperatorAssign.htm">=</a> innerrightorg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The candidate vertices <b><a href="CppFor.htm">for</a></b> knitting.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> upperleft <a href="CppOperatorAssign.htm">=</a> leftcand.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(leftcand, upperleft);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> upperright <a href="CppOperatorAssign.htm">=</a> rightcand.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(rightcand, upperright);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Walk up the gap between the two triangulations, knitting them together.<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Have we reached the top?&nbsp;&nbsp;(This isn't quite the right <a href="CppQuestion.htm">question</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;because even though the left triangulation might seem finished now,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;moving up on the right triangulation might reveal a <b><a href="CppNew.htm">new</a></b> vertex of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the left triangulation.&nbsp;&nbsp;And vice-versa.)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftfinished <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, upperleft, lowerleft, lowerright) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightfinished <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, upperright, lowerleft, lowerright) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftfinished <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rightfinished)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the top <b><a href="CppNew.htm">new</a></b> bounding triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nextedge <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetOrigin(lowerleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(nextedge, lowerleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetDest(lowerright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(nextedge, lowerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Apex is intentionally left <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Connect it to the bounding boxes of the two triangulations.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, baseedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, rightcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, leftcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating top bounding ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Special treatment <b><a href="CppFor.htm">for</a></b> horizontal cuts.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_dwyer <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> axis <a href="CppOperatorEqual.htm">==</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftpt <a href="CppOperatorAssign.htm">=</a> farleft-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*farleft, farleftpt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftapex <a href="CppOperatorAssign.htm">=</a> farleft-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*farleft, farleftapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightpt <a href="CppOperatorAssign.htm">=</a> farright-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*farright, farrightpt);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightapex <a href="CppOperatorAssign.htm">=</a> farright-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*farright, farrightapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*farleft, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> checkedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(checkedge, checkvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The <a href="CppPointer.htm">pointer</a>s to the extremal vertices are restored to the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;leftmost and rightmost vertices (rather than topmost and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;bottommost).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (checkvertex[0] &lt; farleftpt[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;Lprev(checkedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(checkedge, *farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftapex <a href="CppOperatorAssign.htm">=</a> farleftpt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleftpt <a href="CppOperatorAssign.htm">=</a> checkvertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(*farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(*farleft, checkedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> checkedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(checkedge, checkvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (farrightapex[0] &gt; farrightpt[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(*farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightpt <a href="CppOperatorAssign.htm">=</a> farrightapex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farrightapex <a href="CppOperatorAssign.htm">=</a> farright-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*farright, farrightapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Consider eliminating edges from the left triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!leftfinished)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>What vertex would be exposed <b><a href="CppIf.htm">if</a></b> an edge were deleted?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lprev(leftcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(leftcand, nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nextapex <a href="CppOperatorAssign.htm">=</a> nextedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(nextedge, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If nextapex is <a href="CppNULL.htm">NULL</a>, then no vertex would be exposed; the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangulation would have been eaten right through.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextapex <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the edge is Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> badedge <a href="CppOperatorAssign.htm">=</a> incircle(m.m_incirclecount,b.m_noexact, lowerleft, lowerright, upperleft, nextapex) &gt; 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (badedge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Eliminate the edge with an edge flip.&nbsp;&nbsp;As a result, the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;left triangulation will have one more boundary triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> topcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(nextedge, topcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> sidecasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(nextedge, sidecasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, topcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(leftcand, sidecasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftcand.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(leftcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> outercasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(leftcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(leftcand, outercasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, outercasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct the vertices to reflect the edge flip.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftcand.SetOrigin(lowerleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(leftcand, lowerleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftcand.SetDest(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(leftcand, <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftcand.SetApex(nextapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(leftcand, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetOrigin(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(nextedge, <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetDest(upperleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(nextedge, upperleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetApex(nextapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(nextedge, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Consider the newly exposed vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;upperleft <a href="CppOperatorAssign.htm">=</a> nextapex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>What vertex would be exposed <b><a href="CppIf.htm">if</a></b> another edge were deleted?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge <a href="CppOperatorAssign.htm">=</a> sidecasing;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(sidecasing, nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextapex <a href="CppOperatorAssign.htm">=</a> nextedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(nextedge, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextapex <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the edge is Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badedge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> incircle(m.m_incirclecount, b.m_noexact, lowerleft, lowerright, upperleft,nextapex) &gt; 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Avoid eating right through the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badedge <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Consider eliminating edges from the right triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!rightfinished)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>What vertex would be exposed <b><a href="CppIf.htm">if</a></b> an edge were deleted?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetLnext(rightcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(rightcand, nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nextapex <a href="CppOperatorAssign.htm">=</a> nextedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(nextedge, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If nextapex is <a href="CppNULL.htm">NULL</a>, then no vertex would be exposed; the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangulation would have been eaten right through.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextapex <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the edge is Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badedge <a href="CppOperatorAssign.htm">=</a> incircle(m.m_incirclecount, b.m_noexact, lowerleft, lowerright, upperright, nextapex) &gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (badedge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Eliminate the edge with an edge flip.&nbsp;&nbsp;As a result, the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;right triangulation will have one more boundary triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> topcasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(nextedge, topcasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> sidecasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(nextedge, sidecasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, topcasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(rightcand, sidecasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightcand.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(rightcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> outercasing <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(rightcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(rightcand, outercasing);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(nextedge, outercasing);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Correct the vertices to reflect the edge flip.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightcand.SetOrigin(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(rightcand, <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightcand.SetDest(lowwerright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(rightcand, lowerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightcand.SetApex(nextapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(rightcand, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetOrigin(upperright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(nextedge, upperright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetDest(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(nextedge, <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge.SetApex(nextapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(nextedge, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Consider the newly exposed vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;upperright <a href="CppOperatorAssign.htm">=</a> nextapex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>What vertex would be exposed <b><a href="CppIf.htm">if</a></b> another edge were deleted?<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge <a href="CppOperatorAssign.htm">=</a> sidecasing;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(sidecasing, nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextapex <a href="CppOperatorAssign.htm">=</a> nextedge.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(nextedge, nextapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextapex)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the edge is Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badedge <a href="CppOperatorAssign.htm">=</a> incircle(m.m_incirclecount, b.m_noexact, lowerleft, lowerright, upperright,nextapex) &gt; 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Avoid eating right through the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badedge <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftfinished <a href="CppOperatorLogicalOr.htm">||</a> (!rightfinished <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (incircle(m.m_incirclecount, b.m_noexact, upperleft, lowerleft, lowerright, upperright) &gt; 0.0)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Knit the triangulations, adding an edge from `lowerleft'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to `upperright'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(baseedge, rightcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseedge.Lprev(rightcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(rightcand, baseedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseedge.SetDest(lowerleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(baseedge, lowerleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowerright <a href="CppOperatorAssign.htm">=</a> upperright;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightcand <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(baseedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(baseedge, rightcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightcand.SetApex(upperight);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(rightcand, upperright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Knit the triangulations, adding an edge from `upperleft'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to `lowerright'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(baseedge, leftcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseedge.Lnext(leftcand);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(leftcand, baseedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseedge-&gt;SetOrigin(lowerright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(baseedge, lowerright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowerleft <a href="CppOperatorAssign.htm">=</a> upperleft;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftcand <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(baseedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(baseedge, leftcand);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftcand.SetApex(upperleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(leftcand, upperleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Connecting ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;baseedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::divconqrecurse(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Vertex * <b><a href="CppConst.htm">const</a></b> sort<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertices,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> axis,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farleft,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; farright<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri midtri, tri1, tri2, tri3;<br/>
&nbsp;&nbsp;Otri innerleft, innerright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> area;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> divider;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangulating <a href="CppOperatorModulus.htm">%</a>d vertices.\n", vertices);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertices <a href="CppOperatorEqual.htm">==</a> 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The triangulation of two vertices is an edge.&nbsp;&nbsp;An edge is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;represented by two bounding triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farleft <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(*farleft, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;SetDest(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(*farleft, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The apex is intentionally left <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;SetApex(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farright <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(*farright, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;SetDest(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(*farright, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The apex is intentionally left <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;SetApex(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(*farleft, *farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(*farleft, *farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*farright);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Bond(farleft,farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the origin of `farleft' is sort<a href="CppArray.htm">array</a>[0].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farleft-&gt;Lprev(*farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*farright, *farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (vertices <a href="CppOperatorEqual.htm">==</a> 3)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The triangulation of three vertices is either a triangle (with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;three bounding triangles) or two edges (with four bounding<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangles).&nbsp;&nbsp;In either <b><a href="CppCase.htm">case</a></b>, four triangles are created.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> midtri <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;midtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;midtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tri1 <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;tri1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tri2 <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;tri2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tri3 <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;tri3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> area <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, sort<a href="CppArray.htm">array</a>[0], sort<a href="CppArray.htm">array</a>[1], sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (area <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Three collinear vertices; the triangulation is two edges.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(midtri, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetDest(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(midtri, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri1, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;SetDest(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri1, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri2, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;SetDest(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri2, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri3, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;SetDest(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri3, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>All apices are intentionally left <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(midtri, tri1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(tri2, tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(midtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(midtri, tri3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(tri1, tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(midtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(midtri, tri1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(tri2, tri3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the origin of `farleft' is sort<a href="CppArray.htm">array</a>[0].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleft <a href="CppOperatorAssign.htm">=</a> tri1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(tri1, *farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the destination of `farright' is sort<a href="CppArray.htm">array</a>[2].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farright <a href="CppOperatorAssign.htm">=</a> tri2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(tri2, *farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The three vertices are not collinear; the triangulation is one<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle, namely `midtri'.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(midtri, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;SetDest(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri1, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri3, sort<a href="CppArray.htm">array</a>[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Apices of tri1, tri2, and tri3 are left <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (area &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The vertices are in <a href="CppCounter.htm">counter</a>clockwise order.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetDest(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(midtri, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri1, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;SetDest(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri2, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetApex(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(midtri, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri2, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;SetDest(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri3, sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The vertices are in clockwise order.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(midtri, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri1, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;SetDest(sort<a href="CppArray.htm">array</a>[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri2, sort<a href="CppArray.htm">array</a>[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;SetApex(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetApex(midtri, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;SetOrigin(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(tri2, sort<a href="CppArray.htm">array</a>[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;SetDest(sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(tri3, sort<a href="CppArray.htm">array</a>[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The topology does not depend on how the vertices are ordered.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(midtri, tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(midtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(midtri, tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(midtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(midtri, tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(tri1, tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri1-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(tri1, tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri2-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(tri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri3-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(tri3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(tri2, tri3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the origin of `farleft' is sort<a href="CppArray.htm">array</a>[0].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farleft <a href="CppOperatorAssign.htm">=</a> tri1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(tri1, *farleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the destination of `farright' is sort<a href="CppArray.htm">array</a>[2].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (area &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farright <a href="CppOperatorAssign.htm">=</a> tri2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(tri2, *farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farright-&gt;SetLnext(*farleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*farleft, *farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;midtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;tri1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;tri2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;tri3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Split the vertices in half.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> divider <a href="CppOperatorAssign.htm">=</a> vertices <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively triangulate each half.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;divconqrecurse(m, b, sort<a href="CppArray.htm">array</a>, divider, 1 <a href="CppOperatorMinus.htm">-</a> axis, farleft, &amp;innerleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;divconqrecurse(m, b, &amp;sort<a href="CppArray.htm">array</a>[divider], vertices <a href="CppOperatorMinus.htm">-</a> divider, 1 <a href="CppOperatorMinus.htm">-</a> axis,&amp;innerright, farright);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Joining triangulations with <a href="CppOperatorModulus.htm">%</a>d and <a href="CppOperatorModulus.htm">%</a>d vertices.\n", divider,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertices <a href="CppOperatorMinus.htm">-</a> divider);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Merge the two triangulations into one.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mergehulls(m, b, farleft, &amp;innerleft, &amp;innerright, farright, axis);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::removeghosts(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; <a href="CppComment.htm">/*</a>b<a href="CppComment.htm">*/</a>,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; startghost<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; searchedge;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; dissolveedge;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; deadtriangle;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex markorg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> hullsize;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Removing ghost triangles.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find an edge on the convex hull to start <a href="CppPointer.htm">point</a> location from.<br/>
&nbsp;&nbsp;searchedge.lprev(*startghost);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(*startghost, searchedge);<br/>
<br/>
&nbsp;&nbsp;searchedge.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchedge);<br/>
<br/>
&nbsp;&nbsp;m.m_dummytri[0] <a href="CppOperatorAssign.htm">=</a> searchedge.m_tri[searchedge.m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri[0] <a href="CppOperatorAssign.htm">=</a> encode(searchedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remove the bounding box and count the convex hull edges.<br/>
<br/>
&nbsp;&nbsp;dissolveedge <a href="CppOperatorAssign.htm">=</a> startghost;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(*startghost, dissolveedge);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> hullsize <a href="CppOperatorAssign.htm">=</a> 1; ; <a href="CppOperatorIncrement.htm">++</a>hullsize) <a href="CppComment.htm">//</a>?Why must it start at index 1?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> hullsize <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hullsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deadtriangle.SetLnext(dissolveedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(dissolveedge, deadtriangle);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dissolveedge.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dissolveedge.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remove a bounding triangle from a convex hull triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dissolveedge.Dissolve(m_m_dummyri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dissolve(dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the next bounding triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dissolveedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(deadtriangle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(deadtriangle, dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the bounding triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, deadtriangle.m_tri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.KillTriangle(deadtriangle.m_triangles);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dissolveedge <a href="CppOperatorEqual.htm">==</a> *startghost) <b><a href="CppBreak.htm">break</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (dissolveedge <a href="CppOperatorNotEqual.htm">!=</a> *startghost);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (!otriequal(dissolveedge, *startghost));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> hullsize;<br/>
}<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::divconqdelaunay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertex *sort<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt; sort<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; hullleft;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; hullright;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> divider;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Sorting vertices.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Allocate an <a href="CppArray.htm">array</a> of <a href="CppPointer.htm">pointer</a>s to vertices <b><a href="CppFor.htm">for</a></b> sorting.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sort<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> (vertex *) trimalloc(m.invertices * (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(vertex));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppAuto.htm">auto</a></b> sort<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> m.m_invertices;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sort<a href="CppArray.htm">array</a>.resize(m.m_invertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; m.m_invertices; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;sort<a href="CppArray.htm">array</a>[i] <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Sort the vertices.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexsort(&amp;sort<a href="CppArray.htm">array</a>[0], m.m_invertices);<br/>
&nbsp;&nbsp;<a href="CppStdSort.htm">std::sort</a>(m.m_invertices.begin(),m.m_invertices.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lhs, <b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetX() &lt; rhs-&gt;GetX()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lhs-&gt;GetX() &gt; rhs-&gt;GetX()) <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lhs-&gt;GetY() &lt; rhs-&gt;GetY();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Discard duplicate vertices, which can really mess up the <a href="CppAlgorithm.htm">algorithm</a>.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 1; j &lt; m.m_invertices; j<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((sort<a href="CppArray.htm">array</a>[i][0] <a href="CppOperatorEqual.htm">==</a> sort<a href="CppArray.htm">array</a>[j][0]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (sort<a href="CppArray.htm">array</a>[i][1] <a href="CppOperatorEqual.htm">==</a> sort<a href="CppArray.htm">array</a>[j][1]))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;A duplicate vertex at ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sort<a href="CppArray.htm">array</a>[j][0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> sort<a href="CppArray.htm">array</a>[j][1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") appeared and was ignored.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort<a href="CppArray.htm">array</a>[j]-&gt;SetVertexType(VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertextype(sort<a href="CppArray.htm">array</a>[j], VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_undeads<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort<a href="CppArray.htm">array</a>[i] <a href="CppOperatorAssign.htm">=</a> sort<a href="CppArray.htm">array</a>[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;i<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_dwyer)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Re-sort the <a href="CppArray.htm">array</a> of vertices to accommodate alternating cuts.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> divider <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorMinus.htm">-</a> divider <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (divider <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternateaxes(&amp;sort<a href="CppArray.htm">array</a>[0], divider, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternateaxes(&amp;sort<a href="CppArray.htm">array</a>[divider], i <a href="CppOperatorMinus.htm">-</a> divider, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Forming triangulation.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Form the Delaunay triangulation.<br/>
&nbsp;&nbsp;divconqrecurse(m, b, &amp;sort<a href="CppArray.htm">array</a>[0], i, 0, &amp;hullleft, &amp;hullright);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDelete.htm">delete</a></b> sort<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sort<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> removeghosts(m, b, &amp;hullleft);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::boundingbox(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; inftri;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Handle <b><a href="CppFor.htm">for</a></b> the triangular bounding box.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating triangular bounding box.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the width (or height, whichever is larger) of the triangulation.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> width <a href="CppOperatorAssign.htm">=</a> m.m_xmax <a href="CppOperatorMinus.htm">-</a> m.m_xmin;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_ymax <a href="CppOperatorMinus.htm">-</a> m.m_ymin &gt; width)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;width <a href="CppOperatorAssign.htm">=</a> m.m_ymax <a href="CppOperatorMinus.htm">-</a> m.m_ymin;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (width <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;width <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the vertices of the bounding box.<br/>
&nbsp;&nbsp;m.m_infvertex1 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;(); <a href="CppComment.htm">//</a>(Vertex) TriMalloc(m.m_vertices.m_itembytes);<br/>
&nbsp;&nbsp;m.m_infvertex2 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;(); <a href="CppComment.htm">//</a>TriMalloc(m.m_vertices.m_itembytes);<br/>
&nbsp;&nbsp;m.m_infvertex3 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;(); <a href="CppComment.htm">//</a>TriMalloc(m.m_vertices.m_itembytes);<br/>
&nbsp;&nbsp;m.m_infvertex1[0] <a href="CppOperatorAssign.htm">=</a> m.m_xmin <a href="CppOperatorMinus.htm">-</a> 50.0 * width;<br/>
&nbsp;&nbsp;m.m_infvertex1[1] <a href="CppOperatorAssign.htm">=</a> m.m_ymin <a href="CppOperatorMinus.htm">-</a> 40.0 * width;<br/>
&nbsp;&nbsp;m.m_infvertex2[0] <a href="CppOperatorAssign.htm">=</a> m.m_xmax <a href="CppOperatorPlus.htm">+</a> 50.0 * width;<br/>
&nbsp;&nbsp;m.m_infvertex2[1] <a href="CppOperatorAssign.htm">=</a> m.m_ymin <a href="CppOperatorMinus.htm">-</a> 40.0 * width;<br/>
&nbsp;&nbsp;m.m_infvertex3[0] <a href="CppOperatorAssign.htm">=</a> 0.5 * (m.m_xmin <a href="CppOperatorPlus.htm">+</a> m.m_xmax);<br/>
&nbsp;&nbsp;m.m_infvertex3[1] <a href="CppOperatorAssign.htm">=</a> m.m_ymax <a href="CppOperatorPlus.htm">+</a> 60.0 * width;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the bounding box.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> inftri <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;inftri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;inftri);<br/>
<br/>
&nbsp;&nbsp;inftri.SetOrigin(m.m_infvertex1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(inftri, m.m_infvertex1);<br/>
<br/>
&nbsp;&nbsp;inftri.SetDest(m.m_infvertex2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/setdest(inftri, m.m_infvertex2);<br/>
<br/>
&nbsp;&nbsp;inftri.SetApex(m.m_infvertex3);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(inftri, m.m_infvertex3);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppLink.htm">Link</a> dummytri to the bounding box so we can always find an<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge to begin searching (<a href="CppPointer.htm">point</a> location) from.<br/>
&nbsp;&nbsp;m.m_dummytri[0] <a href="CppOperatorAssign.htm">=</a> inftri.m_triangles;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printtriangle(m, b, &amp;inftri);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::removebox(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri deadtriangle;<br/>
&nbsp;&nbsp;Otri searchedge;<br/>
&nbsp;&nbsp;Otri checkedge;<br/>
&nbsp;&nbsp;Otri nextedge, <b><a href="CppFinal.htm">final</a></b>edge, dissolveedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex markorg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> hullsize;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Removing triangular bounding box.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a boundary triangle.<br/>
&nbsp;&nbsp;nextedge.m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;nextedge.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;nextedge.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(nextedge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark a place to stop.<br/>
&nbsp;&nbsp;<b><a href="CppFinal.htm">final</a></b>edge.lprev(nextedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(nextedge, <b><a href="CppFinal.htm">final</a></b>edge);<br/>
<br/>
&nbsp;&nbsp;nextedge.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(nextedge);<br/>
<br/>
&nbsp;&nbsp;nextedge.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(nextedge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle (on the boundary of the vertex set) that isn't<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;a bounding box triangle.<br/>
&nbsp;&nbsp;searchedge.Lprev(nextedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(nextedge, searchedge);<br/>
<br/>
&nbsp;&nbsp;searchedge.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchedge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether nextedge is another boundary triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent to the first one.<br/>
&nbsp;&nbsp;checkedge.SetLnext(nextedge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(nextedge, checkedge);<br/>
<br/>
&nbsp;&nbsp;checkedge.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(checkedge);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkedge.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Go on to the next triangle.&nbsp;&nbsp;There are only three boundary<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangles, and <b><a href="CppThis.htm">this</a></b> next triangle cannot be the third one,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;so it's safe to stop here.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchedge.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(searchedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchedge.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchedge);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a <b><a href="CppNew.htm">new</a></b> boundary edge to search from, as the current search<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge lies on a bounding box triangle and will be deleted.<br/>
&nbsp;&nbsp;m.m_dummytri[0] <a href="CppOperatorAssign.htm">=</a> searchedge.m_tri[searchedge.m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_dummytri[0] <a href="CppOperatorAssign.htm">=</a> encode(searchedge);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>hullsize <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>2l;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> hullsize <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1; ; <a href="CppOperatorIncrement.htm">++</a>hullsize) <a href="CppComment.htm">//</a>?Why start at <a href="CppOperatorMinus.htm">-</a>1?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> hullsize <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1; nextedge <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppFinal.htm">final</a></b>edge; <a href="CppOperatorIncrement.htm">++</a>hullsize) <a href="CppComment.htm">//</a>?Why start at <a href="CppOperatorMinus.htm">-</a>1?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (nextedge <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppFinal.htm">final</a></b>edge)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (!otriequal(nextedge, <b><a href="CppFinal.htm">final</a></b>edge))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextedge <a href="CppOperatorEqual.htm">==</a> <b><a href="CppFinal.htm">final</a></b>edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangledealloc(m, <b><a href="CppFinal.htm">final</a></b>edge.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> m.m_infvertex1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_infvertex1 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> m.m_infvertex2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_infvertex2 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> m.m_infvertex3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_infvertex3 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> hullsize;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hullsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dissolveedge.Lprev(nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(nextedge, dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dissolveedge.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If not <b><a href="CppUsing.htm">using</a></b> a PSLG, the vertices should be marked now.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(If <b><a href="CppUsing.htm">using</a></b> a PSLG, markhull() will <b><a href="CppDo.htm">do</a></b> the job.)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Disconnect the bounding box triangle from the mesh triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dissolveedge.Dissolve(m_m_dummyri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dissolve(dissolveedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deadtriangle.SetLnext(nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(nextedge, deadtriangle);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nextedge <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(deadtriangle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(deadtriangle, nextedge);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Get rid of the bounding box triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangledealloc(m, deadtriangle.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Do we need to turn the corner?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextedge.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Turn the corner.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextedge <a href="CppOperatorAssign.htm">=</a> dissolveedge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(dissolveedge, nextedge);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;triangledealloc(m, <b><a href="CppFinal.htm">final</a></b>edge.m_triangles);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> m.m_infvertex1;<br/>
&nbsp;&nbsp;m.m_infvertex1 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> m.m_infvertex2;<br/>
&nbsp;&nbsp;m.m_infvertex2 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> m.m_infvertex3;<br/>
&nbsp;&nbsp;m.m_infvertex3 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> hullsize;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::incrementaldelaunay(Mesh&amp; m,<b><a href="CppConst.htm">const</a></b> Arguments&amp; b)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri starttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex vertexloop;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a triangular bounding box.<br/>
&nbsp;&nbsp;boundingbox(m, b);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Incrementally inserting vertices.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (vertexloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> vertexloop: m.m_vertices)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Otri starttri.m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (insertvertex(m, b, vertexloop, &amp;starttri, <b><a href="CppNullptr.htm">nullptr</a></b>, 0, 0) <a href="CppOperatorEqual.htm">==</a> DUPLICATEVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;A duplicate vertex at (" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop[0]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop[1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") appeared and was ignored.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertextype(vertexloop, VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_undeads<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remove the bounding box.<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> removebox(m, b);<br/>
}<br/>
<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::createeventheap(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;Event *** eventheap,<br/>
&nbsp;&nbsp;Event ** events,<br/>
&nbsp;&nbsp;Event ** freeevents<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_m_invertices <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m.m_invertices.size());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex <b><a href="CppThis.htm">this</a></b>vertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> maxevents;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> maxevents <a href="CppOperatorAssign.htm">=</a> (3 * m_m_invertices) <a href="CppOperatorDivide.htm">/</a> 2;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdVector.htm">std::vector</a>&lt;Event<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> eventheap(maxevents);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*eventheap <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> Event **) TriMalloc(maxevents *<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppStruct.htm">struct</a></b> Event *));<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Event&gt; events(maxevents);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*events <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> Event *) TriMalloc(maxevents * (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppStruct.htm">struct</a></b> Event));<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m_m_invertices; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; m.m_invertices; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppThis.htm">this</a></b>vertex <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> <b><a href="CppThis.htm">this</a></b>vertex <a href="CppOperatorAssign.htm">=</a> m.m_invertices[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;events[i].m_eventptr <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>vertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(*events)[i].m_eventptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *) <b><a href="CppThis.htm">this</a></b>vertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;events[i].m_xkey <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>vertex-&gt;GetX();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(*events)[i].m_xkey <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>vertex[0];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;events[i].m_ykey <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>vertex-&gt;GetY();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>(*events)[i].m_ykey <a href="CppOperatorAssign.htm">=</a> <b><a href="CppThis.htm">this</a></b>vertex[1];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eventheapinsert(*eventheap, i, *events <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;*freeevents <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;<b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> maxevents <a href="CppOperatorMinus.htm">-</a> 1; i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m.m_invertices; i<a href="CppOperatorDecrement.htm">--</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*events)[i].m_eventptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *) *freeevents;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*freeevents <a href="CppOperatorAssign.htm">=</a> *events <a href="CppOperatorPlus.htm">+</a> i;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::rightofhyperbola(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b>&amp; m_m_hyperbolacount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> fronttri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; newsite<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>m_m_hyperbolacount;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> fronttri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(*fronttri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> fronttri-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(*fronttri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( leftvertex-&gt;GetY() &lt; rightvertex-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> (leftvertex-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> rightvertex-&gt;GetY() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> leftvertex-&gt;GetX() &lt; rightvertex-&gt;GetX())<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newsite-&gt;GetX() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> rightvertex-&gt;GetX()) { <b><a href="CppReturn.htm">return</a></b> <b><a href="CppTrue.htm">true</a></b>; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newsite[0] <a href="CppOperatorLessEqual.htm">&lt;=</a> leftvertex[0]) { <b><a href="CppReturn.htm">return</a></b> <b><a href="CppFalse.htm">false</a></b>; }<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxa <a href="CppOperatorAssign.htm">=</a> leftvertex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> newsite-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dya <a href="CppOperatorAssign.htm">=</a> leftvertex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> newsite-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dxb <a href="CppOperatorAssign.htm">=</a> rightvertex-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> newsite-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> dyb <a href="CppOperatorAssign.htm">=</a> rightvertex-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> newsite-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> dya * (dxb * dxb <a href="CppOperatorPlus.htm">+</a> dyb * dyb) &gt; dyb * (dxa * dxa <a href="CppOperatorPlus.htm">+</a> dya * dya);<br/>
}<br/>
<br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::circletop(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> ccwabc<br/>
)<br/>
{<br/>
&nbsp;&nbsp;m.m_circletopcount<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> xac <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> yac <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> xbc <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ybc <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> xab <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pb-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> yab <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pb-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> aclen2 <a href="CppOperatorAssign.htm">=</a> xac * xac <a href="CppOperatorPlus.htm">+</a> yac * yac;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bclen2 <a href="CppOperatorAssign.htm">=</a> xbc * xbc <a href="CppOperatorPlus.htm">+</a> ybc * ybc;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ablen2 <a href="CppOperatorAssign.htm">=</a> xab * xab <a href="CppOperatorPlus.htm">+</a> yab * yab;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> pc-&gt;GetY() <a href="CppOperatorPlus.htm">+</a> (xac * bclen2 <a href="CppOperatorMinus.htm">-</a> xbc * aclen2 <a href="CppOperatorPlus.htm">+</a> sqrt(aclen2 * bclen2 * ablen2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorDivide.htm">/</a> (2.0 * ccwabc);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::check4deadevent(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> checktri,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Event ** <b><a href="CppConst.htm">const</a></b> freeevents,<br/>
&nbsp;&nbsp;Event ** <b><a href="CppConst.htm">const</a></b> eventheap,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> * <b><a href="CppConst.htm">const</a></b> heapsize<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex eventvertex <a href="CppOperatorAssign.htm">=</a> checktri-&gt;GetOrigon();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(*checktri, eventvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (eventvertex <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Event * deadevent <a href="CppOperatorAssign.htm">=</a> (Event *) eventvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> eventnum <a href="CppOperatorAssign.htm">=</a> deadevent-&gt;m_heapposition;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deadevent-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *) *freeevents;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*freeevents <a href="CppOperatorAssign.htm">=</a> deadevent;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eventheapdelete(eventheap, *heapsize, eventnum);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(*heapsize)<a href="CppOperatorDecrement.htm">--</a>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checktri-&gt;SetOrigin(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(*checktri,<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::SplayNode&gt; <a href="CppRibi.htm">ribi</a>::tricpp::splay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt;&amp; splaytree,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a>,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; searchtri<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!splaytree)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; no_splay_node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> no_splay_node;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; child;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; grandchild;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; lefttree;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; righttree;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; leftright;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> splaytree-&gt;m_keyedge-&gt;GetDest();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(splaytree-&gt;m_keyedge, checkvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkvertex <a href="CppOperatorEqual.htm">==</a> splaytree-&gt;m_keydest)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rightofroot <a href="CppOperatorAssign.htm">=</a> rightofhyperbola(m, &amp;splaytree-&gt;m_keyedge, search<a href="CppPointer.htm">point</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofroot)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*searchtri <a href="CppOperatorAssign.htm">=</a> splaytree-&gt;m_keyedge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(splaytree-&gt;m_keyedge, *searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child <a href="CppOperatorAssign.htm">=</a> splaytree-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child <a href="CppOperatorAssign.htm">=</a> splaytree-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!child)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkvertex <a href="CppOperatorAssign.htm">=</a> child-&gt;m_keyedge-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(child-&gt;m_keyedge, checkvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkvertex <a href="CppOperatorNotEqual.htm">!=</a> child-&gt;m_keydest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child <a href="CppOperatorAssign.htm">=</a> splay(m, child, search<a href="CppPointer.htm">point</a>, searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!child)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofroot)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> rightofchild <a href="CppOperatorAssign.htm">=</a> rightofhyperbola(m, &amp;child-&gt;m_keyedge, search<a href="CppPointer.htm">point</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofchild)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> child-&gt;m_keyedge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(child-&gt;m_keyedge, *searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandchild <a href="CppOperatorAssign.htm">=</a> splay(m, child-&gt;m_rchild, search<a href="CppPointer.htm">point</a>, searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> grandchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandchild <a href="CppOperatorAssign.htm">=</a> splay(m, child-&gt;m_lchild, search<a href="CppPointer.htm">point</a>, searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> grandchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!grandchild)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofroot)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> child-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> child-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> child;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofchild)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofroot)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> child-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> grandchild-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandchild-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> grandchild-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandchild-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> child;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (rightofroot)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> grandchild-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandchild-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splaytree-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> child-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> splaytree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> grandchild-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandchild-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> child;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> grandchild;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;lefttree <a href="CppOperatorAssign.htm">=</a> splay(m, splaytree-&gt;m_lchild, search<a href="CppPointer.htm">point</a>, searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;righttree <a href="CppOperatorAssign.htm">=</a> splay(m, splaytree-&gt;m_rchild, search<a href="CppPointer.htm">point</a>, searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PoolDealloc(m.m_splaynodes,splaytree);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!lefttree)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> righttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (!righttree)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lefttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (!lefttree-&gt;m_rchild)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttree-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> righttree-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttree-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> lefttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> righttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (!righttree-&gt;m_lchild)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttree-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> lefttree-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttree-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> righttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lefttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftright <a href="CppOperatorAssign.htm">=</a> lefttree-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (leftright-&gt;m_rchild)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftright <a href="CppOperatorAssign.htm">=</a> leftright-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftright-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> righttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> lefttree;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::SplayNode&gt; <a href="CppRibi.htm">ribi</a>::tricpp::splayinsert(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splayroot,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; newkey,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; search<a href="CppPointer.htm">point</a><br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SplayNode *newsplaynode;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SplayNode *newsplaynode <a href="CppOperatorAssign.htm">=</a> (SplayNode *) PoolAlloc(&amp;m.m_splaynodes);<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; newsplaynode(<b><a href="CppNew.htm">new</a></b> SplayNode);<br/>
<br/>
&nbsp;&nbsp;newsplaynode-&gt;m_keyedge <a href="CppOperatorAssign.htm">=</a> newkey;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(*newkey, newsplaynode-&gt;m_keyedge);<br/>
<br/>
&nbsp;&nbsp;newsplaynode-&gt;m_keydest <a href="CppOperatorAssign.htm">=</a> newkey-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*newkey, newsplaynode-&gt;m_keydest);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (splayroot <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsplaynode-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsplaynode-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (rightofhyperbola(m, &amp;splayroot-&gt;m_keyedge, search<a href="CppPointer.htm">point</a>))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsplaynode-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> splayroot;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsplaynode-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> splayroot-&gt;m_rchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;splayroot-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsplaynode-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> splayroot-&gt;m_lchild;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newsplaynode-&gt;m_rchild <a href="CppOperatorAssign.htm">=</a> splayroot;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;splayroot-&gt;m_lchild <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newsplaynode;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::SplayNode&gt; <a href="CppRibi.htm">ribi</a>::tricpp::circletopinsert(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splayroot,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; newkey,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pa,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pb,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; pc,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> topy<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ccwabc;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> xac, yac, xbc, ybc;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> aclen2, bclen2;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> search<a href="CppPointer.htm">point</a>[2];<br/>
&nbsp;&nbsp;Otri dummytri;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> ccwabc <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, pa, pb, pc);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> xac <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> yac <a href="CppOperatorAssign.htm">=</a> pa-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> xbc <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> ybc <a href="CppOperatorAssign.htm">=</a> pb-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> pc-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> aclen2 <a href="CppOperatorAssign.htm">=</a> xac * xac <a href="CppOperatorPlus.htm">+</a> yac * yac;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> bclen2 <a href="CppOperatorAssign.htm">=</a> xbc * xbc <a href="CppOperatorPlus.htm">+</a> ybc * ybc;<br/>
&nbsp;&nbsp;search<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorAssign.htm">=</a> pc-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> (yac * bclen2 <a href="CppOperatorMinus.htm">-</a> ybc * aclen2) <a href="CppOperatorDivide.htm">/</a> (2.0 * ccwabc);<br/>
&nbsp;&nbsp;search<a href="CppPointer.htm">point</a>[1] <a href="CppOperatorAssign.htm">=</a> topy;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> splayinsert(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;splay(m, splayroot,search<a href="CppPointer.htm">point</a>, &amp;dummytri),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newkey,search<a href="CppPointer.htm">point</a><br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::SplayNode * <a href="CppRibi.htm">ribi</a>::tricpp::frontlocate(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;SplayNode * splayroot,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> bottommost,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; searchvertex,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> * <b><a href="CppConst.htm">const</a></b> farright<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> farrightflag;<br/>
&nbsp;&nbsp;Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by onext().<br/>
<br/>
&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> bottommost;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(*bottommost, *searchtri);<br/>
<br/>
&nbsp;&nbsp;splayroot <a href="CppOperatorAssign.htm">=</a> splay(m, splayroot, searchvertex, searchtri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> farrightflag <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (!farrightflag <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rightofhyperbola(m, searchtri, searchvertex))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Onextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onextself(*searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;farrightflag <a href="CppOperatorAssign.htm">=</a> *searchtri <a href="CppOperatorEqual.htm">==</a> *bottommost;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>farrightflag <a href="CppOperatorAssign.htm">=</a> otriequal(*searchtri, *bottommost);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;*farright <a href="CppOperatorAssign.htm">=</a> farrightflag;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> splayroot;<br/>
}<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::sweeplinedelaunay(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Event **eventheap;<br/>
&nbsp;&nbsp;Event *events;<br/>
&nbsp;&nbsp;Event *freeevents;<br/>
&nbsp;&nbsp;Event *nextevent;<br/>
&nbsp;&nbsp;Event *newevent;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SplayNode *splayroot;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SplayNode&gt; splayroot;<br/>
&nbsp;&nbsp;Otri bottommost;<br/>
&nbsp;&nbsp;Otri searchtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri fliptri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri lefttri, righttri, farlefttri,<br/>
&nbsp;&nbsp;Otri farrighttri;<br/>
&nbsp;&nbsp;Otri inserttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex firstvertex, secondvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex nextvertex, lastvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex connectvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex leftvertex, midvertex, rightvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> lefttest, righttest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> heapsize;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> check4events, farrightflag;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym(), onext(), and oprev().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>PoolInit(&amp;m.m_splaynodes, <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppStruct.htm">struct</a></b> SplayNode), SPLAYNODEPERBLOCK,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPLAYNODEPERBLOCK, 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>splayroot <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Placing vertices in event heap.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;createeventheap(m, &amp;eventheap, &amp;events, &amp;freeevents);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> heapsize <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m.m_vertices.size());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>heapsize <a href="CppOperatorAssign.htm">=</a> m.m_invertices;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Forming triangulation.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lefttri <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;lefttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;lefttri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> righttri <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;righttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;righttri);<br/>
<br/>
&nbsp;&nbsp;Bond(lefttri, righttri);<br/>
<br/>
&nbsp;&nbsp;lefttri.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(lefttri);<br/>
<br/>
&nbsp;&nbsp;righttri.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(righttri);<br/>
<br/>
&nbsp;&nbsp;Bond(lefttri, righttri);<br/>
<br/>
&nbsp;&nbsp;lefttri.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(lefttri);<br/>
<br/>
&nbsp;&nbsp;righttri.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(righttri);<br/>
<br/>
&nbsp;&nbsp;Bond(lefttri, righttri);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> firstvertex <a href="CppOperatorAssign.htm">=</a> eventheap[0]-&gt;m_eventptr;<br/>
&nbsp;&nbsp;eventheap[0]-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> freeevents;<br/>
&nbsp;&nbsp;freeevents <a href="CppOperatorAssign.htm">=</a> eventheap[0];<br/>
&nbsp;&nbsp;eventheapdelete(eventheap, heapsize, 0);<br/>
&nbsp;&nbsp;<a href="CppOperatorDecrement.htm">--</a>heapsize;<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (heapsize <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdRuntime_error.htm">std::runtime_error</a>("Triangle: Input vertices are all identical");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> secondvertex <a href="CppOperatorAssign.htm">=</a> eventheap[0]-&gt;m_eventptr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eventheap[0]-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> freeevents;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;freeevents <a href="CppOperatorAssign.htm">=</a> eventheap[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eventheapdelete(eventheap, heapsize, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorDecrement.htm">--</a>heapsize;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (firstvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> secondvertex-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> firstvertex-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> secondvertex-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;A duplicate vertex at (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) appeared and was ignored.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondvertex[0],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondvertex[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondvertex.SetVertexType(VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertextype(secondvertex, VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_undeads<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ((firstvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> secondvertex-&gt;GetX()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (firstvertex-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> secondvertex-&gt;GetY()));<br/>
<br/>
&nbsp;&nbsp;lefttri.SetOrigin(firstvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(lefttri, firstvertex);<br/>
<br/>
&nbsp;&nbsp;lefttri.SetDest(secondvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(lefttri, secondvertex);<br/>
<br/>
&nbsp;&nbsp;righttri.SetOrigin(secondvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(righttri, secondvertex);<br/>
<br/>
&nbsp;&nbsp;righttri.SetDest(firstvertex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(righttri, firstvertex);<br/>
<br/>
&nbsp;&nbsp;bottommost.Lprev(lefttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(lefttri, bottommost);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lastvertex <a href="CppOperatorAssign.htm">=</a> secondvertex;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (heapsize &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nextevent <a href="CppOperatorAssign.htm">=</a> eventheap[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eventheapdelete(eventheap, heapsize, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;heapsize<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;check4events <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextevent-&gt;m_xkey &lt; m.m_xmin)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> fliptri <a href="CppOperatorAssign.htm">=</a> nextevent-&gt;m_eventptr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nextevent-&gt;m_eventptr, fliptri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farlefttri.Oprev(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(fliptri, farlefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check4deadevent(&amp;farlefttri, &amp;freeevents, eventheap, &amp;heapsize);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farrighttri.Onext(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(fliptri, farrighttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check4deadevent(&amp;farrighttri, &amp;freeevents, eventheap, &amp;heapsize);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (farlefttri <a href="CppOperatorEqual.htm">==</a> bottommost)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (otriequal(farlefttri, bottommost))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottommost.Lprev(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(fliptri, bottommost);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flip(m, b, &amp;fliptri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fliptri.SetApex(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(fliptri, <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttri.Lprev(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(fliptri, lefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttri.Lnext(fliptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(fliptri, righttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farlefttri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(lefttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(lefttri, farlefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> SAMPLERATE <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fliptri.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(fliptri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> fliptri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(fliptri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> midvertex <a href="CppOperatorAssign.htm">=</a> fliptri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(fliptri, midvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> fliptri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(fliptri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splayroot<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> circletopinsert(m, b, splayroot, &amp;lefttri, leftvertex, midvertex, rightvertex, nextevent-&gt;m_ykey);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nextvertex <a href="CppOperatorAssign.htm">=</a> nextevent-&gt;m_eventptr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (nextvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> lastvertex-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> nextvertex-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> lastvertex-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Warning:&nbsp;&nbsp;A duplicate vertex at (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) appeared and was ignored.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextvertex[0],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextvertex[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertextype(nextvertex, VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_undeads<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check4events <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastvertex <a href="CppOperatorAssign.htm">=</a> nextvertex;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splayroot <a href="CppOperatorAssign.htm">=</a> frontlocate(m, splayroot, &amp;bottommost, nextvertex,&amp;searchtri, &amp;farrightflag);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check4deadevent(&amp;searchtri, &amp;freeevents, eventheap, &amp;heapsize);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farrighttri <a href="CppOperatorAssign.htm">=</a> searchtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(searchtri, farrighttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farlefttri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(searchtri, farlefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lefttri <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;lefttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;lefttri);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> righttri <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m.m_dummytri,m.m_dummysub,m.m_eextras,b.m_vararea,&amp;righttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;righttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> connectvertex <a href="CppOperatorAssign.htm">=</a> farrighttri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(farrighttri, connectvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttri.SetOrigin(connectvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(lefttri, connectvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttri.SetDest(nextvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(lefttri, nextvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttri.SetOrigin(nextvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(righttri, nextvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttri.SetDest(connectvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(righttri, connectvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(lefttri, righttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(lefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttri.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(righttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(lefttri, righttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(lefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;righttri.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(righttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(lefttri, farlefttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(righttri, farrighttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!farrightflag <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> farrighttri <a href="CppOperatorEqual.htm">==</a> bottommost)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!farrightflag <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> otriequal(farrighttri, bottommost))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottommost <a href="CppOperatorAssign.htm">=</a> lefttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(lefttri, bottommost);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> SAMPLERATE <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splayroot <a href="CppOperatorAssign.htm">=</a> splayinsert(m, splayroot, &amp;lefttri, nextvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (<a href="CppStdRand.htm">std::rand</a>() <a href="CppOperatorModulus.htm">%</a> SAMPLERATE <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inserttri.SetLnext(righttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(righttri, inserttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splayroot <a href="CppOperatorAssign.htm">=</a> splayinsert(m, splayroot, &amp;inserttri, nextvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nextevent-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> freeevents;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;freeevents <a href="CppOperatorAssign.htm">=</a> nextevent;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (check4events)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> farlefttri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(farlefttri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> midvertex <a href="CppOperatorAssign.htm">=</a> lefttri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(lefttri, midvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> lefttri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(lefttri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lefttest <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, leftvertex, midvertex, rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (lefttest &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent <a href="CppOperatorAssign.htm">=</a> freeevents;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeevents <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> Event *) freeevents-&gt;m_eventptr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent-&gt;m_xkey <a href="CppOperatorAssign.htm">=</a> m.m_xminextreme;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent-&gt;m_ykey <a href="CppOperatorAssign.htm">=</a> circletop(m, leftvertex, midvertex, rightvertex,lefttest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> lefttri.m_tri[lefttri.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>newevent-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> encode(lefttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventheapinsert(eventheap, heapsize, newevent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefttri.SetOrigin(newevent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(lefttri, newevent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> leftvertex <a href="CppOperatorAssign.htm">=</a> righttri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(righttri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> midvertex <a href="CppOperatorAssign.htm">=</a> righttri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(righttri, midvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> rightvertex <a href="CppOperatorAssign.htm">=</a> farrighttri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(farrighttri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> righttest <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, leftvertex, midvertex, rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (righttest &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent <a href="CppOperatorAssign.htm">=</a> freeevents;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeevents <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> Event *) freeevents-&gt;m_eventptr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent-&gt;m_xkey <a href="CppOperatorAssign.htm">=</a> m.m_xminextreme;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent-&gt;m_ykey <a href="CppOperatorAssign.htm">=</a> circletop(m, leftvertex, midvertex, rightvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; righttest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newevent-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> farrighttri.m_tri[farrighttri.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>newevent-&gt;m_eventptr <a href="CppOperatorAssign.htm">=</a> encode(farrighttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventheapinsert(eventheap, heapsize, newevent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;farrighttri.SetOrigin(newevent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(farrighttri, newevent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;PoolDeinit(&amp;m.m_splaynodes);<br/>
<br/>
&nbsp;&nbsp;bottommost.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(bottommost);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> removeghosts(m, b, &amp;bottommost);<br/>
}<br/>
<br/>
<b><a href="CppLong.htm">long</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::delaunay(Mesh&amp; m,<b><a href="CppConst.htm">const</a></b> Arguments&amp; b)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> hulledges;<br/>
<br/>
&nbsp;&nbsp;m.m_eextras <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppInitialize.htm">initialize</a>trisubpools(m, b);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppConstructor.htm">Construct</a>ing Delaunay triangulation ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_incremental) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "by incremental <a href="CppMemberFunction.htm">member function</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (b.m_sweepline) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "by sweepline <a href="CppMemberFunction.htm">member function</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "by divide-and-conquer <a href="CppMemberFunction.htm">member function</a>.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_incremental)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> hulledges <a href="CppOperatorAssign.htm">=</a> incrementaldelaunay(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m.m_triangles.m_items <a href="CppOperatorEqual.htm">==</a> 0 ? 0 : hulledges;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (b.m_sweepline)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> hulledges <a href="CppOperatorAssign.htm">=</a> sweeplinedelaunay(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m.m_triangles.m_items <a href="CppOperatorEqual.htm">==</a> 0 ? 0 : hulledges;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> hulledges <a href="CppOperatorAssign.htm">=</a> divconqdelaunay(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m.m_triangles.m_items <a href="CppOperatorEqual.htm">==</a> 0 ? 0 : hulledges;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_triangles.m_items <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The input vertices were all collinear, so there are no triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> hulledges;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;SubSeg<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::tricpp::ReadEdges(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; elefilename,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; areafilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> polyfile<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *elefile;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *areafile;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppChar.htm">char</a></b> inputline[g_max_inputline_size];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppChar.htm">char</a></b> *stringptr;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> areaelements;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleleft;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri checktri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri checkleft;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri checkneighbor;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub subsegloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;Triangle&gt; vertex<a href="CppArray.htm">array</a>; <a href="CppComment.htm">//</a>?Why not a vector of Vertex then?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle *vertex<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle *prev<a href="CppLink.htm">link</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle nexttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex tdest, tapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex checkdest, checkapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex shorg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex segmentorg, segmentdest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> area;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> corner[3];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> end[2];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> killvertexindex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> incorners;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> segmentmarkers;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> boundmarker;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> aroundvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> hullsize;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> notfound;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> i, i;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> i, j;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the triangles from an .ele file.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>elefile <a href="CppOperatorAssign.htm">=</a> fopen(elefilename.c_str(), "r");<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppFileToVector.htm">FileToVector</a>(elefilename);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_triangles <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_corners <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_extras <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!v.empty());<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(v[0],' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n_triangles <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n_corners&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;n_extras&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[2]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_corners <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_extras <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_triangles <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdIfstream.htm">std::ifstream</a> elefile(elefilename.c_str());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (elefile <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Cannot access file '" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elefilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "'";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdRuntime_error.htm">std::runtime_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read number of triangles, number of vertices per triangle, and<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;number of triangle attributes from .ele file.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, elefile);<br/>
&nbsp;&nbsp;m.m_inelements <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;incorners <a href="CppOperatorAssign.htm">=</a> 3;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;incorners <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (incorners &lt; 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Triangles in " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elefilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " must have at least 3 vertices";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_eextras <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_eextras <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppInitialize.htm">initialize</a>trisubpools(m, b);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the triangles.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_inelements; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Triangle triangle;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;m.m_triangles.push_back(triangle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>triangle(m, b, &amp;triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the triangle as living.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_tri[3] <a href="CppOperatorAssign.htm">=</a> (Triangle) triangleloop.m_tri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>segmentmarkers <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read number of segments and number of segment<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;boundary markers from .poly file.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_segments <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> n_segment_markers <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> line_number <a href="CppOperatorAssign.htm">=</a> n_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> line_number <a href="CppOperatorAssign.htm">=</a> m.m_inelements;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> lines <a href="CppOperatorAssign.htm">=</a> <a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppFileToVector.htm">FileToVector</a>(polyfile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a> first_line <a href="CppOperatorAssign.htm">=</a> lines[0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> w <a href="CppOperatorAssign.htm">=</a> Helper().<a href="CppSeperateString.htm">SeperateString</a>(first_line,' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!w.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_segments <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (w.size() <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_segment_markers <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_segments <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_segment_markers <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_insegments <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorNotEqual.htm">!=</a> '\0')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segmentmarkers <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_segments <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the subsegments.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> n_segments; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_insegments; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> subsegloop <a href="CppOperatorAssign.htm">=</a> <a href="CppMake.htm">make</a>subseg(m.m_dummytri,m.m_dummysub);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>subseg(m.m_dummytri,m.m_dummysub,&amp;subsegloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMake.htm">make</a>subseg(m, &amp;subsegloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the subsegment as living.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subsegloop-&gt;m_subsegs[2] <a href="CppOperatorAssign.htm">=</a> (SubSeg) subsegloop-&gt;m_subsegs;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> SUPPORT_AREA_<a href="CppCfile.htm">FILE</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Open an .area file, check <b><a href="CppFor.htm">for</a></b> consistency with the .ele file.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;areafile <a href="CppOperatorAssign.htm">=</a> fopen(areafilename.c_str(), "r");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (areafile <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Cannot access file "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> areafilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdRuntime_error.htm">std::runtime_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, areafile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;areaelements <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (areaelements <a href="CppOperatorNotEqual.htm">!=</a> m.m_inelements) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elefilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> areafilename<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " disagree on number of triangles"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdRuntime_error.htm">std::runtime_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Re<a href="CppConstructor.htm">construct</a>ing mesh.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Allocate a temporary <a href="CppArray.htm">array</a> that maps each vertex to some adjacent<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangle.&nbsp;&nbsp;I took care to allocate all the permanent <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangles and subsegments first.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertex<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> (Triangle *) TriMalloc(m.m_vertices.m_items * (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle));<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertex<a href="CppArray.htm">array</a>-&gt;resize(n_vertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Each vertex is initially unrepresented.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b>&amp; v: vertex<a href="CppArray.htm">array</a>) { v <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;(); }<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; m.m_vertices.m_items; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertex<a href="CppArray.htm">array</a>[i] <a href="CppOperatorAssign.htm">=</a> (Triangle) m.m_dummytri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity)<br/>
&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Assembling triangles.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the triangles from the .ele file, and <a href="CppLink.htm">link</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;together those that share an edge.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>i <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_triangles; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read triangle number and the triangle's three corners.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 <a href="CppOperatorPlus.htm">+</a> i, <a href="CppComment.htm">//</a>+1 to skip the header line<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 3 <a href="CppOperatorPlus.htm">+</a> n_extras);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdArray.htm">std::array</a>&lt;<b><a href="CppInt.htm">int</a></b>,3&gt; corners; <a href="CppComment.htm">//</a>Vertex indices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;corners[0] <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;corners[1] <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;corners[2] <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, elefile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Triangle "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " is missing vertex "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (j <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " in " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elefilename;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corner[j] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (corner[j] &lt; b.m_firstnumber <a href="CppOperatorLogicalOr.htm">||</a> corner[j] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> m.m_invertices)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Triangle " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " has an invalid vertex index";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find out <a href="CppAbout.htm">about</a> (and <b><a href="CppThrow.htm">throw</a></b> away) extra nodes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 3; j &lt; incorners; j<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorNotEqual.htm">!=</a> '\0')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killvertexindex <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (killvertexindex <a href="CppOperatorGreaterEqual.htm">&gt;=</a> b.m_firstnumber <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> killvertexindex &lt; b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> m.m_invertices)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete the non-corner vertex <b><a href="CppIf.htm">if</a></b> it's not already deleted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillVertex(killvertexindex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b>&amp; killvertex <a href="CppOperatorAssign.htm">=</a> m.GetVertex(killvertexindex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (vertextype(killvertex) <a href="CppOperatorNotEqual.htm">!=</a> VertexType::DEADVERTEX) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertexdealloc(m, killvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; elem_attribs;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; n_extras; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> elem_attrib <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(w[3 <a href="CppOperatorPlus.htm">+</a> i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem_attribs.push_back(elem_attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the triangle's attributes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j <a href="CppOperatorNotEqual.htm">!=</a> m.m_eextras; <a href="CppOperatorIncrement.htm">++</a>j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;SetElemAttrib(j,0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(triangleloop, j, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;SetElemAttrib(j,strtod(stringptr, &amp;stringptr));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(triangleloop, j,strtod(stringptr, &amp;stringptr));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> SUPPORT_VARAREA_20140527<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read an area constraint from the .area file.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, areafile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>No constraint on <b><a href="CppThis.htm">this</a></b> triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;area <a href="CppOperatorAssign.htm">=</a> strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;SetAreaBound(area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(triangleloop, area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triangle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[0],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[2],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem_attribs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(triangle-&gt;GetOrient() <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(triangle-&gt;GetOrigin() <a href="CppOperatorEqual.htm">==</a> vertices[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(triangle-&gt;GetDest() <a href="CppOperatorEqual.htm">==</a> vertices[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(triangle-&gt;GetApex() <a href="CppOperatorEqual.htm">==</a> vertices[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(triangle-&gt;GetElemAttribs()<a href="CppOperatorEqual.htm">==</a> elem_attribs);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Inform the vertices that a Triangle uses them<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices[0]-&gt;<a href="CppAdd.htm">Add</a>Triangle(triangle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices[1]-&gt;<a href="CppAdd.htm">Add</a>Triangle(triangle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices[2]-&gt;<a href="CppAdd.htm">Add</a>Triangle(triangle);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the triangle's vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangle-&gt;SetOrient(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangle-&gt;SetOrigin(vertices[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop-&gt;SetOrigin(getvertex(m.m_vertices, b, corner[0]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setorg(triangleloop, getvertex(m.m_vertices, b, corner[0]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangle-&gt;SetDest(vertices[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop-&gt;SetDest(getvertex(m.m_vertices, b, corner[1]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setdest(triangleloop, getvertex(m.m_vertices, b, corner[1]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangle-&gt;SetApex(vertices[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop-&gt;SetApex(getvertex(m.m_vertices, b, corner[2]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setapex(triangleloop, getvertex(m.m_vertices, b, corner[2]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangle-&gt;PushElemAttrib(elem_attrib);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangles.push_back(triangle);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_triangles; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Try <a href="CppLink.htm">link</a>ing the triangle to others that share these vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient <a href="CppOperatorNotEqual.htm">!=</a> 3; <a href="CppOperatorIncrement.htm">++</a>triangleloop-&gt;m_orient)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> orientation <a href="CppOperatorAssign.htm">=</a> 0; orientation<a href="CppOperatorNotEqual.htm">!=</a>3; <a href="CppOperatorIncrement.htm">++</a>orientation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> aroundvertex&nbsp;&nbsp;<a href="CppComment.htm">//</a>An index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> corner[orientation];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Take the number <b><a href="CppFor.htm">for</a></b> the origin of triangleloop.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>aroundvertex <a href="CppOperatorAssign.htm">=</a> corner[triangleloop-&gt;m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Look <b><a href="CppFor.htm">for</a></b> other triangles having <b><a href="CppThis.htm">this</a></b> vertex.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> nexttri <a href="CppOperatorAssign.htm">=</a> vertices[aroundvertex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>nexttri <a href="CppOperatorAssign.htm">=</a> vertex<a href="CppArray.htm">array</a>[aroundvertex <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppLink.htm">Link</a> the current triangle to the next one in the stack.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangle-&gt;SetNextTriangle(nexttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop-&gt;m_triangles[6 <a href="CppOperatorPlus.htm">+</a> triangleloop-&gt;m_orient] <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Push the current triangle onto the stack.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertex<a href="CppArray.htm">array</a>[aroundvertex <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber] <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;m_tri[triangleloop-&gt;m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertex<a href="CppArray.htm">array</a>[aroundvertex <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber] <a href="CppOperatorAssign.htm">=</a> encode(triangleloop);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checktri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nexttri, checktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (checktri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(triangleloop, tdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tapex <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(triangleloop, tapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Look <b><a href="CppFor.htm">for</a></b> other triangles that share an edge.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> checkdest <a href="CppOperatorAssign.htm">=</a> checktri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(checktri, checkdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> checkapex <a href="CppOperatorAssign.htm">=</a> checktri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(checktri, checkapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tapex <a href="CppOperatorEqual.htm">==</a> checkdest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The two triangles share an edge; bond them together.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleleft.Lprev(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(triangleloop, triangleleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(triangleleft, checktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (tdest <a href="CppOperatorEqual.htm">==</a> checkapex)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The two triangles share an edge; bond them together.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkleft.Lprev(checktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(checktri, checkleft);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bond(triangleloop, checkleft);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the next triangle in the stack.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nexttri <a href="CppOperatorAssign.htm">=</a> checktri.m_triangles[6 <a href="CppOperatorPlus.htm">+</a> checktri.m_orient];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checktri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nexttri, checktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (checktri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;i<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;fclose(elefile);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fclose(areafile);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>hullsize <a href="CppOperatorAssign.htm">=</a> 0;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Prepare to count the boundary edges.<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; polyfile_lines<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppFileToVector.htm">FileToVector</a>(polyfilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Marking segments in triangulation.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the segments from the .poly file, and <a href="CppLink.htm">link</a> them<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to their neighboring triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>boundmarker <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_subsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subsegs <a href="CppOperatorAssign.htm">=</a> subsegtraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>i <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i=0; i<a href="CppOperatorNotEqual.htm">!=</a>n_segments; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (subsegloop-&gt;m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(lines[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> from_index <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> to_index <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the endpoints of each segment, and possibly a boundary marker.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Skip the first (segment number) field.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Segment "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " has no endpoints in "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end[0] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Segment " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " is missing its second endpoint in "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end[1] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> boundmarker<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> n_segmentmarkers<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[2])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (segmentmarkers)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundmarker <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundmarker <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 2; j<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (end[j] &lt; b.m_firstnumber <a href="CppOperatorLogicalOr.htm">||</a> end[j] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> m.m_invertices)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Segment "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> i<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " has an invalid vertex index"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>set the subsegment's vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> subseg<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;SubSeg&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[from_index],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[to_index],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundmarker<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(subseg-&gt;GetOrient() <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(subseg-&gt;GetOrigin() <a href="CppOperatorEqual.htm">==</a> vertices[from_index]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> segmentord <a href="CppOperatorAssign.htm">=</a> vertices[from_index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>segmentorg <a href="CppOperatorAssign.htm">=</a> getvertex(m.m_vertices, b, end[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(subseg-&gt;GetDest() <a href="CppOperatorEqual.htm">==</a> vertices[to_index]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> segmentdest <a href="CppOperatorAssign.htm">=</a> vertices[to_index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>segmentdest <a href="CppOperatorAssign.htm">=</a> getvertex(m.m_vertices, b, end[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(subseg-&gt;GetBoundMarker() <a href="CppOperatorEqual.htm">==</a> boundmarker);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[from_index]-&gt;<a href="CppAdd.htm">Add</a>SubSeg(subseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[to_index]-&gt;<a href="CppAdd.htm">Add</a>SubSeg(subseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subsegs.push_back(subseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;SetsOrigin(segmentorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetsOrigin(subsegloop, segmentorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;SetDest(segmentdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetDest(subsegloop, segmentdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setsegorg(subsegloop, segmentorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setsegdest(subsegloop, segmentdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setmark(subsegloop, boundmarker);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Try <a href="CppLink.htm">link</a>ing the subsegment to triangles that share these vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (subsegloop-&gt;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 0; subsegloop-&gt;m_subseg_orient &lt; 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subsegloop-&gt;m_subseg_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Take the number <b><a href="CppFor.htm">for</a></b> the destination of subsegloop-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aroundvertex <a href="CppOperatorAssign.htm">=</a> end[1 <a href="CppOperatorMinus.htm">-</a> subsegloop-&gt;m_subseg_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Look <b><a href="CppFor.htm">for</a></b> triangles having <b><a href="CppThis.htm">this</a></b> vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev<a href="CppLink.htm">link</a> <a href="CppOperatorAssign.htm">=</a> &amp;vertex<a href="CppArray.htm">array</a>[aroundvertex <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nexttri <a href="CppOperatorAssign.htm">=</a> vertex<a href="CppArray.htm">array</a>[aroundvertex <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checktri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nexttri, checktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shorg <a href="CppOperatorAssign.htm">=</a> subsegloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(subsegloop, shorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notfound <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Look <b><a href="CppFor.htm">for</a></b> triangles having <b><a href="CppThis.htm">this</a></b> edge.&nbsp;&nbsp;Note that I'm only<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;comparing each triangle's destination with the subsegment;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;each triangle's apex is handled through a different vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Because each triangle appears on three vertices' lists, each<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;occurrence of a triangle on a list can (and does) represent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;an edge.&nbsp;&nbsp;In <b><a href="CppThis.htm">this</a></b> way, most edges are represented twice, and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;every triangle-subsegment bond is represented once.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (notfound <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (checktri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkdest <a href="CppOperatorAssign.htm">=</a> checktri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(checktri, checkdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (shorg <a href="CppOperatorEqual.htm">==</a> checkdest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We have a match.&nbsp;&nbsp;Remove <b><a href="CppThis.htm">this</a></b> triangle from the list.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*prev<a href="CppLink.htm">link</a> <a href="CppOperatorAssign.htm">=</a> checktri.m_triangles[6 <a href="CppOperatorPlus.htm">+</a> checktri.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Bond the subsegment to the triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsbond(checktri, subsegloop);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> is a boundary edge.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkneighbor <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(checktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(checktri, checkneighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkneighbor.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The next line doesn't insert a subsegment (because there's<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;already one there), but it sets the boundary markers of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the existing subsegment and its vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, &amp;checktri, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hullsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notfound <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the next triangle in the stack.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev<a href="CppLink.htm">link</a> <a href="CppOperatorAssign.htm">=</a> &amp;checktri.m_triangles[6 <a href="CppOperatorPlus.htm">+</a> checktri.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nexttri <a href="CppOperatorAssign.htm">=</a> checktri.m_triangles[6 <a href="CppOperatorPlus.htm">+</a> checktri.m_orient];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checktri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nexttri, checktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subsegloop-&gt;m_subsegs <a href="CppOperatorAssign.htm">=</a> subsegtraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the remaining edges as not being attached to <a href="CppAny.htm">any</a> subsegment.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Also, count the (yet uncounted) boundary edges.<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; m.m_vertices.m_items; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search the stack of triangles adjacent to a vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nexttri <a href="CppOperatorAssign.htm">=</a> vertex<a href="CppArray.htm">array</a>[i];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checktri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nexttri, checktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (checktri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the next triangle in the stack before <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;information gets overwritten.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nexttri <a href="CppOperatorAssign.htm">=</a> checktri.m_triangles[6 <a href="CppOperatorPlus.htm">+</a> checktri.m_orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>No adjacent subsegment.&nbsp;&nbsp;(This overwrites the stack info.)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(checktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkneighbor <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(checktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(checktri, checkneighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkneighbor.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, &amp;checktri, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hullsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checktri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(nexttri, checktri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> vertex<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;vertex<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> hullsize;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::FindDirectionResult <a href="CppRibi.htm">ribi</a>::tricpp::finddirection(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; search<a href="CppPointer.htm">point</a><br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri checktri;<br/>
&nbsp;&nbsp;Vertex startvertex;<br/>
&nbsp;&nbsp;Vertex leftvertex, rightvertex;<br/>
&nbsp;&nbsp;Triangle ptr;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Temporary variable used by onext() and oprev().<br/>
<br/>
&nbsp;&nbsp;startvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*searchtri, startvertex);<br/>
<br/>
&nbsp;&nbsp;rightvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*searchtri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*searchtri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is `search<a href="CppPointer.htm">point</a>' to the left?<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> leftccw <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, search<a href="CppPointer.htm">point</a>, startvertex, leftvertex);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> leftflag <a href="CppOperatorAssign.htm">=</a> leftccw &gt; 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is `search<a href="CppPointer.htm">point</a>' to the right?<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> rightccw <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, startvertex, search<a href="CppPointer.htm">point</a>, rightvertex);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> rightflag <a href="CppOperatorAssign.htm">=</a> rightccw &gt; 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftflag <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rightflag)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>`searchtri' faces directly away from `search<a href="CppPointer.htm">point</a>'.&nbsp;&nbsp;We could go left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;or right.&nbsp;&nbsp;Ask whether it's a triangle or a boundary on the left.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checktri.Onext(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(*searchtri, checktri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checktri.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftflag <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightflag <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (leftflag)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Turn left until satisfied.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Onextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onextself(*searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (searchtri-&gt;m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Internal error in finddirection(): "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Unable to find a triangle leading from ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> startvertex[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> startvertex-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") to"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> search<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ")."<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*searchtri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rightccw <a href="CppOperatorAssign.htm">=</a> leftccw;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;leftccw <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, search<a href="CppPointer.htm">point</a>, startvertex, leftvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;leftflag <a href="CppOperatorAssign.htm">=</a> leftccw &gt; 0.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (rightflag)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Turn right until satisfied.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Oprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprevself(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (searchtri-&gt;m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Internal error in finddirection():&nbsp;&nbsp;Unable to find a "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "triangle leading from (" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> startvertex[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> startvertex-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") to"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> search<a href="CppPointer.htm">point</a>[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> search<a href="CppPointer.htm">point</a>-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rightvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*searchtri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;leftccw <a href="CppOperatorAssign.htm">=</a> rightccw;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rightccw <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, startvertex, search<a href="CppPointer.htm">point</a>, rightvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rightflag <a href="CppOperatorAssign.htm">=</a> rightccw &gt; 0.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftccw <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> LEFTCOLLINEAR;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (rightccw <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> RIGHTCOLLINEAR;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> WITHIN;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::segmentintersection(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; splittri,<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt;&amp; splitsubseg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; endpoint2<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Osub opposubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex endpoint1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex torg, tdest;<br/>
&nbsp;&nbsp;Vertex leftvertex, rightvertex;<br/>
&nbsp;&nbsp;Vertex newvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>InsertVertexResult success;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppEnum.htm">enum</a></b> finddirectionresult collinear;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ex, ey;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> tx, ty;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> etx, ety;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> split, denom;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by onext().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by snext().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the other three segment endpoints.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint1 <a href="CppOperatorAssign.htm">=</a> splittri-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*splittri, endpoint1);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> splittri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*splittri, torg);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> splittri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*splittri, tdest);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Segment intersection formulae; see the Antonio reference.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tx <a href="CppOperatorAssign.htm">=</a> tdest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> torg-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ty <a href="CppOperatorAssign.htm">=</a> tdest[1] <a href="CppOperatorMinus.htm">-</a> torg[1];<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ex <a href="CppOperatorAssign.htm">=</a> endpoint2-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> endpoint1-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ey <a href="CppOperatorAssign.htm">=</a> endpoint2[1] <a href="CppOperatorMinus.htm">-</a> endpoint1[1];<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> etx <a href="CppOperatorAssign.htm">=</a> torg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> endpoint2-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ety <a href="CppOperatorAssign.htm">=</a> torg[1] <a href="CppOperatorMinus.htm">-</a> endpoint2[1];<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> denom <a href="CppOperatorAssign.htm">=</a> ty * ex <a href="CppOperatorMinus.htm">-</a> tx * ey;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (denom <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Triangle: Internal error in segmentintersection(): "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Attempt to find intersection of parallel segments";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;split <a href="CppOperatorAssign.htm">=</a> (ey * etx <a href="CppOperatorMinus.htm">-</a> ex * ety) <a href="CppOperatorDivide.htm">/</a> denom;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the <b><a href="CppNew.htm">new</a></b> vertex.<br/>
&nbsp;&nbsp;newvertex <a href="CppOperatorAssign.htm">=</a> (Vertex) PoolAlloc(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Interpolate its coordinate and attributes.<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2 <a href="CppOperatorPlus.htm">+</a> m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newvertex[i] <a href="CppOperatorAssign.htm">=</a> torg[i] <a href="CppOperatorPlus.htm">+</a> split * (tdest[i] <a href="CppOperatorMinus.htm">-</a> torg[i]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;setvertexmark(newvertex, mark(*splitsubseg));<br/>
&nbsp;&nbsp;setvertextype(newvertex, VertexType::INPUTVERTEX);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;"&nbsp;&nbsp;Splitting subsegment (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) at (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; torg[0], torg[1], tdest[0], tdest[1], newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the intersection vertex.&nbsp;&nbsp;This should always succeed.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> InsertVertexResult success <a href="CppOperatorAssign.htm">=</a> insertvertex(m, b, newvertex, splittri, splitsubseg, 0, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorNotEqual.htm">!=</a> SUCCESSFULVERTEX) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in segmentintersection():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Failure to split a segment.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Record a triangle whose origin is the <b><a href="CppNew.htm">new</a></b> vertex.<br/>
<br/>
&nbsp;&nbsp;setvertex2tri(newvertex, splittri-&gt;m_tri[splittri.m_orient]);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertex2tri(newvertex, encode(*splittri));<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_steinerleft &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_steinerleft<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Divide the segment into two, and correct the segment endpoints.<br/>
&nbsp;&nbsp;ssymself(*splitsubseg);<br/>
&nbsp;&nbsp;spivot(*splitsubseg, opposubseg);<br/>
&nbsp;&nbsp;sdissolve(*splitsubseg);<br/>
&nbsp;&nbsp;sdissolve(opposubseg);<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;setsegorg(*splitsubseg, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;snextself(*splitsubseg);<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (splitsubseg-&gt;m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub);<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;setsegorg(opposubseg, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;snextself(opposubseg);<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (opposubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Inserting the vertex may have caused edge flips.&nbsp;&nbsp;We wish to rediscover<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the edge connecting endpoint1 to the <b><a href="CppNew.htm">new</a></b> intersection vertex.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppEnum.htm">enum</a></b> finddirectionresult collinear <a href="CppOperatorAssign.htm">=</a>finddirection(m, b, splittri, endpoint1);<br/>
&nbsp;&nbsp;rightvertex <a href="CppOperatorAssign.htm">=</a> splittri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*splittri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> splittri-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*splittri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> endpoint1-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> leftvertex[1] <a href="CppOperatorEqual.htm">==</a> endpoint1[1])<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;splittri-&gt;Onextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onextself(*splittri);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (rightvertex-&gt;GetX() <a href="CppOperatorNotEqual.htm">!=</a> endpoint1-&gt;GetX() <a href="CppOperatorLogicalOr.htm">||</a> rightvertex[1] <a href="CppOperatorNotEqual.htm">!=</a> endpoint1[1])<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in segmentintersection():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Topological inconsistency after splitting a segment.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>`splittri' should have destination endpoint1.<br/>
}<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::scoutsegment(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> searchtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri crosstri;<br/>
&nbsp;&nbsp;Osub crosssubseg;<br/>
&nbsp;&nbsp;Vertex leftvertex, rightvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppEnum.htm">enum</a></b> finddirectionresult collinear;<br/>
&nbsp;&nbsp;SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> FindDirectionResult collinear <a href="CppOperatorAssign.htm">=</a> finddirection(m, b, searchtri, endpoint2);<br/>
<br/>
&nbsp;&nbsp;rightvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(*searchtri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> searchtri-&gt;GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(*searchtri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( (leftvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> leftvertex[1] <a href="CppOperatorEqual.htm">==</a> endpoint2[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalOr.htm">||</a> (rightvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> rightvertex[1] <a href="CppOperatorEqual.htm">==</a> endpoint2[1])<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The segment is already an edge in the mesh.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> leftvertex[1] <a href="CppOperatorEqual.htm">==</a> endpoint2[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert a subsegment, <b><a href="CppIf.htm">if</a></b> there isn't already one there.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, searchtri, newmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 1;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (collinear <a href="CppOperatorEqual.htm">==</a> LEFTCOLLINEAR)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We've collided with a vertex between the segment's endpoints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make the collinear vertex be the triangle's origin.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, searchtri, newmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the remainder of the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> scoutsegment(m, b, searchtri, endpoint2, newmark);<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (collinear <a href="CppOperatorEqual.htm">==</a> RIGHTCOLLINEAR) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We've collided with a vertex between the segment's endpoints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, searchtri, newmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make the collinear vertex be the triangle's origin.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri-&gt;Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(*searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the remainder of the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> scoutsegment(m, b, searchtri, endpoint2, newmark);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;crosstri.SetLnext(*searchtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*searchtri, crosstri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> crosssubseg <a href="CppOperatorAssign.htm">=</a> crosstri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>crosstri.Tspivot(crosssubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(crosstri, crosssubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> a crossing segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (crosssubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert a vertex at the intersection.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segmentintersection(m, b, &amp;crosstri, &amp;crosssubseg, endpoint2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri <a href="CppOperatorAssign.htm">=</a> crosstri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(crosstri, *searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, searchtri, newmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the remainder of the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> scoutsegment(m, b, searchtri, endpoint2, newmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::conformingedge(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; endpoint1,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri searchtri1, searchtri2;<br/>
&nbsp;&nbsp;Osub brokensubseg;<br/>
&nbsp;&nbsp;Vertex newvertex;<br/>
&nbsp;&nbsp;Vertex midvertex1, midvertex2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>InsertVertexResult success;<br/>
<br/>
&nbsp;&nbsp;SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Forcing segment into triangulation by recursive splitting:\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n", endpoint1[0], endpoint1[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint2[0], endpoint2[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a <b><a href="CppNew.htm">new</a></b> vertex to insert in the middle of the segment.<br/>
&nbsp;&nbsp;newvertex <a href="CppOperatorAssign.htm">=</a> (Vertex) PoolAlloc(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Interpolate coordinates and attributes.<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2 <a href="CppOperatorPlus.htm">+</a> m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newvertex[i] <a href="CppOperatorAssign.htm">=</a> 0.5 * (endpoint1[i] <a href="CppOperatorPlus.htm">+</a> endpoint2[i]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;setvertexmark(newvertex, newmark);<br/>
&nbsp;&nbsp;setvertextype(newvertex, VertexType::SEGMENTVERTEX);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>No known triangle to search from.<br/>
&nbsp;&nbsp;searchtri1-&gt;m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Attempt to insert the <b><a href="CppNew.htm">new</a></b> vertex.<br/>
&nbsp;&nbsp;InsertVertexResult success <a href="CppOperatorAssign.htm">=</a> insertvertex(m, b, newvertex, &amp;searchtri1, <b><a href="CppNullptr.htm">nullptr</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorEqual.htm">==</a> DUPLICATEVERTEX)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Segment intersects existing vertex (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use the vertex that's already there.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexdealloc(m.m_vertices, newvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newvertex <a href="CppOperatorAssign.htm">=</a> searchtri1-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri1, newvertex);<br/>
<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorEqual.htm">==</a> VIOLATINGVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Two segments intersect at (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>By fluke, we've landed right on another segment.&nbsp;&nbsp;Split it.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> brokensubseg <a href="CppOperatorAssign.htm">=</a> searchtri1-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>searchtri1-&gt;Tspivot(brokensubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(searchtri1, brokensubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success <a href="CppOperatorAssign.htm">=</a> insertvertex(m, b, newvertex, &amp;searchtri1, &amp;brokensubseg,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorNotEqual.htm">!=</a> SUCCESSFULVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in conformingedge():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Failure to split a segment.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The vertex has been inserted successfully.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_steinerleft &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_steinerleft<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;searchtri2 <a href="CppOperatorAssign.htm">=</a> searchtri1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(searchtri1, searchtri2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>`searchtri1' and `searchtri2' are fastened at their origins to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;`newvertex', and will be directed toward `endpoint1' and `endpoint2'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;respectively.&nbsp;&nbsp;First, we must get `searchtri2' out of the way so it<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;won't be invalidated during the insertion of the first half of the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segment.<br/>
&nbsp;&nbsp;finddirection(m, b, &amp;searchtri2, endpoint2);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!scoutsegment(m, b, &amp;searchtri1, endpoint1, newmark)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The origin of searchtri1 may have changed <b><a href="CppIf.htm">if</a></b> a collision with an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;intervening vertex on the segment occurred.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;midvertex1 <a href="CppOperatorAssign.htm">=</a> searchtri1-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri1, midvertex1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;conformingedge(m, b, midvertex1, endpoint1, newmark);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!scoutsegment(m, b, &amp;searchtri2, endpoint2, newmark)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The origin of searchtri2 may have changed <b><a href="CppIf.htm">if</a></b> a collision with an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;intervening vertex on the segment occurred.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;midvertex2 <a href="CppOperatorAssign.htm">=</a> searchtri2-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri2, midvertex2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;conformingedge(m, b, midvertex2, endpoint2, newmark);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::delaunayfixup(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Otri * <b><a href="CppConst.htm">const</a></b> fixuptri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> leftside<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri neartri;<br/>
&nbsp;&nbsp;Otri fartri;<br/>
&nbsp;&nbsp;Osub faredge;<br/>
&nbsp;&nbsp;Vertex nearvertex, leftvertex, rightvertex, farvertex;<br/>
&nbsp;&nbsp;Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;neartri.SetLnext(*fixuptri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*fixuptri, neartri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> fartri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(neartri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(neartri, fartri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the edge opposite the origin of fixuptri can be flipped.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (fartri.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> faredge <a href="CppOperatorAssign.htm">=</a> neartri.CreateTspivot();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>neartri.Tspivot(faredge);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(neartri, faredge);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (faredge.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find all the relevant vertices.<br/>
&nbsp;&nbsp;nearvertex <a href="CppOperatorAssign.htm">=</a> neartri.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(neartri, nearvertex);<br/>
<br/>
&nbsp;&nbsp;leftvertex <a href="CppOperatorAssign.htm">=</a> neartri.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(neartri, leftvertex);<br/>
<br/>
&nbsp;&nbsp;rightvertex <a href="CppOperatorAssign.htm">=</a> neartri.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(neartri, rightvertex);<br/>
<br/>
&nbsp;&nbsp;farvertex <a href="CppOperatorAssign.htm">=</a> fartri.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(fartri, farvertex);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the previous polygon vertex is a reflex vertex.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (leftside)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, nearvertex, leftvertex, farvertex) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>leftvertex is a reflex vertex too.&nbsp;&nbsp;Nothing can<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;be done until a convex section is found.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, farvertex, rightvertex, nearvertex) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>rightvertex is a reflex vertex too.&nbsp;&nbsp;Nothing can<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;be done until a convex section is found.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, rightvertex, leftvertex, farvertex) &gt; 0.0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fartri is not an inverted triangle, and farvertex is not a reflex<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertex.&nbsp;&nbsp;As there are no reflex vertices, fixuptri isn't an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;inverted triangle, either.&nbsp;&nbsp;Hence, test the edge between the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangles to ensure it is locally Delaunay.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (incircle(m.m_incirclecount, b.m_noexact, leftvertex, farvertex, rightvertex, nearvertex) <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Not locally Delaunay; go on to an edge flip.<br/>
&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b> fartri is inverted; remove it from the stack by flipping.<br/>
&nbsp;&nbsp;flip(m, b, &amp;neartri);<br/>
<br/>
&nbsp;&nbsp;fixuptri-&gt;Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(*fixuptri);&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Restore the origin of fixuptri after the flip.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Recursively process the two triangles that result from the flip.<br/>
&nbsp;&nbsp;delaunayfixup(m, b, fixuptri, leftside);<br/>
&nbsp;&nbsp;delaunayfixup(m, b, &amp;fartri, leftside);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::constrainededge(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> starttri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri fixuptri, fixuptri2;<br/>
&nbsp;&nbsp;Osub crosssubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex endpoint1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex farvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> area;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> collision;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> done;<br/>
&nbsp;&nbsp;Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym() and oprev().<br/>
&nbsp;&nbsp;SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint1 <a href="CppOperatorAssign.htm">=</a> starttri-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(*starttri, endpoint1);<br/>
<br/>
&nbsp;&nbsp;fixuptri.SetLnext(*starttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(*starttri, fixuptri);<br/>
<br/>
&nbsp;&nbsp;flip(m, b, &amp;fixuptri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>`collision' indicates whether we have found a vertex directly<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;between endpoint1 and endpoint2.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> collision <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> done <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> farvertex <a href="CppOperatorAssign.htm">=</a> fixuptri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(fixuptri, farvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>`farvertex' is the extreme <a href="CppPointer.htm">point</a> of the polygon we are "digging"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to get from endpoint1 to endpoint2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (farvertex[0] <a href="CppOperatorEqual.htm">==</a> endpoint2[0] <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> farvertex[1] <a href="CppOperatorEqual.htm">==</a> endpoint2[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (farvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetX() <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> farvertex-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixuptri2-&gt;Oprev(fixuptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(fixuptri, fixuptri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Enforce the Delaunay condition around endpoint2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delaunayfixup(m, b, &amp;fixuptri, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delaunayfixup(m, b, &amp;fixuptri2, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether farvertex is to the left or right of the segment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;being inserted, to decide which edge of fixuptri to dig<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;through next.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> area <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, endpoint1, endpoint2, farvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (area <a href="CppOperatorEqual.htm">==</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We've collided with a vertex between endpoint1 and endpoint2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collision <a href="CppOperatorAssign.htm">=</a> 1;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixuptri2-&gt;Oprev(fixuptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(fixuptri, fixuptri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Enforce the Delaunay condition around farvertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delaunayfixup(m, b, &amp;fixuptri, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delaunayfixup(m, b, &amp;fixuptri2, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (area &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>farvertex is to the left of the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixuptri2-&gt;Oprev(fixuptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(fixuptri, fixuptri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Enforce the Delaunay condition around farvertex, on the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;left side of the segment only.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delaunayfixup(m, b, &amp;fixuptri2, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Flip the edge that crosses the segment.&nbsp;&nbsp;After the edge is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;flipped, one of its endpoints is the fan vertex, and the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;destination of fixuptri is the fan vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixuptri.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(fixuptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>farvertex is to the right of the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delaunayfixup(m, b, &amp;fixuptri, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Flip the edge that crosses the segment.&nbsp;&nbsp;After the edge is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;flipped, one of its endpoints is the fan vertex, and the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;destination of fixuptri is the fan vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixuptri.Oprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprevself(fixuptri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> two intersecting segments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> crosssubseg <a href="CppOperatorAssign.htm">=</a> fixuptri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>fixuptri.Tspivot(crosssubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(fixuptri, crosssubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (crosssubseg.m_subsegs[0] <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flip(m, b, &amp;fixuptri);&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>May create inverted triangle at left.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>We've collided with a segment between endpoint1 and endpoint2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collision <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert a vertex at the intersection.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segmentintersection(m, b, &amp;fixuptri, &amp;crosssubseg, endpoint2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (!done);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert a subsegment to <a href="CppMake.htm">make</a> the segment permanent.<br/>
&nbsp;&nbsp;insertsubseg(m, b, &amp;fixuptri, newmark);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If there was a collision with an interceding vertex, install another<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segment connecting that vertex with endpoint2.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (collision)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the remainder of the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!scoutsegment(m, b, &amp;fixuptri, endpoint2, newmark))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constrainededge(m, b, &amp;fixuptri, endpoint2, newmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::insertsegment(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;Vertex endpoint1,<br/>
&nbsp;&nbsp;Vertex endpoint2,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> newmark<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri searchtri1, searchtri2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle encodedtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex checkvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Connecting (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) to (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint1[0], endpoint1[1], endpoint2[0], endpoint2[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle whose origin is the segment's first endpoint.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkvertex <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> encodedtri <a href="CppOperatorAssign.htm">=</a> vertex2tri(endpoint1);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (encodedtri <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri1 <a href="CppOperatorAssign.htm">=</a> encodedtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(encodedtri, searchtri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkvertex <a href="CppOperatorAssign.htm">=</a> searchtri1-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri1, checkvertex);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkvertex <a href="CppOperatorNotEqual.htm">!=</a> endpoint1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a boundary triangle to search from.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri1-&gt;m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri1-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri1-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchtri1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> the segment's first endpoint by <a href="CppPointer.htm">point</a> location.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (locate(m, b, endpoint1, &amp;searchtri1) <a href="CppOperatorNotEqual.htm">!=</a> ONVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Internal error in insertsegment():&nbsp;&nbsp;Unable to locate PSLG vertex\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) in triangulation.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint1[0], endpoint1[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remember <b><a href="CppThis.htm">this</a></b> triangle to improve subsequent <a href="CppPointer.htm">point</a> location.<br/>
&nbsp;&nbsp;m.m_recenttri <a href="CppOperatorAssign.htm">=</a> searchtri1;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(searchtri1, m.m_recenttri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Scout the beginnings of a path from the first endpoint<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;toward the second.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (scoutsegment(m, b, &amp;searchtri1, endpoint2, newmark))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The segment was easily inserted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The first endpoint may have changed <b><a href="CppIf.htm">if</a></b> a collision with an intervening<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertex on the segment occurred.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint1 <a href="CppOperatorAssign.htm">=</a> searchtri1-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri1, endpoint1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle whose origin is the segment's second endpoint.<br/>
&nbsp;&nbsp;checkvertex <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;();<br/>
&nbsp;&nbsp;encodedtri <a href="CppOperatorAssign.htm">=</a> vertex2tri(endpoint2);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (encodedtri)<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri2 <a href="CppOperatorAssign.htm">=</a> mdecode;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(encodedtri, searchtri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkvertex <a href="CppOperatorAssign.htm">=</a> searchtri2-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri2, checkvertex);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkvertex <a href="CppOperatorNotEqual.htm">!=</a> endpoint2)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a boundary triangle to search from.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri2-&gt;m_triangles[0] <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri2-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;searchtri2-&gt;Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchtri2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Search <b><a href="CppFor.htm">for</a></b> the segment's second endpoint by <a href="CppPointer.htm">point</a> location.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (locate(m, b, endpoint2, &amp;searchtri2) <a href="CppOperatorNotEqual.htm">!=</a> ONVERTEX) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Internal error in insertsegment():&nbsp;&nbsp;Unable to locate PSLG vertex\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) in triangulation.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint2[0], endpoint2[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remember <b><a href="CppThis.htm">this</a></b> triangle to improve subsequent <a href="CppPointer.htm">point</a> location.<br/>
&nbsp;&nbsp;m.m_recenttri <a href="CppOperatorAssign.htm">=</a> searchtri2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(searchtri2, m.m_recenttri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Scout the beginnings of a path from the second endpoint<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;toward the first.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (scoutsegment(m, b, &amp;searchtri2, endpoint1, newmark))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The segment was easily inserted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The second endpoint may have changed <b><a href="CppIf.htm">if</a></b> a collision with an intervening<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertex on the segment occurred.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint2 <a href="CppOperatorAssign.htm">=</a> searchtri2-&gt;GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri2, endpoint2);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_splitseg)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert vertices to force the segment into the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;conformingedge(m, b, endpoint1, endpoint2, newmark);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the segment directly into the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;constrainededge(m, b, &amp;searchtri1, endpoint2, newmark);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::markhull(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri hulltri;<br/>
&nbsp;&nbsp;Otri nexttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri starttri;<br/>
&nbsp;&nbsp;Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym() and oprev().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle handle on the hull.<br/>
&nbsp;&nbsp;hulltri.m_triangles[0] <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;hulltri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;hulltri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(hulltri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remember where we started so we know when to stop.<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> starttri <a href="CppOperatorAssign.htm">=</a> hulltri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(hulltri, starttri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Go once <a href="CppCounter.htm">counter</a>clockwise around the convex hull.<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a subsegment <b><a href="CppIf.htm">if</a></b> there isn't already one here.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;insertsubseg(m, b, &amp;hulltri, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>To find the next hull edge, go clockwise around the next vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;hulltri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(hulltri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nexttri.Oprev(hulltri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(hulltri, nexttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (nexttri.m_triangles[0] <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hulltri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(nexttri, hulltri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nexttri.Oprev(hulltri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(hulltri, nexttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> ( hulltri <a href="CppOperatorNotEqual.htm">!=</a> starttri) <a href="CppComment.htm">//</a>!otriequal(hulltri, starttri) );<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::formskeleton(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> polyfile,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> inputline[g_max_inputline_size];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex endpoint1, endpoint2;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> segmentmarkers;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> end1, end2;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> boundmarker;<br/>
<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Recovering segments in Delaunay triangulation.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the segments from a .poly file.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read number of segments and number of boundary markers.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> * stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile); <a href="CppComment.htm">//</a>RJCB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_insegments <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segmentmarkers <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segmentmarkers <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the input vertices are collinear, there is no triangulation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;so don't <b><a href="CppTry.htm">try</a></b> to insert segments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_triangles.m_items <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If segments are to be inserted, compute a mapping<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;from vertices to triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_insegments &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppMake.htm">make</a>vertexmap(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Recovering PSLG segments.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boundmarker <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read and insert the segments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; m.m_insegments; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Segment " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " has no endpoints in " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ".\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end1 <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Segment " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " is missing its second endpoint in " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ".\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end2 <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (segmentmarkers) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundmarker <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundmarker <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (end1 &lt; b.m_firstnumber <a href="CppOperatorLogicalOr.htm">||</a> end1 <a href="CppOperatorGreaterEqual.htm">&gt;=</a> b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> m.m_invertices)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;Invalid first endpoint of segment "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " in "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ".\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (end2 &lt; b.m_firstnumber <a href="CppOperatorLogicalOr.htm">||</a> end2 <a href="CppOperatorGreaterEqual.htm">&gt;=</a> b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> m.m_invertices)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;Invalid second endpoint of segment "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " in "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ".\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the vertices numbered `end1' and `end2'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint1 <a href="CppOperatorAssign.htm">=</a> getvertex(m.m_vertices, b, end1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint2 <a href="CppOperatorAssign.htm">=</a> getvertex(m.m_vertices, b, end2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (endpoint1-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetX()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> endpoint1-&gt;GetY() <a href="CppOperatorEqual.htm">==</a> endpoint2-&gt;GetY()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Warning:&nbsp;&nbsp;End<a href="CppPointer.htm">point</a>s of segment "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>(b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " are coincident in "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> polyfilename <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ".\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertsegment(m, b, endpoint1, endpoint2, boundmarker);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_insegments <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_convex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Enclosing convex hull with segments.\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;markhull(m, b);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::infecthull(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; hulltri;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; nexttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri starttri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub hullsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **deadtriangle;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex horg, hdest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Marking concavities (<b><a href="CppExtern.htm">extern</a></b>al triangles) <b><a href="CppFor.htm">for</a></b> elimination.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle handle on the hull.<br/>
&nbsp;&nbsp;hulltri.m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;hulltri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;hulltri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(hulltri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remember where we started so we know when to stop.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> starttri <a href="CppOperatorAssign.htm">=</a> hulltri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(hulltri, starttri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Go once <a href="CppCounter.htm">counter</a>clockwise around the convex hull.<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ignore triangles that are already infected.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (hulltri.GetIsInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!infected(hulltri))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the triangle <b><a href="CppProtected.htm">protected</a></b> by a subsegment?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> hullsubseg <a href="CppOperatorAssign.htm">=</a> hulltri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hulltri.Tspivot(hullsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(hulltri, hullsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (hullsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The triangle is not <b><a href="CppProtected.htm">protected</a></b>; infect it.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (hulltri.GetInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!infected(hulltri))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hulltri.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(hulltri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> deadtriangle <a href="CppOperatorAssign.htm">=</a> hulltri.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>deadtriangle <a href="CppOperatorAssign.htm">=</a> (Triangle **) PoolAlloc(&amp;m.m_viri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>*deadtriangle <a href="CppOperatorAssign.htm">=</a> hulltri.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The triangle is <b><a href="CppProtected.htm">protected</a></b>; set boundary markers <b><a href="CppIf.htm">if</a></b> appropriate.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mark(hullsubseg) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hullsubseg-&gt;SetMark(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setmark(hullsubseg, 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> horg <a href="CppOperatorAssign.htm">=</a> hulltri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(hulltri, horg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> hdest <a href="CppOperatorAssign.htm">=</a> hulltri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(hulltri, hdest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertexmark(horg) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horg-&gt;SetVertexMark(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(horg, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertexmark(hdest) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdest-&gt;SetVertexMark(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(hdest, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>To find the next hull edge, go clockwise around the next vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;hulltri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(hulltri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;nexttri.Oprev(hulltri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(hulltri, nexttri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (nexttri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hulltri <a href="CppOperatorAssign.htm">=</a> nexttri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(nexttri, hulltri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nexttri.Oprev(hulltri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(hulltri, nexttri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (hulltri <a href="CppOperatorNotEqual.htm">!=</a> starttri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (!otriequal(hulltri, starttri));<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::plague(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; testtri;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; neighbor;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **virusloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **deadtriangle;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub neighborsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex testvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex norg, ndest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex deadorg, deaddest, deadapex;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> killorg <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym() and onext().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Marking neighbors of marked triangles.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Loop through all the infected triangles, spreading the virus to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;their neighbors, then to their neighbors' neighbors.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> virusloop: m.m_viri)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (virusloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.m_triangles <a href="CppOperatorAssign.htm">=</a> *virusloop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>A triangle is marked as infected by messing with one of its <a href="CppPointer.htm">pointer</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to subsegments, setting it to an illegal value.&nbsp;&nbsp;Hence, we have to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;temporarily uninfect <b><a href="CppThis.htm">this</a></b> triangle so that we can examine its<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent subsegments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetInfected(<b><a href="CppFalse.htm">false</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>uninfect(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assign the triangle an orientation <b><a href="CppFor.htm">for</a></b> convenience in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;checking its vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetOrigin(testtri, deadorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetDest(testtri, deaddest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetApex(testtri, deadapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Checking (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadorg[0], deadorg[1], deaddest[0], deaddest[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadapex[0], deadapex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check each of the triangle's three neighbors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (testtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0; testtri.m_orient &lt; 3; testtri.m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> neighbor <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(testtri, neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> a subsegment between the triangle and its neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> neighborsubseg <a href="CppOperatorAssign.htm">=</a> testtri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>testtri.Tspivot(neighborsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(testtri, neighborsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the neighbor is nonexistent or already infected.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri <a href="CppOperatorLogicalOr.htm">||</a> neighbor.GetInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (neighbor.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri <a href="CppOperatorLogicalOr.htm">||</a> infected(neighbor))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighborsubseg.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There is a subsegment separating the triangle from its<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;neighbor, but both triangles are dying, so the subsegment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;dies too.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subsegdealloc(m, neighborsubseg.m_subsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make sure the subsegment doesn't get deallocated again<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;later when the infected neighbor is visited.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.SetInfected(<b><a href="CppFalse.htm">false</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>uninfect(neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsdissolve(neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(neighbor);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The neighbor exists and is not infected.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighborsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There is no subsegment protecting the neighbor, so<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the neighbor becomes infected.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetOrigin(neighbor, deadorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetDest(neighbor, deaddest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetApex(neighbor, deadapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;Marking (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadorg[0], deadorg[1], deaddest[0], deaddest[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadapex[0], deadapex[1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the neighbor's neighbors will be infected.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> deadtriangle <a href="CppOperatorAssign.htm">=</a> neighbour.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>deadtriangle <a href="CppOperatorAssign.htm">=</a> (Triangle **) PoolAlloc(&amp;m.m_viri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>*deadtriangle <a href="CppOperatorAssign.htm">=</a> neighbor.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>The neighbor is <b><a href="CppProtected.htm">protected</a></b> by a subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remove <b><a href="CppThis.htm">this</a></b> triangle from the subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>issolve(neighborsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The subsegment becomes a boundary.&nbsp;&nbsp;Set markers accordingly.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mark(neighborsubseg) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setmark(neighborsubseg, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> norg <a href="CppOperatorAssign.htm">=</a> neighbor.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(neighbor, norg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> ndest <a href="CppOperatorAssign.htm">=</a> neighbor.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(neighbor, ndest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertexmark(norg) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertexmark(norg, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (vertexmark(ndest) <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertexmark(ndest, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remark the triangle as infected, so it doesn't get added to the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;virus pool again.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Deleting marked triangles.\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> virusloop: m.m_viri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (virusloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.m_triangles <a href="CppOperatorAssign.htm">=</a> *virusloop;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check each of the three corners of the triangle <b><a href="CppFor.htm">for</a></b> elimination.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;This is done by walking around each vertex, checking <b><a href="CppIf.htm">if</a></b> it is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;still connected to at least one live triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (testtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0; testtri.m_orient &lt; 3; testtri.m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testvertex <a href="CppOperatorAssign.htm">=</a> testtri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(testtri, testvertex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppIf.htm">if</a></b> the vertex has already been tested.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (testvertex <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killorg <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the corner of the triangle as having been tested.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetOrigin(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(testtri, <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Walk <a href="CppCounter.htm">counter</a>clockwise <a href="CppAbout.htm">about</a> the vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.Onext(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onext(testtri, neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Stop upon reaching a boundary or the starting triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (neighbor.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> neighbor <a href="CppOperatorNotEqual.htm">!=</a> testtri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (neighbor.m_tri <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !otriequal(neighbor, testtri))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.GetInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (infected(neighbor))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the corner of <b><a href="CppThis.htm">this</a></b> triangle as having been tested.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.SetOrigin(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(neighbor, <a href="CppNULL.htm">NULL</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>A live triangle.&nbsp;&nbsp;The vertex survives.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killorg <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Walk <a href="CppCounter.htm">counter</a>clockwise <a href="CppAbout.htm">about</a> the vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.Onextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>onextself(neighbor);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If we reached a boundary, we must walk clockwise as well.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Walk clockwise <a href="CppAbout.htm">about</a> the vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.Oprev(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprev(testtri, neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Stop upon reaching a boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (neighbor.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.GetInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (infected(neighbor))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the corner of <b><a href="CppThis.htm">this</a></b> triangle as having been tested.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.SetOrigin(<b><a href="CppNullptr.htm">nullptr</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetOrigin(neighbor, <a href="CppNULL.htm">NULL</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>A live triangle.&nbsp;&nbsp;The vertex survives.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killorg <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Walk clockwise <a href="CppAbout.htm">about</a> the vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.Oprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>oprevself(neighbor);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (killorg)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Deleting vertex (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testvertex[0], testvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertextype(testvertex, VertexType::UNDEADVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_undeads<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Record changes in the number of boundary edges, and disconnect<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;dead triangles from their neighbors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (testtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0; testtri.m_orient &lt; 3; testtri.m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> neighbor <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(testtri, neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There is no neighboring triangle on <b><a href="CppThis.htm">this</a></b> edge, so <b><a href="CppThis.htm">this</a></b> edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;is a boundary edge.&nbsp;&nbsp;This triangle is being deleted, so <b><a href="CppThis.htm">this</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;boundary edge is deleted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_hullsize<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Disconnect the triangle from its neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor.Dissolve(m_m_dummyri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dissolve(neighbor);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>There is a neighboring triangle on <b><a href="CppThis.htm">this</a></b> edge, so <b><a href="CppThis.htm">this</a></b> edge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;becomes a boundary edge when <b><a href="CppThis.htm">this</a></b> triangle is deleted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_hullsize<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Return the dead triangle to the pool of triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledealloc(m, testtri.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Empty the virus pool.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>PoolRestart(&amp;m.m_viri);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::regionplague(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> attribute,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> area<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri testtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri neighbor;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **virusloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **regiontri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub neighborsubseg;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex regionorg, regiondest, regionapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym() and onext().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Loop through all the infected triangles, spreading the attribute<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;and/or area constraint to their neighbors, then to their neighbors'<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;neighbors.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> virusloop: m.m_viri)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (virusloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; testtri <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Otri&gt;();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri-&gt;m_triangles <a href="CppOperatorAssign.htm">=</a> *virusloop;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>A triangle is marked as infected by messing with one of its <a href="CppPointer.htm">pointer</a>s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to subsegments, setting it to an illegal value.&nbsp;&nbsp;Hence, we have to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;temporarily uninfect <b><a href="CppThis.htm">this</a></b> triangle so that we can examine its<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent subsegments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri-&gt;SetInfected(<b><a href="CppFalse.htm">false</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>uninfect(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_regionattrib)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set an attribute.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetElemAttrib(attribute,m.m_eextras);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(testtri, m.m_eextras, attribute);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set an area constraint.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetAreaBound(area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setareabound(testtri, area);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assign the triangle an orientation <b><a href="CppFor.htm">for</a></b> convenience in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;checking its vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetOrigin(testtri, regionorg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest(testtri, regiondest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apex(testtri, regionapex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Checking (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regionorg[0], regionorg[1], regiondest[0], regiondest[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regionapex[0], regionapex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check each of the triangle's three neighbors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (testtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0; testtri.m_orient &lt; 3; testtri.m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> neighbor <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(testtri, neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check <b><a href="CppFor.htm">for</a></b> a subsegment between the triangle and its neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> neighborsubseg <a href="CppOperatorAssign.htm">=</a> testtri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>testtri.Tspivot(neighborsubseg);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(testtri, neighborsubseg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make sure the neighbor exists, is not already infected, and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;isn't <b><a href="CppProtected.htm">protected</a></b> by a subsegment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (neighbor.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !neighbor.GetInfected()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !infected(neighbor)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (neighborsubseg.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetOrigin(neighbor, regionorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regiondest <a href="CppOperatorAssign.htm">=</a> neighbor.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(neighbor, regiondest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionapex <a href="CppOperatorAssign.htm">=</a> neighbor.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(neighbor, regionapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Marking (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regionorg[0], regionorg[1], regiondest[0], regiondest[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regionapex[0], regionapex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Infect the neighbor.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor-&gt;SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(neighbor);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the neighbor's neighbors will be infected.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regiontri <a href="CppOperatorAssign.htm">=</a> neighbor.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>regiontri <a href="CppOperatorAssign.htm">=</a> (Triangle **) PoolAlloc(&amp;m.m_viri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>*regiontri <a href="CppOperatorAssign.htm">=</a> neighbor.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Remark the triangle as infected, so it doesn't get added to the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;virus pool again.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Uninfect all triangles.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> virusloop: m.m_viri)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (virusloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; testtri <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Otri&gt;();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.m_triangles <a href="CppOperatorAssign.htm">=</a> *virusloop;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetInfected(<b><a href="CppFalse.htm">false</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>uninfect(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>virusloop <a href="CppOperatorAssign.htm">=</a> (Triangle **) Traverse(&amp;m.m_viri);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Empty the virus pool.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>PoolRestart(m.m_viri);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::carveholes(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; holes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> holelist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> holes,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; regions<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> regionlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> regions<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri searchtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> regiontris;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> holetri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **holetri;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> regiontri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle **regiontri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex searchorg, searchdest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>LocateResult intersect;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!(b.m_quiet <a href="CppOperatorLogicalOr.htm">||</a> (b.m_noholes <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> b.m_convex))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Removing unwanted triangles.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (holes &gt; 0)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Marking holes <b><a href="CppFor.htm">for</a></b> elimination.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (regions &gt; 0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppComment.htm">//</a>Allocate storage <b><a href="CppFor.htm">for</a></b> the triangles in which region <a href="CppPointer.htm">point</a>s fall.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;regiontris <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Otri&gt;();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;regiontris <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> Otri *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (((holes &gt; 0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !b.m_noholes) <a href="CppOperatorLogicalOr.htm">||</a> !b.m_convex <a href="CppOperatorLogicalOr.htm">||</a> (regions &gt; 0)) {<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> a pool of viri to be used <b><a href="CppFor.htm">for</a></b> holes, concavities,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;regional attributes, and/or regional area constraints.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;PoolInit(&amp;m.m_viri, <b><a href="CppSizeof.htm">sizeof</a></b>(Triangle *), VIRUSPERBLOCK, VIRUSPERBLOCK, 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_convex)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark as infected <a href="CppAny.htm">any</a> un<b><a href="CppProtected.htm">protected</a></b> triangles on the boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;This is one way by which concavities are created.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;infecthull(m, b);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (holes &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !b.m_noholes)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Infect each triangle in which a hole lies.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2 * holes; i <a href="CppOperatorPlusAssign.htm">+=</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ignore holes that aren't within the bounds of the mesh.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (holelist[i] &lt; m.m_xmin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> holelist[i] &gt; m.m_xmax<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> holelist[i <a href="CppOperatorPlus.htm">+</a> 1] &lt; m.m_ymin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> holelist[i <a href="CppOperatorPlus.htm">+</a> 1] &gt; m.m_ymax<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (holelist[i] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m.m_xmin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> holelist[i] <a href="CppOperatorLessEqual.htm">&lt;=</a> m.m_xmax<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> holelist[i <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m.m_ymin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> holelist[i <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> m.m_ymax<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppContinue.htm">continue</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start searching from some triangle on the outer boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Otri searchtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the hole is to the left of <b><a href="CppThis.htm">this</a></b> boundary edge;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;otherwise, locate() will <b><a href="CppFalse.htm">false</a></b>ly report that the hole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;falls within the starting triangle.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> searchorg <a href="CppOperatorAssign.htm">=</a> searchtri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(searchtri, searchorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> searchdest <a href="CppOperatorAssign.htm">=</a> searchtri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(searchtri, searchdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, searchorg, searchdest, &amp;holelist[i]) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle that contains the hole.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> intersect <a href="CppOperatorAssign.htm">=</a> locate(m, b, &amp;holelist[i], &amp;searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (intersect <a href="CppOperatorNotEqual.htm">!=</a> OUTSIDE <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !searchtri.GetInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> ((intersect <a href="CppOperatorNotEqual.htm">!=</a> OUTSIDE) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !infected(searchtri))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Infect the triangle.&nbsp;&nbsp;This is done by marking the triangle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;as infected and including the triangle in the virus pool.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holetri <a href="CppOperatorAssign.htm">=</a> searchtri.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>holetri <a href="CppOperatorAssign.htm">=</a> (Triangle **) PoolAlloc(&amp;m.m_viri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>*holetri <a href="CppOperatorAssign.htm">=</a> searchtri.m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Now, we have to find all the regions BEFORE we carve the holes, because<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;locate() won't work when the triangulation is no longer convex.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(Incidentally, <b><a href="CppThis.htm">this</a></b> is the reason why regional attributes and area<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;constraints can't be used when refining a preexisting mesh, which<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;might not be convex; they can only be used with a freshly<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangulated PSLG.)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the starting triangle <b><a href="CppFor.htm">for</a></b> each region.<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; regions; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;regiontris[i].m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ignore region <a href="CppPointer.htm">point</a>s that aren't within the bounds of the mesh.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ( regionlist[4 * i&nbsp;&nbsp;&nbsp;&nbsp;] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m.m_xmin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> regionlist[4 * i&nbsp;&nbsp;&nbsp;&nbsp;] <a href="CppOperatorLessEqual.htm">&lt;=</a> m.m_xmax<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> regionlist[4 * i <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorGreaterEqual.htm">&gt;=</a> m.m_ymin<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> regionlist[4 * i <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorLessEqual.htm">&lt;=</a> m.m_ymax<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Start searching from some triangle on the outer boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.m_triangles <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchtri.Symself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the region <a href="CppPointer.htm">point</a> is to the left of <b><a href="CppThis.htm">this</a></b> boundary<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge; otherwise, locate() will <b><a href="CppFalse.htm">false</a></b>ly report that the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;region <a href="CppPointer.htm">point</a> falls within the starting triangle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> searchorg <a href="CppOperatorAssign.htm">=</a> searchtri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(searchtri, searchorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> searchdest <a href="CppOperatorAssign.htm">=</a> searchtri.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(searchtri, searchdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (<a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, searchorg, searchdest, &amp;regionlist[4 * i]) &gt; 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find a triangle that contains the region <a href="CppPointer.htm">point</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> intersect <a href="CppOperatorAssign.htm">=</a> locate(m, b, &amp;regionlist[4 * i], &amp;searchtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (intersect <a href="CppOperatorNotEqual.htm">!=</a> OUTSIDE <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !searchtri.GetInfected())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (intersect <a href="CppOperatorNotEqual.htm">!=</a> OUTSIDE <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !infected(searchtri)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Record the triangle <b><a href="CppFor.htm">for</a></b> processing after the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;holes have been carved.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regiontris[i] <a href="CppOperatorAssign.htm">=</a> searchtri;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>otricopy(searchtri, regiontris[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!m.m_viri.empty())<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (m.m_viri.m_items &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Carve the holes and concavities.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;plague(m, b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The virus pool should be empty now.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!regions.empty())<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (regions &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_regionattrib) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Spreading regional attributes and area constraints.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Spreading regional attributes.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> { <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Spreading regional area constraints.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_regionattrib <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !b.m_do_refine)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assign every triangle a regional attribute of zero.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;SetElemAttrib(0.0,m.m_eextras);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setelemattribute(triangleloop, m.m_eextras, 0.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; regions; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (regiontris[i].m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make sure the triangle under consideration still exists.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;It may have been eaten by the virus.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!deadtri(regiontris[i].m_triangles))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Put one triangle in the virus pool.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regiontris[i].SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>infect(regiontris[i]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regiontri <a href="CppOperatorAssign.htm">=</a> regiontris[i]-&gt;m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>regiontri <a href="CppOperatorAssign.htm">=</a> (Triangle **) PoolAlloc(&amp;m.m_viri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>*regiontri <a href="CppOperatorAssign.htm">=</a> regiontris[i].m_triangles;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Apply one region's attribute and/or area constraint.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionplague(m, b, regionlist[4 * i <a href="CppOperatorPlus.htm">+</a> 2], regionlist[4 * i <a href="CppOperatorPlus.htm">+</a> 3]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The virus pool should be empty now.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_regionattrib <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !b.m_do_refine)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Note the fact that each triangle has an additional attribute.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_eextras<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Free up <a href="CppMemory.htm">memory</a>.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (((holes &gt; 0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !b.m_noholes) <a href="CppOperatorLogicalOr.htm">||</a> !b.m_convex <a href="CppOperatorLogicalOr.htm">||</a> (regions &gt; 0)) {<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;PoolDeinit(&amp;m.m_viri);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (regions &gt; 0)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> regiontris;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;regiontris <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::tallyencs(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub subsegloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> dummy;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_subsegs);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subsegs <a href="CppOperatorAssign.htm">=</a> subsegtraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> subsegloop: m.m_subsegs)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (subsegloop-&gt;m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subsegloop-&gt;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the segment is encroached, add it to the list.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkseg4encroach(m.m_dummytri,b.m_conformdel,b.m_goodangle,b.m_nobisect,&amp;subsegloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>checkseg4encroach(m, b, &amp;subsegloop);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subsegs <a href="CppOperatorAssign.htm">=</a> subsegtraverse(m);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::splitencsegs(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> triflaws<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri enctri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri testtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub testsh;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub currentenc;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>BadSubSeg *encloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex eorg, edest, eapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex newvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>InsertVertexResult success;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> segmentlength,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> nearestpoweroftwo;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> split;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> multiplier,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> divisor;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> acuteorg, acuteorg2, acutedest, acutedest2;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by stpivot().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by snext().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Note that steinerleft <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1 <b><a href="CppIf.htm">if</a></b> an unlimited number<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;of Steiner <a href="CppPointer.htm">point</a>s is allowed.<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (!m.m_badsubsegs.empty() &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m.m_steinerleft)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (m.m_badsubsegs.m_items &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m.m_steinerleft <a href="CppOperatorNotEqual.htm">!=</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_badsubsegs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>encloop <a href="CppOperatorAssign.htm">=</a> badsubsegtraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> ((encloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (m.m_steinerleft <a href="CppOperatorNotEqual.htm">!=</a> 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> encloop: m.m_badsubsegs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!m.m_steinerleft) <b><a href="CppBreak.htm">break</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> currentenc <a href="CppOperatorAssign.htm">=</a> encloop-&gt;m_encsubseg-&gt;Sdecode();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sdecode(encloop-&gt;m_encsubseg, currentenc);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> eorg <a href="CppOperatorAssign.htm">=</a> currentenc.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(currentenc, eorg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edest <a href="CppOperatorAssign.htm">=</a> currentenc.GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(currentenc, edest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make sure that <b><a href="CppThis.htm">this</a></b> segment is still the same segment it was<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;when it was determined to be encroached.&nbsp;&nbsp;If the segment was<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;enqueued multiple <a href="CppTime.htm">time</a>s (because several newly inserted<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertices encroached it), it may have already been split.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!deadsubseg(currentenc.m_subsegs) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eorg <a href="CppOperatorEqual.htm">==</a> encloop-&gt;m_subsegorg) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (edest <a href="CppOperatorEqual.htm">==</a> encloop-&gt;m_subsegdest)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>To decide where to split a segment, we need to know <b><a href="CppIf.htm">if</a></b> the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segment shares an endpoint with an adjacent segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;The concern is that, <b><a href="CppIf.htm">if</a></b> we simply split every encroached<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segment in its center, two adjacent segments with a small<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;angle between them might lead to an infinite loop; each<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;vertex added to split one segment will encroach upon the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;other segment, which must then be split with a vertex that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;will encroach upon the first segment, and so on forever.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>To avoid <b><a href="CppThis.htm">this</a></b>, imagine a set of concentric circles, whose<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;radii are powers of two, <a href="CppAbout.htm">about</a> each segment endpoint.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;These concentric circles determine where the segment is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;split.&nbsp;&nbsp;(If both endpoints are shared with adjacent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;segments, split the segment in the middle, and apply the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;concentric circles <b><a href="CppFor.htm">for</a></b> later splittings.)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the origin shared with another segment?<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> enctri <a href="CppOperatorAssign.htm">=</a> currentenc.GetStPivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>stpivot(currentenc, enctri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.SetLnext(enctri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(enctri, testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsh <a href="CppOperatorAssign.htm">=</a> testtri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>testtri.Tspivot(testsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(testtri, testsh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> acuteorg <a href="CppOperatorAssign.htm">=</a> testsh.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the destination shared with another segment?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsh <a href="CppOperatorAssign.htm">=</a> testtri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>testtri.Tspivot(testsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(testtri, testsh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> acutedest <a href="CppOperatorAssign.htm">=</a> testsh.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If we're <b><a href="CppUsing.htm">using</a></b> Chew's <a href="CppAlgorithm.htm">algorithm</a> (rather than Ruppert's)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;to define encroachment, <b><a href="CppDelete.htm">delete</a></b> free vertices from the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;subsegment's diametral circle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_conformdel <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !acuteorg <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !acutedest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> eapex <a href="CppOperatorAssign.htm">=</a> enctri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(enctri, eapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (vertextype(eapex) <a href="CppOperatorEqual.htm">==</a> VertexType::FREEVERTEX<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((eorg[0] <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) &lt; 0.0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deletevertex(m, b, &amp;testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enctri <a href="CppOperatorAssign.htm">=</a> currentenc.GetStPivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>stpivot(currentenc, enctri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapex <a href="CppOperatorAssign.htm">=</a> enctri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(enctri, eapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.Lprev(enctri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(enctri, testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Now, check the other side of the segment, <b><a href="CppIf.htm">if</a></b> there's a triangle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;there.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testtri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(enctri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(enctri, testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (testtri.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the destination shared with another segment?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsh <a href="CppOperatorAssign.htm">=</a> testtri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>testtri.Tspivot(testsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(testtri, testsh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> acutedest2 <a href="CppOperatorAssign.htm">=</a> testsh.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acutedest <a href="CppOperatorAssign.htm">=</a> acutedest <a href="CppOperatorLogicalOr.htm">||</a> acutedest2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Is the origin shared with another segment?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.Lnextself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testsh <a href="CppOperatorAssign.htm">=</a> testtri.CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>testtri.Tspivot(testsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(testtri, testsh);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> acuteorg2 <a href="CppOperatorAssign.htm">=</a> testsh.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acuteorg <a href="CppOperatorAssign.htm">=</a> acuteorg <a href="CppOperatorLogicalOr.htm">||</a> acuteorg2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Delete free vertices from the subsegment's diametral circle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_conformdel <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !acuteorg2 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !acutedest2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapex <a href="CppOperatorAssign.htm">=</a> testtri.GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(testtri, eapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertextype(eapex) <a href="CppOperatorEqual.htm">==</a> VertexType::FREEVERTEX<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp; (eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eapex-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorPlus.htm">+</a> (eorg[1] <a href="CppOperatorMinus.htm">-</a> eapex[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eapex[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deletevertex(m, b, &amp;testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> testtri <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(enctri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(enctri, testtri);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapex <a href="CppOperatorAssign.htm">=</a> testtri.GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(testtri, eapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testtri.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(testtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Use the concentric circles <b><a href="CppIf.htm">if</a></b> exactly one endpoint is shared<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;with another adjacent segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (acuteorg <a href="CppOperatorLogicalOr.htm">||</a> acutedest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> segmentlength<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> sqrt((edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eorg-&gt;GetX()) * (edest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> eorg-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;&nbsp;&nbsp;(edest[1] <a href="CppOperatorMinus.htm">-</a> eorg[1]) * (edest[1] <a href="CppOperatorMinus.htm">-</a> eorg[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the power of two that most evenly splits the segment.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;The worst <b><a href="CppCase.htm">case</a></b> is a 2:1 ratio between subsegment lengths.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> nearestpoweroftwo <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (segmentlength &gt; 3.0 * nearestpoweroftwo)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nearestpoweroftwo <a href="CppOperatorMultiplyAssign.htm">*=</a> 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (segmentlength &lt; 1.5 * nearestpoweroftwo)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nearestpoweroftwo <a href="CppOperatorMultiplyAssign.htm">*=</a> 0.5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Where <b><a href="CppDo.htm">do</a></b> we split the segment?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> split <a href="CppOperatorAssign.htm">=</a> nearestpoweroftwo <a href="CppOperatorDivide.htm">/</a> segmentlength;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (acutedest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split <a href="CppOperatorAssign.htm">=</a> 1.0 <a href="CppOperatorMinus.htm">-</a> split;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If we're not worried <a href="CppAbout.htm">about</a> adjacent segments, split<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppThis.htm">this</a></b> segment in the middle.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split <a href="CppOperatorAssign.htm">=</a> 0.5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create the <b><a href="CppNew.htm">new</a></b> vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newvertex <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newvertex <a href="CppOperatorAssign.htm">=</a> (Vertex) PoolAlloc(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Interpolate its coordinate and attributes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2 <a href="CppOperatorPlus.htm">+</a> m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex[i] <a href="CppOperatorAssign.htm">=</a> eorg[i] <a href="CppOperatorPlus.htm">+</a> split * (edest[i] <a href="CppOperatorMinus.htm">-</a> eorg[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_noexact)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Roundoff in the above calculation may yield a `newvertex'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;that is not precisely collinear with `eorg' and `edest'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Improve collinearity by one step of iterative refinement.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> multiplier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, eorg, edest, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> divisor<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ((eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> edest-&gt;GetX()) * (eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> edest-&gt;GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a>&nbsp;&nbsp;(eorg[1] <a href="CppOperatorMinus.htm">-</a> edest[1]) * (eorg[1] <a href="CppOperatorMinus.htm">-</a> edest[1])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((multiplier <a href="CppOperatorNotEqual.htm">!=</a> 0.0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (divisor <a href="CppOperatorNotEqual.htm">!=</a> 0.0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiplier <a href="CppOperatorAssign.htm">=</a> multiplier <a href="CppOperatorDivide.htm">/</a> divisor;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Watch out <b><a href="CppFor.htm">for</a></b> NANs.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (multiplier <a href="CppOperatorEqual.htm">==</a> multiplier)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex-&gt;GetX() <a href="CppOperatorPlusAssign.htm">+=</a> multiplier * (edest[1] <a href="CppOperatorMinus.htm">-</a> eorg[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex[1] <a href="CppOperatorPlusAssign.htm">+=</a> multiplier * (eorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> edest-&gt;GetX());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex.SetMark(currentenc.GetMark());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(newvertex, mark(currentenc));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex.SetVertexType(VertexType::SEGMENTVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertextype(newvertex, VertexType::SEGMENTVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;Splitting subsegment (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) at (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eorg[0], eorg[1], edest[0], edest[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex[0], newvertex[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the <b><a href="CppNew.htm">new</a></b> vertex lies on an endpoint.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((newvertex[0] <a href="CppOperatorEqual.htm">==</a> eorg[0]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> eorg[1])) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((newvertex[0] <a href="CppOperatorEqual.htm">==</a> edest[0]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> edest[1]))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Ran out of precision at ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> newvertex[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> newvertex[1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ").\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "I attempted to split a segment to a smaller size than\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;can be accommodated by the finite precision of\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;floating <a href="CppPointer.htm">point</a> arithmetic.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the splitting vertex.&nbsp;&nbsp;This should always succeed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> InsertVertexResult success<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> insertvertex(m, b, newvertex, &amp;enctri, &amp;currentenc,1, triflaws);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!(success <a href="CppOperatorNotEqual.htm">!=</a> SUCCESSFULVERTEX <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> success <a href="CppOperatorNotEqual.htm">!=</a> ENCROACHINGVERTEX));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((success <a href="CppOperatorNotEqual.htm">!=</a> SUCCESSFULVERTEX) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (success <a href="CppOperatorNotEqual.htm">!=</a> ENCROACHINGVERTEX))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Internal error in splitencsegs():\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Failure to split a segment.\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_steinerleft &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_steinerleft<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check the two <b><a href="CppNew.htm">new</a></b> subsegments to see <b><a href="CppIf.htm">if</a></b> they're encroached.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkseg4encroach(m.m_dummytri,b.m_conformdel,b.m_goodangle,b.m_nobisect,&amp;currentenc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>checkseg4encroach(m, b, &amp;currentenc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snextself(currentenc);<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkseg4encroach(m.m_dummytri,b.m_conformdel,b.m_goodangle,b.m_nobisect,&amp;currentenc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>checkseg4encroach(m, b, &amp;currentenc);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badsubsegdealloc(m, encloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encloop <a href="CppOperatorAssign.htm">=</a> badsubsegtraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::tallyfaces(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> (Triangle *) <a href="CppNULL.htm">NULL</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the triangle is bad, enqueue it.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;testtriangle(m, b, &amp;triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::splittriangle(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt;&amp; badtri<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri badotri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex borg, bdest, bapex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex newvertex;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> xi, eta;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>InsertVertexResult success;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> errorflag;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> badotri <a href="CppOperatorAssign.htm">=</a> badtri-&gt;m_poortri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(badtri-&gt;m_poortri, badotri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> borg <a href="CppOperatorAssign.htm">=</a> badotri.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(badotri, borg);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bdest <a href="CppOperatorAssign.htm">=</a> badotri.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(badotri, bdest);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> bapex <a href="CppOperatorAssign.htm">=</a> badotri.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>apex(badotri, bapex);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Make sure that <b><a href="CppThis.htm">this</a></b> triangle is still the same triangle it was<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;when it was tested and determined to be of bad quality.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Subsequent transformations may have made it a different triangle.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!deadtri(badotri.m_tri) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (borg <a href="CppOperatorEqual.htm">==</a> badtri-&gt;m_triangorg) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bdest <a href="CppOperatorEqual.htm">==</a> badtri-&gt;m_triangdest) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (bapex <a href="CppOperatorEqual.htm">==</a> badtri-&gt;m_triangapex))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Splitting <b><a href="CppThis.htm">this</a></b> triangle at its circumcenter:\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n", borg[0],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; borg[1], bdest[0], bdest[1], bapex[0], bapex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>errorflag <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a <b><a href="CppNew.htm">new</a></b> vertex at the triangle's circumcenter.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newvertex <a href="CppOperatorAssign.htm">=</a> (Vertex) PoolAlloc(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;Vertex newvertex;<br/>
&nbsp;&nbsp;findcircumcenter(m.m_circumcentercount,m.m_<a href="CppCounter.htm">counter</a>clockcount,b.m_noexact,b.m_offconstant, borg, bdest, bapex, newvertex, xi, eta, 1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Check whether the <b><a href="CppNew.htm">new</a></b> vertex lies on a triangle vertex.<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!((newvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> borg-&gt;GetX()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> borg[1])) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((newvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> bdest-&gt;GetX()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> bdest[1])) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((newvertex-&gt;GetX() <a href="CppOperatorEqual.htm">==</a> bapex-&gt;GetX()) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> bapex[1]))<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (((newvertex[0] <a href="CppOperatorEqual.htm">==</a> borg[0]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> borg[1])) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((newvertex[0] <a href="CppOperatorEqual.htm">==</a> bdest[0]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> bdest[1])) <a href="CppOperatorLogicalOr.htm">||</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((newvertex[0] <a href="CppOperatorEqual.htm">==</a> bapex[0]) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (newvertex[1] <a href="CppOperatorEqual.htm">==</a> bapex[1])))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Warning:&nbsp;&nbsp;New vertex (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) falls on existing vertex.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errorflag <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexdealloc(m, newvertex);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 2; i &lt; 2 <a href="CppOperatorPlus.htm">+</a> m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Interpolate the vertex attributes at the circumcenter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex[i] <a href="CppOperatorAssign.htm">=</a> borg[i] <a href="CppOperatorPlus.htm">+</a> xi * (bdest[i] <a href="CppOperatorMinus.htm">-</a> borg[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorPlus.htm">+</a> eta * (bapex[i] <a href="CppOperatorMinus.htm">-</a> borg[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The <b><a href="CppNew.htm">new</a></b> vertex must be in the interior, and therefore is a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;free vertex with a marker of zero.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newvertex.SetMark(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(newvertex, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newvertex.SetVertexType(VertexType::FREEVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertextype(newvertex, VertexType::FREEVERTEX);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that the handle `badotri' does not represent the longest<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge of the triangle.&nbsp;&nbsp;This ensures that the circumcenter must<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;fall to the left of <b><a href="CppThis.htm">this</a></b> edge, so <a href="CppPointer.htm">point</a> location will work.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;(If the angle org-apex-dest exceeds 90 degrees, then the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;circumcenter lies outside the org-dest edge, and eta is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;negative.&nbsp;&nbsp;Roundoff error might prevent eta from being<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;negative when it should be, so I test eta against xi.)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (eta &lt; xi)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;badotri.Lprevself();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(badotri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert the circumcenter, searching from the edge of the triangle,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;and maintain the Delaunay property of the triangulation.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> success <a href="CppOperatorAssign.htm">=</a> insertvertex(m, b, newvertex, &amp;badotri, <b><a href="CppNullptr.htm">nullptr</a></b>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorEqual.htm">==</a> SUCCESSFULVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_steinerleft &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_steinerleft<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorEqual.htm">==</a> ENCROACHINGVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If the newly inserted vertex encroaches upon a subsegment,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> the <b><a href="CppNew.htm">new</a></b> vertex.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undovertex(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Rejecting (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n", newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexdealloc(m, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillVertex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b> (success <a href="CppOperatorEqual.htm">==</a> VIOLATINGVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Failed to insert the <b><a href="CppNew.htm">new</a></b> vertex, but some subsegment was<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;marked as being encroached.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexdealloc(m, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillVertex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>success <a href="CppOperatorEqual.htm">==</a> DUPLICATEVERTEX<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Couldn't insert the <b><a href="CppNew.htm">new</a></b> vertex because a vertex is already there.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Warning:&nbsp;&nbsp;New vertex (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) falls on existing vertex.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newvertex[0], newvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errorflag <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertexdealloc(m, newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.KillVertex(newvertex);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAssert.htm">assert</a>(!errorflag);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (errorflag)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;The <b><a href="CppNew.htm">new</a></b> vertex is at the circumcenter of triangle\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;(" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> borg[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> borg[1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") ("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> bdest[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> bdest[1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ") (" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> bapex[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> bapex[1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ")\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "This probably means that I am trying to refine triangles\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;to a smaller size than can be accommodated by the finite\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;precision of floating <a href="CppPointer.htm">point</a> arithmetic.&nbsp;&nbsp;(You can be\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;sure of <b><a href="CppThis.htm">this</a></b> <b><a href="CppIf.htm">if</a></b> I fail to terminate.)\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppStdEndl.htm">std::endl</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::enforcequality(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>BadTriang *badtri;<br/>
<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppAdd.htm">Add</a>ing Steiner <a href="CppPointer.htm">point</a>s to enforce quality.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the pool of encroached subsegments.<br/>
&nbsp;&nbsp;PoolInit(&amp;m.m_badsubsegs, <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppStruct.htm">struct</a></b> BadSubSeg), BADSUBSEGPERBLOCK,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BADSUBSEGPERBLOCK, 0);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Looking <b><a href="CppFor.htm">for</a></b> encroached subsegments.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test all segments to see <b><a href="CppIf.htm">if</a></b> they're encroached.<br/>
&nbsp;&nbsp;tallyencs(m, b);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (m.m_badsubsegs.m_items &gt; 0)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Splitting encroached subsegments.\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fix encroached subsegments without noting bad triangles.<br/>
&nbsp;&nbsp;splitencsegs(m, b, 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>At <b><a href="CppThis.htm">this</a></b> <a href="CppPointer.htm">point</a>, <b><a href="CppIf.htm">if</a></b> we haven't run out of Steiner <a href="CppPointer.htm">point</a>s, the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;triangulation should be (conforming) Delaunay.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Next, we worry <a href="CppAbout.htm">about</a> enforcing triangle quality.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((b.m_minangle &gt; 0.0) <a href="CppOperatorLogicalOr.htm">||</a> b.m_vararea <a href="CppOperatorLogicalOr.htm">||</a> b.m_fixedarea <a href="CppOperatorLogicalOr.htm">||</a> b.m_usertest)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_queuefront.resize(4096);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the pool of bad triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>PoolInit(&amp;m.m_badtriangles, <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppStruct.htm">struct</a></b> BadTriang), g_bad_triangles_per_block,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_bad_triangles_per_block, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the queues of bad triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 4096; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;m.m_queuefront[i] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> BadTriang *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_firstnonemptyq <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Test all triangles to see <b><a href="CppIf.htm">if</a></b> they're bad.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;tallyfaces(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">Initialize</a> the pool of recently flipped triangles.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>PoolInit(&amp;m.m_flipstackers, <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppStruct.htm">struct</a></b> FlipStacker), FLIPSTACKERPERBLOCK,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLIPSTACKERPERBLOCK, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_checkquality <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Splitting bad triangles.\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m.m_badtriangles.m_items &gt; 0 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> m.m_steinerleft <a href="CppOperatorNotEqual.htm">!=</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fix one bad triangle by inserting a vertex at its circumcenter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> badtri <a href="CppOperatorAssign.htm">=</a> dequeuebadtriang(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splittriangle(m, b, badtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_badsubsegs.m_items &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Put bad triangle back in queue <b><a href="CppFor.htm">for</a></b> another <b><a href="CppTry.htm">try</a></b> later.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Enqueuebadtriang(badtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Fix <a href="CppAny.htm">any</a> encroached subsegments that resulted.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Record <a href="CppAny.htm">any</a> <b><a href="CppNew.htm">new</a></b> bad triangles that result.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitencsegs(m, b, 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Return the bad triangle to the pool.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PoolDealloc(&amp;m.m_badtriangles, (<b><a href="CppVoid.htm">void</a></b> *) badtri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>At <b><a href="CppThis.htm">this</a></b> <a href="CppPointer.htm">point</a>, <b><a href="CppIf.htm">if</a></b> the "-D" <b><a href="CppSwitch.htm">switch</a></b> was selected and we haven't run out<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;of Steiner <a href="CppPointer.htm">point</a>s, the triangulation should be (conforming) Delaunay<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;and have no low-quality triangles.<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Might we have run out of Steiner <a href="CppPointer.htm">point</a>s too soon?<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_quiet <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> b.m_conformdel <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (m.m_badsubsegs.m_items &gt; 0) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m.m_steinerleft <a href="CppOperatorEqual.htm">==</a> 0))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\nWarning:&nbsp;&nbsp;I ran out of Steiner <a href="CppPointer.htm">point</a>s, but the mesh has\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_badsubsegs.m_items <a href="CppOperatorEqual.htm">==</a> 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;one encroached subsegment, and therefore might not be truly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>ld encroached subsegments, and therefore might not be truly\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , m.m_badsubsegs.m_items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Delaunay.&nbsp;&nbsp;If the Delaunay property is important to you,\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<b><a href="CppTry.htm">try</a></b> increasing the number of Steiner <a href="CppPointer.htm">point</a>s (controlled by\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;the <a href="CppOperatorMinus.htm">-</a>S <b><a href="CppSwitch.htm">switch</a></b>) slightly and <b><a href="CppTry.htm">try</a></b> again.\n\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::highorder(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop, trisym;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub checkmark;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex newvertex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex torg, tdest;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!b.m_quiet) {<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppAdd.htm">Add</a>ing vertices <b><a href="CppFor.htm">for</a></b> second-order triangles.\n";<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The following line ensures that dead items in the pool of nodes<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;cannot be allocated <b><a href="CppFor.htm">for</a></b> the extra nodes associated with high<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;order elements.&nbsp;&nbsp;This ensures that the primary nodes (at the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;corners of elements) will occur earlier in the output files, and<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;have lower indices, than the extra nodes.<br/>
&nbsp;&nbsp;m.m_vertices.m_deaditemstack <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; <a href="CppComment.htm">//</a>(<b><a href="CppVoid.htm">void</a></b> *) <a href="CppNULL.htm">NULL</a>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To loop over the set of edges, loop over all triangles, and look at<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the three edges of each triangle.&nbsp;&nbsp;If there isn't another triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent to the edge, operate on the edge.&nbsp;&nbsp;If there is another<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent triangle, operate on the edge only <b><a href="CppIf.htm">if</a></b> the current triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;has a smaller <a href="CppPointer.htm">pointer</a> than its neighbor.&nbsp;&nbsp;This way, each edge is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;considered only once.<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> (Triangle *) <a href="CppNULL.htm">NULL</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient &lt; 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; triangleloop-&gt;m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> trisym <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, trisym);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop-&gt;m_triangles &lt; trisym.m_triangles <a href="CppOperatorLogicalOr.htm">||</a> trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(triangleloop, torg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(triangleloop, tdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Create a <b><a href="CppNew.htm">new</a></b> node in the middle of the edge.&nbsp;&nbsp;Interpolate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;its attributes.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> newvertex <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>newvertex <a href="CppOperatorAssign.htm">=</a> (Vertex) PoolAlloc(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2 <a href="CppOperatorPlus.htm">+</a> m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newvertex[i] <a href="CppOperatorAssign.htm">=</a> 0.5 * (torg[i] <a href="CppOperatorPlus.htm">+</a> tdest[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set the <b><a href="CppNew.htm">new</a></b> node's marker to zero or one, depending on<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;whether it lies on a boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertexmark(newvertex, trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertextype(newvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? VertexType::FREEVERTEX : VertexType::SEGMENTVERTEX<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkmark <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.Tspivot(checkmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(triangleloop, checkmark);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If <b><a href="CppThis.htm">this</a></b> edge is a segment, transfer the marker to the <b><a href="CppNew.htm">new</a></b> node.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkmark.m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertexmark(newvertex, mark(checkmark));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setvertextype(newvertex, VertexType::SEGMENTVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 1) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Creating (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g).\n", newvertex-&gt;GetX(), newvertex[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Record the <b><a href="CppNew.htm">new</a></b> node in the (one or two) adjacent elements.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_triangles[m.m_highorderindex <a href="CppOperatorPlus.htm">+</a> triangleloop-&gt;m_orient] <a href="CppOperatorAssign.htm">=</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Triangle) newvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (trisym.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trisym.m_triangles[m.m_highorderindex <a href="CppOperatorPlus.htm">+</a> trisym.m_orient] <a href="CppOperatorAssign.htm">=</a> (Triangle) newvertex;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> <a href="CppRibi.htm">ribi</a>::tricpp::ReadVertices(<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::ReadNodes(<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh&amp; m,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::PolyFile p;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> v <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppFileToVector.htm">FileToVector</a>(polyfilename);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> first_line_strings <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(v[0],' ');<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(first_line_strings.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_vertices <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(first_line_strings[0]);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> mesh_dimensionality <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(first_line_strings[1]);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_extras <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(first_line_strings[2]);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> n_nodemarkers <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(first_line_strings[3]);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (n_vertices &lt; 3)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Input must have at least three input vertices.\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_invertices <a href="CppOperatorAssign.htm">=</a> n_vertices;<br/>
<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(mesh_dimensionality <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_extras <a href="CppOperatorEqual.htm">==</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(n_nodemarkers <a href="CppOperatorEqual.htm">==</a> 1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppInitialize.htm">initialize</a>vertexpool(m, b);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> n_vertices; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; line <a href="CppOperatorAssign.htm">=</a> v[index];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(line,' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorEqual.htm">==</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> firstnode <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(firstnode <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(w[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> currentmarker <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[3]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop[0] <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop[1] <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(currentmarker <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;setvertexmark(vertexloop, currentmarker);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertextype(vertexloop, VertexType::INPUTVERTEX);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; vertexloop(<b><a href="CppNew.htm">new</a></b> Vertex(x,y,currentmarker);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a> Determine the smallest and largest x and y coordinates<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (i <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_xmin <a href="CppOperatorAssign.htm">=</a> m.m_xmax <a href="CppOperatorAssign.htm">=</a> x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_ymin <a href="CppOperatorAssign.htm">=</a> m.m_ymax <a href="CppOperatorAssign.htm">=</a> y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_xmin <a href="CppOperatorAssign.htm">=</a> (x &lt; m.m_xmin) ? x : m.m_xmin;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_xmax <a href="CppOperatorAssign.htm">=</a> (x &gt; m.m_xmax) ? x : m.m_xmax;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_ymin <a href="CppOperatorAssign.htm">=</a> (y &lt; m.m_ymin) ? y : m.m_ymin;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_ymax <a href="CppOperatorAssign.htm">=</a> (y &gt; m.m_ymax) ? y : m.m_ymax;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Nonexistent x value used as a flag to mark circle events in sweepline<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; Delaunay <a href="CppAlgorithm.htm">algorithm</a>.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_xminextreme <a href="CppOperatorAssign.htm">=</a> 10 * m.m_xmin <a href="CppOperatorMinus.htm">-</a> 9 * m.m_xmax;<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::readholes(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> polyfile,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> polyfilename,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b> &gt;&amp; hlist, <a href="CppComment.htm">//</a>hole list<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ** <b><a href="CppConst.htm">const</a></b> hlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> * <b><a href="CppConst.htm">const</a></b> holes,<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; rlist <a href="CppComment.htm">//</a>region list<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> ** <b><a href="CppConst.htm">const</a></b> rlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> *regions<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> *holelist;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> *regionlist;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppChar.htm">char</a></b> inputline[g_max_inputline_size];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> index;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; v <a href="CppOperatorAssign.htm">=</a> <a href="CppRibi.htm">ribi</a>::<a href="CppFileIo.htm">fileio</a>::<a href="CppFileIo.htm">FileIo</a>().<a href="CppFileToVector.htm">FileToVector</a>(polyfilename);<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;holes <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the holes.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppChar.htm">char</a></b> * stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*holes <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (*holes &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>hlist.resize(holes * 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 1; i<a href="CppOperatorNotEqual.htm">!=</a> 1 <a href="CppOperatorPlus.htm">+</a> holes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(v[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hlist.push_back(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hlist.push_back(y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;holelist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b> *) TriMalloc(2 * *holes * (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*hlist <a href="CppOperatorAssign.htm">=</a> holelist;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 2 * *holes; i <a href="CppOperatorPlusAssign.htm">+=</a> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Hole <a href="CppOperatorModulus.htm">%</a>d has no x coordinate.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> (i <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holelist[i] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Hole <a href="CppOperatorModulus.htm">%</a>d has no y coordinate.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> (i <a href="CppOperatorStreamIn.htm">&gt;&gt;</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holelist[i <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;*hlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b> *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> ((b.m_regionattrib <a href="CppOperatorLogicalOr.htm">||</a> b.m_vararea) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> !b.m_do_refine)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (1 <a href="CppOperatorPlus.htm">+</a> n_holes <a href="CppOperatorGreaterEqual.htm">&gt;=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size())) <b><a href="CppReturn.htm">return</a></b>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(v[1 <a href="CppOperatorPlus.htm">+</a> n_holes] );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regions <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>rlist.resize(regions * 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 1; i<a href="CppOperatorNotEqual.htm">!=</a> 1 <a href="CppOperatorPlus.htm">+</a> holes; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt; w <a href="CppOperatorAssign.htm">=</a> <a href="CppSeperateString.htm">SeperateString</a>(v[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(w.size() <a href="CppOperatorEqual.htm">==</a> 4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x1 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y1 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[1]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x2 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y2 <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostLexical_cast.htm">boost::lexical_cast</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(w[3]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlist.push_back(x1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlist.push_back(y1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlist.push_back(x2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlist.push_back(y2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read the area constraints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (stringptr <a href="CppOperatorEqual.htm">==</a> 0) <b><a href="CppGoto.htm">goto</a></b> my_end; <a href="CppComment.htm">//</a>RJCB<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*regions <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) strtol(stringptr, &amp;stringptr, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*regions &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b> *) TriMalloc(4 * *regions * (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppDouble.htm">double</a></b>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rlist <a href="CppOperatorAssign.htm">=</a> regionlist;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; *regions; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> readline(inputline, polyfile);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Region <a href="CppOperatorModulus.htm">%</a>d has no x coordinate.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionlist[index<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "Error:&nbsp;&nbsp;Region <a href="CppOperatorModulus.htm">%</a>d has no y coordinate.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionlist[index<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Error:&nbsp;&nbsp;Region <a href="CppOperatorModulus.htm">%</a>d has no region attribute or area constraint.\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionlist[index<a href="CppOperatorIncrement.htm">++</a>] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringptr <a href="CppOperatorAssign.htm">=</a> FindField(stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*stringptr <a href="CppOperatorEqual.htm">==</a> '\0') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionlist[index] <a href="CppOperatorAssign.htm">=</a> regionlist[index <a href="CppOperatorMinus.htm">-</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regionlist[index] <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b>) strtod(stringptr, &amp;stringptr);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_end: ;<a href="CppComment.htm">//</a>RJCB<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppComment.htm">//</a>Set `*regions' to zero to avoid an accidental free() later.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;*regions <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;*rlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppDouble.htm">double</a></b> *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>fclose(polyfile);<br/>
}<br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> finishfile()&nbsp;&nbsp; Write the command line to the output file so the user<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can remember how the file was generated.&nbsp;&nbsp;Close the file.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> finishfile(<br/>
&nbsp;&nbsp;<a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> outfile,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> <a href="CppArgc.htm">argc</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(args.size());<br/>
&nbsp;&nbsp;<a href="CppStd.htm">std</a>::f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, "# Generated by");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> <a href="CppArgc.htm">argc</a>; <a href="CppOperatorIncrement.htm">++</a>i) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStd.htm">std</a>::f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, " ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdFputs.htm">std::fputs</a>(args[i].c_str(), outfile);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppStd.htm">std</a>::f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, "\n");<br/>
&nbsp;&nbsp;<a href="CppStdFclose.htm">std::fclose</a>(outfile);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writenodes(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; nodefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *outfile <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex vertexloop;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> outvertices<br/>
&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> b.m_do_jettison<br/>
&nbsp;&nbsp; ? <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m.m_vertices.size()) <a href="CppOperatorMinus.htm">-</a> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m.m_undeads.size())<br/>
&nbsp;&nbsp; : <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m.m_vertices.size())<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> vertexnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (b.m_jettison)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;outvertices <a href="CppOperatorAssign.htm">=</a> m.m_vertices.m_items <a href="CppOperatorMinus.htm">-</a> m.m_undeads;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;outvertices <a href="CppOperatorAssign.htm">=</a> m.m_vertices.m_items;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> outfile <a href="CppOperatorAssign.htm">=</a> fopen(nodefilename.c_str(),"w");<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> nodefile(nodefilename.c_str());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of vertices, number of dimensions, number of vertex attributes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;and number of boundary markers (zero or one).<br/>
&nbsp;&nbsp;nodefile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outvertices <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "2" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppComment.htm">//</a>m.m_mesh_dim,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_nextras <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (1 <a href="CppOperatorMinus.htm">-</a> b.m_nobound);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> vertexnumber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> vertexloop: m.m_vertices)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (vertexloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_do_jettison <a href="CppOperatorLogicalOr.htm">||</a> vertexloop-&gt;GetType() <a href="CppOperatorNotEqual.htm">!=</a> VertexType::UNDEADVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!b.m_jettison <a href="CppOperatorLogicalOr.htm">||</a> vertextype(vertexloop) <a href="CppOperatorNotEqual.htm">!=</a> VertexType::UNDEADVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex number, x and y coordinates.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodefile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexnumber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop-&gt;GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppComment.htm">//</a>No endline<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Write an attribute.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodefile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop[i <a href="CppOperatorPlus.htm">+</a> 2] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_nobound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodefile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Write the boundary marker.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodefile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop.GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexmark(vertexloop) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertexloop-&gt;SetMark(vertexnumber);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(vertexloop, vertexnumber);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertexnumber<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finishfile(outfile, args);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::numbernodes(Mesh&amp; m, <b><a href="CppConst.htm">const</a></b> Arguments&amp; b)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex vertexloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> vertexnumber;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> vertexnumber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> vertexloo: m.m_vertices)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (vertexloop <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexloo-&gt;SetMark(vertexnumber);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>setvertexmark(vertexloop, vertexnumber);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_do_jettison <a href="CppOperatorLogicalOr.htm">||</a> vertextype(vertexloop) <a href="CppOperatorNotEqual.htm">!=</a> VertexType::UNDEADVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>vertexnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writeelements(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; elefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *outfile;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex p1, p2, p3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex mid1, mid2, mid3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> elementnumber;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> outfile(elefilename.c_str());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * <b><a href="CppConst.htm">const</a></b> outfile <a href="CppOperatorAssign.htm">=</a> fopen(elefilename.c_str(), "w");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of triangles, vertices per triangle, attributes per triangle.<br/>
&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_triangles.m_items <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ((b.m_order <a href="CppOperatorPlus.htm">+</a> 1) * (b.m_order <a href="CppOperatorPlus.htm">+</a> 2) <a href="CppOperatorDivide.htm">/</a> 2) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_eextras <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, "%ld&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", m.m_triangles.m_items,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b.m_order <a href="CppOperatorPlus.htm">+</a> 1) * (b.m_order <a href="CppOperatorPlus.htm">+</a> 2) <a href="CppOperatorDivide.htm">/</a> 2, m.m_eextras);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> elementnumber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangle_loop: m.m_triangles)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p1 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(triangleloop, p1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p2 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(triangleloop, p2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p3 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(triangleloop, p3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_order <a href="CppOperatorEqual.htm">==</a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle number, indices <b><a href="CppFor.htm">for</a></b> three vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elementnumber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1.GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2.GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p3.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> mid1 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;m_triangles[m.m_highorderindex <a href="CppOperatorPlus.htm">+</a> 1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> mid2 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;m_triangles[m.m_highorderindex <a href="CppOperatorPlus.htm">+</a> 2];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> mid3 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;m_triangles[m.m_highorderindex];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle number, indices <b><a href="CppFor.htm">for</a></b> six vertices.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elementnumber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1.GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2.GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p3.GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> mid1-&gt;GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> mid2-&gt;GetMark() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> mid3-&gt;GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i <a href="CppOperatorNotEqual.htm">!=</a> m.m_eextras; <a href="CppOperatorIncrement.htm">++</a>i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> triangleloop-&gt;GetElemAttrib() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n";<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>elementnumber;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finishfile(outfile, args);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writepoly(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; polyfilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; holes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> holelist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> holes,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;&amp; regions,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> * <b><a href="CppConst.htm">const</a></b> regionlist,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> regions,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *outfile;<br/>
 <a href="CppComment.htm">//</a> <b><a href="CppLong.htm">long</a></b> hol<b><a href="CppEnum.htm">enum</a></b>ber, regionnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub subsegloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex endpoint1, endpoint2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> subsegnumber;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> outfile(polyfilename.c_str());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The zero indicates that the vertices are in a separate .node file.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Followed by number of dimensions, number of vertex attributes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;and number of boundary markers (zero or one).<br/>
&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 0 <a href="CppComment.htm">//</a>vertices are in a separate .node file.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 2 <a href="CppComment.htm">//</a>mesh_dim<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_nextras<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (1 <a href="CppOperatorMinus.htm">-</a> b.m_nobound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of segments, number of boundary markers (zero or one).<br/>
&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_subsegs.m_items <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (1 <a href="CppOperatorMinus.htm">-</a> b.m_nobound) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_subsegs);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subsegs <a href="CppOperatorAssign.htm">=</a> subsegtraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>subsegloop-&gt;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> subsegnumber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> subsegloop m.m_subsegs)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (subsegloop-&gt;m_subsegs <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint1 <a href="CppOperatorAssign.htm">=</a> subsegloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(subsegloop, endpoint1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> endpoint2 <a href="CppOperatorAssign.htm">=</a> subsegloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(subsegloop, endpoint2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Segment number, indices of its two endpoints, and possibly a marker.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_nobound)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> subsegnumber<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> endpoint1.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> endpoint2.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> subsegnumber<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> endpoint1.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> endpoint2.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> subsegloop-&gt;GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subsegloop-&gt;m_subsegs <a href="CppOperatorAssign.htm">=</a> subsegtraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subsegnumber<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> holes <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> hol<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> 0; hol<b><a href="CppEnum.htm">enum</a></b>ber &lt; holes; hol<b><a href="CppEnum.htm">enum</a></b>ber<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Hole number, x and y coordinates.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> hol<b><a href="CppEnum.htm">enum</a></b>ber)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> holelist[2 * hol<b><a href="CppEnum.htm">enum</a></b>ber]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> holelist[2 * hol<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorPlus.htm">+</a> 1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (regions &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> regions <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> regionnumber <a href="CppOperatorAssign.htm">=</a> 0; regionnumber &lt; regions; regionnumber<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Region number, x and y coordinates, attribute, maximum area.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (b.m_firstnumber <a href="CppOperatorPlus.htm">+</a> regionnumber)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> regionlist[4 * regionnumbe&nbsp;&nbsp;<a href="CppOperatorPlus.htm">+</a> 0]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> regionlist[4 * regionnumber <a href="CppOperatorPlus.htm">+</a> 1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> regionlist[4 * regionnumber <a href="CppOperatorPlus.htm">+</a> 2]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> regionlist[4 * regionnumber <a href="CppOperatorPlus.htm">+</a> 3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;finishfile(outfile, args);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writeedges(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; edgefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *outfile;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri trisym;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Osub checkmark;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex p1, p2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> edg<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg sptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Temporary variable used by tspivot().<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> outfile(edgefilename.c_str());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of edges, number of boundary markers (zero or one).<br/>
&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_edges <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' ' <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (1 <a href="CppOperatorMinus.htm">-</a> b.m_nobound) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> edg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To loop over the set of edges, loop over all triangles, and look at<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the three edges of each triangle.&nbsp;&nbsp;If there isn't another triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent to the edge, operate on the edge.&nbsp;&nbsp;If there is another<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent triangle, operate on the edge only <b><a href="CppIf.htm">if</a></b> the current triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;has a smaller <a href="CppPointer.htm">pointer</a> than its neighbor.&nbsp;&nbsp;This way, each edge is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;considered only once.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> trinagleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient &lt; 3; triangleloop-&gt;m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> trisym <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, trisym);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop-&gt;m_triangles &lt; trisym.m_triangles <a href="CppOperatorLogicalOr.htm">||</a> trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p1 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>org(triangleloop, p1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p2 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>dest(triangleloop, p2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_nobound) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Edge number, indices of two endpoints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edg<b><a href="CppEnum.htm">enum</a></b>ber<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1.GetMark() <a href="CppComment.htm">//</a>vertexmark(p1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2.GetMark() <a href="CppComment.htm">//</a>vertexmark(p2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Edge number, indices of two endpoints, and a boundary marker.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;If there's no subsegment, the boundary marker is zero.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> checkmark <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;CreateTspivot();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.Tspivot(checkmark);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>tspivot(triangleloop, checkmark);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (checkmark.m_subsegs <a href="CppOperatorEqual.htm">==</a> m.m_dummysub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edg<b><a href="CppEnum.htm">enum</a></b>ber<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 0 <a href="CppComment.htm">//</a>Marker: no subsegment, thus zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edg<b><a href="CppEnum.htm">enum</a></b>ber<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a>' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> checkmark.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> edg<b><a href="CppEnum.htm">enum</a></b>ber<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2.GetMark()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ' '<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edg<b><a href="CppEnum.htm">enum</a></b>ber<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;finishfile(outfile, args);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writevoronoi(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; vnodefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; vedgefilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop, trisym;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex torg, tdest, tapex;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> vnod<b><a href="CppEnum.htm">enum</a></b>ber, vedg<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> p1, p2;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> * outfile <a href="CppOperatorAssign.htm">=</a> fopen(vnodefilename.c_str(), "w");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of triangles, two dimensions, number of vertex attributes,<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;no markers.<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> outfile(vnodefilename.c_str());<br/>
&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_triangles.m_items <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 2 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_nextras <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 0 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> vnod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(triangleloop, torg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(triangleloop, tdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tapex <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(triangleloop, tapex);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> xi <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> eta <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; circumcenter(2,0.0); <a href="CppComment.htm">//</a>X and Y coordinat<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;findcircumcenter(m.m_circumcentercount,m.m_<a href="CppCounter.htm">counter</a>clockcount,b.m_noexact,b.m_offconstant, torg, tdest, tapex, circumcenter, &amp;xi, &amp;eta, 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Voronoi vertex number, x and y coordinates.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vnod<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> circumcenter[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> circumcenter[1];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, "%4ld&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.17g&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.17g", vnod<b><a href="CppEnum.htm">enum</a></b>ber, circumcenter[0],circumcenter[1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 2; i &lt; 2 <a href="CppOperatorPlus.htm">+</a> m.m_nextras; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Interpolate the vertex attributes at the circumcenter.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (torg[i] <a href="CppOperatorPlus.htm">+</a> xi * (tdest[i] <a href="CppOperatorMinus.htm">-</a> torg[i]) <a href="CppOperatorPlus.htm">+</a> eta * (tapex[i] <a href="CppOperatorMinus.htm">-</a> torg[i])) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, "&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.17g", torg[i] <a href="CppOperatorPlus.htm">+</a> xi * (tdest[i] <a href="CppOperatorMinus.htm">-</a> torg[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorPlus.htm">+</a> eta * (tapex[i] <a href="CppOperatorMinus.htm">-</a> torg[i]));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>f<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outfile, "\n";<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* (<b><a href="CppInt.htm">int</a></b> *) (triangleloop-&gt;m_triangles <a href="CppOperatorPlus.htm">+</a> 6) <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) vnod<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vnod<b><a href="CppEnum.htm">enum</a></b>ber<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finishfile(outfile, args);<br/>
<br/>
&nbsp;&nbsp;outfile.close();<br/>
&nbsp;&nbsp;outfile.open(vedgefilename.c_str());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>outfile <a href="CppOperatorAssign.htm">=</a> fopen(vedgefilename.c_str(), "w");<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of edges, zero boundary markers.<br/>
&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_edges <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 0 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> vedg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>To loop over the set of edges, loop over all triangles, and look at<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;the three edges of each triangle.&nbsp;&nbsp;If there isn't another triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent to the edge, operate on the edge.&nbsp;&nbsp;If there is another<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;adjacent triangle, operate on the edge only <b><a href="CppIf.htm">if</a></b> the current triangle<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;has a smaller <a href="CppPointer.htm">pointer</a> than its neighbor.&nbsp;&nbsp;This way, each edge is<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;considered only once.<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0; triangleloop-&gt;m_orient &lt; 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; triangleloop-&gt;m_orient<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> trisym <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, trisym);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triangleloop-&gt;m_triangles &lt; trisym.m_triangles <a href="CppOperatorLogicalOr.htm">||</a> trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the number of <b><a href="CppThis.htm">this</a></b> triangle (and Voronoi vertex).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> p1 <a href="CppOperatorAssign.htm">=</a> * (<b><a href="CppInt.htm">int</a></b> *) (triangleloop-&gt;m_triangles <a href="CppOperatorPlus.htm">+</a> 6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (trisym.m_triangles <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> torg <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(triangleloop, torg);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> tdest <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(triangleloop, tdest);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Write an infinite ray.&nbsp;&nbsp;Edge number, index of one endpoint, <a href="CppOperatorMinus.htm">-</a>1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;and x and y coordinates of a vector representing the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;direction of the ray.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vedg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> <a href="CppOperatorMinus.htm">-</a>1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (tdest[1] <a href="CppOperatorMinus.htm">-</a> torg[1]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ( torg[0] <a href="CppOperatorMinus.htm">-</a> tdest[0]) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find the number of the adjacent triangle (and Voronoi vertex).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> p2 <a href="CppOperatorAssign.htm">=</a> * (<b><a href="CppInt.htm">int</a></b> *) (trisym.m_triangles <a href="CppOperatorPlus.htm">+</a> 6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Finite edge.&nbsp;&nbsp;Write indices of two endpoints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vedg<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> p2 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>vedg<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>finishfile(outfile, args);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writeneighbors(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; neighborfilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *outfile;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri trisym;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppLong.htm">long</a></b> elementnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> neighbor1, neighbor2, neighbor3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Temporary variable used by sym().<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> outfile(neighborfilename.c_str());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of triangles, three neighbors per triangle.<br/>
&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_triangles.m_items <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> 3 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> elementnumber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;SetElementNumber(elementnumber);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>* (<b><a href="CppInt.htm">int</a></b> *) (triangleloop.m_triangles <a href="CppOperatorPlus.htm">+</a> 6) <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) elementnumber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorIncrement.htm">++</a>elementnumber;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>* (<b><a href="CppInt.htm">int</a></b> *) (m.m_dummytri <a href="CppOperatorPlus.htm">+</a> 6) <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;elementnumber <a href="CppOperatorAssign.htm">=</a> b.m_firstnumber;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 1;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppAuto.htm">auto</a></b> trisym <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, trisym);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> neighbor1 <a href="CppOperatorAssign.htm">=</a> * (<b><a href="CppInt.htm">int</a></b> *) (trisym.m_triangles <a href="CppOperatorPlus.htm">+</a> 6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 2;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trisym <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, trisym);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> neighbor2 <a href="CppOperatorAssign.htm">=</a> * (<b><a href="CppInt.htm">int</a></b> *) (trisym.m_triangles <a href="CppOperatorPlus.htm">+</a> 6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trisym <a href="CppOperatorAssign.htm">=</a> Otri::CreateSym(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(triangleloop, trisym);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> neighbor3 <a href="CppOperatorAssign.htm">=</a> * (<b><a href="CppInt.htm">int</a></b> *) (trisym.m_triangles <a href="CppOperatorPlus.htm">+</a> 6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle number, neighboring triangle numbers.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> elementnumber <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> neighbor1 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> neighbor2 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> neighbor3 <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elementnumber<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;finishfile(outfile, args);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::writeoff(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; offfilename,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppCfile.htm">FILE</a> *outfile;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex vertexloop;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex p1, p2, p3;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> outvertices <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_do_jettison)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outvertices <a href="CppOperatorAssign.htm">=</a> m.m_vertices.m_items <a href="CppOperatorMinus.htm">-</a> m.m_undeads;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outvertices <a href="CppOperatorAssign.htm">=</a> m.m_vertices.m_items;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdOfstream.htm">std::ofstream</a> outfile(offfilename.c_str());<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Number of vertices, triangles, and edges.<br/>
&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "OFF\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> outvertices <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_triangles.m_items <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_edges <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Write the vertices.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (vertexloop)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> vertexloop: m.m_vertices)<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_do_jettison <a href="CppOperatorLogicalOr.htm">||</a> vertexloop.GetVertexType() <a href="CppOperatorNotEqual.htm">!=</a> VertexType::UNDEADVERTEX)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!b.m_jettison <a href="CppOperatorLogicalOr.htm">||</a> (vertextype(vertexloop) <a href="CppOperatorNotEqual.htm">!=</a> VertexType::UNDEADVERTEX))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The OFF format uses 3D coordinates<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> z <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop-&gt;GetX() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> vertexloop-&gt;GetY() <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> z <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertexloop <a href="CppOperatorAssign.htm">=</a> vertextraverse(m);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Write the triangles.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b>(<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p1 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(triangleloop, p1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p2 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(triangleloop, p2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> p3 <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(triangleloop, p3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>The "3" means a three-vertex polygon.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;outfile <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " 3&nbsp;&nbsp; "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (vertexmark(p1) <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (vertexmark(p2) <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (vertexmark(p3) <a href="CppOperatorMinus.htm">-</a> b.m_firstnumber)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;finishfile(outfile, args);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::quality_statistics(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri triangleloop;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> p(3);<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> cossquaretable[8];<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> ratiotable[16];<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> dx[3], dy[3];<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> edgelength[3];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> dotproduct;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> cossquare;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> triarea;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> shortest, longest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> trilongest2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> smallestarea, biggestarea;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> triminaltitude2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> minaltitude;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> triaspect2;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> worstaspect;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> smallestangle, biggestangle;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> radconst, degconst;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> angletable[18];<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; aspecttable(16,0.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> aspectindex;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> tendegree;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> acutebiggest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> i, ii, j, k;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> radconst <a href="CppOperatorAssign.htm">=</a> <a href="CppBoost.htm">boost</a>::math::constants::pi&lt;<b><a href="CppDouble.htm">double</a></b>&gt;() <a href="CppOperatorDivide.htm">/</a> 18.0;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> degconst <a href="CppOperatorAssign.htm">=</a> 180.0 <a href="CppOperatorDivide.htm">/</a> <a href="CppBoost.htm">boost</a>::math::constants::pi&lt;<b><a href="CppDouble.htm">double</a></b>&gt;();<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 8; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cossquaretable[i]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppStdPow.htm">std::pow</a>(<a href="CppStdCos.htm">std::cos</a>(radconst * <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(i <a href="CppOperatorPlus.htm">+</a> 1)),2.0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>cossquaretable[i] <a href="CppOperatorAssign.htm">=</a> cossquaretable[i] * cossquaretable[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 18; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;angletable[i] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;ratiotable[0]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[1]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;ratiotable[2]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[3]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp; 3.0;<br/>
&nbsp;&nbsp;ratiotable[4]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[5]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp; 6.0;<br/>
&nbsp;&nbsp;ratiotable[6]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp; 10.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[7]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;15.0;<br/>
&nbsp;&nbsp;ratiotable[8]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp; 25.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[9]&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;50.0;<br/>
&nbsp;&nbsp;ratiotable[10] <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp;100.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[11] <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp; 300.0;<br/>
&nbsp;&nbsp;ratiotable[12] <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp; 1000.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[13] <a href="CppOperatorAssign.htm">=</a> 10000.0;<br/>
&nbsp;&nbsp;ratiotable[14] <a href="CppOperatorAssign.htm">=</a> 100000.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ratiotable[15] <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;&nbsp;&nbsp; 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 16; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;aspecttable[i] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> minaltitude <a href="CppOperatorAssign.htm">=</a> <a href="CppStdPow.htm">std::pow</a>(m.m_xmax <a href="CppOperatorMinus.htm">-</a> m.m_xmin <a href="CppOperatorPlus.htm">+</a> m.m_ymax <a href="CppOperatorMinus.htm">-</a> m.m_ymin,2.0);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>minaltitude <a href="CppOperatorAssign.htm">=</a> minaltitude * minaltitude;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> shortest <a href="CppOperatorAssign.htm">=</a> minaltitude;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> longest <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> smallestarea <a href="CppOperatorAssign.htm">=</a> minaltitude;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> biggestarea <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> worstaspect <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> smallestangle <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> biggestangle <a href="CppOperatorAssign.htm">=</a> 2.0;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> acutebiggest <a href="CppOperatorAssign.htm">=</a> 1;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>TraversalInit(&amp;m.m_triangles);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppWhile.htm">while</a></b> (triangleloop.m_triangles <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> triangleloop: m.m_triangles)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(triangleloop);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangleloop-&gt;m_orient <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p[0] <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetOrigin();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetOrigin(triangleloop, p[0]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p[1] <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetDest();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetDest(triangleloop, p[1]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;p[2] <a href="CppOperatorAssign.htm">=</a> triangleloop-&gt;GetApex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>GetApex(triangleloop, p[2]);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> trilongest2 <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 3; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorModulus.htm">%</a> 3; <a href="CppComment.htm">//</a>plus1mod3_cpp[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> k <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 2 <a href="CppOperatorModulus.htm">%</a> 3; <a href="CppComment.htm">//</a>minus1mod3_cpp[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx[i] <a href="CppOperatorAssign.htm">=</a> p[j][0] <a href="CppOperatorMinus.htm">-</a> p[k][0];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy[i] <a href="CppOperatorAssign.htm">=</a> p[j][1] <a href="CppOperatorMinus.htm">-</a> p[k][1];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edgelength[i] <a href="CppOperatorAssign.htm">=</a> dx[i] * dx[i] <a href="CppOperatorPlus.htm">+</a> dy[i] * dy[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgelength[i] &gt; trilongest2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trilongest2 <a href="CppOperatorAssign.htm">=</a> edgelength[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgelength[i] &gt; longest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longest <a href="CppOperatorAssign.htm">=</a> edgelength[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (edgelength[i] &lt; shortest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shortest <a href="CppOperatorAssign.htm">=</a> edgelength[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> triarea <a href="CppOperatorAssign.htm">=</a> <a href="CppCounter.htm">counter</a>clockwise(m_m_<a href="CppCounter.htm">counter</a>clockcount, b_m_noexact, p[0], p[1], p[2]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triarea &lt; smallestarea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallestarea <a href="CppOperatorAssign.htm">=</a> triarea;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triarea &gt; biggestarea)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biggestarea <a href="CppOperatorAssign.htm">=</a> triarea;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> triminaltitude2 <a href="CppOperatorAssign.htm">=</a> triarea * triarea <a href="CppOperatorDivide.htm">/</a> trilongest2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triminaltitude2 &lt; minaltitude)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minaltitude <a href="CppOperatorAssign.htm">=</a> triminaltitude2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> triaspect2 <a href="CppOperatorAssign.htm">=</a> trilongest2 <a href="CppOperatorDivide.htm">/</a> triminaltitude2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (triaspect2 &gt; worstaspect)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worstaspect <a href="CppOperatorAssign.htm">=</a> triaspect2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> aspectindex <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (triaspect2 &gt; ratiotable[aspectindex] * ratiotable[aspectindex]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> aspectindex &lt; 15)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aspectindex<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;aspecttable[aspectindex]<a href="CppOperatorIncrement.htm">++</a>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 3; i<a href="CppOperatorIncrement.htm">++</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> j <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorModulus.htm">%</a> 3; <a href="CppComment.htm">//</a>plus1mod3_cpp[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> k <a href="CppOperatorAssign.htm">=</a> i <a href="CppOperatorPlus.htm">+</a> 2 <a href="CppOperatorModulus.htm">%</a> 3; <a href="CppComment.htm">//</a>minus1mod3_cpp[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dotproduct <a href="CppOperatorAssign.htm">=</a> dx[j] * dx[k] <a href="CppOperatorPlus.htm">+</a> dy[j] * dy[k];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> cossquare <a href="CppOperatorAssign.htm">=</a> dotproduct * dotproduct <a href="CppOperatorDivide.htm">/</a> (edgelength[j] * edgelength[k]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> tendegree <a href="CppOperatorAssign.htm">=</a> 8;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b> ii <a href="CppOperatorAssign.htm">=</a> 7; ii <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0; ii<a href="CppOperatorDecrement.htm">--</a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cossquare &gt; cossquaretable[ii])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tendegree <a href="CppOperatorAssign.htm">=</a> ii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (dotproduct <a href="CppOperatorLessEqual.htm">&lt;=</a> 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angletable[tendegree]<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (cossquare &gt; smallestangle)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallestangle <a href="CppOperatorAssign.htm">=</a> cossquare;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (acutebiggest <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (cossquare &lt; biggestangle))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biggestangle <a href="CppOperatorAssign.htm">=</a> cossquare;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angletable[17 <a href="CppOperatorMinus.htm">-</a> tendegree]<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (acutebiggest <a href="CppOperatorLogicalOr.htm">||</a> cossquare &gt; biggestangle)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biggestangle <a href="CppOperatorAssign.htm">=</a> cossquare;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acutebiggest <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangleloop.m_triangles <a href="CppOperatorAssign.htm">=</a> triangletraverse(m);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;shortest <a href="CppOperatorAssign.htm">=</a> sqrt(shortest);<br/>
&nbsp;&nbsp;longest <a href="CppOperatorAssign.htm">=</a> sqrt(longest);<br/>
&nbsp;&nbsp;minaltitude <a href="CppOperatorAssign.htm">=</a> sqrt(minaltitude);<br/>
&nbsp;&nbsp;worstaspect <a href="CppOperatorAssign.htm">=</a> sqrt(worstaspect);<br/>
&nbsp;&nbsp;smallestarea <a href="CppOperatorMultiplyAssign.htm">*=</a> 0.5;<br/>
&nbsp;&nbsp;biggestarea <a href="CppOperatorMultiplyAssign.htm">*=</a> 0.5;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (smallestangle <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 1.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;smallestangle <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;smallestangle <a href="CppOperatorAssign.htm">=</a> degconst * acos(sqrt(smallestangle));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (biggestangle <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 1.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;biggestangle <a href="CppOperatorAssign.htm">=</a> 180.0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (acutebiggest)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biggestangle <a href="CppOperatorAssign.htm">=</a> degconst * acos(sqrt(biggestangle));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biggestangle <a href="CppOperatorAssign.htm">=</a> 180.0 <a href="CppOperatorMinus.htm">-</a> degconst * acos(sqrt(biggestangle));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Smallest area: <a href="CppOperatorModulus.htm">%</a>16.5g&nbsp;&nbsp; |&nbsp;&nbsp;Largest area: <a href="CppOperatorModulus.htm">%</a>16.5g\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smallestarea, biggestarea;<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Shortest edge: <a href="CppOperatorModulus.htm">%</a>16.5g&nbsp;&nbsp; |&nbsp;&nbsp;Longest edge: <a href="CppOperatorModulus.htm">%</a>16.5g\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortest, longest;<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Shortest altitude: <a href="CppOperatorModulus.htm">%</a>12.5g&nbsp;&nbsp; |&nbsp;&nbsp;Largest aspect ratio: <a href="CppOperatorModulus.htm">%</a>8.5g\n\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minaltitude, worstaspect;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Triangle aspect ratio histogram:\n");<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;1.1547 <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>-6.6g&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d&nbsp;&nbsp;&nbsp;&nbsp;| <a href="CppOperatorModulus.htm">%</a>6.6g <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>-6.6g&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ratiotable[0], aspecttable[0], ratiotable[7], ratiotable[8],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aspecttable[8];<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 1; i &lt; 7; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>6.6g <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>-6.6g&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d&nbsp;&nbsp;&nbsp;&nbsp;| <a href="CppOperatorModulus.htm">%</a>6.6g <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>-6.6g&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ratiotable[i <a href="CppOperatorMinus.htm">-</a> 1], ratiotable[i], aspecttable[i],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ratiotable[i <a href="CppOperatorPlus.htm">+</a> 7], ratiotable[i <a href="CppOperatorPlus.htm">+</a> 8], aspecttable[i <a href="CppOperatorPlus.htm">+</a> 8];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>6.6g <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>-6.6g&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d&nbsp;&nbsp;&nbsp;&nbsp;| <a href="CppOperatorModulus.htm">%</a>6.6g <a href="CppOperatorMinus.htm">-</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ratiotable[6], ratiotable[7], aspecttable[7], ratiotable[14],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aspecttable[15]);<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(Aspect ratio is longest edge divided by shortest altitude)\n\n");<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Smallest angle: <a href="CppOperatorModulus.htm">%</a>15.5g&nbsp;&nbsp; |&nbsp;&nbsp;Largest angle: <a href="CppOperatorModulus.htm">%</a>15.5g\n\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smallestangle, biggestangle);<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Angle histogram:\n");<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; 9; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>3d <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>3d degrees:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>3d <a href="CppOperatorMinus.htm">-</a> <a href="CppOperatorModulus.htm">%</a>3d degrees:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>8d\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i * 10, i * 10 <a href="CppOperatorPlus.htm">+</a> 10, angletable[i],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i * 10 <a href="CppOperatorPlus.htm">+</a> 90, i * 10 <a href="CppOperatorPlus.htm">+</a> 100, angletable[i <a href="CppOperatorPlus.htm">+</a> 9]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n");<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::statistics(<br/>
&nbsp;&nbsp;Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\nStatistics:\n\n");<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Input vertices: <a href="CppOperatorModulus.htm">%</a>d\n" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_invertices;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_do_refine) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Input triangles: <a href="CppOperatorModulus.htm">%</a>d\n", m.m_inelements);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Input segments: <a href="CppOperatorModulus.htm">%</a>d\n"<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_insegments;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!b.m_do_refine) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Input holes: <a href="CppOperatorModulus.htm">%</a>d\n" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> m.m_holes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n&nbsp;&nbsp;Mesh vertices: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_vertices.m_items <a href="CppOperatorMinus.htm">-</a> m.m_undeads);<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Mesh triangles: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_triangles.m_items);<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Mesh edges: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_edges);<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Mesh exterior boundary edges: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_hullsize);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_do_refine)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Mesh interior boundary edges: <a href="CppOperatorModulus.htm">%</a>ld\n" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_subsegs.m_items <a href="CppOperatorMinus.htm">-</a> m.m_hullsize);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Mesh subsegments (constrained edges): <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_subsegs.m_items);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;quality_statistics(m, b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppMemory.htm">Memory</a> allocation statistics:\n\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of vertices: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_vertices.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of triangles: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_triangles.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_subsegs.m_maxitems &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of subsegments: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_subsegs.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_viri.m_maxitems &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of viri: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_viri.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_badsubsegs.m_maxitems &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of encroached subsegments: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_badsubsegs.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_badtriangles.m_maxitems &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of bad triangles: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_badtriangles.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_flipstackers.m_maxitems &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of stacked triangle flips: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_flipstackers.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_splaynodes.m_maxitems &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Maximum number of splay tree nodes: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_splaynodes.m_maxitems);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Approximate heap <a href="CppMemory.htm">memory</a> use (bytes): <a href="CppOperatorModulus.htm">%</a>ld\n\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_vertices.m_maxitems * m.m_vertices.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_triangles.m_maxitems * m.m_triangles.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_subsegs.m_maxitems * m.m_subsegs.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_viri.m_maxitems * m.m_viri.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_badsubsegs.m_maxitems * m.m_badsubsegs.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_badtriangles.m_maxitems * m.m_badtriangles.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_flipstackers.m_maxitems * m.m_flipstackers.m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_splaynodes.m_maxitems * m.m_splaynodes.m_itembytes);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "<a href="CppAlgorithm.htm">Algorithm</a>ic statistics:\n\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (!b.m_weighted)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Number of incircle tests: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_incirclecount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Number of 2D orientation tests: <a href="CppOperatorModulus.htm">%</a>ld\n", m.m_<a href="CppCounter.htm">counter</a>clockcount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_hyperbolacount &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Number of right-of-hyperbola tests: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_hyperbolacount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_circletopcount &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Number of circle top computations: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_circletopcount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_circumcentercount &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Number of triangle circumcenter computations: <a href="CppOperatorModulus.htm">%</a>ld\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.m_circumcentercount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> CARE_TODAY_20140602<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::triangle_cpp_main(<b><a href="CppConst.htm">const</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppStdString.htm">std::string</a>&gt;&amp; args)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppUsing.htm">using</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Vertex;<br/>
&nbsp;&nbsp;<b><a href="CppUsing.htm">using</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Edge;<br/>
&nbsp;&nbsp;<b><a href="CppUsing.htm">using</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Triangle;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Vertices;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> Triangles;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mesh m;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments arguments(args);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> mesh <a href="CppOperatorAssign.htm">=</a> MeshBuilder().Create(arguments);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; hole<a href="CppArray.htm">array</a>; <a href="CppComment.htm">//</a><a href="CppArray.htm">Array</a> of holes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; region<a href="CppArray.htm">array</a>; <a href="CppComment.htm">//</a><a href="CppArray.htm">Array</a> of regional attributes and area constraints.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>mesh.m_steinerleft <a href="CppOperatorAssign.htm">=</a> arguments.m_max_added_steiner_<a href="CppPointer.htm">point</a>s;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::PolyFile polyfile(arguments.m_inpolyfilename);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (b.m_do_refine)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Read and re<a href="CppConstructor.htm">construct</a> a mesh.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mesh.m_hullsize<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> ReadEdges(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments.m_inelefilename,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>b.m_areafilename,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments.m_inpolyfilename,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyfile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;m.m_hullsize <a href="CppOperatorAssign.htm">=</a> delaunay(m, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangulate the vertices.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Ensure that no vertex can be mistaken <b><a href="CppFor.htm">for</a></b> a triangular bounding<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;box vertex in insertvertex().<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_infvertex1 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_infvertex2 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_infvertex3 <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>mesh.m_checksegments <a href="CppOperatorAssign.htm">=</a> 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Segments will be introduced next.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!arguments.m_do_refine)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Insert PSLG segments and/or convex hull segments.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formskeleton(mesh, arguments, arguments.m_inpolyfilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>formskeleton(m, b, polyfile, b.m_inpolyfilename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Using holes is not supported<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mesh.m_triangles.m_items &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;readholes(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>polyfile,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments.m_inpolyfilename,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&amp;m.m_holes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region<a href="CppArray.htm">array</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&amp;m.m_regions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!arguments.m_do_refine)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Carve out holes and concavities.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carveholes(mesh, arguments, hole<a href="CppArray.htm">array</a>, region<a href="CppArray.htm">array</a>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>carveholes(m, b, hole<a href="CppArray.htm">array</a>, m.m_holes, region<a href="CppArray.htm">array</a>, m.m_regions);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Without a PSLG, there can be no holes or regional attributes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;or area constraints.&nbsp;&nbsp;The following are set to zero to avoid<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;an accidental free() later.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mesh.m_holes <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mesh.m_regions <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppIf.htm">if</a></b> (arguments.m_quality <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> mesh.m_triangles.m_items &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>enforcequality(mesh, arguments); <a href="CppComment.htm">//</a>Enforce angle and area constraints.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;enforcequality(mesh); <a href="CppComment.htm">//</a>Enforce angle and area constraints.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Calculate the number of edges.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>mesh.m_edges <a href="CppOperatorAssign.htm">=</a> (3l * mesh.m_triangles.m_items <a href="CppOperatorPlus.htm">+</a> mesh.m_hullsize) <a href="CppOperatorDivide.htm">/</a> 2l;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;RJCB: Only used arguments.m_order <a href="CppOperatorEqual.htm">==</a> 1<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_order &gt; 1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;highorder(mesh, arguments);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>Promote elements to higher polynomial order.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>If not <b><a href="CppUsing.htm">using</a></b> iteration numbers, don't write a .node file <b><a href="CppIf.htm">if</a></b> one was<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;read, because the original one would be overwritten!<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_nonodewritte)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!arguments.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "NOT writing a .node file.\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;numbernodes(mesh, arguments);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a>We must remember to number the vertices.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;writenodes(mesh, arguments, arguments.m_outnodefilename, args);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_noelewritten)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!arguments.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "NOT writing an .ele file.\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;writeelements(mesh, arguments, arguments.m_outelefilename, args);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The <a href="CppOperatorMinus.htm">-</a>c <b><a href="CppSwitch.htm">switch</a></b> (convex <b><a href="CppSwitch.htm">switch</a></b>) causes a PSLG to be written<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;even <b><a href="CppIf.htm">if</a></b> none was read.<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>If not <b><a href="CppUsing.htm">using</a></b> iteration numbers, don't overwrite the .poly file.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_nopolywritten <a href="CppOperatorLogicalOr.htm">||</a> arguments.m_noiterationnum)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!arguments.m_quiet)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "NOT writing a .poly file.\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writepoly(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments.m_outpolyfilename,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hole<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_holes,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region<a href="CppArray.htm">array</a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m.m_regions,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mesh.m_regions &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> region<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;region<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (mesh.m_holes &gt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> hole<a href="CppArray.htm">array</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;hole<a href="CppArray.htm">array</a> <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_geomview)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;writeoff(mesh, arguments, arguments.m_offfilename, args);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_edgesout)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;writeedges(mesh, arguments, arguments.m_edgefilename, args);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_voronoi)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;writevoronoi(mesh, arguments, arguments.m_vnodefilename, arguments.m_vedgefilename, args);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_neighbors)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;writeneighbors(mesh, arguments, arguments.m_neighborfilename, args);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (!arguments.m_quiet)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;statistics(mesh, arguments);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (arguments.m_do_check)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkmesh(mesh, arguments);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;checkdelaunay(mesh,mesh.m_incirclecount);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>checkdelaunay(m, b);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>triangledeinit(m, b);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::printtriangle(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Mesh&amp; m,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Arguments&amp; b,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Otri * <b><a href="CppConst.htm">const</a></b> t<br/>
)<br/>
{<br/>
&nbsp;&nbsp;Otri printtri;<br/>
&nbsp;&nbsp;Osub printsh;<br/>
&nbsp;&nbsp;Vertex printvertex;<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "triangle " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> t-&gt;m_tri <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " with orientation " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> t-&gt;m_orient <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ":\n";<br/>
<br/>
&nbsp;&nbsp;decode(t-&gt;m_tri[0], printtri);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printtri.m_tri <a href="CppOperatorEqual.htm">==</a> m.m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[0] <a href="CppOperatorAssign.htm">=</a> Outer space\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[0] <a href="CppOperatorAssign.htm">=</a> " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printtri.m_tri<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printtri.m_orient <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;decode(t-&gt;m_tri[1], printtri);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printtri.m_tri <a href="CppOperatorEqual.htm">==</a> m.m_dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[1] <a href="CppOperatorAssign.htm">=</a> Outer space\n");<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[1] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printtri.m_tri,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printtri.m_orient);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;decode(t-&gt;m_tri[2], printtri);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printtri.m_tri <a href="CppOperatorEqual.htm">==</a> m.m_dummytri) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[2] <a href="CppOperatorAssign.htm">=</a> Outer space\n");<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[2] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printtri.m_tri,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printtri.m_orient);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;GetOrigin(*t, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Origin[%d] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n", (t-&gt;m_orient <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorModulus.htm">%</a> 3 <a href="CppOperatorPlus.htm">+</a> 3);<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Origin[%d] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (t-&gt;m_orient <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorModulus.htm">%</a> 3 <a href="CppOperatorPlus.htm">+</a> 3, (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printvertex[0], printvertex[1]);<br/>
&nbsp;&nbsp;GetDest(*t, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Dest&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n", (t-&gt;m_orient <a href="CppOperatorPlus.htm">+</a> 2) <a href="CppOperatorModulus.htm">%</a> 3 <a href="CppOperatorPlus.htm">+</a> 3);<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Dest&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (t-&gt;m_orient <a href="CppOperatorPlus.htm">+</a> 2) <a href="CppOperatorModulus.htm">%</a> 3 <a href="CppOperatorPlus.htm">+</a> 3, (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printvertex[0], printvertex[1]);<br/>
&nbsp;&nbsp;GetApex(*t, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Apex&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n", t-&gt;m_orient <a href="CppOperatorPlus.htm">+</a> 3);<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Apex&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t-&gt;m_orient <a href="CppOperatorPlus.htm">+</a> 3, (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printvertex[0], printvertex[1]);<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sdecode(t-&gt;m_tri[6], printsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printsh.m_subseg <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[6] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printsh.m_subseg,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printsh.m_subseg_orient);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sdecode(t-&gt;m_tri[7], printsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printsh.m_subseg <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[7] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printsh.m_subseg,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printsh.m_subseg_orient);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sdecode(t-&gt;m_tri[8], printsh);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printsh.m_subseg <a href="CppOperatorNotEqual.htm">!=</a> m.m_dummysub) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[8] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printsh.m_subseg,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printsh.m_subseg_orient);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_vararea) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Area constraint:&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.4g\n", areabound(*t));<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::printsubseg(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> SubSeg * <b><a href="CppConst.htm">const</a></b> m_dummysub,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Triangle * <b><a href="CppConst.htm">const</a></b> m_dummytri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Osub&amp; osub<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;Osub printsh;<br/>
&nbsp;&nbsp;Otri printtri;<br/>
&nbsp;&nbsp;Vertex printvertex;<br/>
<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "subsegment "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> osub.m_subseg<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " with orientation "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> osub.m_subseg_orient<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " and mark "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> mark(*osub)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ":\n"<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;sdecode(osub.m_subseg[0], printsh);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printsh.m_subseg <a href="CppOperatorEqual.htm">==</a> m_dummysub)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[0] <a href="CppOperatorAssign.htm">=</a> No subsegment\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[0] <a href="CppOperatorAssign.htm">=</a> " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printsh.m_subseg <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printsh.m_subseg_orient <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;sdecode(osub.m_subseg[1], printsh);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printsh.m_subseg <a href="CppOperatorEqual.htm">==</a> m_dummysub)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[1] <a href="CppOperatorAssign.htm">=</a> No subsegment\n";<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[1] <a href="CppOperatorAssign.htm">=</a> " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printsh.m_subseg <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> " " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printsh.m_subseg_orient <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;GetOrigin(*osub, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Origin[" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (2 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Origin[" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> (2 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient) <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "] <a href="CppOperatorAssign.htm">=</a> "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printvertex <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;(" <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printvertex[0] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ", " <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> printvertex[1] <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> ")\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;GetDest(*osub, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Dest&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n", 3 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Dest&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient, (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printvertex[0], printvertex[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;decode(osub.m_subseg[6], printtri);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printtri.m_tri <a href="CppOperatorEqual.htm">==</a> m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[6] <a href="CppOperatorAssign.htm">=</a> Outer space\n");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[6] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printtri.m_tri,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtri.m_orient<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;decode(osub.m_subseg[7], printtri);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printtri.m_tri <a href="CppOperatorEqual.htm">==</a> m_dummytri)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[7] <a href="CppOperatorAssign.htm">=</a> Outer space\n");<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;[7] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>d\n", (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printtri.m_tri,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printtri.m_orient<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;GetOrg(*osub, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Segment origin[%d] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n", 4 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Segment origin[%d] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient, (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printvertex[0], printvertex[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;GetDest(*osub, printvertex);<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (printvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Segment dest&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> <a href="CppNULL.htm">NULL</a>\n", 5 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;Segment dest&nbsp;&nbsp;[%d] <a href="CppOperatorAssign.htm">=</a> x%lx&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient, (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) printvertex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printvertex[0], printvertex[1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop <a href="CppComment.htm">//</a>RJCB<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmemorypool.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmemorypool.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPMEMORYPOOL_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPMEMORYPOOL_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_MEMORYPOOL<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> A type used to allocate <a href="CppMemory.htm">memory</a>.&nbsp;&nbsp;firstblock is the first block of items.&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; nowblock is the block from which items are currently being allocated.&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; nextitem <a href="CppPointer.htm">point</a>s to the next slab of free <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> an item.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; deaditemstack is the head of a <a href="CppLink.htm">link</a>ed list (stack) of deallocated items <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; that can be recycled.&nbsp;&nbsp;unallocateditems is the number of items that&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; remain to be allocated from nowblock.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a> Traversal is the process of walking through the entire list of items, and <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; is separate from allocation.&nbsp;&nbsp;Note that a traversal will visit items on <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; the "deaditemstack" stack as well as live items.&nbsp;&nbsp;pathblock <a href="CppPointer.htm">point</a>s to&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; the block currently being traversed.&nbsp;&nbsp;pathitem <a href="CppPointer.htm">point</a>s to the next item&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; to be traversed.&nbsp;&nbsp;pathitemsleft is the number of items that remain to&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; be traversed in pathblock.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a> alignbytes determines how <b><a href="CppNew.htm">new</a></b> records should be aligned in <a href="CppMemory.htm">memory</a>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; itembytes is the length of a record in bytes (after rounding up).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; itemsperblock is the number of items allocated at once in a single&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; block.&nbsp;&nbsp;itemsfirstblock is the number of items in the first block,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; which can vary from the others.&nbsp;&nbsp;items is the number of currently&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; allocated items.&nbsp;&nbsp;maxitems is the maximum number of items that have&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; been allocated at once; it is the current number of items plus the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; number of records kept on deaditemstack.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppStruct.htm">struct</a></b> <a href="CppMemory.htm">Memory</a>Pool<br/>
{<br/>
&nbsp;&nbsp;<a href="CppMemory.htm">Memory</a>Pool();<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_alignbytes;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> *m_deaditemstack;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> **m_firstblock;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_itembytes;<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_items;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_itemsfirstblock;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_itemsperblock;<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_maxitems;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> *m_nextitem;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> **m_nowblock;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> **m_pathblock;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> *m_pathitem;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_pathitemsleft;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_unallocateditems;<br/>
};<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;poolalloc()&nbsp;&nbsp; Allocate space <b><a href="CppFor.htm">for</a></b> an item.<br/>
<b><a href="CppVoid.htm">void</a></b> * PoolAlloc(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool);<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;pooldealloc()&nbsp;&nbsp; Deallocate space <b><a href="CppFor.htm">for</a></b> an item.<br/>
<a href="CppComment.htm">///</a><br/>
<b><a href="CppVoid.htm">void</a></b> PoolDealloc(<br/>
&nbsp;&nbsp;<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool,<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> * <b><a href="CppConst.htm">const</a></b> dyingitem<br/>
);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;The deallocated space is stored in a queue <b><a href="CppFor.htm">for</a></b> later reuse.<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> PoolDealloc(<a href="CppStdVector.htm">std::vector</a>&lt;BadSubSeg&gt;&amp; subseg,BadSubSeg&amp; dyingsubseg);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> PoolDealloc(<a href="CppStdVector.htm">std::vector</a>&lt;SubSeg&gt;&amp; subseg,SubSeg&amp; dyingsubseg);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> PoolDealloc(<a href="CppStdVector.htm">std::vector</a>&lt;Triangle&gt;&amp; triangles,Triangle&amp; dyingtriangle);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> PoolDealloc(<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices,Vertex&amp; dyingitem);<br/>
<br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt;<br/>
<b><a href="CppVoid.htm">void</a></b> PoolDealloc(<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;T<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices,<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;T&gt;&amp; dyingitem)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*<a href="CppStdFind.htm">std::find</a>(vertices.begin(),vertices.end(),dyingitem),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices.back()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;vertices.pop_back();<br/>
}<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;pooldeinit()&nbsp;&nbsp; Free to the operating system all <a href="CppMemory.htm">memory</a> taken by a pool.<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> PoolDeinit(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool);<br/>
<a href="CppComment.htm">*/</a><br/>
<b><a href="CppTemplate.htm">template</a></b> &lt;<b><a href="CppClass.htm">class</a></b> T&gt; <b><a href="CppVoid.htm">void</a></b> PoolDeinit(<a href="CppStdVector.htm">std::vector</a>&lt;T&gt;&amp; v) { v.resize(0); }<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;poolinit()&nbsp;&nbsp; <a href="CppInitialize.htm">Initialize</a> a pool of <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> allocation of items.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;This routine <a href="CppInitialize.htm">initialize</a>s the machinery <b><a href="CppFor.htm">for</a></b> allocating items.&nbsp;&nbsp;A `pool'<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;is created whose records have size at least `bytecount'.&nbsp;&nbsp;Items will be<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;allocated in `itemcount'-item blocks.&nbsp;&nbsp;Each item is assumed to be a<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;collection of words, and either <a href="CppPointer.htm">pointer</a>s or floating-<a href="CppPointer.htm">point</a> values are<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;assumed to be the "primary" word type.&nbsp;&nbsp;(The "primary" word type is used<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;to determine alignment of items.)&nbsp;&nbsp;If `alignment' isn't zero, all items<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;will be `alignment'-byte aligned in <a href="CppMemory.htm">memory</a>.&nbsp;&nbsp;`alignment' must be either<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;a multiple or a factor of the primary word size; powers of two are safe.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;`alignment' is normally used to create a few unused bits at the bottom<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;of each item's <a href="CppPointer.htm">pointer</a>, in which information may be stored.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;Don't change <b><a href="CppThis.htm">this</a></b> routine unless you understand it.<br/>
<a href="CppComment.htm">///</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> PoolInit(<br/>
&nbsp;&nbsp;<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytecount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> itemcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> firstitemcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> alignment<br/>
);<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;poolrestart()&nbsp;&nbsp; Deallocate all items in a pool.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;The pool is <b><a href="CppReturn.htm">return</a></b>ed to its starting state, except that no <a href="CppMemory.htm">memory</a> is<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;freed to the operating system.&nbsp;&nbsp;Rather, the previously allocated blocks<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;are ready to be reused.<br/>
<b><a href="CppVoid.htm">void</a></b> PoolRestart(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool);<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;poolzero()&nbsp;&nbsp; Set all of a pool's fields to zero.<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;This procedure should never be called on a pool that has <a href="CppAny.htm">any</a> <a href="CppMemory.htm">memory</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;allocated to it, as that <a href="CppMemory.htm">memory</a> would leak.<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> poolzero(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool);<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;traversalinit()&nbsp;&nbsp; Prepare to traverse the entire list of items.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;This routine is used in conjunction with traverse().<br/>
<b><a href="CppVoid.htm">void</a></b> TraversalInit(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool);<br/>
<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;traverse()&nbsp;&nbsp; Find the next item in the list.<br/>
<a href="CppComment.htm">///</a><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;This routine is used in conjunction with traversalinit().&nbsp;&nbsp;Be forewarned<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;that <b><a href="CppThis.htm">this</a></b> routine successively <a href="CppReturn.htm">returns</a> all items in the list, including<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;deallocated ones on the deaditemqueue.&nbsp;&nbsp;It's up to you to figure out<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;which ones are actually dead.&nbsp;&nbsp;Why?&nbsp;&nbsp;I don't want to allocate extra<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;space just to demarcate dead items.&nbsp;&nbsp;It can usually be done more<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;space-efficiently by a routine that knows something <a href="CppAbout.htm">about</a> the structure<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;of the item.<br/>
<b><a href="CppVoid.htm">void</a></b> * Traverse(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_MEMORYPOOL<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPMEMORYPOOL_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmemorypool.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmemorypool.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecpp<a href="CppMemory.htm">memory</a>pool.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppAlgorithmH.htm">algorithm</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptrimalloc.h"<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppMemory.htm">Memory</a>Pool::<a href="CppMemory.htm">Memory</a>Pool()<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_alignbytes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_deaditemstack{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_firstblock{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_itembytes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_itemsfirstblock{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_itemsperblock{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_maxitems{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nextitem{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nowblock{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_pathblock{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_pathitem{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_pathitemsleft{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_unallocateditems{0}<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> * <a href="CppRibi.htm">ribi</a>::tricpp::PoolAlloc(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> *newitem;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> **newblock;<br/>
&nbsp;&nbsp;<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> First check the <a href="CppLink.htm">link</a>ed list of dead items.&nbsp;&nbsp;If the list is not<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; empty, allocate an item from the list rather than a fresh one.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (pool-&gt;m_deaditemstack <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newitem <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_deaditemstack;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Take first item in list.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_deaditemstack <a href="CppOperatorAssign.htm">=</a> * (<b><a href="CppVoid.htm">void</a></b> **) pool-&gt;m_deaditemstack;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Check <b><a href="CppIf.htm">if</a></b> there are <a href="CppAny.htm">any</a> free items left in the current block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (pool-&gt;m_unallocateditems <a href="CppOperatorEqual.htm">==</a> 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Check <b><a href="CppIf.htm">if</a></b> another block must be allocated.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*(pool-&gt;m_nowblock) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Allocate a <b><a href="CppNew.htm">new</a></b> block of items, <a href="CppPointer.htm">point</a>ed to by the previous block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) TriMalloc(pool-&gt;m_itemsperblock * pool-&gt;m_itembytes <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppVoid.htm">void</a></b> *) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool-&gt;m_alignbytes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(pool-&gt;m_nowblock) <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *) newblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> The next block <a href="CppPointer.htm">pointer</a> is <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*newblock <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Move to the <b><a href="CppNew.htm">new</a></b> block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_nowblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) *(pool-&gt;m_nowblock);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the first item in the block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; Increment by the size of (<b><a href="CppVoid.htm">void</a></b> *).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (pool-&gt;m_nowblock <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Align the item on an `alignbytes'-byte boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_nextitem <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> There are lots of unallocated items left in <b><a href="CppThis.htm">this</a></b> block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_unallocateditems <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_itemsperblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Allocate a <b><a href="CppNew.htm">new</a></b> item.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newitem <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_nextitem;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Advance `nextitem' <a href="CppPointer.htm">pointer</a> to next free item in block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_nextitem <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *) ((<b><a href="CppChar.htm">char</a></b> *) pool-&gt;m_nextitem <a href="CppOperatorPlus.htm">+</a> pool-&gt;m_itembytes);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_unallocateditems<a href="CppOperatorDecrement.htm">--</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_maxitems<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;pool-&gt;m_items<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newitem;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolDealloc(<br/>
&nbsp;&nbsp;<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool,<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> * <b><a href="CppConst.htm">const</a></b> dyingitem<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Push freshly killed item onto stack.<br/>
&nbsp;&nbsp;*((<b><a href="CppVoid.htm">void</a></b> **) dyingitem) <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_deaditemstack;<br/>
&nbsp;&nbsp;pool-&gt;m_deaditemstack <a href="CppOperatorAssign.htm">=</a> dyingitem;<br/>
&nbsp;&nbsp;<a href="CppOperatorDecrement.htm">--</a>pool-&gt;m_items;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolDealloc(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Triangle&gt;&amp; triangles,<br/>
&nbsp;&nbsp;Triangle&amp; dying_triangle<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*<a href="CppStdFind.htm">std::find</a>(triangles.begin(),triangles.end(),dying_triangle),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;triangles.back()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;triangles.pop_back();<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolDealloc(<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices,Vertex&amp; dyingitem<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Push freshly killed item onto stack.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*((<b><a href="CppVoid.htm">void</a></b> **) dyingitem) <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_deaditemstack;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>pool-&gt;m_deaditemstack <a href="CppOperatorAssign.htm">=</a> dyingitem;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDecrement.htm">--</a>pool-&gt;m_items;<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*<a href="CppStdFind.htm">std::find</a>(vertices.begin(),vertices.end(),dyingitem),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices.back()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;vertices.pop_back();<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolDeinit(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (pool-&gt;m_firstblock <a href="CppOperatorNotEqual.htm">!=</a> <b><a href="CppNullptr.htm">nullptr</a></b>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_nowblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) *(pool-&gt;m_firstblock);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDelete.htm">delete</a></b> pool-&gt;m_firstblock;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_firstblock <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_firstblock <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_nowblock;<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolDeinit(<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt;&amp; vertices)<br/>
{<br/>
&nbsp;&nbsp;vertices.resize(0);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolInit(<br/>
&nbsp;&nbsp;<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> bytecount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> itemcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> firstitemcount,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> alignment<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the proper alignment, which must be at least as large as:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; <a href="CppOperatorMinus.htm">-</a> The parameter `alignment'.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; <a href="CppOperatorMinus.htm">-</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppVoid.htm">void</a></b> *), so the stack of dead items can be maintained<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; without unaligned accesses.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (alignment &gt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(<b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppVoid.htm">void</a></b> *))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_alignbytes <a href="CppOperatorAssign.htm">=</a> alignment;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_alignbytes <a href="CppOperatorAssign.htm">=</a> <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppVoid.htm">void</a></b> *);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;pool-&gt;m_itembytes <a href="CppOperatorAssign.htm">=</a> ((bytecount <a href="CppOperatorMinus.htm">-</a> 1) <a href="CppOperatorDivide.htm">/</a> pool-&gt;m_alignbytes <a href="CppOperatorPlus.htm">+</a> 1) *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_alignbytes;<br/>
&nbsp;&nbsp;pool-&gt;m_itemsperblock <a href="CppOperatorAssign.htm">=</a> itemcount;<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (firstitemcount <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_itemsfirstblock <a href="CppOperatorAssign.htm">=</a> itemcount;<br/>
&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_itemsfirstblock <a href="CppOperatorAssign.htm">=</a> firstitemcount;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Allocate a block of items.&nbsp;&nbsp;Space <b><a href="CppFor.htm">for</a></b> `itemsfirstblock' items and one<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; <a href="CppPointer.htm">pointer</a> (to <a href="CppPointer.htm">point</a> to the next block) are allocated, as well as space<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; to ensure alignment of the items.<br/>
&nbsp;&nbsp;pool-&gt;m_firstblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TriMalloc(pool-&gt;m_itemsfirstblock * pool-&gt;m_itembytes <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppInt.htm">int</a></b>) <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppVoid.htm">void</a></b> *) <a href="CppOperatorPlus.htm">+</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_alignbytes);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Set the next block <a href="CppPointer.htm">pointer</a> to <a href="CppNULL.htm">NULL</a>.<br/>
&nbsp;&nbsp;*(pool-&gt;m_firstblock) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;PoolRestart(pool);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::PoolRestart(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool)<br/>
{<br/>
&nbsp;&nbsp;pool-&gt;m_items <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;pool-&gt;m_maxitems <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Set the currently active block.<br/>
&nbsp;&nbsp;pool-&gt;m_nowblock <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_firstblock;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the first item in the pool.&nbsp;&nbsp;Increment by the size of (<b><a href="CppVoid.htm">void</a></b> *).<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (pool-&gt;m_nowblock <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Align the item on an `alignbytes'-byte boundary.<br/>
&nbsp;&nbsp;pool-&gt;m_nextitem <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> There are lots of unallocated items left in <b><a href="CppThis.htm">this</a></b> block.<br/>
&nbsp;&nbsp;pool-&gt;m_unallocateditems <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_itemsfirstblock;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> The stack of deallocated items is empty.<br/>
&nbsp;&nbsp;pool-&gt;m_deaditemstack <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::TraversalInit(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Begin the traversal in the first block.<br/>
&nbsp;&nbsp;pool-&gt;m_pathblock <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_firstblock;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the first item in the block.&nbsp;&nbsp;Increment by the size of (<b><a href="CppVoid.htm">void</a></b> *).<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (pool-&gt;m_pathblock <a href="CppOperatorPlus.htm">+</a> 1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Align with item on an `alignbytes'-byte boundary.<br/>
&nbsp;&nbsp;pool-&gt;m_pathitem <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes));<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Set the number of items left in the current block.<br/>
&nbsp;&nbsp;pool-&gt;m_pathitemsleft <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_itemsfirstblock;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> * <a href="CppRibi.htm">ribi</a>::tricpp::Traverse(<a href="CppMemory.htm">Memory</a>Pool * <b><a href="CppConst.htm">const</a></b> pool)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Stop upon exhausting the list of items.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (pool-&gt;m_pathitem <a href="CppOperatorEqual.htm">==</a> pool-&gt;m_nextitem)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Check whether <a href="CppAny.htm">any</a> untraversed items remain in the current block.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (pool-&gt;m_pathitemsleft <a href="CppOperatorEqual.htm">==</a> 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the next block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_pathblock <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> **) *(pool-&gt;m_pathblock);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the first item in the block.&nbsp;&nbsp;Increment by the size of (<b><a href="CppVoid.htm">void</a></b> *).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b> alignptr <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>)pool-&gt;m_pathblock <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Align with item on an `alignbytes'-byte boundary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_pathitem <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(alignptr <a href="CppOperatorPlus.htm">+</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes <a href="CppOperatorMinus.htm">-</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (alignptr <a href="CppOperatorModulus.htm">%</a> (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) pool-&gt;m_alignbytes));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Set the number of items left in the current block.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pool-&gt;m_pathitemsleft <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_itemsperblock;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> * <b><a href="CppConst.htm">const</a></b> newitem <a href="CppOperatorAssign.htm">=</a> pool-&gt;m_pathitem;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Find the next item in the block.<br/>
&nbsp;&nbsp;pool-&gt;m_pathitem <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppVoid.htm">void</a></b> *) ((<b><a href="CppChar.htm">char</a></b> *) pool-&gt;m_pathitem <a href="CppOperatorPlus.htm">+</a> pool-&gt;m_itembytes);<br/>
&nbsp;&nbsp;<a href="CppOperatorDecrement.htm">--</a>pool-&gt;m_pathitemsleft;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newitem;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmesh.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmesh.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPMESH_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPMESH_H<br/>
<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "trianglecpp<a href="CppMemory.htm">memory</a>pool.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "trianglecppbadtriang.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "trianglecppflipstacker.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "trianglecppotri.h"<br/>
<a href="CppComment.htm">//</a><a href="CppInclude.htm">#include</a> "trianglecppsplaynode.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> Mesh data structure.&nbsp;&nbsp;Triangle operates on only one mesh, but the mesh<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; structure is used (instead of global variables) to allow reentrancy.<br/>
<b><a href="CppStruct.htm">struct</a></b> Mesh<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Arguments&gt; ArgumentsPtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; EdgePtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; TrianglePtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; VertexPtr;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;EdgePtr&gt; Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;TrianglePtr&gt; Triangles;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;VertexPtr&gt; Vertices;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFriend.htm">friend</a></b> <b><a href="CppClass.htm">class</a></b> MeshBuilder;<br/>
&nbsp;&nbsp;Mesh(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> ArgumentsPtr&amp; arguments,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges&amp; edges,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Triangles&amp; triangles,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertices&amp; vertices<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> ArgumentsPtr m_arguments;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges m_edges;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Triangles m_triangles;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertices m_vertices;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;Mesh();<br/>
&nbsp;&nbsp;Mesh(<b><a href="CppConst.htm">const</a></b> Mesh&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;Mesh&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> Mesh&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppAdd.htm">Add</a> a bad triangle to the end of a queue.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Enqueuebadtri(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; enqtri,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> minedge,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; enqapex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; enqorg,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; enqdest<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppAdd.htm">Add</a> a bad triangle data structure to the end of a queue.<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Enqueuebadtriang(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt; badtri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertex&amp; GetVertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex&amp; GetVertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> KillSubSeg(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; subseg) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> KillTriangle(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; triangle) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> KillVertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> m_areaboundindex; <a href="CppComment.htm">//</a>REPLACE BY CONST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Index to find area bound of a triangle.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_badsubsegs; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;BadSubSeg&gt; m_badsubsegs;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_badtriangles;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_badtriangles;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_checkquality;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Has quality triangulation begun yet?<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_checksegments;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Are there segments in the triangulation yet?<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_circletopcount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of circle top calculations performed.<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_circumcentercount;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of circumcenter calculations performed.<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_<a href="CppCounter.htm">counter</a>clockcount;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of <a href="CppCounter.htm">counter</a>clockwise tests performed.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> m_do_readnodefile <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Has a .node file been read?<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; m_dummysub; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> <a href="CppPointer.htm">Pointer</a> to the omnipresent subsegment.&nbsp;&nbsp;Referenced by <a href="CppAny.htm">any</a> triangle or <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; subsegment that isn't really connected to a subsegment at that <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp; location.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SubSeg * m_dummysubbase;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Keep base <a href="CppAddress.htm">address</a> so we can free() it later.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; m_dummytri; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> <a href="CppPointer.htm">Pointer</a> to the `triangle' that occupies all of "outer space."<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle *m_dummytribase;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Keep base <a href="CppAddress.htm">address</a> so we can free() it later.<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_edges;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of output edges.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_eextras;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of attributes per triangle.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_elematt<a href="CppRibi.htm">ribi</a>ndex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Index to find attributes of a triangle.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_firstnonemptyq; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> bad triangle queues.&nbsp;&nbsp;The queues are ordered from 4095 (highest priority) to 0 (lowest priority).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_flipstackers;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;FlipStacker&gt; m_flipstackers;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Index to find extra nodes <b><a href="CppFor.htm">for</a></b> high-order elements.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>The index within each triangle at which the extra nodes (above three)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;associated with high order elements are found.&nbsp;&nbsp;There are three<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppPointer.htm">pointer</a>s to other triangles, three <a href="CppPointer.htm">pointer</a>s to corners, and possibly<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;three <a href="CppPointer.htm">pointer</a>s to subsegments before the extra nodes.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_highorderindex <a href="CppOperatorAssign.htm">=</a> 9;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_holes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of input holes.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_hullsize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of edges in convex hull.<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_hyperbolacount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of right-of-hyperbola tests performed.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_incirclecount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of incircle tests performed.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_inelements;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of input triangles.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_infvertex1; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Triangular bounding box vertices.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_infvertex2; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Triangular bounding box vertices.<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_infvertex3; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Triangular bounding box vertices.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_insegments;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of input segments.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_invertices;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of input vertices.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;FlipStacker&gt; m_lastflip; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Variable that maintains the stack of recently flipped triangles.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_mesh_dim <a href="CppOperatorAssign.htm">=</a> 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Dimension (ought to be 2).<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt; m_nextnonemptyq; <a href="CppComment.htm">//</a>[4096]; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> bad triangle queues.&nbsp;&nbsp;The queues are ordered from 4095 (highest priority) to 0 (lowest priority).<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_nextras <a href="CppOperatorAssign.htm">=</a> 0; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of attributes per vertex.<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_orient3dcount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of 3D orientation tests performed.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_queuefront; <a href="CppComment.htm">//</a>[4096]; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> bad triangle queues.&nbsp;&nbsp;The queues are ordered from 4095 (highest priority) to 0 (lowest priority).<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_queuetail; <a href="CppComment.htm">//</a>[4096]; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> bad triangle queues.&nbsp;&nbsp;The queues are ordered from 4095 (highest priority) to 0 (lowest priority).<br/>
&nbsp;&nbsp;Otri m_recenttri; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> <a href="CppPointer.htm">Pointer</a> to a recently visited triangle.&nbsp;&nbsp;Improves <a href="CppPointer.htm">point</a> location <b><a href="CppIf.htm">if</a></b> proximate vertices are inserted sequentially.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_regions;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of input regions.<br/>
&nbsp;&nbsp;<b><a href="CppLong.htm">long</a></b> m_samples;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of random samples <b><a href="CppFor.htm">for</a></b> <a href="CppPointer.htm">point</a> location.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_splaynodes;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;SplayNode&gt; m_splaynodes;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_steinerleft;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of Steiner <a href="CppPointer.htm">point</a>s not yet used.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_subsegs;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Edge&gt; m_subsegs;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_triangles;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_triangles;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_undeads;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Number of input vertices that don't appear in the mesh.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_vertex2triindex <a href="CppOperatorAssign.htm">=</a> 3; <a href="CppComment.htm">//</a>TODO: REMOVE&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Index to find a triangle adjacent to a vertex.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> m_vertexmarkindex <a href="CppOperatorAssign.htm">=</a> 1; <a href="CppComment.htm">//</a>TODO: REMOVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Index to find boundary marker of a vertex.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_vertices;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt; m_vertices;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppMemory.htm">Memory</a>Pool m_viri;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;Vertex&gt; m_viri;/<a href="CppComment.htm">//</a> Variables used to allocate <a href="CppMemory.htm">memory</a> <b><a href="CppFor.htm">for</a></b> triangles, subsegments, vertices, viri (triangles being eaten), encroached segments, bad (skinny or too large) triangles, and splay tree nodes.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_xmax; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> x and y bounds<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_xmin; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> x and y bounds<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_xminextreme;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Nonexistent x value used as a flag in sweepline.<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_ymax; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> x and y bounds<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_ymin; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> x and y bounds<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
};<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> triangleinit(Mesh&amp; m);<br/>
<br/>
<a href="CppComment.htm">//</a>vertextraverse()&nbsp;&nbsp; Traverse the vertices, skipping dead ones.<br/>
<a href="CppComment.htm">//</a>Vertex vertextraverse(Mesh&amp; m);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPMESH_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmesh.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmesh.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmesh.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppbadsubseg.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppdefines.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppglobals.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Mesh::Mesh(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> ArgumentsPtr&amp; arguments,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges&amp; edges,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Triangles&amp; triangles,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Vertices&amp; vertices<br/>
)<br/>
&nbsp;&nbsp;: m_arguments(arguments),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edges(edges),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangles(triangles),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vertices(vertices)<br/>
{<br/>
<br/>
}<br/>
<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_REALLY_USE_THIS_20140603<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Mesh::Mesh()<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_areaboundindex{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_badsubsegs{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_badtriangles{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_checkquality{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_checksegments{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_circletopcount{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_circumcentercount{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppCounter.htm">counter</a>clockcount{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_do_readnodefile{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_dummysub{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_dummysubbase{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_dummytri{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_dummytribase{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edges{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_eextras{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_elematt<a href="CppRibi.htm">ribi</a>ndex{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_firstnonemptyq{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_flipstackers{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_holes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_hullsize{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_hyperbolacount{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_incirclecount{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_inelements{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_infvertex1{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_infvertex2{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_infvertex3{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_insegments{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_invertices{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_lastflip{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_nextnonemptyq{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_orient3dcount{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_queuefront{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_queuetail{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_recenttri{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_regions{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_samples{1}, <a href="CppComment.htm">//</a><a href="CppPoint.htm">Point</a> location should take at least one sample<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_splaynodes{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_steinerleft{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subsegs{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangles{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_undeads{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>m_vertex2triindex{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vertices{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_viri{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_xmax{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_xmin{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_xminextreme{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_ymax{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_ymin{0.0}<br/>
{<br/>
<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Mesh::Enqueuebadtri(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; enqtri,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> minedge,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; enqapex,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; enqorg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; enqdest<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Allocates a badtriang data structure <b><a href="CppFor.htm">for</a></b> the triangle, then passes it to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> enqueuebadtriang().<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt; newbad(<b><a href="CppNew.htm">new</a></b> BadTriang);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Allocate space <b><a href="CppFor.htm">for</a></b> the bad triangle.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>newbad <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppStruct.htm">struct</a></b> BadTriang *) PoolAlloc(&amp;m.m_badtriangles);<br/>
&nbsp;&nbsp;newbad-&gt;m_poortri <a href="CppOperatorAssign.htm">=</a> enqtri-&gt;m_triangles[enqtri-&gt;m_orient]; <a href="CppComment.htm">//</a>encode(*enqtri);<br/>
&nbsp;&nbsp;newbad-&gt;m_key <a href="CppOperatorAssign.htm">=</a> minedge;<br/>
&nbsp;&nbsp;newbad-&gt;m_triangapex <a href="CppOperatorAssign.htm">=</a> enqapex;<br/>
&nbsp;&nbsp;newbad-&gt;m_triangorg <a href="CppOperatorAssign.htm">=</a> enqorg;<br/>
&nbsp;&nbsp;newbad-&gt;m_triangdest <a href="CppOperatorAssign.htm">=</a> enqdest;<br/>
&nbsp;&nbsp;Enqueuebadtriang(newbad);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>enqueuebadtriang(m,newbad);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Mesh::Enqueuebadtriang(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;BadTriang&gt; badtri)<br/>
{<br/>
&nbsp;&nbsp;m_badtriangles.push_back(badtri);<br/>
&nbsp;&nbsp;<a href="CppIfdef.htm">#ifdef</a> KEEP_THIS_20140520<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> The queue is actually a set of 4096 queues.&nbsp;&nbsp;I use multiple queues to<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> give priority to smaller angles.&nbsp;&nbsp;I originally implemented a heap, but<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> the queues are faster by a larger margin than I'd suspected.<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> length <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> multiplier;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> exponent;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> expincrement;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> queu<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>1;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> posexponent <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (b.m_verbosity &gt; 2) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;Queueing bad triangle:\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;(%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g) (%.12g, <a href="CppOperatorModulus.htm">%</a>.12g)\n",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; badtri-&gt;m_triangorg[0], badtri-&gt;m_triangorg[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; badtri-&gt;m_triangdest[0], badtri-&gt;m_triangdest[1],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; badtri-&gt;m_triangapex[0], badtri-&gt;m_triangapex[1]);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Determine the appropriate queue to put the bad triangle into.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Recall that the key is the square of its shortest edge length.<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (badtri-&gt;m_key <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 1.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;length <a href="CppOperatorAssign.htm">=</a> badtri-&gt;m_key;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;posexponent <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>`badtri-&gt;key' is 2.0 to a negative exponent, so we'll record that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;fact and use the reciprocal of `badtri-&gt;key', which is &gt; 1.0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;length <a href="CppOperatorAssign.htm">=</a> 1.0 <a href="CppOperatorDivide.htm">/</a> badtri-&gt;m_key;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;posexponent <a href="CppOperatorAssign.htm">=</a> <b><a href="CppFalse.htm">false</a></b>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>`length' is approximately 2.0 to what exponent?&nbsp;&nbsp;The following code<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;determines the answer in <a href="CppTime.htm">time</a> logarithmic in the exponent.<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> exponent <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (length &gt; 2.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Find an approximation by repeated squaring of two.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> expincrement <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> multiplier <a href="CppOperatorAssign.htm">=</a> 0.5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (length * multiplier * multiplier &gt; 1.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expincrement <a href="CppOperatorMultiplyAssign.htm">*=</a> 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiplier <a href="CppOperatorMultiplyAssign.htm">*=</a> multiplier;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Reduce the value of `length', then <a href="CppIterator.htm">iterate</a> <b><a href="CppIf.htm">if</a></b> necessary.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;exponent <a href="CppOperatorPlusAssign.htm">+=</a> expincrement;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;length <a href="CppOperatorMultiplyAssign.htm">*=</a> multiplier;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>`length' is approximately squareroot(2.0) to what exponent?<br/>
&nbsp;&nbsp;exponent <a href="CppOperatorAssign.htm">=</a> 2.0 * exponent <a href="CppOperatorPlus.htm">+</a> (length &gt; <a href="CppBoost.htm">boost</a>::math::constants::root_two&lt;<b><a href="CppDouble.htm">double</a></b>&gt;());<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>`exponent' is now in the range 0...2047 <b><a href="CppFor.htm">for</a></b> IEEE <b><a href="CppDouble.htm">double</a></b> precision.<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Choose a queue in the range 0...4095.&nbsp;&nbsp;The shortest edges have the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;highest priority (queue 4095).<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (posexponent)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;queu<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> 2047 <a href="CppOperatorMinus.htm">-</a> exponent;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;queu<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorAssign.htm">=</a> 2048 <a href="CppOperatorPlus.htm">+</a> exponent;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Are we inserting into an empty queue?<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (m.m_queuefront.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Yes, we are inserting into an empty queue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Will <b><a href="CppThis.htm">this</a></b> become the highest-priority queue?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (queu<b><a href="CppEnum.htm">enum</a></b>ber &gt; m.m_firstnonemptyq)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Yes, <b><a href="CppThis.htm">this</a></b> is the highest-priority queue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_nextnonemptyq[queu<b><a href="CppEnum.htm">enum</a></b>ber] <a href="CppOperatorAssign.htm">=</a> m.m_firstnonemptyq;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_firstnonemptyq <a href="CppOperatorAssign.htm">=</a> queu<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>No, <b><a href="CppThis.htm">this</a></b> is not the highest-priority queue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;Find the queue with next higher priority.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i <a href="CppOperatorAssign.htm">=</a> queu<b><a href="CppEnum.htm">enum</a></b>ber <a href="CppOperatorPlus.htm">+</a> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> (m.m_queuefront[i] <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Mark the newly nonempty queue as following a higher-priority queue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_nextnonemptyq[queu<b><a href="CppEnum.htm">enum</a></b>ber] <a href="CppOperatorAssign.htm">=</a> m.m_nextnonemptyq[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.m_nextnonemptyq[i] <a href="CppOperatorAssign.htm">=</a> queu<b><a href="CppEnum.htm">enum</a></b>ber;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a>Put the bad triangle at the beginning of the (empty) queue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_queuefront[queu<b><a href="CppEnum.htm">enum</a></b>ber] <a href="CppOperatorAssign.htm">=</a> badtri;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppElse.htm">else</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppAdd.htm">Add</a> the bad triangle to the end of an already nonempty queue.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m.m_queuetail[queu<b><a href="CppEnum.htm">enum</a></b>ber]-&gt;m_nexttriang <a href="CppOperatorAssign.htm">=</a> badtri;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Maintain a <a href="CppPointer.htm">pointer</a> to the last triangle of the queue.<br/>
&nbsp;&nbsp;m.m_queuetail[queu<b><a href="CppEnum.htm">enum</a></b>ber] <a href="CppOperatorAssign.htm">=</a> badtri;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Newly enqueued bad triangle has no successor in the queue.<br/>
&nbsp;&nbsp;badtri-&gt;m_nexttriang <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<a href="CppEndif.htm">#endif</a><br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Vertex&amp; <a href="CppRibi.htm">ribi</a>::tricpp::Mesh::GetVertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_vertices.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_vertices[index];<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
Vertex&amp; <a href="CppRibi.htm">ribi</a>::tricpp::Mesh::GetVertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_vertices));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_vertices[index];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Mesh::KillVertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_vertices.size()));<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!m_vertices.empty());<br/>
&nbsp;&nbsp;<a href="CppStdSwap.htm">std::swap</a>(m_vertices[index],m_vertices[m_vertices.size() <a href="CppOperatorMinus.htm">-</a> 1]);<br/>
&nbsp;&nbsp;m_vertices.pop_back();<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Vertex <a href="CppRibi.htm">ribi</a>::tricpp::vertextraverse(Mesh&amp; m)<br/>
{<br/>
&nbsp;&nbsp;Vertex newvertex;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppDo.htm">do</a></b><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;newvertex <a href="CppOperatorAssign.htm">=</a> (Vertex) Traverse(&amp;m.m_vertices);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (newvertex <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;} <b><a href="CppWhile.htm">while</a></b> (IsDeadVertexType(newvertex)); <a href="CppComment.htm">//</a> Skip dead ones<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> newvertex;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppEndif.htm">#endif</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmeshbuilder.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmeshbuilder.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPMESHBUILDER_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPMESHBUILDER_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">///</a>Creates a Mesh<br/>
<b><a href="CppStruct.htm">struct</a></b> MeshBuilder<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<b><a href="CppConst.htm">const</a></b> Arguments&gt; ArgumentsPtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; EdgePtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; TrianglePtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; VertexPtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;EdgePtr&gt; Edges;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;TrianglePtr&gt; Triangles;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;VertexPtr&gt; Vertices;<br/>
<br/>
&nbsp;&nbsp;MeshBuilder();<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Mesh&gt; Create(<b><a href="CppConst.htm">const</a></b> Arguments&amp; arguments) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> CreateEdges(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::PolyFile&amp; polyfile,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Assembles Triangles from edges<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> CreateTriangles(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; edges<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/<a href="CppConvert.htm">Converts</a> raw .poly file its contents<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>/to Vertex <a href="CppInstance.htm">instances</a><br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> CreateVertices(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::PolyFile&amp; polyfile<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPMESHBUILDER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppmeshbuilder.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppmeshbuilder.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppmeshbuilder.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppMake_shared.htm">make_shared</a>.hpp&gt;<br/>
<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Mesh&gt;<br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::tricpp::MeshBuilder::Create(<b><a href="CppConst.htm">const</a></b> Arguments&amp; arguments) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;Vertices vertices <a href="CppOperatorAssign.htm">=</a> CreateVertices(polyfile);<br/>
&nbsp;&nbsp;Edges edges <a href="CppOperatorAssign.htm">=</a> CreateEdges(polyfile,vertices);<br/>
&nbsp;&nbsp;Triangles triangles <a href="CppOperatorAssign.htm">=</a> CreateTriangles(edges);<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Mesh&gt;(arguments,edges,triangles,vertices);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(mesh);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> mesh;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::tricpp::MeshBuilder::CreateEdges(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::PolyFile&amp; polyfile,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; vertices<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> edges;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> vertex_indices: polyfile.GetEdges())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertex_index <a href="CppOperatorAssign.htm">=</a> vertex_indices.first;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> next_vertex_index <a href="CppOperatorAssign.htm">=</a> vertex_indices.second;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(vertex_index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(vertices.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(next_vertex_index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(vertices.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> edge <a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Edge&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertices[vertex_index],vertices[next_vertex_index]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;edges.push_back(edge);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> edges;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::tricpp::MeshBuilder::CreateTriangles(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a>&amp; edges<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> triangles;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> edge: edges)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> from_edges <a href="CppOperatorAssign.htm">=</a> edge-&gt;GetFromEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> to_edges <a href="CppOperatorAssign.htm">=</a> edge-&gt;GetToEdges();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> from_edge: from_edges)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppAuto.htm">auto</a></b> to_edge: to_edges)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (AreConnected(*from_edge,*to_edge))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> triangle<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Triangle&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make_<a href="CppArray.htm">array</a>(edge,from_edge,to_edge)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangles.push_back(triangle);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> triangles;<br/>
}<br/>
<br/>
<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a><br/>
&nbsp;&nbsp;<a href="CppRibi.htm">ribi</a>::tricpp::MeshBuilder::CreateVertices(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::PolyFile&amp; polyfile<br/>
&nbsp;&nbsp;) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> vertices;<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> coordinat: polyfile.GetVertices())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> currentmarker <a href="CppOperatorAssign.htm">=</a> 1; <a href="CppComment.htm">//</a>Appeared to always be <b><a href="CppTrue.htm">true</a></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppAuto.htm">auto</a></b> vertex<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppBoostMake_shared.htm">boost::make_shared</a>&lt;Vertex&gt;(coordinat.x(),coordinat.y(),currentmarker);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;vertices.push_back(vertex);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> vertices;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpposub.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpposub.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPOSUB_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPOSUB_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_OSUB<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> An oriented subsegment:&nbsp;&nbsp;includes a <a href="CppPointer.htm">pointer</a> to a subsegment and an&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; orientation.&nbsp;&nbsp;The orientation denotes a side of the edge.&nbsp;&nbsp;Hence, there <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; are two possible orientations.&nbsp;&nbsp;By convention, the edge is always&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; directed so that the "side" denoted is the right side of the edge.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> Osub<br/>
{<br/>
&nbsp;&nbsp;Osub();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>stpivot() finds a triangle abutting a subsegment.&nbsp;&nbsp;It requires that the<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;variable `ptr' of type `triangle' be defined.<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; GetStPivot() <b><a href="CppConst.htm">const</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Otri<br/>
<br/>
<br/>
&nbsp;&nbsp;Edge&amp; GetSubSeg(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i);<br/>
&nbsp;&nbsp;Triangle&amp; GetTriangle(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetSubSeg(Edge&amp; subseg, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetTriangle(Triangle&amp; triangle, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i);<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; GetDest() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; GetOrigin() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetMark() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_mark; }<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; Sencode() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetMark(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_mark <a href="CppOperatorAssign.htm">=</a> value; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetOrient(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> orient) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetDest(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; subseg) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetOrigin(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; subseg) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetSubsegOrient(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subseg_orient) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Ssym(<b><a href="CppConst.htm">const</a></b> Osub&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Ssymself() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_subsegs; <a href="CppComment.htm">//</a>Origanaly called 'm_sugseg', yet it must be a <a href="CppStdVector.htm">std::vector</a><br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_triangles;<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> morient;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Ranges from 0 to 1<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_subseg_orient;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_mark;<br/>
};<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>These primitives read or set a boundary marker.&nbsp;&nbsp;Boundary markers are<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;used to hold user-defined tags <b><a href="CppFor.htm">for</a></b> setting boundary conditions in<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;finite element solvers.<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> mark(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setmark(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value);<br/>
<br/>
<a href="CppComment.htm">///</a>Bond two subsegments together.<br/>
<b><a href="CppVoid.htm">void</a></b> sbond(Osub&amp; osub1, Osub&amp; osub2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetOrigin(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetDest(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">///</a>spivot() finds the other subsegment (from the same segment) that shares<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp;the same origin.<br/>
<b><a href="CppVoid.htm">void</a></b> spivot(Osub&amp; osub1, Osub&amp; osub2, Edge&amp; sptr);<br/>
<b><a href="CppVoid.htm">void</a></b> spivotself(Osub&amp; osub1, Edge&amp; sptr);<br/>
<b><a href="CppVoid.htm">void</a></b> snext(Osub&amp; osub1, Osub&amp; osub2, Edge&amp; sptr);<br/>
<b><a href="CppVoid.htm">void</a></b> snextself(Osub&amp; osub, Edge&amp; sptr);<br/>
<br/>
<a href="CppComment.htm">//</a>tspivot() finds a subsegment abutting a triangle.<br/>
<b><a href="CppVoid.htm">void</a></b> tspivot(Otri&amp; otri, Osub&amp; osub);<br/>
<b><a href="CppVoid.htm">void</a></b> stpivot(Osub&amp; osub, Otri&amp; otri);<br/>
<b><a href="CppVoid.htm">void</a></b> tsbond(Otri&amp; otri, Osub&amp; osub);<br/>
<b><a href="CppVoid.htm">void</a></b> tsdissolve(Otri&amp; otri, Edge&amp; m_m_dummysub);<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppStd.htm">std</a>issolve(Osub&amp; osub, Triangle&amp; m_m_dummytri);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_OSUB<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPOSUB_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpposub.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpposub.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecpposub.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Osub::Osub()<br/>
&nbsp;&nbsp;: m_subsegs{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subseg_orient{0}<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Otri&gt; <a href="CppRibi.htm">ribi</a>::tricpp::Osub::GetStPivot() <b><a href="CppConst.htm">const</a></b><br/>
<a href="CppComment.htm">//</a><a href="CppRibi.htm">ribi</a>::tricpp::Otri&amp; <a href="CppRibi.htm">ribi</a>::tricpp::Osub::GetStPivot() <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> <b><a href="CppThis.htm">this</a></b>-&gt;m_subsegs[6 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient];<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;();<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Edge&gt; <a href="CppRibi.htm">ribi</a>::tricpp::Osub::Sencode() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_subseg_orient <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(m_subseg_orient &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_subsegs.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_subsegs[m_subseg_orient];<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;<a href="CppDefine.htm">#define</a> sencode(osub) \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(SubSeg) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (osub).m_subseg | (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (osub).m_subseg_orient)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Osub::SetSubsegOrient(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subseg_orient) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Ranges from 0 to 1<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(subseg_orient <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(subseg_orient&nbsp;&nbsp;&lt; 2);<br/>
&nbsp;&nbsp;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> subseg_orient;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Osub::SetSubsegOrient(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> subseg_orient) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;osub.m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Osub::Ssym(<b><a href="CppConst.htm">const</a></b> Osub&amp; other)<br/>
{<br/>
&nbsp;&nbsp;m_subseg <a href="CppOperatorAssign.htm">=</a> other.m_subseg;<br/>
&nbsp;&nbsp;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> other.m_subseg_orient;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Osub::Ssymself() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;m_subseg_orient <a href="CppOperatorAssign.htm">=</a> 1 <a href="CppOperatorMinus.htm">-</a> m_subseg_orient;<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a>These primitives read or set a boundary marker.&nbsp;&nbsp;Boundary markers are<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;used to hold user-defined tags <b><a href="CppFor.htm">for</a></b> setting boundary conditions in<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;finite element solvers.<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> mark(osub)&nbsp;&nbsp;(* (<b><a href="CppInt.htm">int</a></b> *) ((osub).m_subseg <a href="CppOperatorPlus.htm">+</a> 8))<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::mark(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub) { <b><a href="CppReturn.htm">return</a></b> osub.GetMark(); }<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> setmark(osub, value) \<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;* (<b><a href="CppInt.htm">int</a></b> *) ((osub).m_subseg <a href="CppOperatorPlus.htm">+</a> 8) <a href="CppOperatorAssign.htm">=</a> value<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setmark(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value) { <b><a href="CppReturn.htm">return</a></b> osub.SetMark(value); }<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a>Bond two subsegments together.<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::sbond(Osub&amp; osub1, Osub&amp; osub2)<br/>
{<br/>
&nbsp;&nbsp;osub1.m_subsegs[osub1.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> osub2.Sencode();<br/>
&nbsp;&nbsp;osub2.m_subsegs[osub2.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> osub1.Sencode();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub1.m_subsegs[osub1.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> sencode(osub2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub2.m_subsegs[osub2.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> sencode(osub1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> sbond(osub1, osub2) \<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;(osub1).m_subseg[(osub1).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> sencode(osub2); \<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;(osub2).m_subseg[(osub2).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> sencode(osub1)<br/>
<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetOrigin(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> osub.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does not <b><a href="CppDo.htm">do</a></b> <a href="CppAny.htm">any</a>thing yet<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexptr <a href="CppOperatorAssign.htm">=</a> osub.m_subseg[2 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sorg(osub, vertexptr) \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (osub).m_subseg[2 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetDest(<b><a href="CppConst.htm">const</a></b> Osub&amp; osub, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> osub.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Does not <b><a href="CppDo.htm">do</a></b> <a href="CppAny.htm">any</a>thing yet<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexptr <a href="CppOperatorAssign.htm">=</a> osub.m_subseg[3 <a href="CppOperatorMinus.htm">-</a> osub.m_subseg_orient];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sdest(osub, vertexptr) \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (osub).m_subseg[3 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>spivot() finds the other subsegment (from the same segment) that shares<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;the same origin.<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::spivot(Osub&amp; osub1, Osub&amp; osub2, Edge&amp; sptr)<br/>
{<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> osub1.m_subsegs[osub1.m_subseg_orient];<br/>
&nbsp;&nbsp;sdecode(sptr, osub2);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> spivot(osub1, osub2) \<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> (osub1).m_subseg[(osub1).m_subseg_orient]; \<br/>
&nbsp;&nbsp;sdecode(sptr, osub2)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::spivotself(Osub&amp; osub1, Edge&amp; sptr)<br/>
{<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> osub.m_subseg[osub.m_subseg_orient];<br/>
&nbsp;&nbsp;sdecode(sptr, osub);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> spivotself(osub) \<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> (osub).m_subseg[(osub).m_subseg_orient]; \<br/>
&nbsp;&nbsp;sdecode(sptr, osub)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>snext() finds the next subsegment (from the same segment) in sequence;<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;one whose origin is the input subsegment's destination.<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::snext(Osub&amp; osub1, Osub&amp; osub2, Edge&amp; sptr)<br/>
{<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> osub1.ss[1 <a href="CppOperatorMinus.htm">-</a> osub1.m_subseg_orient];<br/>
&nbsp;&nbsp;sdecode(sptr, osub2);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> snext(osub1, osub2) \<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> (osub1).ss[1 <a href="CppOperatorMinus.htm">-</a> (osub1).m_subseg_orient]; \<br/>
&nbsp;&nbsp;sdecode(sptr, osub2)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::snextself(Osub&amp; osub, Edge&amp; sptr)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Does not change the <a href="CppPointer.htm">pointer</a>");<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> (osub).m_subsegs[1 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient];<br/>
&nbsp;&nbsp;sdecode(sptr, osub);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> snextself(osub) \<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> (osub).m_subseg[1 <a href="CppOperatorMinus.htm">-</a> (osub).m_subseg_orient]; \<br/>
&nbsp;&nbsp;sdecode(sptr, osub)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>tspivot() finds a subsegment abutting a triangle.<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::tspivot(Otri&amp; otri, Osub&amp; osub)<br/>
{<br/>
&nbsp;&nbsp;otri.Tspivot(osub);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub <a href="CppOperatorAssign.htm">=</a> otri.m_tri[6 <a href="CppOperatorPlus.htm">+</a> otri.m_orient];<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sptr <a href="CppOperatorAssign.htm">=</a> (SubSeg) (otri).m_tri[6 <a href="CppOperatorPlus.htm">+</a> (otri).m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sdecode(sptr, osub)<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> tspivot(otri, osub)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;sptr <a href="CppOperatorAssign.htm">=</a> (SubSeg) (otri).m_tri[6 <a href="CppOperatorPlus.htm">+</a> (otri).m_orient];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;sdecode(sptr, osub)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>stpivot() finds a triangle abutting a subsegment.&nbsp;&nbsp;It requires that the<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;variable `ptr' of type `triangle' be defined.<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::stpivot(Osub&amp; osub, Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri <a href="CppOperatorAssign.htm">=</a> osub.GetStPivot();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri <a href="CppOperatorAssign.htm">=</a> osub.m_subsegs[6 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient];<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ptr <a href="CppOperatorAssign.htm">=</a> (Triangle) (osub).m_subseg[6 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(ptr, otri);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> stpivot(osub, otri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;ptr <a href="CppOperatorAssign.htm">=</a> (Triangle) (osub).m_subseg[6 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;decode(ptr, otri)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>Bond a triangle to a subsegment.<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::tsbond(Otri&amp; otri, Osub&amp; osub)<br/>
{<br/>
&nbsp;&nbsp;otri.m_tri[6 <a href="CppOperatorPlus.htm">+</a> otri.m_orient] <a href="CppOperatorAssign.htm">=</a> osub.Sencode();<br/>
&nbsp;&nbsp;osub.m_subsegs[6 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a>&nbsp;&nbsp;(Edge) encode(otri);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri.m_tri[6 <a href="CppOperatorPlus.htm">+</a> (otri).m_orient] <a href="CppOperatorAssign.htm">=</a> (Triangle) sencode(osub);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>osub.m_subsegs[6 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) encode(otri);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> tsbond(otri, osub)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[6 <a href="CppOperatorPlus.htm">+</a> (otri).m_orient] <a href="CppOperatorAssign.htm">=</a> (Triangle) sencode(osub);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;(osub).m_subseg[6 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) encode(otri)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>Dissolve a bond (from the triangle side).<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::tsdissolve(Otri&amp; otri, Edge&amp; m_m_dummysub)<br/>
{<br/>
&nbsp;&nbsp;otri.Dissolve(m_m_dummysub);<br/>
&nbsp;&nbsp;otri.m_tri[6 <a href="CppOperatorPlus.htm">+</a> otri.m_orient] <a href="CppOperatorAssign.htm">=</a> m_m_dummysub;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> tsdissolve(otri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[6 <a href="CppOperatorPlus.htm">+</a> (otri).m_orient] <a href="CppOperatorAssign.htm">=</a> (Triangle) m.m_dummysub<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>Dissolve a bond (from the subsegment side).<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::<a href="CppStd.htm">std</a>issolve(Osub&amp; osub, Triangle&amp; m_m_dummytri)<br/>
{<br/>
&nbsp;&nbsp;osub.m_subsegs[6 <a href="CppOperatorPlus.htm">+</a> osub.m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> <a href="CppStd.htm">std</a>issolve(osub)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(osub).m_subseg[6 <a href="CppOperatorPlus.htm">+</a> (osub).m_subseg_orient] <a href="CppOperatorAssign.htm">=</a> (SubSeg) m.m_dummytri<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppotri.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppotri.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPOTRI_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPOTRI_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_OTRI<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStringH.htm">string</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> An oriented triangle:&nbsp;&nbsp;includes a <a href="CppPointer.htm">pointer</a> to a triangle and orientation.&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; The orientation denotes an edge of the triangle.&nbsp;&nbsp;Hence, there are&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; three possible orientations.&nbsp;&nbsp;By convention, each edge always <a href="CppPointer.htm">point</a>s&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; <a href="CppCounter.htm">counter</a>clockwise <a href="CppAbout.htm">about</a> the corresponding triangle.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Otri<br/>
{<br/>
&nbsp;&nbsp;Otri();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle * <b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppStatic.htm">static</a></b> Otri CreateSym(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Dissolve(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; m_m_dummytri);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Dnext(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Dnextself();<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Dprev(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; CreateTspivot();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Tspivot(Osub&amp; osub);<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; GetApex() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetAreaBound() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_area_bound; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; GetDest() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> GetElemAttrib(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index);<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> GetInfected() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_is_infected; }<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; GetOrigin() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetDest(<b><a href="CppConst.htm">const</a></b> Vertex&amp; GetDest) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetOrigin(<b><a href="CppConst.htm">const</a></b> Vertex&amp; origin) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetLnext(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Lnextself();<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Lprev(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Lprevself();<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Onext(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Onextself(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Oprev(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Oprevself();<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetApex(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; apex) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_apex <a href="CppOperatorAssign.htm">=</a> apex; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetAreaBound(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> area_bound) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_area_bound <a href="CppOperatorAssign.htm">=</a> area_bound; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetDest(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; dest) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_dest <a href="CppOperatorAssign.htm">=</a> dest; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetElemAttrib(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> value, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetInfected(<b><a href="CppConst.htm">const</a></b> <b><a href="CppBool.htm">bool</a></b> is_infected) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_is_infected <a href="CppOperatorAssign.htm">=</a> is_infected; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetOrigin(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; origin) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_origin <a href="CppOperatorAssign.htm">=</a> origin; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetSubSeg(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;&amp; subseg, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetTriangle(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; triangle, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetOrient() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_orient; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetOrient(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> orient) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppStatic.htm">static</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt; CreateSym(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Sym(<b><a href="CppConst.htm">const</a></b> Otri&amp; other);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> Symself() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_apex;<br/>
&nbsp;&nbsp;<b><a href="CppBool.htm">bool</a></b> m_is_infected;<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> m_area_bound;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt; m_attributes;<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_dest;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_orient; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Ranges from 0 to 2<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt; m_origin;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_subsegs;<br/>
&nbsp;&nbsp;<a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_triangles; <a href="CppComment.htm">//</a>Must be <a href="CppStdVector.htm">std::vector</a><br/>
};<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetOrigin(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri, Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetDest(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri, Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> GetApex(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri, Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetOrigin(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetDest(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetApex(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> Vertex&amp; vertexptr);<br/>
<a href="CppComment.htm">//</a> Bond two triangles together<br/>
<b><a href="CppVoid.htm">void</a></b> Bond(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; otri1, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; otri2);<br/>
<a href="CppComment.htm">//</a> Dissolve a bond (from one side).&nbsp;&nbsp;Note that the other triangle will still<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; think it's connected to <b><a href="CppThis.htm">this</a></b> triangle.&nbsp;&nbsp;Usually, however, the other<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; triangle is being deleted entirely, or bonded to another triangle, so<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; it doesn't matter.<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> dissolve(Otri&amp; otri, Triangle * m_m_dummytri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> otricopy(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> otriequal(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, <b><a href="CppConst.htm">const</a></b> Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> infect(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> uninfect(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> infected(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> elemattribute(Otri&amp; otri, <b><a href="CppInt.htm">int</a></b> attnum);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setelemattribute(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> attnum, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> value);<br/>
<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b> areabound(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setareabound(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> value);<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Otri&amp; lhs, <b><a href="CppConst.htm">const</a></b> Otri&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Otri&amp; lhs, <b><a href="CppConst.htm">const</a></b> Otri&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> decode(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><a href="CppStdString.htm">std::string</a> encode(<b><a href="CppConst.htm">const</a></b> Otri&amp; <a href="CppComment.htm">/*</a>otri<a href="CppComment.htm">*/</a>);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> sym(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> symself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> lnext(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> lnextself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> lprev(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> lprevself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> onext(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> onextself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> oprev(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> oprevself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> dnext(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> dnextself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> dprev(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> dprevself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> rnext(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> rnextself(Otri&amp; otri);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> rprev(Otri&amp; otri1, Otri&amp; otri2);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> rprevself(Otri&amp; otri);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_OTRI<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPOTRI_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppotri.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppotri.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppotri.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Otri::Otri()<br/>
&nbsp;&nbsp;: m_apex{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_area_bound{0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_attributes{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_dest{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_is_infected{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_orient{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_origin{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subsegs{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangles{}<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Triangle&gt; <a href="CppRibi.htm">ribi</a>::tricpp::Otri::<b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 9 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Just a guess");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; 12);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_triangles.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_triangles[index];<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Dissolve(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; m_m_dummytri)<br/>
{<br/>
&nbsp;&nbsp;m_triangles[m_orient] <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Dnext(<b><a href="CppConst.htm">const</a></b> Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b> <a href="CppOperatorAssign.htm">=</a> CreateSym(other);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri2);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Dnextself()<br/>
{<br/>
&nbsp;&nbsp;Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
<br/>
&nbsp;&nbsp;Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Dprev(<b><a href="CppConst.htm">const</a></b> Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;SetLnext(other);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(otri1, otri2);<br/>
&nbsp;&nbsp;Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri2);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::SetLnext(<b><a href="CppConst.htm">const</a></b> Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;m_triangles <a href="CppOperatorAssign.htm">=</a> other.m_triangles;<br/>
&nbsp;&nbsp;m_orient <a href="CppOperatorAssign.htm">=</a> other.m_orient <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::LnextSelf()<br/>
{<br/>
&nbsp;&nbsp;m_orient <a href="CppOperatorAssign.htm">=</a> m_orient <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Lprev(<b><a href="CppConst.htm">const</a></b> Otri&amp; other) <b><a href="CppConst.htm">const</a></b><br/>
{<br/>
&nbsp;&nbsp;m_triangles <a href="CppOperatorAssign.htm">=</a> other.m_triangles;<br/>
&nbsp;&nbsp;m_orient <a href="CppOperatorAssign.htm">=</a> other.m_orient <a href="CppOperatorPlus.htm">+</a> 2 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Lprevself()<br/>
{<br/>
&nbsp;&nbsp;m_orient <a href="CppOperatorAssign.htm">=</a> m_orient <a href="CppOperatorPlus.htm">+</a> 2 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Onext(Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;Lprev(other);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri2);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Onextself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri);<br/>
<br/>
&nbsp;&nbsp;Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Oprev(Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b> <a href="CppOperatorAssign.htm">=</a> CreateSym(other);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri2);<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Oprevself()<br/>
{<br/>
&nbsp;&nbsp;Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
<br/>
&nbsp;&nbsp;Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri);<br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::SetOrient(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> orient) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(orient <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(orient&nbsp;&nbsp;&lt; 3);<br/>
&nbsp;&nbsp;m_orient <a href="CppOperatorAssign.htm">=</a> orient;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Otri&gt; <a href="CppRibi.htm">ribi</a>::tricpp::Otri::CreateSym(<b><a href="CppConst.htm">const</a></b> Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> other.m_triangles[other.m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>*<b><a href="CppThis.htm">this</a></b> <a href="CppOperatorAssign.htm">=</a> other.m_triangles[other.m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2 <a href="CppOperatorAssign.htm">=</a> otri1.m_triangles[(otri1).m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;ptr <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri[(otri1).m_orient];&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;decode(ptr, otri2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Sym(<b><a href="CppConst.htm">const</a></b> Otri&amp; other)<br/>
{<br/>
&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b> <a href="CppOperatorAssign.htm">=</a> other.m_triangles[other.m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2 <a href="CppOperatorAssign.htm">=</a> otri1.m_triangles[(otri1).m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a><br/>
&nbsp;&nbsp;ptr <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri[(otri1).m_orient];&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;decode(ptr, otri2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Symself() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>???<br/>
&nbsp;&nbsp;*<b><a href="CppThis.htm">this</a></b> <a href="CppOperatorAssign.htm">=</a> m_triangles[m_orient];<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::SetTriangle(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; triangle, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 9 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "Just a guess");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; 12);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(index &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_triangles.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_triangles[index] <a href="CppOperatorAssign.htm">=</a> triangle;<br/>
}<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Osub&gt; <a href="CppRibi.htm">ribi</a>::tricpp::Otri::CreateTspivot()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Osub&gt; osub <a href="CppOperatorAssign.htm">=</a> m_tri[6 <a href="CppOperatorPlus.htm">+</a> m_orient];<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> osub;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Otri::Tspivot(Osub&amp; osub)<br/>
{<br/>
&nbsp;&nbsp;osub <a href="CppOperatorAssign.htm">=</a> m_tri[6 <a href="CppOperatorPlus.htm">+</a> m_orient];<br/>
}<br/>
<br/>
<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>Vertex * GetOrg(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri)<br/>
<a href="CppComment.htm">//</a>{<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> otri.m_tri[0][((otri.m_orient <a href="CppOperatorPlus.htm">+</a> 1) <a href="CppOperatorModulus.htm">%</a> 3) <a href="CppOperatorPlus.htm">+</a> 3];<br/>
<a href="CppComment.htm">//</a>}<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetOrigin(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> otri.GetOrigin();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri.m_tri[plus1mod3_cpp[(otri).m_orient] <a href="CppOperatorPlus.htm">+</a> 3];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> org(otri, vertexptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (otri).m_tri[plus1mod3_cpp[(otri).m_orient] <a href="CppOperatorPlus.htm">+</a> 3]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>Vertex GetDest(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri) { <b><a href="CppReturn.htm">return</a></b> otri.m_tri[0][((otri.m_orient <a href="CppOperatorMinus.htm">-</a> 1 <a href="CppOperatorPlus.htm">+</a> 3) <a href="CppOperatorModulus.htm">%</a> 3) <a href="CppOperatorPlus.htm">+</a> 3]; }<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetDest(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> otri.GetDest();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexptr <a href="CppOperatorAssign.htm">=</a> otri.m_tri[minus1mod3_cpp[(otri).m_orient] <a href="CppOperatorPlus.htm">+</a> 3];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> dest(otri, vertexptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (otri).m_tri[minus1mod3_cpp[(otri).m_orient] <a href="CppOperatorPlus.htm">+</a> 3]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetApex(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri, Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> otri.GetApex();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>vertexptr <a href="CppOperatorAssign.htm">=</a> otri.m_tri[(otri).m_orient <a href="CppOperatorPlus.htm">+</a> 3];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> apex(otri, vertexptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;vertexptr <a href="CppOperatorAssign.htm">=</a> (Vertex) (otri).m_tri[(otri).m_orient <a href="CppOperatorPlus.htm">+</a> 3]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::SetOrigin(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;otri.SetOrg(vertexptr);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri.m_tri[plus1mod3_cpp[otri.m_orient] <a href="CppOperatorPlus.htm">+</a> 3] <a href="CppOperatorAssign.htm">=</a> vertexptr;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setorg(otri, vertexptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;(otri).m_tri[plus1mod3_cpp[(otri).m_orient] <a href="CppOperatorPlus.htm">+</a> 3] <a href="CppOperatorAssign.htm">=</a> (Triangle) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::SetDest(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;otri.setDest(vertexptr);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri.m_tri[minus1mod3_cpp[otri.m_orient] <a href="CppOperatorPlus.htm">+</a> 3] <a href="CppOperatorAssign.htm">=</a> vertexptr;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setdest(otri, vertexptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[minus1mod3_cpp[(otri).m_orient] <a href="CppOperatorPlus.htm">+</a> 3] <a href="CppOperatorAssign.htm">=</a> (Triangle) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::SetApex(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> Vertex&amp; vertexptr)<br/>
{<br/>
&nbsp;&nbsp;otri.SetApex(vertexptr);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri).m_tri[(otri).m_orient <a href="CppOperatorPlus.htm">+</a> 3] <a href="CppOperatorAssign.htm">=</a> (Triangle) vertexptr;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setapex(otri, vertexptr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[(otri).m_orient <a href="CppOperatorPlus.htm">+</a> 3] <a href="CppOperatorAssign.htm">=</a> (Triangle) vertexptr<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Bond two triangles together.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Bond(<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; otri1, <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Otri&gt;&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri1-&gt;m_triangles[otri1-&gt;m_orient] <a href="CppOperatorAssign.htm">=</a> otri2-&gt;m_tri[otri2-&gt;m_orient];<br/>
&nbsp;&nbsp;otri2-&gt;m_triangles[otri2-&gt;m_orient] <a href="CppOperatorAssign.htm">=</a> otri1-&gt;m_tri[otri2-&gt;m_orient];<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri1).m_triangles[otri1.m_orient] <a href="CppOperatorAssign.htm">=</a> encode(otri2);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri2).m_triangles[otri2.m_orient] <a href="CppOperatorAssign.htm">=</a> encode(otri1);<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> bond(otri1, otri2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri1).m_tri[(otri1).m_orient] <a href="CppOperatorAssign.htm">=</a> encode(otri2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri2).m_tri[(otri2).m_orient] <a href="CppOperatorAssign.htm">=</a> encode(otri1)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Dissolve a bond (from one side).&nbsp;&nbsp;Note that the other triangle will still <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; think it's connected to <b><a href="CppThis.htm">this</a></b> triangle.&nbsp;&nbsp;Usually, however, the other&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; triangle is being deleted entirely, or bonded to another triangle, so&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; it doesn't matter.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::dissolve(Otri&amp; otri, Triangle * m_m_dummytri)<br/>
{<br/>
&nbsp;&nbsp;(otri).m_triangles[(otri).m_orient] <a href="CppOperatorAssign.htm">=</a> m.m_dummytri;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> dissolve(otri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[(otri).m_orient] <a href="CppOperatorAssign.htm">=</a> (Triangle) m.m_dummytri<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Copy an oriented triangle.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::otricopy(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2 <a href="CppOperatorAssign.htm">=</a> otri1;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> otricopy(otri1, otri2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri2).m_tri <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri2).m_orient <a href="CppOperatorAssign.htm">=</a> (otri1).m_orient<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Test <b><a href="CppFor.htm">for</a></b> equality of oriented triangles.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::otriequal(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, <b><a href="CppConst.htm">const</a></b> Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> otri1 <a href="CppOperatorEqual.htm">==</a> otri2;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> otriequal(otri1, otri2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;(((otri1).m_tri <a href="CppOperatorEqual.htm">==</a> (otri2).m_tri) <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp; ((otri1).m_orient <a href="CppOperatorEqual.htm">==</a> (otri2).m_orient))<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Primitives to infect or cure a triangle with the virus.&nbsp;&nbsp;These rely on&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; the assumption that all subsegments are aligned to four-byte boundaries.<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::infect(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.SetInfected(<b><a href="CppTrue.htm">true</a></b>);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri).m_triangles[6] <a href="CppOperatorAssign.htm">=</a> (otri).m_triangles[6] | 2l;<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> infect(otri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[6] <a href="CppOperatorAssign.htm">=</a> (Triangle)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_tri[6] | (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 2l)<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::uninfect(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;(otri).m_triangles[6] <a href="CppOperatorAssign.htm">=</a> otri.m_triangles[6] &amp; ~ 2l;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> uninfect(otri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri).m_tri[6] <a href="CppOperatorAssign.htm">=</a> (Triangle)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_tri[6] &amp; ~ (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 2l)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Test a triangle <b><a href="CppFor.htm">for</a></b> viral infection.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::infected(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> otri.GetInfected();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> ((otri.m_triangles[6] &amp; (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 2l) <a href="CppOperatorNotEqual.htm">!=</a> 0l)<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> infected(otri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_tri[6] &amp; (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 2l) <a href="CppOperatorNotEqual.htm">!=</a> 0l)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Check or set a triangle's attributes.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">///</a>Returns the attnum-th attribute, the <b><a href="CppDouble.htm">double</a></b> at m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorPlus.htm">+</a> attnum<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::elemattribute(Otri&amp; otri, <b><a href="CppInt.htm">int</a></b> attnum)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> otri.GetElemAttrib(attnum);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> otri.m_tri[m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorPlus.htm">+</a> attnum];<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> elemattribute(otri, attnum)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorPlus.htm">+</a> (attnum)]<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setelemattribute(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> attnum, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> value)<br/>
{<br/>
&nbsp;&nbsp;otri.SetElemAttrib(value,attnum);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorPlus.htm">+</a> (attnum)] <a href="CppOperatorAssign.htm">=</a> value<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">///</a>Set the attnum-th attribute with a value<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setelemattribute(otri, attnum, value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_elematt<a href="CppRibi.htm">ribi</a>ndex <a href="CppOperatorPlus.htm">+</a> (attnum)] <a href="CppOperatorAssign.htm">=</a> value<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> Check or set a triangle's maximum area bound.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppDouble.htm">double</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::areabound(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> otri.GetAreaBound();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp;((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_areaboundindex]<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> areabound(otri)&nbsp;&nbsp;((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_areaboundindex]<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setareabound(Otri&amp; otri, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> value)<br/>
{<br/>
&nbsp;&nbsp;otri.SetAreaBound(value);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_areaboundindex] <a href="CppOperatorAssign.htm">=</a> value<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setareabound(otri, value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br/>
&nbsp;&nbsp;((<b><a href="CppDouble.htm">double</a></b> *) (otri).m_tri)[m.m_areaboundindex] <a href="CppOperatorAssign.htm">=</a> value<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>decode() <a href="CppConvert.htm">converts</a> a <a href="CppPointer.htm">pointer</a> to an oriented triangle.&nbsp;&nbsp;The orientation is<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;extracted from the two least significant bits of the <a href="CppPointer.htm">pointer</a>.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::decode(<b><a href="CppConst.htm">const</a></b> <a href="CppStdString.htm">std::string</a>&amp; s, Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.m_orient <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (ptr) &amp; (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 3l); \<br/>
&nbsp;&nbsp;otri.m_tri <a href="CppOperatorAssign.htm">=</a> (Triangle *) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (ptr) ^ (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_orient)<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> decode(ptr, otri) \<br/>
&nbsp;&nbsp;(otri).m_orient <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b>) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (ptr) &amp; (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) 3l); \<br/>
&nbsp;&nbsp;(otri).m_tri <a href="CppOperatorAssign.htm">=</a> (Triangle *) \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (ptr) ^ (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_orient)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>encode() compresses an oriented triangle into a single <a href="CppPointer.htm">pointer</a>.&nbsp;&nbsp;It<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;relies on the assumption that all triangles are aligned to four-byte<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;boundaries, so the two least significant bits of (otri).m_tri are zero.<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppStdString.htm">std::string</a> <a href="CppRibi.htm">ribi</a>::tricpp::encode(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(!"Get rid of <b><a href="CppThis.htm">this</a></b>");<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> "";<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppReturn.htm">returns</a> the Triangle otri.m_tri[otri.m_orient]<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> encode(otri)&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(Triangle) ((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_tri | (<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppLong.htm">long</a></b>) (otri).m_orient)<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>The following handle manipulation primitives are all described by Guibas<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;and Stolfi.&nbsp;&nbsp;However, Guibas and Stolfi use an edge-based data<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;structure, whereas I use a triangle-based data structure.<br/>
<br/>
<a href="CppComment.htm">//</a>sym() finds the abutting triangle, on the same edge.&nbsp;&nbsp;Note that the edge<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;direction is necessarily reversed, because the handle specified by an<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;oriented triangle is directed <a href="CppCounter.htm">counter</a>clockwise around the triangle.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::sym(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.Sym(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2 <a href="CppOperatorAssign.htm">=</a> otri1.m_triangles[(otri1).m_orient];<br/>
<br/>
&nbsp;&nbsp;ptr <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri[(otri1).m_orient]; \<br/>
&nbsp;&nbsp;decode(ptr, otri2);<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> sym(otri1, otri2) \<br/>
&nbsp;&nbsp;ptr <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri[(otri1).m_orient];&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;decode(ptr, otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::symself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri <a href="CppOperatorAssign.htm">=</a> otri.m_triangles[(otri).m_orient];<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>ptr <a href="CppOperatorAssign.htm">=</a> (otri).m_tri[(otri).m_orient];<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>decode(ptr, otri);<br/>
<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> symself(otri) \<br/>
&nbsp;&nbsp;ptr <a href="CppOperatorAssign.htm">=</a> (otri).m_tri[(otri).m_orient];&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;decode(ptr, otri);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>lnext() finds the next edge (<a href="CppCounter.htm">counter</a>clockwise) of a triangle.<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::lnext(<b><a href="CppConst.htm">const</a></b> Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.lnext(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2.m_triangles <a href="CppOperatorAssign.htm">=</a> otri1.m_triangles;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2.m_orient <a href="CppOperatorAssign.htm">=</a> otri1.m_orient <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> lnext(otri1, otri2) \<br/>
&nbsp;&nbsp;(otri2).m_tri <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri2).m_orient <a href="CppOperatorAssign.htm">=</a> plus1mod3_cpp[(otri1).m_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::lnextself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Lnextself();<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri.m_orient <a href="CppOperatorAssign.htm">=</a> otri.m_orient <a href="CppOperatorPlus.htm">+</a> 1 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri).m_orient <a href="CppOperatorAssign.htm">=</a> plus1mod3_cpp[(otri).m_orient]<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> lnextself(otri) \<br/>
&nbsp;&nbsp;(otri).m_orient <a href="CppOperatorAssign.htm">=</a> plus1mod3_cpp[(otri).m_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>lprev() finds the previous edge (clockwise) of a triangle.<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::lprev(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.Lprev(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri2).m_triangles <a href="CppOperatorAssign.htm">=</a> otri1.m_triangles;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>(otri2).m_orient <a href="CppOperatorAssign.htm">=</a> otri1.m_orient <a href="CppOperatorPlus.htm">+</a> 2 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> lprev(otri1, otri2) \<br/>
&nbsp;&nbsp;(otri2).m_tri <a href="CppOperatorAssign.htm">=</a> (otri1).m_tri;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;(otri2).m_orient <a href="CppOperatorAssign.htm">=</a> minus1mod3_cpp[(otri1).m_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::lprevself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri.m_orient <a href="CppOperatorAssign.htm">=</a> otri.m_orient <a href="CppOperatorPlus.htm">+</a> 2 <a href="CppOperatorModulus.htm">%</a> 3;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> lprevself(otri) \<br/>
&nbsp;&nbsp;(otri).m_orient <a href="CppOperatorAssign.htm">=</a> minus1mod3_cpp[(otri).m_orient]<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>onext() spins <a href="CppCounter.htm">counter</a>clockwise around a vertex; that is, it finds the<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;next edge with the same origin in the <a href="CppCounter.htm">counter</a>clockwise direction.&nbsp;&nbsp;This<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;edge is part of a different triangle.<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::onext(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.Onext(otri1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2.Lprev(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprev(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>otri2.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> onext(otri1, otri2) \<br/>
&nbsp;&nbsp;lprev(otri1, otri2);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;symself(otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::onextself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> onextself(otri) \<br/>
&nbsp;&nbsp;lprevself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;symself(otri);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>oprev() spins clockwise around a vertex; that is, it finds the next edge<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;with the same origin in the clockwise direction.&nbsp;&nbsp;This edge is part of<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;a different triangle.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::oprev(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.Sym(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;otri2.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> oprev(otri1, otri2) \<br/>
&nbsp;&nbsp;sym(otri1, otri2);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lnextself(otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::oprevself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> oprevself(otri) \<br/>
&nbsp;&nbsp;symself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lnextself(otri);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>dnext() spins <a href="CppCounter.htm">counter</a>clockwise around a vertex; that is, it finds the<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;next edge with the same destination in the <a href="CppCounter.htm">counter</a>clockwise direction.<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;This edge is part of a different triangle.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::dnext(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.Sym(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>sym(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;otri2.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> dnext(otri1, otri2) \<br/>
&nbsp;&nbsp;sym(otri1, otri2);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lprevself(otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::dnextself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> dnextself(otri) \<br/>
&nbsp;&nbsp;symself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lprevself(otri);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>dprev() spins clockwise around a vertex; that is, it finds the next edge<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;with the same destination in the clockwise direction.&nbsp;&nbsp;This edge is<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;part of a different triangle.<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::dprev(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;otri2.Lnext(otri1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnext(otri1, otri2);<br/>
&nbsp;&nbsp;otri2.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> dprev(otri1, otri2) \<br/>
&nbsp;&nbsp;lnext(otri1, otri2);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;symself(otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::dprevself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> dprevself(otri) \<br/>
&nbsp;&nbsp;lnextself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;symself(otri);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>rnext() moves one edge <a href="CppCounter.htm">counter</a>clockwise <a href="CppAbout.htm">about</a> the adjacent triangle.<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;(It's best understood by reading Guibas and Stolfi.&nbsp;&nbsp;It involves<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;changing triangles twice.)<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::rnext(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;sym(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;otri2.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri2);<br/>
<br/>
&nbsp;&nbsp;otri2.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> rnext(otri1, otri2) \<br/>
&nbsp;&nbsp;sym(otri1, otri2);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lnextself(otri2); \<br/>
&nbsp;&nbsp;symself(otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::rnextself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Lnextself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lnextself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> rnextself(otri) \<br/>
&nbsp;&nbsp;symself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lnextself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;symself(otri);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">//</a>rprev() moves one edge clockwise <a href="CppAbout.htm">about</a> the adjacent triangle.<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;(It's best understood by reading Guibas and Stolfi.&nbsp;&nbsp;It involves<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;changing triangles twice.)<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::rprev(Otri&amp; otri1, Otri&amp; otri2)<br/>
{<br/>
&nbsp;&nbsp;sym(otri1, otri2);<br/>
<br/>
&nbsp;&nbsp;otri2.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri2);<br/>
<br/>
&nbsp;&nbsp;otri2.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri2);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> rprev(otri1, otri2) \<br/>
&nbsp;&nbsp;sym(otri1, otri2);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lprevself(otri2); \<br/>
&nbsp;&nbsp;symself(otri2);<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::rprevself(Otri&amp; otri)<br/>
{<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Lprevself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>lprevself(otri);<br/>
<br/>
&nbsp;&nbsp;otri.Symself();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>symself(otri);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> rprevself(otri) \<br/>
&nbsp;&nbsp;symself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;lprevself(otri);&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;symself(otri);<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppsplaynode.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppsplaynode.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPSPLAYNODE_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPSPLAYNODE_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_SPLAYNODE<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppotri.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
/<a href="CppComment.htm">//</a> A node in the splay tree.&nbsp;&nbsp;Each node holds an oriented ghost triangle<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; that represents a boundary edge of the growing triangulation.&nbsp;&nbsp;When a<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; circle event covers two boundary edges with a triangle, so that they<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; are no longer boundary edges, those edges are not immediately deleted<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; from the tree; rather, they are lazily deleted when they are next<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; en<a href="CppCounter.htm">counter</a>ed.&nbsp;&nbsp;(Since only a random sample of boundary edges are kept<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; in the tree, lazy deletion is faster.)&nbsp;&nbsp;`keydest' is used to verify<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; that a triangle is still the same as when it entered the splay tree; <b><a href="CppIf.htm">if</a></b><br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; it has been rotated (due to a circle event), it no longer represents a<br/>
/<a href="CppComment.htm">//</a>&nbsp;&nbsp; boundary edge and should be deleted.<br/>
<b><a href="CppStruct.htm">struct</a></b> SplayNode<br/>
{<br/>
&nbsp;&nbsp;SplayNode();<br/>
&nbsp;&nbsp;SplayNode(<b><a href="CppConst.htm">const</a></b> SplayNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
&nbsp;&nbsp;SplayNode&amp; <b><a href="CppOperator.htm">operator</a></b>=(<b><a href="CppConst.htm">const</a></b> SplayNode&amp;) <a href="CppOperatorAssign.htm">=</a> <b><a href="CppDelete.htm">delete</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Used to verify that splay node is still live.<br/>
&nbsp;&nbsp;Vertex m_keydest;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Lprev of an edge on the front.<br/>
&nbsp;&nbsp;Otri m_keyedge;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Children in splay tree.<br/>
&nbsp;&nbsp;SplayNode * m_lchild;<br/>
&nbsp;&nbsp;SplayNode * m_rchild;<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_SPLAYNODE<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPSPLAYNODE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppsplaynode.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppsplaynode.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppsplaynode.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::SplayNode::SplayNode()<br/>
&nbsp;&nbsp;: m_keydest{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_keyedge{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_lchild{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_rchild{<b><a href="CppNullptr.htm">nullptr</a></b>}<br/>
{<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppstring.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppstring.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPSTRING_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPSTRING_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_STRING<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;findfield()&nbsp;&nbsp; Find the next field of a string.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Jumps past the current field by searching <b><a href="CppFor.htm">for</a></b> whitespace, then jumps&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;past the whitespace to find the next field.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a><b><a href="CppChar.htm">char</a></b> * FindField(<b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> string);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_STRING<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPSTRING_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppstring.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppstring.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppstring.h"<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<br/>
<b><a href="CppChar.htm">char</a></b> * <a href="CppRibi.htm">ribi</a>::tricpp::FindField(<b><a href="CppChar.htm">char</a></b> * <b><a href="CppConst.htm">const</a></b> string)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppChar.htm">char</a></b> * result <a href="CppOperatorAssign.htm">=</a> string;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Skip the current field.&nbsp;&nbsp;Stop upon reaching whitespace.<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorNotEqual.htm">!=</a> '\0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '#')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> ' ') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '\t')) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Now skip the whitespace and <a href="CppAny.htm">any</a>thing <b><a href="CppElse.htm">else</a></b> that doesn't look like a<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>&nbsp;&nbsp; number, a comment, or the end of a line.<br/>
&nbsp;&nbsp;<b><a href="CppWhile.htm">while</a></b> ((*result <a href="CppOperatorNotEqual.htm">!=</a> '\0') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '#')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '.') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '+') <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (*result <a href="CppOperatorNotEqual.htm">!=</a> '-')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> ((*result &lt; '0') <a href="CppOperatorLogicalOr.htm">||</a> (*result &gt; '9'))) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result<a href="CppOperatorIncrement.htm">++</a>;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a> Check <b><a href="CppFor.htm">for</a></b> a comment (prefixed with `#').<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (*result <a href="CppOperatorEqual.htm">==</a> '#') {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*result <a href="CppOperatorAssign.htm">=</a> '\0';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> result;<br/>
}<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppsyntax.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppsyntax.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPSYNTAX_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPSYNTAX_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> Syntax();<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPSYNTAX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppsyntax.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppsyntax.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppsyntax.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppIostreamH.htm">iostream</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppSstreamH.htm">sstream</a>&gt;<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Syntax()<br/>
{<br/>
&nbsp;&nbsp;<a href="CppStdStringstream.htm">std::stringstream</a> s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "triangle [-rq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "input_file must be a .poly file\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>r&nbsp;&nbsp;Refines a previously generated mesh.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>q&nbsp;&nbsp;Quality mesh generation.&nbsp;&nbsp;A minimum angle may be specified.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>a&nbsp;&nbsp;Applies a maximum triangle area constraint.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>u&nbsp;&nbsp;Applies a user-defined triangle constraint.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>A&nbsp;&nbsp;Applies attributes to identify triangles in certain regions.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>c&nbsp;&nbsp;Encloses the convex hull with segments.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>D&nbsp;&nbsp;Conforming Delaunay:&nbsp;&nbsp;all triangles are truly Delaunay.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>j&nbsp;&nbsp;Jettison unused vertices from output .node file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>e&nbsp;&nbsp;Generates an edge list.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>v&nbsp;&nbsp;Generates a Voronoi diagram.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>n&nbsp;&nbsp;Generates a list of triangle neighbors.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>g&nbsp;&nbsp;Generates an .off file <b><a href="CppFor.htm">for</a></b> Geomview.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>B&nbsp;&nbsp;Suppresses output of boundary information.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>P&nbsp;&nbsp;Suppresses output of .poly file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>N&nbsp;&nbsp;Suppresses output of .node file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>E&nbsp;&nbsp;Suppresses output of .ele file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>I&nbsp;&nbsp;Suppresses mesh iteration numbers.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>O&nbsp;&nbsp;Ignores holes in .poly file.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>X&nbsp;&nbsp;Suppresses use of exact arithmetic.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>z&nbsp;&nbsp;Numbers all items starting from zero (rather than one).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>o2 Generates second-order subparametric elements.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>Y&nbsp;&nbsp;Suppresses boundary segment splitting.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>S&nbsp;&nbsp;Specifies maximum number of added Steiner <a href="CppPointer.htm">point</a>s.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>i&nbsp;&nbsp;Uses incremental <a href="CppMemberFunction.htm">member function</a>, rather than divide-and-conquer.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>F&nbsp;&nbsp;Uses Fortune's sweepline <a href="CppAlgorithm.htm">algorithm</a>, rather than d-and-c.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>l&nbsp;&nbsp;Uses vertical cuts only, rather than alternating cuts.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>s&nbsp;&nbsp;Force segments into mesh by splitting (instead of <b><a href="CppUsing.htm">using</a></b> CDT).\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>C&nbsp;&nbsp;Check consistency of <b><a href="CppFinal.htm">final</a></b> mesh.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>Q&nbsp;&nbsp;Quiet:&nbsp;&nbsp;No terminal output except errors.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>V&nbsp;&nbsp;Verbose:&nbsp;&nbsp;Detailed information on what I'm doing.\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorStreamOut.htm">&lt;&lt;</a> "&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorMinus.htm">-</a>h&nbsp;&nbsp;Help:&nbsp;&nbsp;Detailed instructions <b><a href="CppFor.htm">for</a></b> Triangle.\n"<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;<a href="CppStdCout.htm">std::cout</a> <a href="CppOperatorStreamOut.htm">&lt;&lt;</a> s;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptriangle.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptriangle.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPTRIANGLE_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPTRIANGLE_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppVectorH.htm">vector</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppedge.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">//</a> The triangle data structure.&nbsp;&nbsp;Each triangle contains three <a href="CppPointer.htm">pointer</a>s to<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; adjoining triangles, plus three <a href="CppPointer.htm">pointer</a>s to vertices, plus three<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppPointer.htm">pointer</a>s to subsegments (declared below; these <a href="CppPointer.htm">pointer</a>s are usually<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; `dummysub').&nbsp;&nbsp;It may or may not also contain user-defined attributes<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; and/or a floating-<a href="CppPointer.htm">point</a> "area constraint."&nbsp;&nbsp;It may also contain extra<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; <a href="CppPointer.htm">pointer</a>s <b><a href="CppFor.htm">for</a></b> nodes, when the user asks <b><a href="CppFor.htm">for</a></b> high-order elements.<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; Because the size and structure of a `triangle' is not decided until<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp; run<a href="CppTime.htm">time</a>, I haven't simply declared the type `triangle' as a <b><a href="CppStruct.htm">struct</a></b>.<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppTypedef.htm">typedef</a></b> <b><a href="CppDouble.htm">double</a></b> **Triangle;<br/>
<b><a href="CppStruct.htm">struct</a></b> Triangle<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt; EdgePtr;<br/>
&nbsp;&nbsp;<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdArray.htm">std::array</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge&gt;,3&gt; Edges;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle(<b><a href="CppConst.htm">const</a></b> EdgePtr&amp; a, <b><a href="CppConst.htm">const</a></b> EdgePtr&amp; b, <b><a href="CppConst.htm">const</a></b> EdgePtr&amp; c);<br/>
&nbsp;&nbsp;Triangle(<b><a href="CppConst.htm">const</a></b> Edges&amp; edges);<br/>
<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetTriangle(<b><a href="CppConst.htm">const</a></b> Triangle&amp; triangle, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index); <a href="CppComment.htm">//</a>If the lvalue of <b><a href="CppOperator.htm">operator</a></b>[] needed to be used<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetSubSeg(<b><a href="CppConst.htm">const</a></b> Edge&amp; subseg, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index); <a href="CppComment.htm">//</a>If the lvalue of <b><a href="CppOperator.htm">operator</a></b>[] needed to be used<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle&amp; <b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> Triangle&amp; <b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Vertex GetOrg();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsDead() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> KillMe() <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> m_is_dead;<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edges m_edges;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Triangle(<b><a href="CppConst.htm">const</a></b> EdgePtr&amp; a, <b><a href="CppConst.htm">const</a></b> EdgePtr&amp; b, <b><a href="CppConst.htm">const</a></b> EdgePtr&amp; c);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Edge<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_subsegs;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppStdVector.htm">std::vector</a>&lt;<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle<a href="CppOperatorStreamIn.htm">&gt;&gt;</a> m_triangles;<br/>
};<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Triangle&amp; lhs, <b><a href="CppConst.htm">const</a></b> Triangle&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Triangle&amp; lhs, <b><a href="CppConst.htm">const</a></b> Triangle&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">//</a>These primitives determine or set the origin, destination, or apex of a<br/>
<a href="CppComment.htm">//</a>triangle.<br/>
<br/>
<br/>
<a href="CppComment.htm">//</a>Check or set a triangle's deallocation.&nbsp;&nbsp;Its second <a href="CppPointer.htm">pointer</a> is set to<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<a href="CppNULL.htm">NULL</a> to indicate that it is not allocated.&nbsp;&nbsp;(Its first <a href="CppPointer.htm">pointer</a> is used<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> the stack of dead items.)&nbsp;&nbsp;Its fourth <a href="CppPointer.htm">pointer</a> (its first vertex)<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;is set to <a href="CppNULL.htm">NULL</a> in <b><a href="CppCase.htm">case</a></b> a `badtriang' structure <a href="CppPointer.htm">point</a>s to it.<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> deadtri(tria)&nbsp;&nbsp;((tria)[1] <a href="CppOperatorEqual.htm">==</a> (Triangle) <a href="CppNULL.htm">NULL</a>)<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> deadtri(<b><a href="CppConst.htm">const</a></b> Triangle&amp; t) { <b><a href="CppReturn.htm">return</a></b> t[1] <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>; }<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> killtri(<b><a href="CppConst.htm">const</a></b> Triangle&amp; t) { t[1] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; t[3] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; }<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; vertex2tri(Vertex&amp; vx);<br/>
<a href="CppComment.htm">//</a>Triangle vertex2tri(Vertex&amp; vx);<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setvertex2tri(Vertex&amp; vx, <b><a href="CppConst.htm">const</a></b> Triangle&amp; value);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setvertex2tri(Vertex&amp; vx, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; value);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPTRIANGLE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptriangle.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptriangle.cpp" border = "1"><tr><td><code>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpptriangle.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppCassertH.htm">cassert</a>&gt;<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Triangle::Triangle()<br/>
&nbsp;&nbsp;: m_is_dead{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_subsegs{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangles{}<br/>
{<br/>
<br/>
}<br/>
<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Triangle::IsDead() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Follows:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> deadtri(tria)&nbsp;&nbsp;((tria)[1] <a href="CppOperatorEqual.htm">==</a> (Triangle) <a href="CppNULL.htm">NULL</a>)<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppReturn.htm">return</a></b> <b><a href="CppOperator.htm">operator</a></b>[](1) <a href="CppOperatorEqual.htm">==</a> <b><a href="CppNullptr.htm">nullptr</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_is_dead;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Triangle::KillMe() <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>Follows:<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> killtri(<b><a href="CppConst.htm">const</a></b> Triangle&amp; t) { t[1] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; t[3] <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNullptr.htm">nullptr</a></b>; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetTriangle(<b><a href="CppNullptr.htm">nullptr</a></b>,1);<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a>SetTriangle(<b><a href="CppNullptr.htm">nullptr</a></b>,3);<br/>
&nbsp;&nbsp;m_is_dead <a href="CppOperatorAssign.htm">=</a> <b><a href="CppTrue.htm">true</a></b>;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(IsDead());<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Triangle::SetTriangle(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Triangle&amp; triangle,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; 6 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "But not sure <b><a href="CppIf.htm">if</a></b> 6 is the limit indeed");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_triangles.size()));<br/>
&nbsp;&nbsp;m_triangles[i] <a href="CppOperatorAssign.htm">=</a> triangle;<br/>
}<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Triangle::SetSubSeg(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> Edge&amp; subseg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i<br/>
)<br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 6 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "But not sure <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> is the limit indeed");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i&nbsp;&nbsp;&lt; 9 <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> "But not sure <b><a href="CppIf.htm">if</a></b> <b><a href="CppThis.htm">this</a></b> is the limit indeed");<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_subsegs.size()));<br/>
&nbsp;&nbsp;m_subsegs[i] <a href="CppOperatorAssign.htm">=</a> subseg;<br/>
}<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Triangle&amp; <a href="CppRibi.htm">ribi</a>::tricpp::Triangle::<b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_triangles.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_triangles[i];<br/>
}<br/>
<br/>
<b><a href="CppConst.htm">const</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::Triangle&amp; <a href="CppRibi.htm">ribi</a>::tricpp::Triangle::<b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> i) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i <a href="CppOperatorGreaterEqual.htm">&gt;=</a> 0);<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(i &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(m_triangles.size()));<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> m_triangles[i];<br/>
}<br/>
<br/>
<br/>
<a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;<a href="CppRibi.htm">ribi</a>::tricpp::Triangle&gt; <a href="CppRibi.htm">ribi</a>::tricpp::vertex2tri(Vertex&amp; vx)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> vx.GetTriangle();<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> vertex2tri(vx)&nbsp;&nbsp;((Triangle *) (vx))[m.m_vertex2triindex]<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setvertex2tri(Vertex&amp; vx, <b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; triangle)<br/>
{<br/>
&nbsp;&nbsp;vx.SetTriangle(triangle);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setvertex2tri(vx, value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;((Triangle *) (vx))[m.m_vertex2triindex] <a href="CppOperatorAssign.htm">=</a> value<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> triunsuitable()&nbsp;&nbsp; Determine <b><a href="CppIf.htm">if</a></b> a triangle is unsuitable, and thus must<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be further refined.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> You may write your own procedure that decides whether or not a selected<br/>
<a href="CppComment.htm">//</a> triangle is too big (and needs to be refined).&nbsp;&nbsp;There are two ways to <b><a href="CppDo.htm">do</a></b><br/>
<a href="CppComment.htm">//</a> <b><a href="CppThis.htm">this</a></b>.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> (1)&nbsp;&nbsp;Modify the procedure `triunsuitable' below, then re<a href="CppCompile.htm">compile</a><br/>
<a href="CppComment.htm">//</a> Triangle.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> (2)&nbsp;&nbsp;Define the symbol EXTERNAL_TEST (either by adding the <a href="CppDefinition.htm">definition</a><br/>
<a href="CppComment.htm">//</a> to <b><a href="CppThis.htm">this</a></b> file, or by <b><a href="CppUsing.htm">using</a></b> the appropriate <a href="CppCompiler.htm">compiler</a> <b><a href="CppSwitch.htm">switch</a></b>).&nbsp;&nbsp;This way,<br/>
<a href="CppComment.htm">//</a> you can <a href="CppCompile.htm">compile</a> triangle.c separately from your test.&nbsp;&nbsp;Write your own<br/>
<a href="CppComment.htm">//</a> `triunsuitable' procedure in a separate C file (<b><a href="CppUsing.htm">using</a></b> the same prototype<br/>
<a href="CppComment.htm">//</a> as below).&nbsp;&nbsp;<a href="CppCompile.htm">Compile</a> it and <a href="CppLink.htm">link</a> the object code with triangle.o.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">//</a> This procedure <a href="CppReturn.htm">returns</a> 1 <b><a href="CppIf.htm">if</a></b> the triangle is too large and should be<br/>
<a href="CppComment.htm">//</a> refined; 0 otherwise.<br/>
<a href="CppComment.htm">//</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptriangulateio.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptriangulateio.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPTRIANGULATEIO_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPTRIANGULATEIO_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_TRIANGULATEIO<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<b><a href="CppStruct.htm">struct</a></b> TriangulateIo<br/>
{<br/>
&nbsp;&nbsp;TriangulateIo();<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_edgelist; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Out only<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_edgemarkerlist; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Not used with Voronoi diagram; out only<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_holelist;/<a href="CppComment.htm">//</a> In <a href="CppOperatorDivide.htm">/</a> <a href="CppPointer.htm">pointer</a> to <a href="CppArray.htm">array</a> copied out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_neighborlist;/<a href="CppComment.htm">//</a> Out only<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_normlist; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Used only with Voronoi diagram; out only<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_<a href="CppPointer.htm">point</a>attributelist;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_<a href="CppPointer.htm">point</a>list;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_<a href="CppPointer.htm">point</a>markerlist;/<a href="CppComment.htm">//</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_regionlist; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> <a href="CppPointer.htm">pointer</a> to <a href="CppArray.htm">array</a> copied out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_segmentlist; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_segmentmarkerlist; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_trianglearealist;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In only<br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> *m_triangleattributelist;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> *m_trianglelist;/<a href="CppComment.htm">//</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberofcorners; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberofedges; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> Out only<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberofholes; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> copied out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberof<a href="CppPointer.htm">point</a>attributes;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberof<a href="CppPointer.htm">point</a>s;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberofregions; <a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> copied out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberofsegments;/<a href="CppComment.htm">//</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberoftriangleattributes;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_numberoftriangles;&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppOperatorDivide.htm">/</a> In <a href="CppOperatorDivide.htm">/</a> out<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_TRIANGULATEIO<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPTRIANGULATEIO_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptriangulateio.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptriangulateio.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecpptriangulateio.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::TriangulateIo::TriangulateIo()<br/>
&nbsp;&nbsp;: m_edgelist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_edgemarkerlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_holelist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighborlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_normlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppPointer.htm">point</a>attributelist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppPointer.htm">point</a>list{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_<a href="CppPointer.htm">point</a>markerlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_regionlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_segmentlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_segmentmarkerlist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_trianglearealist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_triangleattributelist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_trianglelist{<b><a href="CppNullptr.htm">nullptr</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberofcorners{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberofedges{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberofholes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberof<a href="CppPointer.htm">point</a>attributes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberof<a href="CppPointer.htm">point</a>s{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberofregions{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberofsegments{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberoftriangleattributes{0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_numberoftriangles{0}<br/>
{<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptrimalloc.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptrimalloc.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPTRIMALLOC_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPTRIMALLOC_H<br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> TRIANGLECPP_USE_TRIMALLOC<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">//</a>TODO: Remove <b><a href="CppThis.htm">this</a></b> <a href="CppFunction.htm">function</a><br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> * TriMalloc(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> size);<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPP_USE_TRIMALLOC<br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPTRIMALLOC_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptrimalloc.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptrimalloc.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecpptrimalloc.h"<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> * <a href="CppRibi.htm">ribi</a>::tricpp::TriMalloc(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> size)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> * <b><a href="CppConst.htm">const</a></b> memptr <a href="CppOperatorAssign.htm">=</a> <b><a href="CppNew.htm">new</a></b> <b><a href="CppInt.htm">int</a></b>(size);<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> memptr;<br/>
<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>memptr <a href="CppOperatorAssign.htm">=</a> (VOID *) malloc((<b><a href="CppUnsigned.htm">unsigned</a></b> <b><a href="CppInt.htm">int</a></b>) size);<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><b><a href="CppIf.htm">if</a></b> (memptr <a href="CppOperatorEqual.htm">==</a> (VOID *) <a href="CppNULL.htm">NULL</a>) {<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;printf("Error:&nbsp;&nbsp;Out of <a href="CppMemory.htm">memory</a>.\n");<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>&nbsp;&nbsp;<b><a href="CppThrow.htm">throw</a></b> <a href="CppStdLogic_error.htm">std::logic_error</a>(s.str().c_str());<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a>}<br/>
&nbsp;&nbsp;<a href="CppOperatorDivide.htm">/</a><b><a href="CppReturn.htm">return</a></b>(memptr);<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecpptypedefs.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecpptypedefs.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPTYPEDEFS_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPTYPEDEFS_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-variable"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppGeometry.htm">geometry</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppGeometry.htm">geometry</a>/geometries/<a href="CppPointer.htm">point</a>_xy.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppGeometry.htm">geometry</a>/geometries/polygon.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/si/area.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/si/length.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/systems/si/plane_angle.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppUnits.htm">boost/units</a>/quantity.hpp&gt;<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">//</a>Temporary<br/>
<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostUnits.htm">boost::units</a>::quantity&lt;<a href="CppBoostUnits.htm">boost::units</a>::si::plane_angle&gt; Angle;<br/>
<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostUnits.htm">boost::units</a>::quantity&lt;<a href="CppBoostUnits.htm">boost::units</a>::si::area&gt; Area;<br/>
<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoostUnits.htm">boost::units</a>::quantity&lt;<a href="CppBoostUnits.htm">boost::units</a>::si::length&gt; Length;<br/>
<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoost.htm">boost</a>::<a href="CppGeometry.htm">geometry</a>::model::d2::<a href="CppPointer.htm">point</a>_xy&lt;<b><a href="CppDouble.htm">double</a></b>&gt; Coordinat;<br/>
<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppBoost.htm">boost</a>::<a href="CppGeometry.htm">geometry</a>::model::polygon&lt;Coordinat&gt; Polygon;<br/>
<b><a href="CppTypedef.htm">typedef</a></b> <a href="CppStdVector.htm">std::vector</a>&lt;Polygon&gt; Polygons;<br/>
<br/>
<b><a href="CppUsing.htm">using</a></b> <a href="CppBoostUnits.htm">boost::units</a>::si::meter;<br/>
<b><a href="CppUsing.htm">using</a></b> <a href="CppBoostUnits.htm">boost::units</a>::si::radian;<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPTYPEDEFS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppvertex.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppvertex.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPVERTEX_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPVERTEX_H<br/>
<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic push<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "<a href="CppWeffcpp.htm">-Weffc++</a>"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic ignored "-Wunused-but-set-parameter"<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppBoost.htm">boost</a>/<a href="CppShared_ptr.htm">shared_ptr</a>.hpp&gt;<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertextype.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppfwd.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecpp<b><a href="CppTypedef.htm">typedef</a></b>s.h"<br/>
<a href="CppPragma.htm">#pragma</a> GCC diagnostic pop<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<a href="CppComment.htm">/*</a> The vertex data structure.&nbsp;&nbsp;Each vertex is actually an <a href="CppArray.htm">array</a> of <b><a href="CppDouble.htm">double</a></b>s.&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; The number of <b><a href="CppDouble.htm">double</a></b>s is unknown until run<a href="CppTime.htm">time</a>.&nbsp;&nbsp;An <a href="CppInt.htm">integer</a> boundary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; marker, and some<a href="CppTime.htm">time</a>s a <a href="CppPointer.htm">pointer</a> to a triangle, is appended after the&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; <b><a href="CppDouble.htm">double</a></b>s.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> The vertex types.&nbsp;&nbsp; A DEADVERTEX has been deleted entirely.&nbsp;&nbsp;An&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; UNDEADVERTEX is not part of the mesh, but is written to the output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; .node file and affects the node indexing in the other output files.&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<b><a href="CppStruct.htm">struct</a></b> Vertex<br/>
{<br/>
&nbsp;&nbsp;Vertex(<b><a href="CppConst.htm">const</a></b> Length x, <b><a href="CppConst.htm">const</a></b> Length y, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertexmarker);<br/>
&nbsp;&nbsp;Length GetX() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_x; }<br/>
&nbsp;&nbsp;Length GetY() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_y; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppDouble.htm">double</a></b>&amp; <b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b>&amp; <b><a href="CppOperator.htm">operator</a></b>[](<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> index) <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> Clear() <b><a href="CppNoexcept.htm">noexcept</a></b>; <a href="CppComment.htm">//</a>Set size to zero<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsDead() { <b><a href="CppReturn.htm">return</a></b> m_is_dead; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsEmpty() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> GetMark() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_vertexmark; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt; GetTriangle() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;VertexType GetVertexType() <b><a href="CppConst.htm">const</a></b> <b><a href="CppNoexcept.htm">noexcept</a></b> { <b><a href="CppReturn.htm">return</a></b> m_type; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetMark(<b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> mark) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_vertexmark <a href="CppOperatorAssign.htm">=</a> mark; }<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> SetTriangle(<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Triangle&gt;&amp; triangle) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetVertexType(<b><a href="CppConst.htm">const</a></b> VertexType type) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_type <a href="CppOperatorAssign.htm">=</a> type; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetX(<b><a href="CppConst.htm">const</a></b> Length x) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_x <a href="CppOperatorAssign.htm">=</a> x; }<br/>
&nbsp;&nbsp;<b><a href="CppVoid.htm">void</a></b> SetY(<b><a href="CppConst.htm">const</a></b> Length y) <b><a href="CppNoexcept.htm">noexcept</a></b> { m_y <a href="CppOperatorAssign.htm">=</a> y; }<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppPrivate.htm">private</a></b>:<br/>
&nbsp;&nbsp;Length m_x;<br/>
&nbsp;&nbsp;Length m_y;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> m_is_dead;<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> m_vertexmark;<br/>
&nbsp;&nbsp;VertexType m_type;<br/>
};<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> GetVertexType(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vx) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppComment.htm">//</a><b><a href="CppBool.htm">bool</a></b> IsDeadVertexType(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vx) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> IsTriangleUnsuitable(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; triorg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; tridest,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; triapex<br/>
) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> vertextype(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vertex) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setvertextype(Vertex&amp; vertex, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value);<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorEqual.htm">operator==</a></b>(<b><a href="CppConst.htm">const</a></b> Vertex&amp; lhs,<b><a href="CppConst.htm">const</a></b> Vertex&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<b><a href="CppBool.htm">bool</a></b> <b><a href="CppOperatorNotEqual.htm">operator!=</a></b>(<b><a href="CppConst.htm">const</a></b> Vertex&amp; lhs,<b><a href="CppConst.htm">const</a></b> Vertex&amp; rhs) <b><a href="CppNoexcept.htm">noexcept</a></b>;<br/>
<br/>
<a href="CppComment.htm">//</a><b><a href="CppInt.htm">int</a></b> vertexmark(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vx);<br/>
<a href="CppComment.htm">//</a><b><a href="CppVoid.htm">void</a></b> setvertexmark(Vertex&amp; vx, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value);<br/>
<br/>
<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPVERTEX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppvertex.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppvertex.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppvertex.h"<br/>
<br/>
<a href="CppInclude.htm">#include</a> "trianglecppmesh.h"<br/>
<a href="CppInclude.htm">#include</a> "trianglecppvertextype.h"<br/>
<br/>
<a href="CppRibi.htm">ribi</a>::tricpp::Vertex::Vertex(<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> x, <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> y, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> vertexmarker)<br/>
&nbsp;&nbsp;: m_is_dead{<b><a href="CppFalse.htm">false</a></b>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_type{VertexType::INPUTVERTEX},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_vertexmark{vertexmarker},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_x{x},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_y{y}<br/>
{<br/>
<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::GetVertexType(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vx) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(vx[Mesh::m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 1]);<br/>
}<br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::IsDeadVertexType(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vx) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> GetVertexType(vx) <a href="CppOperatorEqual.htm">==</a> VertexType::DEADVERTEX;<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppBool.htm">bool</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::IsTriangleUnsuitable(<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; triorg,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; tridest,<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <a href="CppBoostShared_ptr.htm">boost::shared_ptr</a>&lt;Vertex&gt;&amp; triapex<br/>
) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dxoa <a href="CppOperatorAssign.htm">=</a> triorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> triapex-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dyoa <a href="CppOperatorAssign.htm">=</a> triorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> triapex-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dxda <a href="CppOperatorAssign.htm">=</a> tridest-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> triapex-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dyda <a href="CppOperatorAssign.htm">=</a> tridest-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> triapex-&gt;GetY();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dxod <a href="CppOperatorAssign.htm">=</a> triorg-&gt;GetX() <a href="CppOperatorMinus.htm">-</a> tridest-&gt;GetX();<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dyod <a href="CppOperatorAssign.htm">=</a> triorg-&gt;GetY() <a href="CppOperatorMinus.htm">-</a> tridest-&gt;GetY();<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Find the squares of the lengths of the triangle's three edges. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> oalen <a href="CppOperatorAssign.htm">=</a> dxoa * dxoa <a href="CppOperatorPlus.htm">+</a> dyoa * dyoa;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> dalen <a href="CppOperatorAssign.htm">=</a> dxda * dxda <a href="CppOperatorPlus.htm">+</a> dyda * dyda;<br/>
&nbsp;&nbsp;<b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b> odlen <a href="CppOperatorAssign.htm">=</a> dxod * dxod <a href="CppOperatorPlus.htm">+</a> dyod * dyod;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Find the square of the length of the longest edge. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<b><a href="CppDouble.htm">double</a></b> maxlen <a href="CppOperatorAssign.htm">=</a> (dalen &gt; oalen) ? dalen : oalen;<br/>
&nbsp;&nbsp;maxlen <a href="CppOperatorAssign.htm">=</a> (odlen &gt; maxlen) ? odlen : maxlen;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> maxlen &gt; 0.05 * (triorg-&gt;GetX() * triorg-&gt;GetX() <a href="CppOperatorPlus.htm">+</a> triorg-&gt;GetY() * triorg-&gt;GetY()) <a href="CppOperatorPlus.htm">+</a> 0.02;<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::vertextype(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vertex) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>*&gt;(vertex)[m.m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 1];<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> vertextype(vx)&nbsp;&nbsp;((<b><a href="CppInt.htm">int</a></b> *) (vx))[m.m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 1]<br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setvertextype(Vertex&amp; vertex, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value) <b><a href="CppNoexcept.htm">noexcept</a></b><br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>*&gt;(vertex)[m.m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> value;<br/>
&nbsp;&nbsp;<a href="CppAssert.htm">assert</a>(vertextype(vertex) <a href="CppOperatorEqual.htm">==</a> value);<br/>
}<br/>
<br/>
<a href="CppComment.htm">//</a><a href="CppDefine.htm">#define</a> setvertextype(vx, value) \<br/>
<a href="CppComment.htm">//</a>&nbsp;&nbsp;((<b><a href="CppInt.htm">int</a></b> *) (vx))[m.m_vertexmarkindex <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorAssign.htm">=</a> value<br/>
<br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::vertexmark(<b><a href="CppConst.htm">const</a></b> Vertex&amp; vx)<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> vx.GetVertexMark();<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> vertexmark(vx)&nbsp;&nbsp;((<b><a href="CppInt.htm">int</a></b> *) (vx))[m.m_vertexmarkindex]<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<b><a href="CppVoid.htm">void</a></b> <a href="CppRibi.htm">ribi</a>::tricpp::setvertexmark(Vertex&amp; vx, <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b> value)<br/>
{<br/>
&nbsp;&nbsp;vx.SetMark(value);<br/>
}<br/>
<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a><br/>
<a href="CppDefine.htm">#define</a> setvertexmark(vx, value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;((<b><a href="CppInt.htm">int</a></b> *) (vx))[m.m_vertexmarkindex] <a href="CppOperatorAssign.htm">=</a> value<br/>
<a href="CppComment.htm">*/</a><br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppvertextype.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppvertextype.h" border = "1"><tr><td><code>
<a href="CppIfndef.htm">#ifndef</a> TRIANGLECPPVERTEXTYPE_H<br/>
<a href="CppDefine.htm">#define</a> TRIANGLECPPVERTEXTYPE_H<br/>
<br/>
<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a> {<br/>
<b><a href="CppNamespace.htm">namespace</a></b> tricpp {<br/>
<br/>
<b><a href="CppEnumClass.htm">enum class</a></b> VertexType<br/>
{<br/>
&nbsp;&nbsp;INPUTVERTEX&nbsp;&nbsp; <a href="CppOperatorAssign.htm">=</a> 0,<br/>
&nbsp;&nbsp;SEGMENTVERTEX <a href="CppOperatorAssign.htm">=</a> 1,<br/>
&nbsp;&nbsp;FREEVERTEX&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> 2,<br/>
&nbsp;&nbsp;DEADVERTEX&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>32768,<br/>
&nbsp;&nbsp;UNDEADVERTEX&nbsp;&nbsp;<a href="CppOperatorAssign.htm">=</a> <a href="CppOperatorMinus.htm">-</a>32767<br/>
};<br/>
<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> tricpp<br/>
} <a href="CppComment.htm">//</a>~<b><a href="CppNamespace.htm">namespace</a></b> <a href="CppRibi.htm">ribi</a><br/>
<br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">//</a> TRIANGLECPPVERTEXTYPE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/trianglecppvertextype.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/trianglecppvertextype.cpp" border = "1"><tr><td><code>
<a href="CppInclude.htm">#include</a> "trianglecppvertextype.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ToolTriangleCpp/tricall_cpp.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ToolTriangleCpp/tricall_cpp.cpp" border = "1"><tr><td><code>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;(tricall.c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Example program that demonstrates how to call Triangle.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Accompanies Triangle <a href="CppVersion.htm">Version</a> 1.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;July 19, 1996&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;This file is placed in the <b><a href="CppPublic.htm">public</a></b> domain (but the file that it calls&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;is still copyrighted!) by&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Jonathan Ri<b><a href="CppChar.htm">char</a></b>d Shewchuk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;2360 Woolsey #H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;Berkeley, California&nbsp;&nbsp;94705-1927&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;jrs@cs.berkeley.edu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> If SINGLE is defined when triangle.o is <a href="CppCompile.htm">compile</a>d, it should also be&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp; defined here.&nbsp;&nbsp;If not, it should not be defined here.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppComment.htm">/*</a> <a href="CppDefine.htm">#define</a> SINGLE <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppIfdef.htm">#ifdef</a> SINGLE<br/>
<a href="CppDefine.htm">#define</a> REAL <b><a href="CppFloat.htm">float</a></b><br/>
<a href="CppPreElse.htm">#else</a> <a href="CppComment.htm">/*</a> not SINGLE <a href="CppComment.htm">*/</a><br/>
<a href="CppDefine.htm">#define</a> REAL <b><a href="CppDouble.htm">double</a></b><br/>
<a href="CppEndif.htm">#endif</a> <a href="CppComment.htm">/*</a> not SINGLE <a href="CppComment.htm">*/</a><br/>
<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStdioH.htm">stdio.h</a>&gt;<br/>
<a href="CppInclude.htm">#include</a> &lt;<a href="CppStd.htm">std</a>lib.h&gt;<br/>
<a href="CppInclude.htm">#include</a> "triangle.h"<br/>
<br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;report()&nbsp;&nbsp; Print the input or output.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppVoid.htm">void</a></b> report(io, markers, reporttriangles, reportneighbors, reportsegments,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reportedges, reportnorms)<br/>
<b><a href="CppStruct.htm">struct</a></b> triangulateio *io;<br/>
<b><a href="CppInt.htm">int</a></b> markers;<br/>
<b><a href="CppInt.htm">int</a></b> reporttriangles;<br/>
<b><a href="CppInt.htm">int</a></b> reportneighbors;<br/>
<b><a href="CppInt.htm">int</a></b> reportsegments;<br/>
<b><a href="CppInt.htm">int</a></b> reportedges;<br/>
<b><a href="CppInt.htm">int</a></b> reportnorms;<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppInt.htm">int</a></b> i, j;<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; io-&gt;numberof<a href="CppPointer.htm">point</a>s; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("<a href="CppPoint.htm">Point</a> <a href="CppOperatorModulus.htm">%</a>4d:", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 2; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.6g", io-&gt;<a href="CppPointer.htm">point</a>list[i * 2 <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (io-&gt;numberof<a href="CppPointer.htm">point</a>attributes &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp; attributes");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; io-&gt;numberof<a href="CppPointer.htm">point</a>attributes; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.6g",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; io-&gt;<a href="CppPointer.htm">point</a>attributelist[i * io-&gt;numberof<a href="CppPointer.htm">point</a>attributes <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (markers) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp; marker <a href="CppOperatorModulus.htm">%</a>d\n", io-&gt;<a href="CppPointer.htm">point</a>markerlist[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;printf("\n");<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (reporttriangles <a href="CppOperatorLogicalOr.htm">||</a> reportneighbors) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; io-&gt;numberoftriangles; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (reporttriangles) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Triangle <a href="CppOperatorModulus.htm">%</a>4d <a href="CppPointer.htm">point</a>s:", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; io-&gt;numberofcorners; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>4d", io-&gt;trianglelist[i * io-&gt;numberofcorners <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (io-&gt;numberoftriangleattributes &gt; 0) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp; attributes");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; io-&gt;numberoftriangleattributes; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.6g", io-&gt;triangleattributelist[i *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; io-&gt;numberoftriangleattributes <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (reportneighbors) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Triangle <a href="CppOperatorModulus.htm">%</a>4d neighbors:", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 3; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>4d", io-&gt;neighborlist[i * 3 <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (reportsegments) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; io-&gt;numberofsegments; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Segment <a href="CppOperatorModulus.htm">%</a>4d <a href="CppPointer.htm">point</a>s:", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 2; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>4d", io-&gt;segmentlist[i * 2 <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (markers) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp; marker <a href="CppOperatorModulus.htm">%</a>d\n", io-&gt;segmentmarkerlist[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (reportedges) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (i <a href="CppOperatorAssign.htm">=</a> 0; i &lt; io-&gt;numberofedges; i<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Edge <a href="CppOperatorModulus.htm">%</a>4d <a href="CppPointer.htm">point</a>s:", i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 2; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>4d", io-&gt;edgelist[i * 2 <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (reportnorms <a href="CppOperatorLogicalAnd.htm">&amp;&amp;</a> (io-&gt;edgelist[i * 2 <a href="CppOperatorPlus.htm">+</a> 1] <a href="CppOperatorEqual.htm">==</a> <a href="CppOperatorMinus.htm">-</a>1)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppFor.htm">for</a></b> (j <a href="CppOperatorAssign.htm">=</a> 0; j &lt; 2; j<a href="CppOperatorIncrement.htm">++</a>) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;<a href="CppOperatorModulus.htm">%</a>.6g", io-&gt;normlist[i * 2 <a href="CppOperatorPlus.htm">+</a> j]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppIf.htm">if</a></b> (markers) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp; marker <a href="CppOperatorModulus.htm">%</a>d\n", io-&gt;edgemarkerlist[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <b><a href="CppElse.htm">else</a></b> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;<a href="CppMain.htm">main</a>()&nbsp;&nbsp; Create and refine a mesh.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<a href="CppComment.htm">/*</a>***************************************************************************<a href="CppComment.htm">*/</a><br/>
<br/>
<b><a href="CppInt.htm">int</a></b> <a href="CppMain.htm">main</a>()<br/>
{<br/>
&nbsp;&nbsp;<b><a href="CppStruct.htm">struct</a></b> triangulateio in, mid, out, vorout;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Define input <a href="CppPointer.htm">point</a>s. <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;in.numberof<a href="CppPointer.htm">point</a>s <a href="CppOperatorAssign.htm">=</a> 4;<br/>
&nbsp;&nbsp;in.numberof<a href="CppPointer.htm">point</a>attributes <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc(in.numberof<a href="CppPointer.htm">point</a>s * 2 * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[1] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[2] <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[3] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[4] <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[5] <a href="CppOperatorAssign.htm">=</a> 10.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[6] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>list[7] <a href="CppOperatorAssign.htm">=</a> 10.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>attributelist <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc(in.numberof<a href="CppPointer.htm">point</a>s *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in.numberof<a href="CppPointer.htm">point</a>attributes *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>attributelist[0] <a href="CppOperatorAssign.htm">=</a> 0.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>attributelist[1] <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>attributelist[2] <a href="CppOperatorAssign.htm">=</a> 11.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>attributelist[3] <a href="CppOperatorAssign.htm">=</a> 10.0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>markerlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) malloc(in.numberof<a href="CppPointer.htm">point</a>s * <b><a href="CppSizeof.htm">sizeof</a></b>(<b><a href="CppInt.htm">int</a></b>));<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>markerlist[0] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>markerlist[1] <a href="CppOperatorAssign.htm">=</a> 2;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>markerlist[2] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;in.<a href="CppPointer.htm">point</a>markerlist[3] <a href="CppOperatorAssign.htm">=</a> 0;<br/>
<br/>
&nbsp;&nbsp;in.numberofsegments <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;in.numberofholes <a href="CppOperatorAssign.htm">=</a> 0;<br/>
&nbsp;&nbsp;in.numberofregions <a href="CppOperatorAssign.htm">=</a> 1;<br/>
&nbsp;&nbsp;in.regionlist <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc(in.numberofregions * 4 * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;in.regionlist[0] <a href="CppOperatorAssign.htm">=</a> 0.5;<br/>
&nbsp;&nbsp;in.regionlist[1] <a href="CppOperatorAssign.htm">=</a> 5.0;<br/>
&nbsp;&nbsp;in.regionlist[2] <a href="CppOperatorAssign.htm">=</a> 7.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Regional attribute (<b><a href="CppFor.htm">for</a></b> whole mesh). <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;in.regionlist[3] <a href="CppOperatorAssign.htm">=</a> 0.1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Area constraint that will not be used. <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;printf("Input <a href="CppPointer.htm">point</a> set:\n\n");<br/>
&nbsp;&nbsp;report(&amp;in, 1, 0, 0, 0, 0, 0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Make necessary <a href="CppInitialize.htm">initialization</a>s so that Triangle can <b><a href="CppReturn.htm">return</a></b> a <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; triangulation in `mid' and a voronoi diagram in `vorout'.&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;mid.<a href="CppPointer.htm">point</a>list <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>N <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>N <b><a href="CppSwitch.htm">switch</a></b> used or number of <a href="CppPointer.htm">point</a> attributes is zero: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.<a href="CppPointer.htm">point</a>attributelist <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;mid.<a href="CppPointer.htm">point</a>markerlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>; <a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>N or <a href="CppOperatorMinus.htm">-</a>B <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.trianglelist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>E <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>E <b><a href="CppSwitch.htm">switch</a></b> used or number of triangle attributes is zero: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.triangleattributelist <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;mid.neighborlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>n <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> segments are output (-p or <a href="CppOperatorMinus.htm">-</a>c) and <a href="CppOperatorMinus.htm">-</a>P not used: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.segmentlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> segments are output (-p or <a href="CppOperatorMinus.htm">-</a>c) and <a href="CppOperatorMinus.htm">-</a>P and <a href="CppOperatorMinus.htm">-</a>B not used: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.segmentmarkerlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;mid.edgelist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>e <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.edgemarkerlist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>e used and <a href="CppOperatorMinus.htm">-</a>B not used. <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;vorout.<a href="CppPointer.htm">point</a>list <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>v <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>v <b><a href="CppSwitch.htm">switch</a></b> used and number of attributes is not zero: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;vorout.<a href="CppPointer.htm">point</a>attributelist <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;vorout.edgelist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>v <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;vorout.normlist <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>v <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Triangulate the <a href="CppPointer.htm">point</a>s.&nbsp;&nbsp;Switches are chosen to read and write a&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; PSLG (p), preserve the convex hull (c), number everything from&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; zero (z), assign a regional attribute to each element (A), and&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; produce an edge list (e), a Voronoi diagram (v), and a triangle <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; neighbor list (n).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;triangulate("pczAevn", &amp;in, &amp;mid, &amp;vorout);<br/>
<br/>
&nbsp;&nbsp;printf("Initial triangulation:\n\n");<br/>
&nbsp;&nbsp;report(&amp;mid, 1, 1, 1, 1, 1, 0);<br/>
&nbsp;&nbsp;printf("Initial Voronoi diagram:\n\n");<br/>
&nbsp;&nbsp;report(&amp;vorout, 0, 0, 0, 0, 1, 1);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Attach area constraints to the triangles in preparation <b><a href="CppFor.htm">for</a></b> <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; refining the triangulation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Needed only <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>r and <a href="CppOperatorMinus.htm">-</a>a <b><a href="CppSwitch.htm">switch</a></b>es used: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;mid.trianglearealist <a href="CppOperatorAssign.htm">=</a> (REAL *) malloc(mid.numberoftriangles * <b><a href="CppSizeof.htm">sizeof</a></b>(REAL));<br/>
&nbsp;&nbsp;mid.trianglearealist[0] <a href="CppOperatorAssign.htm">=</a> 3.0;<br/>
&nbsp;&nbsp;mid.trianglearealist[1] <a href="CppOperatorAssign.htm">=</a> 1.0;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Make necessary <a href="CppInitialize.htm">initialization</a>s so that Triangle can <b><a href="CppReturn.htm">return</a></b> a <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; triangulation in `out'.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;out.<a href="CppPointer.htm">point</a>list <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>N <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>N <b><a href="CppSwitch.htm">switch</a></b> used or number of attributes is zero: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;out.<a href="CppPointer.htm">point</a>attributelist <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;<br/>
&nbsp;&nbsp;out.trianglelist <a href="CppOperatorAssign.htm">=</a> (<b><a href="CppInt.htm">int</a></b> *) <a href="CppNULL.htm">NULL</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>E <b><a href="CppSwitch.htm">switch</a></b> used. <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Not needed <b><a href="CppIf.htm">if</a></b> <a href="CppOperatorMinus.htm">-</a>E <b><a href="CppSwitch.htm">switch</a></b> used or number of triangle attributes is zero: <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;out.triangleattributelist <a href="CppOperatorAssign.htm">=</a> (REAL *) <a href="CppNULL.htm">NULL</a>;<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Refine the triangulation according to the attached <a href="CppComment.htm">*/</a><br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a>&nbsp;&nbsp; triangle area constraints.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;triangulate("prazBP", &amp;mid, &amp;out, (<b><a href="CppStruct.htm">struct</a></b> triangulateio *) <a href="CppNULL.htm">NULL</a>);<br/>
<br/>
&nbsp;&nbsp;printf("Refined triangulation:\n\n");<br/>
&nbsp;&nbsp;report(&amp;out, 0, 1, 0, 0, 0, 0);<br/>
<br/>
&nbsp;&nbsp;<a href="CppComment.htm">/*</a> Free all allocated <a href="CppArray.htm">array</a>s, including those allocated by Triangle. <a href="CppComment.htm">*/</a><br/>
<br/>
&nbsp;&nbsp;free(in.<a href="CppPointer.htm">point</a>list);<br/>
&nbsp;&nbsp;free(in.<a href="CppPointer.htm">point</a>attributelist);<br/>
&nbsp;&nbsp;free(in.<a href="CppPointer.htm">point</a>markerlist);<br/>
&nbsp;&nbsp;free(in.regionlist);<br/>
&nbsp;&nbsp;free(mid.<a href="CppPointer.htm">point</a>list);<br/>
&nbsp;&nbsp;free(mid.<a href="CppPointer.htm">point</a>attributelist);<br/>
&nbsp;&nbsp;free(mid.<a href="CppPointer.htm">point</a>markerlist);<br/>
&nbsp;&nbsp;free(mid.trianglelist);<br/>
&nbsp;&nbsp;free(mid.triangleattributelist);<br/>
&nbsp;&nbsp;free(mid.trianglearealist);<br/>
&nbsp;&nbsp;free(mid.neighborlist);<br/>
&nbsp;&nbsp;free(mid.segmentlist);<br/>
&nbsp;&nbsp;free(mid.segmentmarkerlist);<br/>
&nbsp;&nbsp;free(mid.edgelist);<br/>
&nbsp;&nbsp;free(mid.edgemarkerlist);<br/>
&nbsp;&nbsp;free(vorout.<a href="CppPointer.htm">point</a>list);<br/>
&nbsp;&nbsp;free(vorout.<a href="CppPointer.htm">point</a>attributelist);<br/>
&nbsp;&nbsp;free(vorout.edgelist);<br/>
&nbsp;&nbsp;free(vorout.normlist);<br/>
&nbsp;&nbsp;free(out.<a href="CppPointer.htm">point</a>list);<br/>
&nbsp;&nbsp;free(out.<a href="CppPointer.htm">point</a>attributelist);<br/>
&nbsp;&nbsp;free(out.trianglelist);<br/>
&nbsp;&nbsp;free(out.triangleattributelist);<br/>
<br/>
&nbsp;&nbsp;<b><a href="CppReturn.htm">return</a></b> 0;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
